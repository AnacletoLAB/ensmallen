from typing import *
import numpy as np


class ShortestPathsResultBFS:
    def has_path_to_node_id(self, node_id: int) -> bool: ...
    def get_distance_from_node_id(self, node_id: int) -> int: ...
    def get_parent_from_node_id(self, node_id: int) -> int: ...
    def get_unchecked_kth_point_on_shortest_path(self, dst_node_id: int, k: int) -> int: ...
    def get_kth_point_on_shortest_path(self, dst_node_id: int, k: int) -> int: ...
    def get_median_point(self, dst_node_id: int) -> int: ...
    def get_median_point_to_most_distant_node(self) -> int: ...
    def get_eccentricity(self) -> int: ...
    def get_most_distant_node(self) -> int: ...
    def get_distances(self) -> np.ndarray: ...
    def _repr_html_(self) -> str: ...

class ShortestPathsDjkstra:
    def has_path_to_node_id(self, node_id: int) -> bool: ...
    def get_distance_from_node_id(self, node_id: int) -> float: ...
    def get_parent_from_node_id(self, node_id: int) -> Optional[int]: ...
    def get_point_at_given_distance_on_shortest_path(self, dst_node_id: int, distance: float) -> int: ...
    def get_median_point(self, dst_node_id: int) -> int: ...
    def get_eccentricity(self) -> float: ...
    def get_most_distant_node(self) -> int: ...
    def _repr_html_(self) -> str: ...

class Graph:
    def get_degree_centrality(self) -> np.ndarray: ...
    def get_weighted_degree_centrality(self) -> np.ndarray: ...
    def get_unchecked_closeness_centrality_from_node_id(self, node_id: int) -> float: ...
    def get_unchecked_weighted_closeness_centrality_from_node_id(self, node_id: int, use_edge_weights_as_probabilities: bool) -> float: ...
    def get_closeness_centrality(self, verbose: Optional[bool]) -> np.ndarray: ...
    def get_weighted_closeness_centrality(self, use_edge_weights_as_probabilities: Optional[bool], verbose: Optional[bool]) -> np.ndarray: ...
    def get_unchecked_harmonic_centrality_from_node_id(self, node_id: int) -> float: ...
    def get_unchecked_weighted_harmonic_centrality_from_node_id(self, node_id: int, use_edge_weights_as_probabilities: bool) -> float: ...
    def get_harmonic_centrality(self, verbose: Optional[bool]) -> np.ndarray: ...
    def get_weighted_harmonic_centrality(self, use_edge_weights_as_probabilities: Optional[bool], verbose: Optional[bool]) -> np.ndarray: ...
    def get_stress_centrality(self, normalize: Optional[bool], verbose: Optional[bool]) -> np.ndarray: ...
    def get_betweenness_centrality(self, normalize: Optional[bool], verbose: Optional[bool]) -> np.ndarray: ...
    def get_eigenvector_centrality(self, maximum_iterations_number: Optional[int], tollerance: Optional[float]) -> np.ndarray: ...
    def get_weighted_eigenvector_centrality(self, maximum_iterations_number: Optional[int], tollerance: Optional[float]) -> np.ndarray: ...
    def encode_edge(self, src: int, dst: int) -> int: ...
    def decode_edge(self, edge: int) -> Tuple[int, int]: ...
    def get_max_encodable_edge_number(self) -> int: ...
    def get_dense_binary_adjacency_matrix(self) -> np.ndarray: ...
    def get_dense_weighted_adjacency_matrix(self, weight: Optional[float]) -> np.ndarray: ...
    def get_unchecked_breadth_first_search_predecessors_parallel_from_node_id(self, src_node_id: int) -> ShortestPathsResultBFS: ...
    def get_unchecked_breadth_first_search_distances_parallel_from_node_id(self, src_node_id: int) -> ShortestPathsResultBFS: ...
    def get_unchecked_breadth_first_search_distances_sequential_from_node_id(self, src_node_id: int) -> ShortestPathsResultBFS: ...
    def get_unchecked_breadth_first_search_from_node_ids(self, src_node_id: int, dst_node_id: Optional[int], compute_predecessors: Optional[bool], maximal_depth: Optional[int]) -> ShortestPathsResultBFS: ...
    def get_unchecked_shortest_path_node_ids_from_node_ids(self, src_node_id: int, dst_node_id: int, maximal_depth: Optional[int]) -> np.ndarray: ...
    def get_unchecked_shortest_path_node_names_from_node_ids(self, src_node_id: int, dst_node_id: int, maximal_depth: Optional[int]) -> List[str]: ...
    def get_shortest_path_node_ids_from_node_ids(self, src_node_id: int, dst_node_id: int, maximal_depth: Optional[int]) -> np.ndarray: ...
    def get_shortest_path_node_ids_from_node_names(self, src_node_name: str, dst_node_name: str, maximal_depth: Optional[int]) -> np.ndarray: ...
    def get_shortest_path_node_names_from_node_names(self, src_node_name: str, dst_node_name: str, maximal_depth: Optional[int]) -> List[str]: ...
    def get_unchecked_k_shortest_path_node_ids_from_node_ids(self, src_node_id: int, dst_node_id: int, k: int) -> List[List[int]]: ...
    def get_k_shortest_path_node_ids_from_node_ids(self, src_node_id: int, dst_node_id: int, k: int) -> List[List[int]]: ...
    def get_k_shortest_path_node_ids_from_node_names(self, src_node_name: str, dst_node_name: str, k: int) -> List[List[int]]: ...
    def get_k_shortest_path_node_names_from_node_names(self, src_node_name: str, dst_node_name: str, k: int) -> List[List[str]]: ...
    def get_unchecked_eccentricity_and_most_distant_node_id_from_node_id(self, node_id: int) -> Tuple[int, int]: ...
    def get_unchecked_weighted_eccentricity_from_node_id(self, node_id: int, use_edge_weights_as_probabilities: Optional[bool]) -> float: ...
    def get_eccentricity_and_most_distant_node_id_from_node_id(self, node_id: int) -> Tuple[int, int]: ...
    def get_weighted_eccentricity_from_node_id(self, node_id: int, use_edge_weights_as_probabilities: Optional[bool]) -> float: ...
    def get_eccentricity_from_node_name(self, node_name: str) -> int: ...
    def get_weighted_eccentricity_from_node_name(self, node_name: str, use_edge_weights_as_probabilities: Optional[bool]) -> float: ...
    def get_unchecked_dijkstra_from_node_ids(self, src_node_id: int, maybe_dst_node_id: Optional[int], maybe_dst_node_ids: Optional[List[int]], compute_predecessors: Optional[bool], maximal_depth: Optional[int], use_edge_weights_as_probabilities: Optional[bool]) -> ShortestPathsDjkstra: ...
    def get_unchecked_weighted_shortest_path_node_ids_from_node_ids(self, src_node_id: int, dst_node_id: int, use_edge_weights_as_probabilities: Optional[bool], maximal_depth: Optional[int]) -> Tuple[float, List[int]]: ...
    def get_unchecked_weighted_shortest_path_node_names_from_node_ids(self, src_node_id: int, dst_node_id: int, use_edge_weights_as_probabilities: Optional[bool], maximal_depth: Optional[int]) -> Tuple[float, List[str]]: ...
    def get_weighted_shortest_path_node_ids_from_node_ids(self, src_node_id: int, dst_node_id: int, use_edge_weights_as_probabilities: Optional[bool], maximal_depth: Optional[int]) -> Tuple[float, List[int]]: ...
    def get_weighted_shortest_path_node_ids_from_node_names(self, src_node_name: str, dst_node_name: str, use_edge_weights_as_probabilities: Optional[bool], maximal_depth: Optional[int]) -> Tuple[float, List[int]]: ...
    def get_weighted_shortest_path_node_names_from_node_names(self, src_node_name: str, dst_node_name: str, use_edge_weights_as_probabilities: Optional[bool], maximal_depth: Optional[int]) -> Tuple[float, List[str]]: ...
    def get_breadth_first_search_from_node_ids(self, src_node_id: int, dst_node_id: Optional[int], compute_predecessors: Optional[bool], maximal_depth: Optional[int]) -> ShortestPathsResultBFS: ...
    def get_dijkstra_from_node_ids(self, src_node_id: int, maybe_dst_node_id: Optional[int], maybe_dst_node_ids: Optional[List[int]], compute_predecessors: Optional[bool], maximal_depth: Optional[int], use_edge_weights_as_probabilities: Optional[bool]) -> ShortestPathsDjkstra: ...
    def get_diameter_naive(self, ignore_infinity: Optional[bool], verbose: Optional[bool]) -> float: ...
    def get_diameter(self, ignore_infinity: Optional[bool], verbose: Optional[bool]) -> float: ...
    def get_weighted_diameter_naive(self, ignore_infinity: Optional[bool], use_edge_weights_as_probabilities: Optional[bool], verbose: Optional[bool]) -> float: ...
    def get_breadth_first_search_from_node_names(self, src_node_name: str, dst_node_name: Optional[str], compute_predecessors: Optional[bool], maximal_depth: Optional[int]) -> ShortestPathsResultBFS: ...
    def get_dijkstra_from_node_names(self, src_node_name: str, maybe_dst_node_name: Optional[str], maybe_dst_node_names: Optional[List[str]], compute_predecessors: Optional[bool], maximal_depth: Optional[int], use_edge_weights_as_probabilities: Optional[bool]) -> ShortestPathsDjkstra: ...
    def get_bipartite_edges(self, removed_existing_edges: Optional[bool], first_nodes_set: Optional[Set[str]], second_nodes_set: Optional[Set[str]], first_node_types_set: Optional[Set[str]], second_node_types_set: Optional[Set[str]]) -> np.ndarray: ...
    def get_bipartite_edge_names(self, removed_existing_edges: Optional[bool], first_nodes_set: Optional[Set[str]], second_nodes_set: Optional[Set[str]], first_node_types_set: Optional[Set[str]], second_node_types_set: Optional[Set[str]]) -> List[List[str]]: ...
    def get_star_edges(self, central_node: str, removed_existing_edges: Optional[bool], star_points_nodes_set: Optional[Set[str]], star_points_node_types_set: Optional[Set[str]]) -> np.ndarray: ...
    def get_star_edge_names(self, central_node: str, removed_existing_edges: Optional[bool], star_points_nodes_set: Optional[Set[str]], star_points_node_types_set: Optional[Set[str]]) -> List[List[str]]: ...
    def get_clique_edges(self, directed: Optional[bool], allow_selfloops: Optional[bool], removed_existing_edges: Optional[bool], allow_node_type_set: Optional[Set[str]], allow_node_set: Optional[Set[str]]) -> np.ndarray: ...
    def get_clique_edge_names(self, directed: Optional[bool], allow_selfloops: Optional[bool], removed_existing_edges: Optional[bool], allow_node_type_set: Optional[Set[str]], allow_node_set: Optional[Set[str]]) -> List[List[str]]: ...
    def get_unchecked_minimum_preferential_attachment(self) -> float: ...
    def get_unchecked_maximum_preferential_attachment(self) -> float: ...
    def get_unchecked_weighted_minimum_preferential_attachment(self) -> float: ...
    def get_unchecked_weighted_maximum_preferential_attachment(self) -> float: ...
    def get_unchecked_preferential_attachment_from_node_ids(self, source_node_id: int, destination_node_id: int, normalize: bool) -> float: ...
    def get_preferential_attachment_from_node_ids(self, source_node_id: int, destination_node_id: int, normalize: bool) -> float: ...
    def get_preferential_attachment_from_node_names(self, first_node_name: str, second_node_name: str, normalize: bool) -> float: ...
    def get_unchecked_weighted_preferential_attachment_from_node_ids(self, source_node_id: int, destination_node_id: int, normalize: bool) -> float: ...
    def get_weighted_preferential_attachment_from_node_ids(self, source_node_id: int, destination_node_id: int, normalize: bool) -> float: ...
    def get_weighted_preferential_attachment_from_node_names(self, first_node_name: str, second_node_name: str, normalize: bool) -> float: ...
    def get_unchecked_jaccard_coefficient_from_node_ids(self, source_node_id: int, destination_node_id: int) -> float: ...
    def get_jaccard_coefficient_from_node_ids(self, source_node_id: int, destination_node_id: int) -> float: ...
    def get_jaccard_coefficient_from_node_names(self, first_node_name: str, second_node_name: str) -> float: ...
    def get_unchecked_adamic_adar_index_from_node_ids(self, source_node_id: int, destination_node_id: int) -> float: ...
    def get_adamic_adar_index_from_node_ids(self, source_node_id: int, destination_node_id: int) -> float: ...
    def get_adamic_adar_index_from_node_names(self, first_node_name: str, second_node_name: str) -> float: ...
    def get_unchecked_resource_allocation_index_from_node_ids(self, source_node_id: int, destination_node_id: int) -> float: ...
    def get_unchecked_weighted_resource_allocation_index_from_node_ids(self, source_node_id: int, destination_node_id: int) -> float: ...
    def get_resource_allocation_index_from_node_ids(self, source_node_id: int, destination_node_id: int) -> float: ...
    def get_resource_allocation_index_from_node_names(self, first_node_name: str, second_node_name: str) -> float: ...
    def get_weighted_resource_allocation_index_from_node_ids(self, source_node_id: int, destination_node_id: int) -> float: ...
    def get_weighted_resource_allocation_index_from_node_names(self, first_node_name: str, second_node_name: str) -> float: ...
    def get_unchecked_all_edge_metrics_from_node_ids(self, source_node_id: int, destination_node_id: int, normalize: bool) -> np.ndarray: ...
    def filter_from_ids(self, node_ids_to_keep: Optional[List[int]], node_ids_to_filter: Optional[List[int]], node_type_ids_to_keep: Optional[List[Optional[List[int]]]], node_type_ids_to_filter: Optional[List[Optional[List[int]]]], node_type_id_to_keep: Optional[List[Optional[int]]], node_type_id_to_filter: Optional[List[Optional[int]]], edge_ids_to_keep: Optional[List[int]], edge_ids_to_filter: Optional[List[int]], edge_node_ids_to_keep: Optional[List[Tuple[int, int]]], edge_node_ids_to_filter: Optional[List[Tuple[int, int]]], edge_type_ids_to_keep: Optional[List[Optional[int]]], edge_type_ids_to_filter: Optional[List[Optional[int]]], min_edge_weight: Optional[float], max_edge_weight: Optional[float], filter_singleton_nodes: Optional[bool], filter_singleton_nodes_with_selfloop: Optional[bool], filter_selfloops: Optional[bool], filter_parallel_edges: Optional[bool]) -> Graph: ...
    def filter_from_names(self, node_names_to_keep: Optional[List[str]], node_names_to_filter: Optional[List[str]], node_type_names_to_keep: Optional[List[Optional[List[str]]]], node_type_names_to_filter: Optional[List[Optional[List[str]]]], node_type_name_to_keep: Optional[List[Optional[str]]], node_type_name_to_filter: Optional[List[Optional[str]]], edge_node_names_to_keep: Optional[List[Tuple[str, str]]], edge_node_names_to_filter: Optional[List[Tuple[str, str]]], edge_type_names_to_keep: Optional[List[Optional[str]]], edge_type_names_to_filter: Optional[List[Optional[str]]], min_edge_weight: Optional[float], max_edge_weight: Optional[float], filter_singleton_nodes: Optional[bool], filter_singleton_nodes_with_selfloop: Optional[bool], filter_selfloops: Optional[bool], filter_parallel_edges: Optional[bool]) -> Graph: ...
    def drop_unknown_node_types(self) -> Graph: ...
    def drop_unknown_edge_types(self) -> Graph: ...
    def drop_singleton_nodes(self) -> Graph: ...
    def drop_singleton_nodes_with_selfloops(self) -> Graph: ...
    def drop_disconnected_nodes(self) -> Graph: ...
    def drop_selfloops(self) -> Graph: ...
    def drop_parallel_edges(self) -> Graph: ...
    @staticmethod
    def from_csv(node_type_path: Optional[str], node_type_list_separator: Optional[str], node_types_column_number: Optional[int], node_types_column: Optional[str], node_types_ids_column_number: Optional[int], node_types_ids_column: Optional[str], node_types_number: Optional[int], numeric_node_type_ids: Optional[bool], minimum_node_type_id: Optional[int], node_type_list_header: Optional[bool], node_type_list_rows_to_skip: Optional[int], node_type_list_is_correct: Optional[bool], node_type_list_max_rows_number: Optional[int], node_type_list_comment_symbol: Optional[str], load_node_type_list_in_parallel: Optional[bool], node_path: Optional[str], node_list_separator: Optional[str], node_list_header: Optional[bool], node_list_rows_to_skip: Optional[int], node_list_is_correct: Optional[bool], node_list_max_rows_number: Optional[int], node_list_comment_symbol: Optional[str], default_node_type: Optional[str], nodes_column_number: Optional[int], nodes_column: Optional[str], node_types_separator: Optional[str], node_list_node_types_column_number: Optional[int], node_list_node_types_column: Optional[str], node_ids_column: Optional[str], node_ids_column_number: Optional[int], nodes_number: Optional[int], minimum_node_id: Optional[int], numeric_node_ids: Optional[bool], node_list_numeric_node_type_ids: Optional[bool], skip_node_types_if_unavailable: Optional[bool], load_node_list_in_parallel: Optional[bool], edge_type_path: Optional[str], edge_types_column_number: Optional[int], edge_types_column: Optional[str], edge_types_ids_column_number: Optional[int], edge_types_ids_column: Optional[str], edge_types_number: Optional[int], numeric_edge_type_ids: Optional[bool], minimum_edge_type_id: Optional[int], edge_type_list_separator: Optional[str], edge_type_list_header: Optional[bool], edge_type_list_rows_to_skip: Optional[int], edge_type_list_is_correct: Optional[bool], edge_type_list_max_rows_number: Optional[int], edge_type_list_comment_symbol: Optional[str], load_edge_type_list_in_parallel: Optional[bool], edge_path: Optional[str], edge_list_separator: Optional[str], edge_list_header: Optional[bool], edge_list_rows_to_skip: Optional[int], sources_column_number: Optional[int], sources_column: Optional[str], destinations_column_number: Optional[int], destinations_column: Optional[str], edge_list_edge_types_column_number: Optional[int], edge_list_edge_types_column: Optional[str], default_edge_type: Optional[str], weights_column_number: Optional[int], weights_column: Optional[str], default_weight: Optional[float], edge_ids_column: Optional[str], edge_ids_column_number: Optional[int], edge_list_numeric_edge_type_ids: Optional[bool], edge_list_numeric_node_ids: Optional[bool], skip_weights_if_unavailable: Optional[bool], skip_edge_types_if_unavailable: Optional[bool], edge_list_is_complete: Optional[bool], edge_list_may_contain_duplicates: Optional[bool], edge_list_is_sorted: Optional[bool], edge_list_is_correct: Optional[bool], edge_list_max_rows_number: Optional[int], edge_list_comment_symbol: Optional[str], edges_number: Optional[int], load_edge_list_in_parallel: Optional[bool], verbose: Optional[bool], may_have_singletons: Optional[bool], may_have_singleton_with_selfloops: Optional[bool], directed: bool, name: Optional[str]) -> Graph: ...
    def get_connected_components_number(self, verbose: Optional[bool]) -> Tuple[int, int, int]: ...
    def get_connected_nodes_number(self) -> int: ...
    def get_singleton_nodes_with_selfloops_number(self) -> int: ...
    def get_singleton_nodes_number(self) -> int: ...
    def get_disconnected_nodes_number(self) -> int: ...
    def get_singleton_node_ids(self) -> np.ndarray: ...
    def get_singleton_node_names(self) -> List[str]: ...
    def get_singleton_with_selfloops_node_ids(self) -> np.ndarray: ...
    def get_singleton_with_selfloops_node_names(self) -> List[str]: ...
    def get_density(self) -> float: ...
    def get_trap_nodes_rate(self) -> float: ...
    def get_node_degrees_mean(self) -> float: ...
    def get_weighted_node_degrees_mean(self) -> float: ...
    def get_undirected_edges_number(self) -> int: ...
    def get_unique_undirected_edges_number(self) -> int: ...
    def get_edges_number(self) -> int: ...
    def get_unique_edges_number(self) -> int: ...
    def get_node_degrees_median(self) -> int: ...
    def get_weighted_node_degrees_median(self) -> float: ...
    def get_maximum_node_degree(self) -> int: ...
    def get_unchecked_most_central_node_id(self) -> int: ...
    def get_most_central_node_id(self) -> int: ...
    def get_minimum_node_degree(self) -> int: ...
    def get_node_degrees_mode(self) -> int: ...
    def get_selfloop_nodes_rate(self) -> float: ...
    def get_name(self) -> str: ...
    def get_trap_nodes_number(self) -> int: ...
    def get_source_node_ids(self, directed: bool) -> np.ndarray: ...
    def get_directed_source_node_ids(self) -> np.ndarray: ...
    def get_source_names(self, directed: bool) -> List[str]: ...
    def get_destination_node_ids(self, directed: bool) -> np.ndarray: ...
    def get_directed_destination_node_ids(self) -> np.ndarray: ...
    def get_destination_names(self, directed: bool) -> List[str]: ...
    def get_node_names(self) -> List[str]: ...
    def get_node_urls(self) -> List[Optional[str]]: ...
    def get_node_ontologies(self) -> List[Optional[str]]: ...
    def get_node_ids(self) -> np.ndarray: ...
    def get_edge_type_ids(self) -> List[Optional[int]]: ...
    def get_unique_edge_type_ids(self) -> np.ndarray: ...
    def get_edge_type_names(self) -> List[Optional[str]]: ...
    def get_unique_edge_type_names(self) -> List[str]: ...
    def get_edge_weights(self) -> np.ndarray: ...
    def get_weighted_node_indegrees(self) -> np.ndarray: ...
    def get_node_type_ids(self) -> List[Optional[List[int]]]: ...
    def get_known_node_types_mask(self) -> np.ndarray: ...
    def get_unknown_node_types_mask(self) -> np.ndarray: ...
    def get_one_hot_encoded_node_types(self) -> np.ndarray: ...
    def get_one_hot_encoded_known_node_types(self) -> np.ndarray: ...
    def get_one_hot_encoded_edge_types(self) -> np.ndarray: ...
    def get_one_hot_encoded_known_edge_types(self) -> np.ndarray: ...
    def get_node_type_names(self) -> List[Optional[List[str]]]: ...
    def get_unique_node_type_ids(self) -> np.ndarray: ...
    def get_unique_node_type_names(self) -> List[str]: ...
    def get_unique_directed_edges_number(self) -> int: ...
    def get_nodes_mapping(self) -> Dict[str, int]: ...
    def get_edge_node_ids(self, directed: bool) -> np.ndarray: ...
    def get_directed_edge_node_ids(self) -> np.ndarray: ...
    def get_edge_node_names(self, directed: bool) -> List[Tuple[str, str]]: ...
    def get_directed_edge_node_names(self) -> List[Tuple[str, str]]: ...
    def get_unknown_node_types_number(self) -> int: ...
    def get_known_node_types_number(self) -> int: ...
    def get_unknown_node_types_rate(self) -> float: ...
    def get_known_node_types_rate(self) -> float: ...
    def get_minimum_node_types_number(self) -> int: ...
    def get_maximum_node_types_number(self) -> int: ...
    def get_maximum_multilabel_count(self) -> int: ...
    def get_singleton_node_types_number(self) -> int: ...
    def get_singleton_node_type_ids(self) -> np.ndarray: ...
    def get_singleton_node_type_names(self) -> List[str]: ...
    def get_unknown_edge_types_number(self) -> int: ...
    def get_edge_ids_with_unknown_edge_types(self) -> np.ndarray: ...
    def get_edge_ids_with_known_edge_types(self) -> np.ndarray: ...
    def get_edge_node_ids_with_unknown_edge_types(self, directed: bool) -> List[Tuple[int, int]]: ...
    def get_edge_node_ids_with_known_edge_types(self, directed: bool) -> List[Tuple[int, int]]: ...
    def get_edge_node_names_with_unknown_edge_types(self, directed: bool) -> List[Tuple[str, str]]: ...
    def get_edge_node_names_with_known_edge_types(self, directed: bool) -> List[Tuple[str, str]]: ...
    def get_edge_ids_with_unknown_edge_types_mask(self) -> np.ndarray: ...
    def get_edge_ids_with_known_edge_types_mask(self) -> np.ndarray: ...
    def get_node_ids_with_unknown_node_types(self) -> np.ndarray: ...
    def get_node_ids_with_known_node_types(self) -> np.ndarray: ...
    def get_node_names_with_unknown_node_types(self) -> List[str]: ...
    def get_node_names_with_known_node_types(self) -> List[str]: ...
    def get_node_ids_with_unknown_node_types_mask(self) -> np.ndarray: ...
    def get_node_ids_with_known_node_types_mask(self) -> np.ndarray: ...
    def get_known_edge_types_number(self) -> int: ...
    def get_unknown_edge_types_rate(self) -> float: ...
    def get_known_edge_types_rate(self) -> float: ...
    def get_minimum_edge_types_number(self) -> int: ...
    def get_singleton_edge_types_number(self) -> int: ...
    def get_singleton_edge_type_ids(self) -> np.ndarray: ...
    def get_singleton_edge_type_names(self) -> List[str]: ...
    def get_nodes_number(self) -> int: ...
    def get_node_connected_component_ids(self, verbose: Optional[bool]) -> np.ndarray: ...
    def get_directed_edges_number(self) -> int: ...
    def get_edge_types_number(self) -> int: ...
    def get_node_types_number(self) -> int: ...
    def get_node_degrees(self) -> np.ndarray: ...
    def get_node_indegrees(self) -> np.ndarray: ...
    def get_weighted_node_degrees(self) -> np.ndarray: ...
    def get_not_singletons_node_ids(self) -> np.ndarray: ...
    def get_dense_nodes_mapping(self) -> Dict[int, int]: ...
    def get_parallel_edges_number(self) -> int: ...
    def get_cumulative_node_degrees(self) -> np.ndarray: ...
    def get_reciprocal_sqrt_degrees(self) -> np.ndarray: ...
    def get_unique_source_nodes_number(self) -> int: ...
    def get_edge_type_id_counts_hashmap(self) -> Dict[int, int]: ...
    def get_edge_type_names_counts_hashmap(self) -> Dict[str, int]: ...
    def get_node_type_id_counts_hashmap(self) -> Dict[int, int]: ...
    def get_node_type_names_counts_hashmap(self) -> Dict[str, int]: ...
    def has_default_graph_name(self) -> bool: ...
    def has_nodes(self) -> bool: ...
    def has_edges(self) -> bool: ...
    def has_trap_nodes(self) -> bool: ...
    def is_directed(self) -> bool: ...
    def has_edge_weights(self) -> bool: ...
    def has_edge_weights_representing_probabilities(self) -> bool: ...
    def has_weighted_singleton_nodes(self) -> bool: ...
    def has_constant_edge_weights(self) -> bool: ...
    def has_negative_edge_weights(self) -> bool: ...
    def has_edge_types(self) -> bool: ...
    def has_selfloops(self) -> bool: ...
    def has_disconnected_nodes(self) -> bool: ...
    def has_singleton_nodes(self) -> bool: ...
    def has_singleton_nodes_with_selfloops(self) -> bool: ...
    def is_connected(self, verbose: Optional[bool]) -> bool: ...
    def has_node_types(self) -> bool: ...
    def has_multilabel_node_types(self) -> bool: ...
    def has_unknown_node_types(self) -> bool: ...
    def has_known_node_types(self) -> bool: ...
    def has_unknown_edge_types(self) -> bool: ...
    def has_known_edge_types(self) -> bool: ...
    def has_homogeneous_node_types(self) -> bool: ...
    def has_homogeneous_edge_types(self) -> bool: ...
    def has_singleton_node_types(self) -> bool: ...
    def has_node_oddities(self) -> bool: ...
    def has_node_types_oddities(self) -> bool: ...
    def has_singleton_edge_types(self) -> bool: ...
    def has_edge_types_oddities(self) -> bool: ...
    def is_multigraph(self) -> bool: ...
    def has_nodes_sorted_by_decreasing_outbound_node_degree(self) -> bool: ...
    def has_nodes_sorted_by_lexicographic_order(self) -> bool: ...
    def contains_identity_matrix(self) -> bool: ...
    def has_nodes_sorted_by_increasing_outbound_node_degree(self) -> bool: ...
    def get_total_edge_weights(self) -> float: ...
    def get_mininum_edge_weight(self) -> float: ...
    def get_maximum_edge_weight(self) -> float: ...
    def get_unchecked_maximum_node_degree(self) -> int: ...
    def get_unchecked_minimum_node_degree(self) -> int: ...
    def get_weighted_maximum_node_degree(self) -> float: ...
    def get_weighted_minimum_node_degree(self) -> float: ...
    def get_weighted_singleton_nodes_number(self) -> int: ...
    def get_selfloops_number(self) -> int: ...
    def get_unique_selfloops_number(self) -> int: ...
    def overlaps(self, other: Graph) -> bool: ...
    def contains(self, other: Graph) -> bool: ...
    def sample_negatives(self, negatives_number: int, random_state: Optional[int], seed_graph: Optional[Graph], only_from_same_component: Optional[bool], verbose: Optional[bool]) -> Graph: ...
    def connected_holdout(self, train_size: float, random_state: Optional[int], edge_types: Optional[List[Optional[str]]], include_all_edge_types: Optional[bool], verbose: Optional[bool]) -> Tuple[Graph, Graph]: ...
    def random_holdout(self, train_size: float, random_state: Optional[int], include_all_edge_types: Optional[bool], edge_types: Optional[List[Optional[str]]], min_number_overlaps: Optional[int], verbose: Optional[bool]) -> Tuple[Graph, Graph]: ...
    def get_node_label_holdout_indices(self, train_size: float, use_stratification: Optional[bool], random_state: Optional[int]) -> Tuple[List[int], List[int]]: ...
    def get_node_label_holdout_labels(self, train_size: float, use_stratification: Optional[bool], random_state: Optional[int]) -> Tuple[List[Optional[List[int]]], List[Optional[List[int]]]]: ...
    def get_node_label_holdout_graphs(self, train_size: float, use_stratification: Optional[bool], random_state: Optional[int]) -> Tuple[Graph, Graph]: ...
    def get_edge_label_holdout_graphs(self, train_size: float, use_stratification: Optional[bool], random_state: Optional[int]) -> Tuple[Graph, Graph]: ...
    def get_random_subgraph(self, nodes_number: int, random_state: Optional[int], verbose: Optional[bool]) -> Graph: ...
    def get_node_label_random_holdout(self, train_size: float, use_stratification: Optional[bool], random_state: Optional[int]) -> Tuple[Graph, Graph]: ...
    def get_node_label_kfold(self, k: int, k_index: int, use_stratification: Optional[bool], random_state: Optional[int]) -> Tuple[Graph, Graph]: ...
    def get_edge_label_random_holdout(self, train_size: float, use_stratification: Optional[bool], random_state: Optional[int]) -> Tuple[Graph, Graph]: ...
    def get_edge_label_kfold(self, k: int, k_index: int, use_stratification: Optional[bool], random_state: Optional[int]) -> Tuple[Graph, Graph]: ...
    def get_edge_prediction_kfold(self, k: int, k_index: int, edge_types: Optional[List[Optional[str]]], random_state: Optional[int], verbose: Optional[bool]) -> Tuple[Graph, Graph]: ...
    def get_laplacian_transformed_graph(self) -> Graph: ...
    def get_laplacian_coo_matrix_edges_number(self) -> int: ...
    def get_random_walk_normalized_laplacian_transformed_graph(self) -> Graph: ...
    def get_symmetric_normalized_laplacian_transformed_graph(self) -> Graph: ...
    def get_symmetric_normalized_transformed_graph(self) -> Graph: ...
    def get_undirected_louvain_community_detection(self, recursion_minimum_improvement: Optional[float], first_phase_minimum_improvement: Optional[float], patience: Optional[int], random_state: Optional[int]) -> List[List[int]]: ...
    def get_directed_modularity_from_node_community_memberships(self, node_community_memberships: List[int]) -> float: ...
    def get_undirected_modularity_from_node_community_memberships(self, node_community_memberships: List[int]) -> float: ...
    def get_memory_stats(self) -> str: ...
    def get_total_memory_used(self) -> int: ...
    def get_nodes_total_memory_requirement(self) -> int: ...
    def get_nodes_total_memory_requirement_human_readable(self) -> str: ...
    def get_edges_total_memory_requirement(self) -> int: ...
    def get_edges_total_memory_requirement_human_readable(self) -> str: ...
    def get_edge_weights_total_memory_requirements(self) -> int: ...
    def get_edge_weights_total_memory_requirements_human_readable(self) -> str: ...
    def get_node_types_total_memory_requirements(self) -> int: ...
    def get_node_types_total_memory_requirements_human_readable(self) -> str: ...
    def get_edge_types_total_memory_requirements(self) -> int: ...
    def get_edge_types_total_memory_requirements_human_readable(self) -> str: ...
    def enable(self, vector_sources: Optional[bool], vector_destinations: Optional[bool], vector_cumulative_node_degrees: Optional[bool], vector_reciprocal_sqrt_degrees: Optional[bool]): ...
    def get_random_nodes(self, number_of_nodes_to_sample: int, random_state: int) -> np.ndarray: ...
    def get_breadth_first_search_random_nodes(self, number_of_nodes_to_sample: int, root_node: int) -> np.ndarray: ...
    def get_uniform_random_walk_random_nodes(self, node: int, random_state: int, walk_length: int, unique: Optional[bool]) -> np.ndarray: ...
    def get_node_sampling_methods(self) -> List[str]: ...
    def get_subsampled_nodes(self, number_of_nodes_to_sample: int, random_state: int, root_node: Optional[int], node_sampling_method: str, unique: Optional[bool]) -> np.ndarray: ...
    def is_compatible(self, other: Graph) -> bool: ...
    def has_same_adjacency_matrix(self, other: Graph) -> bool: ...
    def validate_node_id(self, node_id: int) -> int: ...
    def validate_node_ids(self, node_ids: List[int]) -> np.ndarray: ...
    def validate_edge_id(self, edge_id: int) -> int: ...
    def validate_edge_ids(self, edge_ids: List[int]) -> np.ndarray: ...
    def must_not_contain_unknown_node_types(self): ...
    def must_not_contain_unknown_edge_types(self): ...
    def validate_node_type_id(self, node_type_id: Optional[int]) -> Optional[int]: ...
    def validate_node_type_ids(self, node_type_ids: List[Optional[int]]) -> List[Optional[int]]: ...
    def validate_edge_type_id(self, edge_type_id: Optional[int]) -> Optional[int]: ...
    def validate_edge_type_ids(self, edge_type_ids: List[Optional[int]]) -> List[Optional[int]]: ...
    def must_be_undirected(self): ...
    def must_be_multigraph(self): ...
    def must_not_be_multigraph(self): ...
    def must_contain_identity_matrix(self): ...
    def must_not_contain_weighted_singleton_nodes(self): ...
    def must_have_edges(self): ...
    def must_have_nodes(self): ...
    def must_be_connected(self): ...
    def get_number_of_triangles(self, normalize: Optional[bool], low_centrality: Optional[int], verbose: Optional[bool]) -> int: ...
    def get_triads_number(self) -> int: ...
    def get_weighted_triads_number(self) -> float: ...
    def get_transitivity(self, low_centrality: Optional[int], verbose: Optional[bool]) -> float: ...
    def get_number_of_triangles_per_node(self, normalize: Optional[bool], low_centrality: Optional[int], verbose: Optional[bool]) -> np.ndarray: ...
    def get_clustering_coefficient_per_node(self, low_centrality: Optional[int], verbose: Optional[bool]) -> np.ndarray: ...
    def get_clustering_coefficient(self, low_centrality: Optional[int], verbose: Optional[bool]) -> float: ...
    def get_average_clustering_coefficient(self, low_centrality: Optional[int], verbose: Optional[bool]) -> float: ...
    def get_okapi_bm25_node_feature_propagation(self, features: List[List[float]], iterations: Optional[int], maximal_distance: Optional[int], k1: Optional[float], b: Optional[float], include_central_node: Optional[bool], verbose: Optional[bool]) -> np.ndarray: ...
    def get_okapi_bm25_node_label_propagation(self, iterations: Optional[int], maximal_distance: Optional[int], k1: Optional[float], b: Optional[float], verbose: Optional[bool]) -> np.ndarray: ...
    def get_unchecked_edge_weight_from_edge_id(self, edge_id: int) -> Optional[float]: ...
    def get_unchecked_edge_weight_from_node_ids(self, src: int, dst: int) -> float: ...
    def get_unchecked_node_id_from_node_name(self, node_name: str) -> int: ...
    def get_unchecked_edge_type_id_from_edge_type_name(self, edge_type_name: str) -> Optional[int]: ...
    def get_unchecked_edge_type_name_from_edge_type_id(self, edge_type_id: Optional[int]) -> Optional[str]: ...
    def get_unchecked_edge_count_from_edge_type_id(self, edge_type: Optional[int]) -> int: ...
    def get_unchecked_edge_id_from_node_ids_and_edge_type_id(self, src: int, dst: int, edge_type: Optional[int]) -> int: ...
    def get_unchecked_minmax_edge_ids_from_node_ids(self, src: int, dst: int) -> Tuple[int, int]: ...
    def get_unchecked_node_ids_from_edge_id(self, edge_id: int) -> Tuple[int, int]: ...
    def get_unchecked_node_names_from_edge_id(self, edge_id: int) -> Tuple[str, str]: ...
    def get_unchecked_source_node_id_from_edge_id(self, edge_id: int) -> int: ...
    def get_unchecked_destination_node_id_from_edge_id(self, edge_id: int) -> int: ...
    def get_source_node_id_from_edge_id(self, edge_id: int) -> int: ...
    def get_destination_node_id_from_edge_id(self, edge_id: int) -> int: ...
    def get_unchecked_source_node_name_from_edge_id(self, edge_id: int) -> str: ...
    def get_unchecked_destination_node_name_from_edge_id(self, edge_id: int) -> str: ...
    def get_source_node_name_from_edge_id(self, edge_id: int) -> str: ...
    def get_destination_node_name_from_edge_id(self, edge_id: int) -> str: ...
    def get_node_names_from_edge_id(self, edge_id: int) -> Tuple[str, str]: ...
    def get_node_ids_from_edge_id(self, edge_id: int) -> Tuple[int, int]: ...
    def get_unchecked_edge_id_from_node_ids(self, src: int, dst: int) -> int: ...
    def get_edge_id_from_node_ids(self, src: int, dst: int) -> int: ...
    def get_unchecked_unique_source_node_id(self, source_id: int) -> int: ...
    def get_unchecked_node_ids_and_edge_type_id_from_edge_id(self, edge_id: int) -> Tuple[int, int, Optional[int]]: ...
    def get_node_ids_and_edge_type_id_from_edge_id(self, edge_id: int) -> Tuple[int, int, Optional[int]]: ...
    def get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(self, edge_id: int) -> Tuple[int, int, Optional[int], Optional[float]]: ...
    def get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(self, edge_id: int) -> Tuple[int, int, Optional[int], Optional[float]]: ...
    def get_top_k_central_node_ids(self, k: int) -> np.ndarray: ...
    def get_weighted_top_k_central_node_ids(self, k: int) -> np.ndarray: ...
    def get_unchecked_node_degree_from_node_id(self, node_id: int) -> int: ...
    def get_unchecked_weighted_node_degree_from_node_id(self, node_id: int) -> float: ...
    def get_node_degree_from_node_id(self, node_id: int) -> int: ...
    def get_unchecked_comulative_node_degree_from_node_id(self, node_id: int) -> int: ...
    def get_comulative_node_degree_from_node_id(self, node_id: int) -> int: ...
    def get_unchecked_reciprocal_sqrt_degree_from_node_id(self, node_id: int) -> float: ...
    def get_reciprocal_sqrt_degree_from_node_id(self, node_id: int) -> float: ...
    def get_unchecked_reciprocal_sqrt_degrees_from_node_ids(self, node_ids: List[int]) -> np.ndarray: ...
    def get_weighted_node_degree_from_node_id(self, node_id: int) -> float: ...
    def get_node_degree_from_node_name(self, node_name: str) -> int: ...
    def get_top_k_central_node_names(self, k: int) -> List[str]: ...
    def get_unchecked_node_type_id_from_node_id(self, node_id: int) -> Optional[List[int]]: ...
    def get_node_type_ids_from_node_id(self, node_id: int) -> Optional[List[int]]: ...
    def get_unchecked_edge_type_id_from_edge_id(self, edge_id: int) -> Optional[int]: ...
    def get_edge_type_id_from_edge_id(self, edge_id: int) -> Optional[int]: ...
    def get_unchecked_node_type_names_from_node_id(self, node_id: int) -> Optional[List[str]]: ...
    def get_node_type_names_from_node_id(self, node_id: int) -> Optional[List[str]]: ...
    def get_node_type_names_from_node_name(self, node_name: str) -> Optional[List[str]]: ...
    def get_edge_type_name_from_edge_id(self, edge_id: int) -> Optional[str]: ...
    def get_edge_type_name_from_edge_type_id(self, edge_type_id: int) -> str: ...
    def get_edge_weight_from_edge_id(self, edge_id: int) -> float: ...
    def get_edge_weight_from_node_ids(self, src: int, dst: int) -> float: ...
    def get_edge_weight_from_node_ids_and_edge_type_id(self, src: int, dst: int, edge_type: Optional[int]) -> float: ...
    def get_edge_weight_from_node_names_and_edge_type_name(self, src: str, dst: str, edge_type: Optional[str]) -> float: ...
    def get_edge_weight_from_node_names(self, src_name: str, dst_name: str) -> float: ...
    def get_unchecked_node_name_from_node_id(self, node_id: int) -> str: ...
    def get_node_name_from_node_id(self, node_id: int) -> str: ...
    def get_node_id_from_node_name(self, node_name: str) -> int: ...
    def get_node_ids_from_node_names(self, node_names: List[str]) -> np.ndarray: ...
    def get_edge_node_ids_from_edge_node_names(self, edge_node_names: List[Tuple[str, str]]) -> List[Tuple[int, int]]: ...
    def get_edge_node_names_from_edge_node_ids(self, edge_node_ids: List[Tuple[int, int]]) -> List[Tuple[str, str]]: ...
    def get_node_type_ids_from_node_name(self, node_name: str) -> Optional[List[int]]: ...
    def get_node_type_name_from_node_name(self, node_name: str) -> Optional[List[str]]: ...
    def get_edge_count_from_edge_type_id(self, edge_type_id: Optional[int]) -> int: ...
    def get_edge_type_id_from_edge_type_name(self, edge_type_name: Optional[str]) -> Optional[int]: ...
    def get_edge_count_from_edge_type_name(self, edge_type_name: Optional[str]) -> int: ...
    def get_node_type_id_from_node_type_name(self, node_type_name: str) -> int: ...
    def get_node_count_from_node_type_id(self, node_type_id: Optional[int]) -> int: ...
    def get_node_count_from_node_type_name(self, node_type_name: Optional[str]) -> int: ...
    def get_neighbour_node_ids_from_node_id(self, node_id: int) -> np.ndarray: ...
    def get_neighbour_node_ids_from_node_name(self, node_name: str) -> np.ndarray: ...
    def get_neighbour_node_names_from_node_name(self, node_name: str) -> List[str]: ...
    def get_minmax_edge_ids_from_node_ids(self, src: int, dst: int) -> Tuple[int, int]: ...
    def get_edge_id_from_node_ids_and_edge_type_id(self, src: int, dst: int, edge_type: Optional[int]) -> int: ...
    def get_edge_id_from_node_names(self, src_name: str, dst_name: str) -> int: ...
    def get_edge_id_from_node_names_and_edge_type_name(self, src_name: str, dst_name: str, edge_type_name: Optional[str]) -> int: ...
    def get_edge_type_ids_from_edge_type_names(self, edge_type_names: List[Optional[str]]) -> List[Optional[int]]: ...
    def get_node_type_ids_from_node_type_names(self, node_type_names: List[Optional[str]]) -> List[Optional[int]]: ...
    def get_multiple_node_type_ids_from_node_type_names(self, node_type_names: List[Optional[List[str]]]) -> List[Optional[List[int]]]: ...
    def get_unchecked_minmax_edge_ids_from_source_node_id(self, src: int) -> Tuple[int, int]: ...
    def get_minmax_edge_ids_from_source_node_id(self, src: int) -> Tuple[int, int]: ...
    def get_node_type_name_from_node_type_id(self, node_type_id: int) -> str: ...
    def get_unchecked_node_type_names_from_node_type_ids(self, node_type_ids: List[int]) -> List[str]: ...
    def is_unchecked_connected_from_node_id(self, node_id: int) -> bool: ...
    def is_unchecked_disconnected_node_from_node_id(self, node_id: int) -> bool: ...
    def is_unchecked_singleton_from_node_id(self, node_id: int) -> bool: ...
    def is_singleton_from_node_id(self, node_id: int) -> bool: ...
    def is_unchecked_singleton_with_selfloops_from_node_id(self, node_id: int) -> bool: ...
    def is_singleton_with_selfloops_from_node_id(self, node_id: int) -> bool: ...
    def is_unchecked_singleton_from_node_name(self, node_name: str) -> bool: ...
    def is_singleton_from_node_name(self, node_name: str) -> bool: ...
    def has_node_name(self, node_name: str) -> bool: ...
    def has_node_type_id(self, node_type_id: int) -> bool: ...
    def has_node_type_name(self, node_type_name: str) -> bool: ...
    def has_edge_type_id(self, edge_type_id: int) -> bool: ...
    def has_edge_type_name(self, edge_type_name: str) -> bool: ...
    def has_edge_from_node_ids(self, src: int, dst: int) -> bool: ...
    def has_selfloop_from_node_id(self, node_id: int) -> bool: ...
    def has_edge_from_node_ids_and_edge_type_id(self, src: int, dst: int, edge_type: Optional[int]) -> bool: ...
    def is_unchecked_trap_node_from_node_id(self, node_id: int) -> bool: ...
    def is_trap_node_from_node_id(self, node_id: int) -> bool: ...
    def has_node_name_and_node_type_name(self, node_name: str, node_type_name: Optional[List[str]]) -> bool: ...
    def has_edge_from_node_names(self, src_name: str, dst_name: str) -> bool: ...
    def has_edge_from_node_names_and_edge_type_name(self, src_name: str, dst_name: str, edge_type_name: Optional[str]) -> bool: ...
    @staticmethod
    def generate_random_connected_graph(random_state: Optional[int], minimum_node_id: Optional[int], minimum_node_sampling: Optional[int], maximum_node_sampling: Optional[int], nodes_number: Optional[int], include_selfloops: Optional[bool], node_type: Optional[str], edge_type: Optional[str], weight: Optional[float], directed: Optional[bool], name: Optional[str]) -> Graph: ...
    @staticmethod
    def generate_random_spanning_tree(random_state: Optional[int], minimum_node_id: Optional[int], nodes_number: Optional[int], include_selfloops: Optional[bool], node_type: Optional[str], edge_type: Optional[str], weight: Optional[float], directed: Optional[bool], name: Optional[str]) -> Graph: ...
    @staticmethod
    def generate_circle_graph(minimum_node_id: Optional[int], nodes_number: Optional[int], include_selfloops: Optional[bool], node_type: Optional[str], edge_type: Optional[str], weight: Optional[float], directed: Optional[bool], name: Optional[str]) -> Graph: ...
    @staticmethod
    def generate_chain_graph(minimum_node_id: Optional[int], nodes_number: Optional[int], include_selfloops: Optional[bool], node_type: Optional[str], edge_type: Optional[str], weight: Optional[float], directed: Optional[bool], name: Optional[str]) -> Graph: ...
    @staticmethod
    def generate_complete_graph(minimum_node_id: Optional[int], nodes_number: Optional[int], include_selfloops: Optional[bool], node_type: Optional[str], edge_type: Optional[str], weight: Optional[float], directed: Optional[bool], name: Optional[str]) -> Graph: ...
    @staticmethod
    def generate_barbell_graph(minimum_node_id: Optional[int], left_clique_nodes_number: Optional[int], right_clique_nodes_number: Optional[int], chain_nodes_number: Optional[int], include_selfloops: Optional[bool], left_clique_node_type: Optional[str], right_clique_node_type: Optional[str], chain_node_type: Optional[str], left_clique_edge_type: Optional[str], right_clique_edge_type: Optional[str], chain_edge_type: Optional[str], left_clique_weight: Optional[float], right_clique_weight: Optional[float], chain_weight: Optional[float], directed: Optional[bool], name: Optional[str]) -> Graph: ...
    def are_nodes_remappable(self, other: Graph) -> bool: ...
    def remap_unchecked_from_node_ids(self, node_ids: List[int]) -> Graph: ...
    def remap_from_node_ids(self, node_ids: List[int]) -> Graph: ...
    def remap_from_node_names(self, node_names: List[str]) -> Graph: ...
    def remap_from_graph(self, other: Graph) -> Graph: ...
    def remove_components(self, node_names: Optional[List[str]], node_types: Optional[List[Optional[str]]], edge_types: Optional[List[Optional[str]]], minimum_component_size: Optional[int], top_k_components: Optional[int], verbose: Optional[bool]) -> Graph: ...
    def replace(self, node_name_mapping: Optional[Dict[str, str]], node_type_name_mapping: Optional[Dict[str, str]], edge_type_name_mapping: Optional[Dict[str, str]]) -> Graph: ...
    def report(self) -> Dict[str, str]: ...
    def overlap_textual_report(self, other: Graph, verbose: Optional[bool]) -> str: ...
    def get_node_report_from_node_id(self, node_id: int) -> str: ...
    def get_node_report_from_node_name(self, node_name: str) -> str: ...
    def textual_report(self) -> str: ...
    def add_selfloops(self, edge_type_name: Optional[str], weight: Optional[float]) -> Graph: ...
    def set_inplace_all_edge_types(self, edge_type: str): ...
    def set_all_edge_types(self, edge_type: str) -> Graph: ...
    def set_inplace_all_node_types(self, node_type: str): ...
    def set_all_node_types(self, node_type: str) -> Graph: ...
    def remove_inplace_node_type_ids(self, node_type_ids_to_remove: List[int]): ...
    def remove_inplace_singleton_node_types(self): ...
    def remove_inplace_edge_type_ids(self, edge_type_ids_to_remove: List[int]): ...
    def remove_inplace_singleton_edge_types(self): ...
    def remove_inplace_node_type_name(self, node_type_name: str): ...
    def remove_node_type_id(self, node_type_id: int) -> Graph: ...
    def remove_singleton_node_types(self) -> Graph: ...
    def remove_node_type_name(self, node_type_name: str) -> Graph: ...
    def remove_inplace_edge_type_name(self, edge_type_name: str): ...
    def remove_edge_type_id(self, edge_type_id: int) -> Graph: ...
    def remove_singleton_edge_types(self) -> Graph: ...
    def remove_edge_type_name(self, edge_type_name: str) -> Graph: ...
    def remove_inplace_node_types(self): ...
    def remove_node_types(self) -> Graph: ...
    def remove_inplace_edge_types(self): ...
    def remove_edge_types(self) -> Graph: ...
    def remove_inplace_edge_weights(self): ...
    def remove_edge_weights(self) -> Graph: ...
    def sort_by_increasing_outbound_node_degree(self) -> Graph: ...
    def sort_by_decreasing_outbound_node_degree(self) -> Graph: ...
    def sort_by_node_lexicographic_order(self) -> Graph: ...
    def get_bfs_topological_sorting_from_node_id(self, root_node_id: int) -> np.ndarray: ...
    def get_reversed_bfs_topological_sorting_from_node_id(self, root_node_id: int) -> np.ndarray: ...
    def sort_by_bfs_topological_sorting_from_node_id(self, root_node_id: int) -> Graph: ...
    def get_sparse_edge_weighting_methods(self) -> List[str]: ...
    def get_edge_weighting_methods(self) -> List[str]: ...
    def strongly_connected_components(self) -> List[Set[int]]: ...
    def generate_new_edges_from_node_features(self, features: List[List[float]], neighbours_number: Optional[int], max_degree: Optional[int], distance_name: Optional[str], verbose: Optional[bool]) -> Graph: ...
    def to_directed_inplace(self): ...
    def to_directed(self) -> Graph: ...
    def to_upper_triangular(self) -> Graph: ...
    def to_lower_triangular(self) -> Graph: ...
    def to_main_diagonal(self) -> Graph: ...
    def to_anti_diagonal(self) -> Graph: ...
    def to_bidiagonal(self) -> Graph: ...
    def to_arrowhead(self) -> Graph: ...
    def to_transposed(self) -> Graph: ...
    def to_complementary(self) -> Graph: ...
    def get_transitive_closure(self, iterations: Optional[int], verbose: Optional[bool]) -> Graph: ...
    def get_all_shortest_paths(self, iterations: Optional[int], verbose: Optional[bool]) -> Graph: ...
    def get_weighted_all_shortest_paths(self, iterations: Optional[int], use_edge_weights_as_probabilities: Optional[bool], verbose: Optional[bool]) -> Graph: ...
    def random_spanning_arborescence_kruskal(self, random_state: Optional[int], undesired_edge_types: Optional[Set[Optional[int]]], verbose: Optional[bool]) -> Tuple[Set[Tuple[int, int]], List[int], int, int, int]: ...
    def spanning_arborescence_kruskal(self, verbose: Optional[bool]) -> Tuple[Set[Tuple[int, int]], List[int], int, int, int]: ...
    def connected_components(self, verbose: Optional[bool]) -> Tuple[List[int], int, int, int]: ...
    def approximated_vertex_cover_set(self) -> Set[int]: ...
    def to_dot(self) -> str: ...
    def _repr_html_(self) -> str: ...
    def dump_edges(self, path: str, **kwargs): ...
    def hash(self) -> int: ...
    def get_laplacian_coo_matrix(self) -> Tuple[np.ndarray, np.ndarray]: ...
    def get_random_walk_normalized_laplacian_coo_matrix(self) -> Tuple[np.ndarray, np.ndarray]: ...
    def get_symmetric_normalized_laplacian_coo_matrix(self) -> Tuple[np.ndarray, np.ndarray]: ...
    def get_symmetric_normalized_coo_matrix(self) -> Tuple[np.ndarray, np.ndarray]: ...
    def dump_nodes(self, path: str, **kwargs): ...
    def cooccurence_matrix(self, walk_length: int, **kwargs) -> Tuple[np.ndarray, np.ndarray, np.ndarray]: ...
    def node2vec(self, batch_size: int, walk_length: int, window_size: int, **kwargs) -> Tuple[np.ndarray, np.ndarray]: ...
    def get_node_label_prediction_mini_batch(self, idx: int, batch_size: Optional[int], include_central_node: Optional[bool], return_edge_weights: Optional[bool], max_neighbours: Optional[int]) -> Tuple[Tuple[List[List[int]], Optional[List[List[float]]]], np.ndarray, ]: ...
    def get_edge_prediction_mini_batch(self, idx: int, batch_size: Optional[int], negative_samples_rate: Optional[float], return_node_types: Optional[bool], return_edge_types: Optional[bool], return_edge_metrics: Optional[bool], avoid_false_negatives: Optional[bool], maximal_sampling_attempts: Optional[int], shuffle: Optional[bool], graph_to_avoid: Optional[Graph]) -> Tuple[np.ndarray, Optional[np.ndarray], np.ndarray, Optional[np.ndarray], Optional[np.ndarray], Optional[np.ndarray], np.ndarray, ]: ...
    def get_unchecked_edge_prediction_metrics(self, source_node_ids: List[int], destination_node_ids: List[int], normalize: Optional[bool], verbose: Optional[bool]) -> np.ndarray: ...
    def get_edge_prediction_metrics(self, normalize: Optional[bool], verbose: Optional[bool]) -> np.ndarray: ...
    def get_subgraphs(self, number_of_nodes_to_sample: int, random_state: int, root_node: Optional[int], node_sampling_method: str, edge_weighting_methods: List[str], add_selfloops_where_missing: Optional[bool], unique: Optional[bool]) -> Tuple[np.ndarray, List[np.ndarray]]: ...
    def get_edge_ids_from_node_ids(self, node_ids: List[int], add_selfloops_where_missing: Optional[bool], complete: Optional[bool]) -> np.ndarray: ...
    def get_sparse_subgraphs(self, number_of_nodes_to_sample: int, random_state: int, root_node: Optional[int], node_sampling_method: str, edge_weighting_methods: List[str], add_selfloops_where_missing: Optional[bool], unique: Optional[bool]) -> Tuple[np.ndarray, List[Tuple[np.ndarray, np.ndarray]], ]: ...
    def get_sparse_undirected_laplacian_subgraphs(self, number_of_nodes_to_sample: int, random_state: int, root_node: Optional[int], node_sampling_method: str) -> Tuple[np.ndarray, List[Tuple[np.ndarray, np.ndarray]], ]: ...
    def get_edge_prediction_subgraphs(self, number_of_nodes_to_sample: int, random_state: int, node_sampling_method: str, edge_weighting_methods: List[str], add_selfloops_where_missing: Optional[bool]) -> Tuple[np.ndarray, List[np.ndarray], np.ndarray, List[np.ndarray], np.ndarray, ]: ...
    def get_edge_prediction_subgraphs_from_node_ids(self, number_of_nodes_to_sample: int, random_state: int, source_root_node: int, destination_root_node: int, node_sampling_method: str, edge_weighting_methods: List[str], add_selfloops_where_missing: Optional[bool], unique: Optional[bool]) -> Tuple[np.ndarray, List[np.ndarray], np.ndarray, List[np.ndarray], bool, ]: ...
    def spanning_arborescence(self, verbose: Optional[bool]) -> np.ndarray: ...
    def random_walks(self, walk_length: int, quantity: int, **kwargs) -> np.ndarray: ...
    def complete_walks(self, walk_length: int, **kwargs) -> np.ndarray: ...

