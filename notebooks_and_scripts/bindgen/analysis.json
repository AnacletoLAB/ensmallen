[
    {},
    {
        "modifiers": "pub(crate)",
        "name": "get_node_edges_and_destinations",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "max_neighbours",
                "Option<NodeT>"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "node",
                "NodeT"
            ]
        ],
        "return_type": "(EdgeT, EdgeT, Option<Vec<NodeT>>, Option<Vec<u64>>)",
        "body": "// We retrieve the range of edge ids, the minimum and maximum value.\n        let (min_edge_id, max_edge_id) = self.get_minmax_edge_ids_by_source_node_id(node);\n\n        // We check if subsampling is enabled and if so, if it makes sense:\n        // that is, if the range of neighbours (max_edge_id-min_edge_id) is smaller\n        // than the required sub-sampling we do not use it as it would be useless.\n        if let Some(indices) = max_neighbours.and_then(|mn| {\n            sorted_unique_sub_sampling(min_edge_id, max_edge_id, mn as u64, random_state).ok()\n        }) {\n            let destinations: Vec<NodeT> = match self\n                .cached_destinations\n                .as_ref()\n                .and_then(|cds| cds.get(&node))\n            {\n                Some(dsts) => indices\n                    .iter()\n                    .map(|edge_id| dsts[(*edge_id - min_edge_id) as usize])\n                    .collect(),\n                None => indices\n                    .iter()\n                    .map(|edge_id| self.get_destination_node_id_by_edge_id(*edge_id).unwrap())\n                    .collect(),\n            };\n            return (min_edge_id, max_edge_id, Some(destinations), Some(indices));\n        }\n\n        // If the destinations are stored explicitly because the time-memory tradeoff is enabled we are done.\n        if self.destinations.is_some() {\n            return (min_edge_id, max_edge_id, None, None);\n        }\n\n        // Finally if we are using the cache without sub-sampling\n        let destinations = match self\n            .cached_destinations\n            .as_ref()\n            .map_or(false, |cds| cds.contains_key(&node))\n        {\n            true => None,\n            false => Some(\n                self.edges\n                    .iter_in_range(self.encode_edge(node, 0)..self.encode_edge(node + 1, 0))\n                    .map(|edge| self.decode_edge(edge).1)\n                    .collect(),\n            ),\n        };\n        (min_edge_id, max_edge_id, destinations, None)",
        "doc": [
            "TODO:! add doc"
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_destinations_slice",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "min_edge_id",
                "EdgeT"
            ],
            [
                "max_edge_id",
                "EdgeT"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "destinations",
                "&'a Option<Vec<NodeT>>"
            ]
        ],
        "return_type": "&'a [NodeT]",
        "body": "match (&self.destinations, &self.cached_destinations, destinations) {\n            (_, _, Some(dsts)) => &dsts.as_slice(),\n            (Some(dsts), None, None) => &dsts[min_edge_id as usize..max_edge_id as usize],\n            (None, Some(dsts), None) => dsts.get(&node).unwrap(),\n            _ => unreachable!(\n                \"It is not possible to have both destinations and cached destinations at once.\"\n            ),\n        }",
        "doc": [
            "Return true if the graphs are compatible."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_destinations_slice",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "min_edge_id",
                "EdgeT"
            ],
            [
                "max_edge_id",
                "EdgeT"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "destinations",
                "&'a Option<Vec<NodeT>>"
            ]
        ],
        "return_type": "&'a [NodeT]",
        "body": "match (&self.destinations, &self.cached_destinations, destinations) {\n            (_, _, Some(dsts)) => &dsts.as_slice(),\n            (Some(dsts), None, None) => &dsts[min_edge_id as usize..max_edge_id as usize],\n            (None, Some(dsts), None) => dsts.get(&node).unwrap(),\n            _ => unreachable!(\n                \"It is not possible to have both destinations and cached destinations at once.\"\n            ),\n        }",
        "doc": [
            "Return true if the graphs are compatible."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "is_compatible",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "other",
                "&Graph"
            ]
        ],
        "return_type": "Result<bool, String>",
        "body": "self.validate_operator_terms(other)?;\n        if self.nodes != other.nodes {\n            return Ok(false);\n        }\n        if let (Some(snts), Some(onts)) = (&self.node_types, &other.node_types) {\n            if snts.vocabulary != onts.vocabulary {\n                return Ok(false);\n            }\n        }\n        if let (Some(sets), Some(oets)) = (&self.edge_types, &other.edge_types) {\n            if sets.vocabulary != oets.vocabulary {\n                return Ok(false);\n            }\n        }\n        Ok(true)"
    },
    {
        "modifiers": "pub(crate)",
        "name": "generic_operator",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "other",
                "&Graph"
            ],
            [
                "operator",
                "String"
            ],
            [
                "graphs",
                "Vec<(&Graph, Option<&Graph>, Option<&Graph>)>"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "match self.is_compatible(other)? {\n            true => generic_integer_operator(\n                self,\n                other,\n                operator,\n                graphs,\n                might_have_singletons,\n                might_have_singletons_with_selfloops,\n                might_have_trap_nodes,\n            ),\n            false => generic_string_operator(\n                self,\n                other,\n                operator,\n                graphs,\n                might_have_singletons,\n                might_have_singletons_with_selfloops,\n                might_have_trap_nodes,\n            ),\n        }",
        "doc": [
            "Returns the name of the node passed and HORRIBLY PANIC if the id is out",
            "of range."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "generic_operator",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "other",
                "&Graph"
            ],
            [
                "operator",
                "String"
            ],
            [
                "graphs",
                "Vec<(&Graph, Option<&Graph>, Option<&Graph>)>"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "match self.is_compatible(other)? {\n            true => generic_integer_operator(\n                self,\n                other,\n                operator,\n                graphs,\n                might_have_singletons,\n                might_have_singletons_with_selfloops,\n                might_have_trap_nodes,\n            ),\n            false => generic_string_operator(\n                self,\n                other,\n                operator,\n                graphs,\n                might_have_singletons,\n                might_have_singletons_with_selfloops,\n                might_have_trap_nodes,\n            ),\n        }",
        "doc": [
            "Returns the name of the node passed and HORRIBLY PANIC if the id is out",
            "of range."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_node_name_by_node_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "String",
        "body": "self.nodes.unchecked_translate(node_id)",
        "doc": [
            "Returns option with the edge type of the given edge id."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_edge_type_by_edge_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Option<EdgeTypeT>",
        "body": "self.edge_types\n            .as_ref()\n            .and_then(|ets| ets.ids[edge_id as usize])",
        "doc": [
            "Returns option with the weight of the given edge id."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_weight_by_edge_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Option<WeightT>",
        "body": "self.weights.as_ref().map(|ws| ws[edge_id as usize])",
        "doc": [
            "Returns option with the node type of the given node id."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_node_type_id_by_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Option<Vec<NodeTypeT>>",
        "body": "self.node_types\n            .as_ref()\n            .and_then(|nts| nts.ids[node_id as usize].clone())",
        "doc": [
            "Returns node id raising a panic if used unproperly."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_node_id_by_node_name",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "NodeT",
        "body": "*self.nodes.get(node_name).unwrap()",
        "doc": [
            "TODO: add doc"
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_edge_type_id_by_edge_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type_name",
                "Option<&str>"
            ]
        ],
        "return_type": "Option<EdgeTypeT>",
        "body": "match (&self.edge_types, edge_type_name) {\n            (Some(ets), Some(et)) => ets.get(et).copied(),\n            _ => None,\n        }",
        "doc": [
            "TODO: add doc"
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_edge_type_name_by_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type_id",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "Option<String>",
        "body": "match (&self.edge_types, edge_type_id) {\n            (Some(ets), Some(et)) => Some(ets.unchecked_translate(et)),\n            _ => None,\n        }",
        "doc": [
            "Return number of edges of the given edge type without checks.",
            "",
            "# Arguments",
            "",
            "* edge_type: Option<EdgeTypeT> - The edge type to retrieve count of.",
            ""
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_edge_count_by_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "EdgeT",
        "body": "match (&self.edge_types, edge_type) {\n            (Some(ets), None) => ets.get_unknown_count(),\n            (Some(ets), Some(et)) => ets.counts[et as usize],\n            _ => unreachable!(\"The current graph instance does not have edge types!\"),\n        }",
        "doc": [
            "Return number of nodes of the given node type without checks.",
            "",
            "# Arguments",
            "",
            "* node_type: Option<NodeTypeT> - The node type to retrieve count of.",
            ""
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_node_count_by_node_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type",
                "Option<NodeTypeT>"
            ]
        ],
        "return_type": "NodeT",
        "body": "match (&self.node_types, node_type) {\n            (Some(nts), None) => nts.get_unknown_count(),\n            (Some(nts), Some(nt)) => nts.counts[nt as usize],\n            _ => unreachable!(\"The current graph instance does not have node types!\"),\n        }",
        "doc": [
            "Return (subsampled) vector of destinations of given node.",
            "",
            "If the max neighbours parameter is given, and is smaller than the",
            "number of the neighbours of the given node, the subsampling",
            "mechanism is given.",
            "",
            "# Arguments",
            "`node`: NodeT - Node whose neighbours are to return.",
            "`random_state`: u64 - Random state to subsample neighbours.",
            "`max_neighbours`: &Option<NodeT> - Optionally number of neighbours to consider."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_node_destinations_by_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "max_neighbours",
                "Option<NodeT>"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "let (min_edge_id, max_edge_id, destinations, _) =\n            self.get_node_edges_and_destinations(max_neighbours, random_state, node);\n        self.get_destinations_slice(min_edge_id, max_edge_id, node, &destinations)\n            .to_owned()",
        "doc": [
            "Return edge ID without any checks for given tuple of nodes and edge type.",
            "",
            "This method will cause a panic if used improperly when it is not certain",
            "that the edge exists.",
            "",
            "# Arguments",
            "`src`: NodeT - Source node of the edge.",
            "`dst`: NodeT - Destination node of the edge.",
            "`edge_type`: Option<EdgeTypeT> - Edge Type of the edge."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_edge_id_by_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "edge_type",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.edge_types.as_ref().map_or_else(\n            || self.get_unchecked_edge_id_from_tuple(src, dst),\n            |ets| {\n                self.get_unchecked_edge_ids_range(src, dst)\n                    // The vectors of the edge types can only have one element.\n                    .find(|edge_id| ets.ids[*edge_id as usize] == edge_type)\n                    .unwrap()\n            },\n        )",
        "doc": [
            "Returns range of multigraph minimum and maximum edge ids with same source and destination nodes and different edge type.",
            "",
            "# Arguments",
            "",
            "* `src` - Source node of the edge.",
            "* `dst` - Destination node of the edge.",
            ""
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_edge_ids_range",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "impl Iterator<Item = EdgeT>",
        "body": "let (min_edge_id, max_edge_id) = self.get_unchecked_minmax_edge_ids_by_node_ids(src, dst);\n        min_edge_id..max_edge_id",
        "doc": [
            "Return range of outbound edges IDs for all the edges bewteen the given",
            "source and destination nodes.",
            "This operation is meaningfull only in a multigraph.",
            "",
            "# Arguments",
            "",
            "* src: NodeT - Source node.",
            "* dst: NodeT - Destination node.",
            ""
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_minmax_edge_ids_by_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "(EdgeT, EdgeT)",
        "body": "(\n            self.get_unchecked_edge_id_from_tuple(src, dst),\n            self.get_unchecked_edge_id_from_tuple(src, dst + 1),\n        )",
        "doc": [
            "Return the number of edges between the given source and destination nodes.",
            "",
            "This might be thought as the degree of an edge in a multigraph.",
            "On non-multigraph this trivially return 1 on existing edges and 0 on",
            "the non-existing ones.",
            "",
            "# Arguments",
            "",
            "* src: NodeT - Source node.",
            "* dst: NodeT - Destination node.",
            ""
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_edge_degreee_by_node_ids",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "EdgeT",
        "body": "let (min_edge_id, max_edge_id) = self.get_unchecked_minmax_edge_ids_by_node_ids(src, dst);\n        max_edge_id - min_edge_id"
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_edge_degreee_by_node_ids",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "EdgeT",
        "body": "let (min_edge_id, max_edge_id) = self.get_unchecked_minmax_edge_ids_by_node_ids(src, dst);\n        max_edge_id - min_edge_id"
    },
    {
        "modifiers": "",
        "name": "iter_edges_from_random_state",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "u64"
            ]
        ],
        "return_type": "impl Iterator<Item = (EdgeT, NodeT, NodeT)>+ '_",
        "body": "let edges_number = self.get_directed_edges_number();\n        // We execute two times the xorshift to improve the randomness of the seed.\n        let updated_random_state = rand_u64(rand_u64(random_state ^ SEED_XOR as u64));\n        (updated_random_state..edges_number + updated_random_state).filter_map(move |i| {\n            let edge_id = i % edges_number;\n            let (src, dst) = self.get_node_ids_from_edge_id(edge_id);\n            match src == dst || !self.directed && src > dst {\n                true => None,\n                false => Some((edge_id, src, dst)),\n            }\n        })"
    },
    {
        "modifiers": "",
        "name": "iter_on_edges_with_preference",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "unwanted_edge_types",
                "&'a Option<HashSet<Option<EdgeTypeT>>>"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<Item = (NodeT, NodeT)>+ 'a",
        "body": "let pb = get_loading_bar(\n            verbose,\n            format!(\"Building random spanning tree for {}\", self.name).as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n        let result: Box<dyn Iterator<Item = (NodeT, NodeT)>> = if let (Some(uet), _) =\n            (unwanted_edge_types, &self.edge_types)\n        {\n            Box::new(\n                self.iter_edges_from_random_state(random_state)\n                    .filter_map(move |(edge_id, src, dst)| {\n                        if uet.contains(&self.get_unchecked_edge_type_by_edge_id(edge_id)) {\n                            return None;\n                        }\n                        Some((src, dst))\n                    })\n                    .chain(self.iter_edges_from_random_state(random_state).filter_map(\n                        move |(edge_id, src, dst)| {\n                            if !uet.contains(&self.get_unchecked_edge_type_by_edge_id(edge_id)) {\n                                return None;\n                            }\n                            Some((src, dst))\n                        },\n                    )),\n            )\n        } else {\n            Box::new(\n                self.iter_edges_from_random_state(random_state)\n                    .map(|(_, src, dst)| (src, dst)),\n            )\n        };\n\n        result.progress_with(pb)",
        "doc": [
            "Returns set of edges composing a spanning tree and connected components.",
            "",
            "If the graph is composed of a single node with one or more self-loops,",
            "we consider such a graph as a graph with an empty spanning tree, with",
            "a single component of size one.",
            "",
            "# Arguments",
            "",
            "`edges` - Iterator for the edges to explore. If sorted, computed a minimum spanning tree.",
            "",
            "# Returns",
            "Tuple with:",
            "- Set of the edges",
            "- Vector of the nodes components",
            "- Total components number",
            "- Minimum component size",
            "- Maximum component size"
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "kruskal",
        "generics": "'a",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edges",
                "impl Iterator<Item = (NodeT, NodeT)> + 'a"
            ]
        ],
        "return_type": "(HashSet<(NodeT, NodeT)>, Vec<NodeT>, NodeT, NodeT, NodeT)",
        "body": "if !self.has_nodes() {\n            return (HashSet::new(), Vec::new(), 0, 0, 0);\n        }\n        if self.get_edges_number() == 0 {\n            return (\n                HashSet::new(),\n                (0..self.get_nodes_number()).collect(),\n                self.get_nodes_number(),\n                1,\n                1,\n            );\n        }\n\n        let nodes_number = self.get_nodes_number() as usize;\n        let mut tree = HashSet::with_capacity(self.get_nodes_number() as usize);\n        let mut components = vec![NOT_PRESENT; nodes_number];\n        let mut merged_component_number = 0;\n        let mut component_sizes: Vec<usize> = Vec::new();\n        let mut components_remapping: Vec<NodeT> = Vec::new();\n\n        // When there are singleton nodes with self-loops,\n        // which is an arguability weird feature of some graphs,\n        // Kruskal fails to identify them because by definition\n        // a tree cannot contain self-loop.\n        // We call these nodes with one or more self-loops\n        // (in the case of a multigraph) `singletons with self-loops` for lack of\n        // a better term. These nodes are treated as nodes in their own\n        // component and their edges (the self-loops) are not added to the tree.\n        if self.has_singletons() || self.has_singleton_nodes_with_self_loops() {\n            (0..self.get_nodes_number())\n                .filter(|node_id| {\n                    self.is_singleton_by_node_id(*node_id).unwrap()\n                        || self.is_singleton_with_self_loops_by_node_id(*node_id)\n                })\n                .for_each(|node_id| {\n                    components[node_id as usize] = component_sizes.len() as NodeT;\n                    components_remapping.push(component_sizes.len() as NodeT);\n                    component_sizes.push(1);\n                });\n        }\n\n        edges.for_each(|(src, dst)| {\n            if src == dst {\n                return;\n            }\n            let src_component = components[src as usize];\n            let dst_component = components[dst as usize];\n            match (src_component == NOT_PRESENT, dst_component == NOT_PRESENT) {\n                // If neither nodes have a component, they must be inserted\n                // both in the components vector and in the tree.\n                // The edge must be added to the three.\n                (true, true) => {\n                    let component_number = components_remapping.len() as NodeT;\n                    components[src as usize] = component_number;\n                    components[dst as usize] = component_number;\n                    components_remapping.push(component_number);\n                    component_sizes.push(2);\n                    tree.insert((src, dst));\n                }\n                // If both nodes have a component, the two components must be merged\n                // if they are not the same one.\n                // The edge must be added to the three.\n                // The components mapping must be updated and afterwards the other nodes\n                // must be updated accordingly to this update.\n                (false, false) => {\n                    if src_component == dst_component {\n                        return;\n                    }\n                    let src_component = components_remapping[src_component as usize];\n                    let dst_component = components_remapping[dst_component as usize];\n                    components[src as usize] = dst_component;\n                    components[dst as usize] = dst_component;\n                    if src_component == dst_component {\n                        return;\n                    }\n                    let (min_component, max_component) = match src_component < dst_component {\n                        true => (src_component, dst_component),\n                        false => (dst_component, src_component),\n                    };\n                    merged_component_number += 1;\n                    component_sizes[min_component as usize] +=\n                        component_sizes[max_component as usize];\n\n                    components_remapping\n                        .iter_mut()\n                        .enumerate()\n                        .for_each(|(comp, remapped)| {\n                            if *remapped == max_component {\n                                *remapped = min_component;\n                                component_sizes[comp] = 0;\n                            }\n                        });\n                    tree.insert((src, dst));\n                }\n                // If only one node has a component, the second model must be added.\n                _ => {\n                    let (component_number, not_inserted_node) = match src_component == NOT_PRESENT {\n                        true => (dst_component, src),\n                        false => (src_component, dst),\n                    };\n                    let component_number = components_remapping[component_number as usize];\n                    component_sizes[component_number as usize] += 1;\n                    components[not_inserted_node as usize] = component_number as NodeT;\n                    tree.insert((src, dst));\n                }\n            };\n        });\n\n        let components_number = AtomicUsize::new(component_sizes.len());\n        components.par_iter_mut().for_each(|remapped| {\n            if *remapped == NOT_PRESENT {\n                *remapped = (components_number.fetch_add(1, Ordering::SeqCst)\n                    - merged_component_number) as NodeT;\n            } else {\n                *remapped = components_remapping[*remapped as usize];\n            }\n        });\n\n        let total_components_number = component_sizes.len() - merged_component_number;\n\n        // TODO: explore ways to compute these on the fly.\n        let (min_component_size, max_component_size) = component_sizes\n            .into_iter()\n            .filter(|c| *c != 0)\n            .minmax()\n            .into_option()\n            .unwrap();\n\n        (\n            tree,\n            components,\n            total_components_number as NodeT,\n            min_component_size as NodeT,\n            max_component_size as NodeT,\n        )",
        "doc": [
            "Returns set of edges composing a spanning tree and connected components.",
            "",
            "The spanning tree is NOT minimal.",
            "The given random_state is NOT the root of the tree.",
            "",
            "# Arguments",
            "",
            "* `random_state`:NodeT - The random_state to use for the holdout,",
            "* `include_all_edge_types`: bool - whether to include all the edges between two nodes.",
            "* `unwanted_edge_types`: &Option<HashSet<EdgeTypeT>> - Which edge types id to try to avoid.",
            "* `verbose`: bool - whether to show a loading bar or not.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "random_spanning_arborescence_kruskal",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "EdgeT"
            ],
            [
                "unwanted_edge_types",
                "&Option<HashSet<Option<EdgeTypeT>>>"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "(HashSet<(NodeT, NodeT)>, Vec<NodeT>, NodeT, NodeT, NodeT)",
        "body": "self.kruskal(self.iter_on_edges_with_preference(random_state, unwanted_edge_types, verbose))"
    },
    {
        "modifiers": "pub",
        "name": "spanning_arborescence_kruskal",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "(HashSet<(NodeT, NodeT)>, Vec<NodeT>, NodeT, NodeT, NodeT)",
        "body": "let pb = get_loading_bar(\n            verbose,\n            &format!(\n                \"Computing spanning arborescence with Kruskal for {}\",\n                self.get_name()\n            ),\n            self.get_unique_edges_number() as usize,\n        );\n        self.kruskal(self.iter_unique_edges(self.directed).progress_with(pb))",
        "doc": [
            "Returns set of edges composing a spanning tree.",
            "",
            "This is the implementaiton of [A Fast, Parallel Spanning Tree Algorithm for Symmetric Multiprocessors (SMPs)](https://smartech.gatech.edu/bitstream/handle/1853/14355/GT-CSE-06-01.pdf)",
            "by David A. Bader and Guojing Cong."
        ]
    },
    {
        "modifiers": "pub",
        "name": "spanning_arborescence",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(usize, impl Iterator<Item = (NodeT, NodeT)> + '_), String>",
        "body": "if self.directed {\n            return Err(\n                \"The spanning arborescence from Bader et al. algorithm only works for undirected graphs!\".to_owned(),\n            );\n        }\n        let nodes_number = self.get_nodes_number() as usize;\n        let mut parents = vec![NOT_PRESENT; nodes_number];\n        let cpu_number = rayon::current_num_threads();\n        let pool = rayon::ThreadPoolBuilder::new()\n            .num_threads(cpu_number)\n            .build()\n            .unwrap();\n        let shared_stacks: Arc<Vec<Mutex<Vec<NodeT>>>> = Arc::from(\n            (0..std::cmp::max(cpu_number - 1, 1))\n                .map(|_| Mutex::from(Vec::new()))\n                .collect::<Vec<Mutex<Vec<NodeT>>>>(),\n        );\n        let active_nodes_number = AtomicUsize::new(0);\n        let completed = AtomicBool::new(false);\n        let total_inserted_edges = AtomicUsize::new(0);\n        let thread_safe_parents = ThreadSafe {\n            value: std::cell::UnsafeCell::new(&mut parents),\n        };\n\n        // since we were able to build a stub tree with cpu.len() leafs,\n        // we spawn the treads and make anyone of them build the sub-trees.\n        pool.scope(|s| {\n            // for each leaf of the previous stub tree start a DFS keeping track\n            // of which nodes we visited and updating accordingly the parents vector.\n            // the nice trick here is that, since all the leafs are part of the same tree,\n            // if two processes find the same node, we don't care which one of the two take\n            // it so we can proceed in a lockless fashion (and maybe even without atomics\n            // if we manage to remove the colors vecotr and only keep the parents one)\n            s.spawn(|_| {\n                let pb = get_loading_bar(\n                    verbose,\n                    format!(\"Computing spanning tree of graph {}\", self.get_name()).as_ref(),\n                    nodes_number,\n                );\n                (0..nodes_number).progress_with(pb).for_each(|src| {\n                    let ptr = thread_safe_parents.value.get();\n                    unsafe {\n                        // If the node has already been explored we skip ahead.\n                        if (*ptr)[src] != NOT_PRESENT {\n                            return;\n                        }\n                    }\n                    unsafe {\n                        // find the first not explored node (this is guardanteed to be in a new component)\n                        if self.has_singletons()\n                            && self.is_singleton_by_node_id(src as NodeT).unwrap()\n                        {\n                            // We set singletons as self-loops for now.\n                            (*ptr)[src] = src as NodeT;\n                            return;\n                        }\n                    }\n                    loop {\n                        unsafe {\n                            if (*ptr)[src] != NOT_PRESENT {\n                                break;\n                            }\n                        }\n                        if active_nodes_number.load(Ordering::SeqCst) == 0 {\n                            unsafe {\n                                if (*ptr)[src] != NOT_PRESENT {\n                                    break;\n                                }\n                            }\n                            unsafe {\n                                (*ptr)[src] = src as NodeT;\n                            }\n                            shared_stacks[0].lock().unwrap().push(src as NodeT);\n                            active_nodes_number.fetch_add(1, Ordering::SeqCst);\n                            break;\n                        }\n                    }\n                });\n                completed.store(true, Ordering::SeqCst);\n            });\n            (0..shared_stacks.len()).for_each(|_| {\n                s.spawn(|_| 'outer: loop {\n                    let thread_id = rayon::current_thread_index().unwrap();\n                    let src = 'inner: loop {\n                        {\n                            for mut stack in (thread_id..(shared_stacks.len() + thread_id))\n                                .map(|id| shared_stacks[id % shared_stacks.len()].lock().unwrap())\n                            {\n                                if let Some(src) = stack.pop() {\n                                    break 'inner src;\n                                }\n                            }\n\n                            if completed.load(Ordering::SeqCst) {\n                                break 'outer;\n                            }\n                        }\n                    };\n                    self.iter_node_neighbours_ids(src).for_each(|dst| {\n                        let ptr = thread_safe_parents.value.get();\n                        unsafe {\n                            if (*ptr)[dst as usize] == NOT_PRESENT {\n                                (*ptr)[dst as usize] = src;\n                                total_inserted_edges.fetch_add(1, Ordering::SeqCst);\n                                active_nodes_number.fetch_add(1, Ordering::SeqCst);\n                                shared_stacks[rand_u64(dst as u64) as usize % shared_stacks.len()]\n                                    .lock()\n                                    .unwrap()\n                                    .push(dst);\n                            }\n                        }\n                    });\n                    active_nodes_number.fetch_sub(1, Ordering::SeqCst);\n                });\n            });\n        });\n\n        // convert the now completed parents vector to a list of tuples representing the edges\n        // of the spanning arborescense.\n        Ok((\n            // Number of edges inserted\n            total_inserted_edges.load(Ordering::SeqCst),\n            // Return an iterator over all the edges in the spanning arborescence\n            (0..self.get_nodes_number()).filter_map(move |src| {\n                let dst = parents[src as usize];\n                // If the edge is NOT registered as a self-loop\n                // which may happen when dealing with singletons\n                // or the root nodes, we return the edge.\n                if src != dst {\n                    return Some((src, dst));\n                }\n                None\n            }),\n        ))",
        "doc": [
            "Compute the connected components building in parallel a spanning tree using [bader's algorithm](https://www.sciencedirect.com/science/article/abs/pii/S0743731505000882).",
            "**This works only for undirected graphs.**",
            "",
            "This method is **not thread save and not deterministic** but by design of the algorithm this",
            "shouldn't matter but if we will encounter non-detemristic bugs here is where we want to look.",
            "",
            "Returns (Components membership, components number, size of the smallest components, size of the biggest components).",
            "We assign to each node the index of its component, so nodes in the same components will have the same index.",
            "This component index is the returned Components membership vector.",
            "",
            "Example:",
            "```rust",
            "# #![feature(impl_trait_in_bindings)]",
            "# use graph::Graph;",
            "// Graph is a weightless graph with the edges",
            "// [(0, 1), (1, 4), (2, 3)]",
            "# let edge: Vec<Result<(String, String, Option<String>, Option<f32>), String>> = vec![",
            "#        Ok((\"0\".to_string(), \"1\".to_string(), None, None)),",
            "#        Ok((\"1\".to_string(), \"4\".to_string(), None, None)),",
            "#        Ok((\"2\".to_string(), \"3\".to_string(), None, None)),",
            "#     ];",
            "#",
            "# let nodes = None.map(|x: Vec<Result<(String, Option<Vec<String>>), String>>| x.into_iter());",
            "#",
            "# let graph = Graph::from_string_unsorted(",
            "#     edge.into_iter(),",
            "#     nodes,      // nodes",
            "#     false,     // directed",
            "#     false,      // directe edge list",
            "#     \"test graph\",// name",
            "#     false,     // ignore_duplicated_nodes",
            "#     true,     // node_list_is_correct",
            "#     false,     // ignore_duplicated_nodes",
            "#     true,     // node_list_is_correct",
            "#     false,     // verbose",
            "#     false,     // numeric_edge_types_ids",
            "#     false,     // numeric_node_ids",
            "#     false,     // numeric_edge_node_ids",
            "#     false,     // numeric_node_types_ids",
            "#     false,     // has_node_types",
            "#     false,     // has_edge_types",
            "#     false,     // has_weights",
            "#     true,",
            "#     true,",
            "#     true,",
            "# ).unwrap();",
            "let (components, number_of_components, smallest, biggest) =",
            "graph.connected_components(false).unwrap();",
            "",
            "//   nodes names:       0  1  4  2  3",
            "assert_eq!(components, [0, 0, 0, 1, 1].to_vec());",
            "",
            "assert_eq!(number_of_components, 2);",
            "assert_eq!(smallest, 2); // the size of the smallest component",
            "assert_eq!(biggest, 3);  // the size of the biggest component",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "connected_components",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(Vec<NodeT>, NodeT, NodeT, NodeT), String>",
        "body": "if self.directed {\n            return Err(\n                \"The connected components algorithm only works for undirected graphs!\".to_owned(),\n            );\n        }\n        if !self.has_nodes() {\n            return Ok((Vec::new(), 0, 0, 0));\n        }\n        if self.get_edges_number() == 0 {\n            return Ok((\n                (0..self.get_nodes_number()).collect(),\n                self.get_nodes_number(),\n                1,\n                1,\n            ));\n        }\n        let nodes_number = self.get_nodes_number() as usize;\n        let mut components = vec![NOT_PRESENT; nodes_number];\n        let mut component_sizes: Vec<NodeT> = Vec::new();\n        let cpu_number = rayon::current_num_threads();\n        let pool = rayon::ThreadPoolBuilder::new()\n            .num_threads(cpu_number)\n            .build()\n            .unwrap();\n        let shared_stacks: Arc<Vec<Mutex<Vec<NodeT>>>> = Arc::from(\n            (0..std::cmp::max(cpu_number - 1, 1))\n                .map(|_| Mutex::from(Vec::new()))\n                .collect::<Vec<Mutex<Vec<NodeT>>>>(),\n        );\n        let active_nodes_number = AtomicUsize::new(0);\n        let completed = AtomicBool::new(false);\n        let thread_safe_components = ThreadSafe {\n            value: std::cell::UnsafeCell::new(&mut components),\n        };\n        let thread_safe_component_sizes = ThreadSafe {\n            value: std::cell::UnsafeCell::new(&mut component_sizes),\n        };\n\n        // since we were able to build a stub tree with cpu.len() leafs,\n        // we spawn the treads and make anyone of them build the sub-trees.\n        pool.scope(|s| {\n            // for each leaf of the previous stub tree start a DFS keeping track\n            // of which nodes we visited and updating accordingly the components vector.\n            // the nice trick here is that, since all the leafs are part of the same tree,\n            // if two processes find the same node, we don't care which one of the two take\n            // it so we can proceed in a lockless fashion (and maybe even without atomics\n            // if we manage to remove the colors vecotr and only keep the components one)\n            s.spawn(|_| {\n                let pb = get_loading_bar(\n                    verbose,\n                    format!(\n                        \"Computing connected components of graph {}\",\n                        self.get_name()\n                    )\n                    .as_ref(),\n                    nodes_number,\n                );\n                let component_sizes = thread_safe_component_sizes.value.get();\n                (0..nodes_number).progress_with(pb).for_each(|src| {\n                    let ptr = thread_safe_components.value.get();\n                    unsafe {\n                        // If the node has already been explored we skip ahead.\n                        if (*ptr)[src] != NOT_PRESENT {\n                            (*component_sizes)[(*ptr)[src] as usize] += 1;\n                            return;\n                        }\n                    }\n\n                    // find the first not explored node (this is guardanteed to be in a new component)\n                    if self.has_singletons() && self.is_singleton_by_node_id(src as NodeT).unwrap()\n                    {\n                        // We set singletons as self-loops for now.\n                        unsafe {\n                            (*ptr)[src] = (*component_sizes).len() as NodeT;\n                            (*component_sizes).push(1);\n                        }\n                        return;\n                    }\n\n                    loop {\n                        // if the node has been now mapped to a component by anyone of the\n                        // parallel threads, move on to the next node.\n                        unsafe {\n                            if (*ptr)[src] != NOT_PRESENT {\n                                (*component_sizes)[(*ptr)[src] as usize] += 1;\n                                break;\n                            }\n                        }\n                        // Otherwise, Check if the parallel threads are finished\n                        // and are all waiting for a new node to explore.\n                        // In that case add the currently not explored node to the\n                        // work stack of the first thread.\n                        if active_nodes_number.load(Ordering::SeqCst) == 0 {\n                            // The check here might seems redundant but its' needed\n                            // to prevent data races.\n                            //\n                            // If the last parallel thread finishes its stack between the\n                            // presence check above and the active nodes numbers check\n                            // the src node will never increase the component size and thus\n                            // leading to wrong results.\n                            unsafe {\n                                if (*ptr)[src] != NOT_PRESENT {\n                                    (*component_sizes)[(*ptr)[src] as usize] += 1;\n                                    break;\n                                }\n                            }\n                            unsafe {\n                                (*ptr)[src] = (*component_sizes).len() as NodeT;\n                                (*component_sizes).push(1);\n                            }\n                            active_nodes_number.fetch_add(1, Ordering::SeqCst);\n                            shared_stacks[0].lock().unwrap().push(src as NodeT);\n                            break;\n                        }\n                        // Otherwise, Loop until the parallel threads are finished.\n                    }\n                });\n                completed.store(true, Ordering::SeqCst);\n            });\n\n            // Spawn the parallel threads that handle the components mapping,\n            // these threads use work-stealing, meaning that if their stack is empty,\n            // they will steal nodes from the stack of another random thread.\n            (0..shared_stacks.len()).for_each(|_| {\n                s.spawn(|_| 'outer: loop {\n                    // get the id, we use this as an idex for the stacks vector.\n                    let thread_id = rayon::current_thread_index().unwrap();\n\n                    let src = 'inner: loop {\n                        {\n                            for mut stack in (thread_id..(shared_stacks.len() + thread_id))\n                                .map(|id| shared_stacks[id % shared_stacks.len()].lock().unwrap())\n                            {\n                                if let Some(src) = stack.pop() {\n                                    break 'inner src;\n                                }\n                            }\n\n                            if completed.load(Ordering::SeqCst) {\n                                break 'outer;\n                            }\n                        }\n                    };\n\n                    self.iter_node_neighbours_ids(src).for_each(|dst| {\n                        let ptr = thread_safe_components.value.get();\n                        if unsafe { (*ptr)[dst as usize] == NOT_PRESENT } {\n                            unsafe {\n                                (*ptr)[dst as usize] = (*ptr)[src as usize];\n                            }\n                            active_nodes_number.fetch_add(1, Ordering::SeqCst);\n                            shared_stacks[rand_u64(dst as u64) as usize % shared_stacks.len()]\n                                .lock()\n                                .unwrap()\n                                .push(dst);\n                        }\n                    });\n                    active_nodes_number.fetch_sub(1, Ordering::SeqCst);\n                });\n            });\n        });\n\n        let components_number = component_sizes.len();\n\n        // TODO: re-explore the possibility of computing these on the fly.\n        let (min_component_size, max_component_size) =\n            component_sizes.into_iter().minmax().into_option().unwrap();\n\n        Ok((\n            components,\n            components_number as NodeT,\n            min_component_size,\n            max_component_size,\n        ))"
    },
    {
        "modifiers": "pub",
        "name": "connected_components",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(Vec<NodeT>, NodeT, NodeT, NodeT), String>",
        "body": "if self.directed {\n            return Err(\n                \"The connected components algorithm only works for undirected graphs!\".to_owned(),\n            );\n        }\n        if !self.has_nodes() {\n            return Ok((Vec::new(), 0, 0, 0));\n        }\n        if self.get_edges_number() == 0 {\n            return Ok((\n                (0..self.get_nodes_number()).collect(),\n                self.get_nodes_number(),\n                1,\n                1,\n            ));\n        }\n        let nodes_number = self.get_nodes_number() as usize;\n        let mut components = vec![NOT_PRESENT; nodes_number];\n        let mut component_sizes: Vec<NodeT> = Vec::new();\n        let cpu_number = rayon::current_num_threads();\n        let pool = rayon::ThreadPoolBuilder::new()\n            .num_threads(cpu_number)\n            .build()\n            .unwrap();\n        let shared_stacks: Arc<Vec<Mutex<Vec<NodeT>>>> = Arc::from(\n            (0..std::cmp::max(cpu_number - 1, 1))\n                .map(|_| Mutex::from(Vec::new()))\n                .collect::<Vec<Mutex<Vec<NodeT>>>>(),\n        );\n        let active_nodes_number = AtomicUsize::new(0);\n        let completed = AtomicBool::new(false);\n        let thread_safe_components = ThreadSafe {\n            value: std::cell::UnsafeCell::new(&mut components),\n        };\n        let thread_safe_component_sizes = ThreadSafe {\n            value: std::cell::UnsafeCell::new(&mut component_sizes),\n        };\n\n        // since we were able to build a stub tree with cpu.len() leafs,\n        // we spawn the treads and make anyone of them build the sub-trees.\n        pool.scope(|s| {\n            // for each leaf of the previous stub tree start a DFS keeping track\n            // of which nodes we visited and updating accordingly the components vector.\n            // the nice trick here is that, since all the leafs are part of the same tree,\n            // if two processes find the same node, we don't care which one of the two take\n            // it so we can proceed in a lockless fashion (and maybe even without atomics\n            // if we manage to remove the colors vecotr and only keep the components one)\n            s.spawn(|_| {\n                let pb = get_loading_bar(\n                    verbose,\n                    format!(\n                        \"Computing connected components of graph {}\",\n                        self.get_name()\n                    )\n                    .as_ref(),\n                    nodes_number,\n                );\n                let component_sizes = thread_safe_component_sizes.value.get();\n                (0..nodes_number).progress_with(pb).for_each(|src| {\n                    let ptr = thread_safe_components.value.get();\n                    unsafe {\n                        // If the node has already been explored we skip ahead.\n                        if (*ptr)[src] != NOT_PRESENT {\n                            (*component_sizes)[(*ptr)[src] as usize] += 1;\n                            return;\n                        }\n                    }\n\n                    // find the first not explored node (this is guardanteed to be in a new component)\n                    if self.has_singletons() && self.is_singleton_by_node_id(src as NodeT).unwrap()\n                    {\n                        // We set singletons as self-loops for now.\n                        unsafe {\n                            (*ptr)[src] = (*component_sizes).len() as NodeT;\n                            (*component_sizes).push(1);\n                        }\n                        return;\n                    }\n\n                    loop {\n                        // if the node has been now mapped to a component by anyone of the\n                        // parallel threads, move on to the next node.\n                        unsafe {\n                            if (*ptr)[src] != NOT_PRESENT {\n                                (*component_sizes)[(*ptr)[src] as usize] += 1;\n                                break;\n                            }\n                        }\n                        // Otherwise, Check if the parallel threads are finished\n                        // and are all waiting for a new node to explore.\n                        // In that case add the currently not explored node to the\n                        // work stack of the first thread.\n                        if active_nodes_number.load(Ordering::SeqCst) == 0 {\n                            // The check here might seems redundant but its' needed\n                            // to prevent data races.\n                            //\n                            // If the last parallel thread finishes its stack between the\n                            // presence check above and the active nodes numbers check\n                            // the src node will never increase the component size and thus\n                            // leading to wrong results.\n                            unsafe {\n                                if (*ptr)[src] != NOT_PRESENT {\n                                    (*component_sizes)[(*ptr)[src] as usize] += 1;\n                                    break;\n                                }\n                            }\n                            unsafe {\n                                (*ptr)[src] = (*component_sizes).len() as NodeT;\n                                (*component_sizes).push(1);\n                            }\n                            active_nodes_number.fetch_add(1, Ordering::SeqCst);\n                            shared_stacks[0].lock().unwrap().push(src as NodeT);\n                            break;\n                        }\n                        // Otherwise, Loop until the parallel threads are finished.\n                    }\n                });\n                completed.store(true, Ordering::SeqCst);\n            });\n\n            // Spawn the parallel threads that handle the components mapping,\n            // these threads use work-stealing, meaning that if their stack is empty,\n            // they will steal nodes from the stack of another random thread.\n            (0..shared_stacks.len()).for_each(|_| {\n                s.spawn(|_| 'outer: loop {\n                    // get the id, we use this as an idex for the stacks vector.\n                    let thread_id = rayon::current_thread_index().unwrap();\n\n                    let src = 'inner: loop {\n                        {\n                            for mut stack in (thread_id..(shared_stacks.len() + thread_id))\n                                .map(|id| shared_stacks[id % shared_stacks.len()].lock().unwrap())\n                            {\n                                if let Some(src) = stack.pop() {\n                                    break 'inner src;\n                                }\n                            }\n\n                            if completed.load(Ordering::SeqCst) {\n                                break 'outer;\n                            }\n                        }\n                    };\n\n                    self.iter_node_neighbours_ids(src).for_each(|dst| {\n                        let ptr = thread_safe_components.value.get();\n                        if unsafe { (*ptr)[dst as usize] == NOT_PRESENT } {\n                            unsafe {\n                                (*ptr)[dst as usize] = (*ptr)[src as usize];\n                            }\n                            active_nodes_number.fetch_add(1, Ordering::SeqCst);\n                            shared_stacks[rand_u64(dst as u64) as usize % shared_stacks.len()]\n                                .lock()\n                                .unwrap()\n                                .push(dst);\n                        }\n                    });\n                    active_nodes_number.fetch_sub(1, Ordering::SeqCst);\n                });\n            });\n        });\n\n        let components_number = component_sizes.len();\n\n        // TODO: re-explore the possibility of computing these on the fly.\n        let (min_component_size, max_component_size) =\n            component_sizes.into_iter().minmax().into_option().unwrap();\n\n        Ok((\n            components,\n            components_number as NodeT,\n            min_component_size,\n            max_component_size,\n        ))"
    },
    {
        "modifiers": "pub(crate)",
        "name": "new",
        "generics": "S: Into<String>",
        "args": [
            [
                "directed",
                "bool"
            ],
            [
                "unique_self_loop_number",
                "NodeT"
            ],
            [
                "self_loop_number",
                "EdgeT"
            ],
            [
                "not_singleton_nodes_number",
                "NodeT"
            ],
            [
                "singleton_nodes_with_self_loops_number",
                "NodeT"
            ],
            [
                "unique_edges_number",
                "EdgeT"
            ],
            [
                "edges",
                "EliasFano"
            ],
            [
                "unique_sources",
                "Option<EliasFano>"
            ],
            [
                "nodes",
                "Vocabulary<NodeT>"
            ],
            [
                "node_bit_mask",
                "EdgeT"
            ],
            [
                "node_bits",
                "u8"
            ],
            [
                "edge_types",
                "Option<EdgeTypeVocabulary>"
            ],
            [
                "name",
                "S"
            ],
            [
                "weights",
                "Option<Vec<WeightT>>"
            ],
            [
                "node_types",
                "Option<NodeTypeVocabulary>"
            ]
        ],
        "return_type": "Graph",
        "body": "Graph {\n            directed,\n            unique_self_loop_number,\n            self_loop_number,\n            not_singleton_nodes_number,\n            singleton_nodes_with_self_loops_number,\n            unique_edges_number,\n            edges,\n            unique_sources,\n            node_bit_mask,\n            node_bits,\n            weights,\n            node_types: node_types.map(|nts| nts.set_numeric_ids(false)),\n            edge_types: edge_types.map(|ets| ets.set_numeric_ids(false)),\n            nodes: nodes.set_numeric_ids(false),\n            sources: None,\n            destinations: None,\n            outbounds: None,\n            cached_destinations: None,\n            name: name.into(),\n            cached_report: ClonableRwLock::new(None),\n        }",
        "doc": [
            "Return true if given graph has any edge overlapping with current graph.",
            "",
            "# Arguments",
            "",
            "* other: Graph - The graph to check against.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "overlaps",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "other",
                "&Graph"
            ]
        ],
        "return_type": "Result<bool, String>",
        "body": "Ok(match self.is_compatible(other)? {\n            true => other\n                .par_iter_edge_with_type_ids(other.directed)\n                .any(|(_, src, dst, et)| self.has_edge_with_type_by_node_ids(src, dst, et)),\n            false => other.par_iter_edge_with_type(other.directed).any(\n                |(_, _, src_name, _, dst_name, _, edge_type_name)| {\n                    self.has_edge_with_type_by_node_names(\n                        &src_name,\n                        &dst_name,\n                        edge_type_name.as_ref(),\n                    )\n                },\n            ),\n        })",
        "doc": [
            "Return true if given graph edges are all contained within current graph.",
            "",
            "# Arguments",
            "",
            "* other: Graph - The graph to check against.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "contains",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "other",
                "&Graph"
            ]
        ],
        "return_type": "Result<bool, String>",
        "body": "Ok(match self.is_compatible(other)? {\n            true => other\n                .par_iter_edge_with_type_ids(other.directed)\n                .all(|(_, src, dst, et)| self.has_edge_with_type_by_node_ids(src, dst, et)),\n            false => other.par_iter_edge_with_type(other.directed).all(\n                |(_, _, src_name, _, dst_name, _, edge_type_name)| {\n                    self.has_edge_with_type_by_node_names(\n                        &src_name,\n                        &dst_name,\n                        edge_type_name.as_ref(),\n                    )\n                },\n            ),\n        })",
        "doc": [
            "Return training batches for Node2Vec models.",
            "",
            "The batch is composed of a tuple as the following:",
            "",
            "- (Contexts indices, central nodes indices): the tuple of nodes",
            "",
            "This does not provide any output value as the model uses NCE loss",
            "and basically the central nodes that are fed as inputs work as the",
            "outputs value.",
            "",
            "# Arguments",
            "",
            "* walk_parameters: &WalksParameters - the weighted walks parameters.",
            "* quantity: usize - Number of nodes to consider.",
            "* window_size: usize - Window size to consider for the sequences.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "contains",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "other",
                "&Graph"
            ]
        ],
        "return_type": "Result<bool, String>",
        "body": "Ok(match self.is_compatible(other)? {\n            true => other\n                .par_iter_edge_with_type_ids(other.directed)\n                .all(|(_, src, dst, et)| self.has_edge_with_type_by_node_ids(src, dst, et)),\n            false => other.par_iter_edge_with_type(other.directed).all(\n                |(_, _, src_name, _, dst_name, _, edge_type_name)| {\n                    self.has_edge_with_type_by_node_names(\n                        &src_name,\n                        &dst_name,\n                        edge_type_name.as_ref(),\n                    )\n                },\n            ),\n        })",
        "doc": [
            "Return training batches for Node2Vec models.",
            "",
            "The batch is composed of a tuple as the following:",
            "",
            "- (Contexts indices, central nodes indices): the tuple of nodes",
            "",
            "This does not provide any output value as the model uses NCE loss",
            "and basically the central nodes that are fed as inputs work as the",
            "outputs value.",
            "",
            "# Arguments",
            "",
            "* walk_parameters: &WalksParameters - the weighted walks parameters.",
            "* quantity: usize - Number of nodes to consider.",
            "* window_size: usize - Window size to consider for the sequences.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "node2vec",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "walk_parameters",
                "&'a WalksParameters"
            ],
            [
                "quantity",
                "NodeT"
            ],
            [
                "window_size",
                "usize"
            ]
        ],
        "return_type": "Result<impl ParallelIterator<Item = (Vec<NodeT>, NodeT)> + 'a, String>",
        "body": "// do the walks and check the result\n        word2vec(\n            self.random_walks_iter(quantity, walk_parameters)?,\n            window_size,\n        )",
        "doc": [
            "Return triple with CSR representation of cooccurrence matrix.",
            "",
            "The first vector has the sources, the second vector the destinations",
            "and the third one contains the min-max normalized frequencies.",
            "",
            "# Arguments",
            "",
            "* parameters: &WalksParameters - the walks parameters.",
            "* window_size: Option<usize> - Window size to consider for the sequences.",
            "* verbose: Option<bool>,",
            "whether to show the progress bars.",
            "The default behaviour is false.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "cooccurence_matrix",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "walks_parameters",
                "&'a WalksParameters"
            ],
            [
                "window_size",
                "usize"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(usize, impl Iterator<Item=(NodeT, NodeT, f64)> + 'a), String>",
        "body": "if !self.has_edges() {\n            return Err(\n                \"The cooccurence matrix on a graph without edges is not defined.\".to_string(),\n            );\n        }\n        let walks = self.complete_walks_iter(walks_parameters)?;\n        cooccurence_matrix(\n            walks,\n            window_size,\n            (self.get_unique_source_nodes_number() * walks_parameters.iterations) as usize,\n            verbose,\n        )",
        "doc": [
            "Return iterator over neighbours for the given node ID, optionally including given node ID.",
            "",
            "This method is meant to be used to predict node labels using the NoLaN model.",
            "",
            "If you need to predict the node label of a node, not during training,",
            "use `max_neighbours=None`.",
            "",
            "# Arguments",
            "",
            "* `central_node_id`: NodeT - The node ID to retrieve neighbours for.",
            "* `random_state`: u64 - The random state to use to extract the neighbours.",
            "* `include_central_node`: bool - Whether to include the node ID in the returned iterator.",
            "* `offset`: NodeT - Offset for padding porposes.",
            "* `max_neighbours`: &Option<NodeT> - Number of maximum neighbours to consider.",
            ""
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_neighbours_by_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "central_node_id",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "include_central_node",
                "bool"
            ],
            [
                "offset",
                "NodeT"
            ],
            [
                "max_neighbours",
                "Option<NodeT>"
            ]
        ],
        "return_type": "impl Iterator<Item = NodeT>+ '_",
        "body": "(if include_central_node {\n            vec![central_node_id]\n        } else {\n            vec![]\n        })\n        .into_iter()\n        .chain(\n            self.get_unchecked_node_destinations_by_node_id(\n                central_node_id,\n                random_state,\n                max_neighbours,\n            )\n            .into_iter(),\n        )\n        .map(move |node_id| node_id + offset)",
        "doc": [
            "Return tuple with iterator over neighbours for the given node ID, optionally including given node ID, and node type.",
            "",
            "This method is meant to be used to predict node labels using the NoLaN model.",
            "",
            "If you need to predict the node label of a node, not during training,",
            "use `max_neighbours=None`.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - The node ID to retrieve neighbours for.",
            "* `random_state`: u64 - The random state to use to extract the neighbours.",
            "* `include_central_node`: bool - Whether to include the node ID in the returned iterator.",
            "* `offset`: NodeT - Offset for padding porposes.",
            "* `max_neighbours`: &Option<NodeT> - Number of maximum neighbours to consider.",
            ""
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_node_label_prediction_tuple_by_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "include_central_node",
                "bool"
            ],
            [
                "offset",
                "NodeT"
            ],
            [
                "max_neighbours",
                "Option<NodeT>"
            ]
        ],
        "return_type": "(impl Iterator<Item = NodeT>+ '_, Option<Vec<NodeTypeT>>)",
        "body": "(\n            self.get_neighbours_by_node_id(\n                node_id,\n                random_state,\n                include_central_node,\n                offset,\n                max_neighbours,\n            ),\n            self.get_unchecked_node_type_id_by_node_id(node_id),\n        )",
        "doc": [
            "Return iterator over neighbours for the given node IDs, optionally including given the node IDs, and node type.",
            "",
            "This method is meant to be used to predict node labels using the NoLaN model.",
            "",
            "If you need to predict the node label of a node, not during training,",
            "use `max_neighbours=None`.",
            "",
            "# Arguments",
            "",
            "* `node_ids`: Vec<NodeT> - The node ID to retrieve neighbours for.",
            "* `random_state`: u64 - The random state to use to extract the neighbours.",
            "* `include_central_node`: bool - Whether to include the node ID in the returned iterator.",
            "* `offset`: NodeT - Offset for padding porposes.",
            "* `max_neighbours`: &Option<NodeT> - Number of maximum neighbours to consider.",
            "",
            "# Examples",
            "Suppose you want to the get the neighbours of the first 10 nodes:",
            "```rust",
            "# use rayon::iter::ParallelIterator;",
            "# use graph::NodeT;",
            "# use rayon::iter::IndexedParallelIterator;",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, false, false, false).unwrap();",
            "let node_ids = (0..10).collect::<Vec<NodeT>>();",
            "let include_central_nodes = true;",
            "let offset = 0;",
            "let max_neighbours = 5;",
            "let iterator = graph.get_node_label_prediction_tuple_by_node_ids(",
            "node_ids.clone(), 42, include_central_nodes, offset, Some(max_neighbours)",
            ").unwrap();",
            "iterator.enumerate().for_each(|(i, (neighbours_iter, labels))|{",
            "for (j, node_id) in neighbours_iter.enumerate(){",
            "if j==0 && include_central_nodes{",
            "assert!(node_id==node_ids[i]);",
            "}",
            "assert!(",
            "max_neighbours + include_central_nodes as NodeT > j as NodeT,",
            "\"The index {} is higher than the given maximum neighbours number {}!\",",
            "j,",
            "max_neighbours",
            ");",
            "}",
            "});",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_label_prediction_tuple_by_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_ids",
                "Vec<NodeT>"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "include_central_node",
                "bool"
            ],
            [
                "offset",
                "NodeT"
            ],
            [
                "max_neighbours",
                "Option<NodeT>"
            ]
        ],
        "return_type": "Result<\n        impl Iterator<Item = (impl Iterator<Item = NodeT> + '_, Option<Vec<NodeTypeT>>)> + '_,\n        String,\n    >",
        "body": "if !self.has_node_types() {\n            return Err(\"The current graph instance does not have node types!\".to_string());\n        }\n        Ok(node_ids.into_iter().map(move |node_id| {\n            self.get_node_label_prediction_tuple_by_node_id(\n                node_id,\n                random_state,\n                include_central_node,\n                offset,\n                max_neighbours,\n            )\n        }))",
        "doc": [
            "Returns triple with the degrees of source nodes, destination nodes and labels for training model for link prediction.",
            "This method is just for setting the lowerbound on the simplest possible model.",
            "",
            "# Arguments",
            "",
            "* idx:u64 - The index of the batch to generate, behaves like a random random_state,",
            "* batch_size: usize - The maximal size of the batch to generate,",
            "* normalize: bool - Divide the degrees by the max, this way the values are in [0, 1],",
            "* negative_samples: f64 - The component of netagetive samples to use,",
            "* avoid_false_negatives: bool - whether to remove the false negatives when generated.",
            "- It should be left to false, as it has very limited impact on the training, but enabling this will slow things down.",
            "* maximal_sampling_attempts: usize - Number of attempts to execute to sample the negative edges.",
            "* graph_to_avoid: Option<&Graph> - The graph whose edges are to be avoided during the generation of false negatives,",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "link_prediction_degrees",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "idx",
                "u64"
            ],
            [
                "batch_size",
                "usize"
            ],
            [
                "normalize",
                "bool"
            ],
            [
                "negative_samples",
                "f64"
            ],
            [
                "avoid_false_negatives",
                "bool"
            ],
            [
                "maximal_sampling_attempts",
                "usize"
            ],
            [
                "graph_to_avoid",
                "&'a Option<&Graph>"
            ]
        ],
        "return_type": "Result<impl ParallelIterator<Item = (usize, f64, f64, bool)> + 'a, String>",
        "body": "let iter = self.link_prediction_ids(\n            idx,\n            batch_size,\n            negative_samples,\n            avoid_false_negatives,\n            maximal_sampling_attempts,\n            graph_to_avoid,\n        )?;\n\n        let max_degree = match normalize {\n            true => self.get_max_node_degree()? as f64,\n            false => 1.0,\n        };\n\n        Ok(iter.map(move |(index, src, dst, label)| {\n            (\n                index,\n                self.get_node_degree_by_node_id(src).unwrap() as f64 / max_degree,\n                self.get_node_degree_by_node_id(dst).unwrap() as f64 / max_degree,\n                label,\n            )\n        }))",
        "doc": [
            "Returns triple with the ids of source nodes, destination nodes and labels for training model for link prediction.",
            "",
            "# Arguments",
            "",
            "* idx:u64 - The index of the batch to generate, behaves like a random random_state,",
            "* batch_size: usize - The maximal size of the batch to generate,",
            "* negative_samples: f64 - The component of netagetive samples to use,",
            "* avoid_false_negatives: bool - whether to remove the false negatives when generated.",
            "- It should be left to false, as it has very limited impact on the training, but enabling this will slow things down.",
            "* maximal_sampling_attempts: usize - Number of attempts to execute to sample the negative edges.",
            "* graph_to_avoid: Option<&Graph> - The graph whose edges are to be avoided during the generation of false negatives,",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "link_prediction_ids",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "idx",
                "u64"
            ],
            [
                "batch_size",
                "usize"
            ],
            [
                "negative_samples",
                "f64"
            ],
            [
                "avoid_false_negatives",
                "bool"
            ],
            [
                "maximal_sampling_attempts",
                "usize"
            ],
            [
                "graph_to_avoid",
                "&'a Option<&Graph>"
            ]
        ],
        "return_type": "Result<impl ParallelIterator<Item = (usize, NodeT, NodeT, bool)> + 'a, String>",
        "body": "// xor the random_state with a constant so that we have a good amount of 0s and 1s in the number\n        // even with low values (this is needed becasue the random_state 0 make xorshift return always 0)\n        let random_state = idx ^ SEED_XOR as u64;\n\n        if negative_samples < 0.0 || !negative_samples.is_finite() {\n            return Err(\"Negative sample must be a posive real value.\".to_string());\n        }\n\n        // The number of negatives is given by computing their fraction of batchsize\n        let negative_number: usize =\n            ((batch_size as f64 / (1.0 + negative_samples)) * negative_samples) as usize;\n        // All the remaining values then are positives\n        let positive_number: usize = batch_size - negative_number;\n        let graph_has_no_self_loops = !self.has_selfloops();\n\n        let edges_number = self.get_directed_edges_number() as u64;\n        let nodes_number = self.get_nodes_number() as u32;\n\n        let mut rng: StdRng = SeedableRng::seed_from_u64(random_state);\n        let random_values = gen_random_vec(batch_size, random_state);\n        let mut indices: Vec<usize> = (0..batch_size).collect();\n        indices.shuffle(&mut rng);\n\n        Ok((0..batch_size)\n            .into_par_iter()\n            .map(move |i| {\n                let mut sampled = random_values[i];\n                if i < positive_number{\n                    let (src, dst) = self.get_node_ids_from_edge_id(sampled % edges_number);\n                    (indices[i], src, dst, true)\n                } else {\n                    for _ in 0..maximal_sampling_attempts {\n                        // split the random u64 into 2 u32 and mod them to have\n                        // usable nodes (this is slightly biased towards low values)\n                        let src = fast_u32_modulo((sampled & 0xffffffff) as u32, nodes_number);\n                        let dst = fast_u32_modulo((sampled >> 32) as u32, nodes_number);\n\n                        if avoid_false_negatives && self.has_edge_by_node_ids(src, dst) {\n                            sampled = xorshift(sampled);\n                            continue;\n                        }\n\n                        if let Some(g) = &graph_to_avoid {\n                            if g.has_edge_by_node_ids(src, dst)  {\n                                sampled = xorshift(sampled);\n                                continue;\n                            }\n                        }\n\n                        if graph_has_no_self_loops && src == dst {\n                            sampled = xorshift(sampled);\n                            continue;\n                        }\n\n                        return (indices[i], src, dst, false);\n                    }\n                    panic!(\n                        concat!(\n                            \"Executed more than {} attempts to sample a negative edge.\\n\",\n                            \"If your graph is so small that you see this error, you may want to consider \",\n                            \"using one of the edge embedding transformer from the Embiggen library.\"\n                        ),\n                        maximal_sampling_attempts\n                    );\n                }\n            }))",
        "doc": [
            "Return vector of edges to be inserted in the holdout."
        ]
    },
    {
        "modifiers": "pub",
        "name": "link_prediction_ids",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "idx",
                "u64"
            ],
            [
                "batch_size",
                "usize"
            ],
            [
                "negative_samples",
                "f64"
            ],
            [
                "avoid_false_negatives",
                "bool"
            ],
            [
                "maximal_sampling_attempts",
                "usize"
            ],
            [
                "graph_to_avoid",
                "&'a Option<&Graph>"
            ]
        ],
        "return_type": "Result<impl ParallelIterator<Item = (usize, NodeT, NodeT, bool)> + 'a, String>",
        "body": "// xor the random_state with a constant so that we have a good amount of 0s and 1s in the number\n        // even with low values (this is needed becasue the random_state 0 make xorshift return always 0)\n        let random_state = idx ^ SEED_XOR as u64;\n\n        if negative_samples < 0.0 || !negative_samples.is_finite() {\n            return Err(\"Negative sample must be a posive real value.\".to_string());\n        }\n\n        // The number of negatives is given by computing their fraction of batchsize\n        let negative_number: usize =\n            ((batch_size as f64 / (1.0 + negative_samples)) * negative_samples) as usize;\n        // All the remaining values then are positives\n        let positive_number: usize = batch_size - negative_number;\n        let graph_has_no_self_loops = !self.has_selfloops();\n\n        let edges_number = self.get_directed_edges_number() as u64;\n        let nodes_number = self.get_nodes_number() as u32;\n\n        let mut rng: StdRng = SeedableRng::seed_from_u64(random_state);\n        let random_values = gen_random_vec(batch_size, random_state);\n        let mut indices: Vec<usize> = (0..batch_size).collect();\n        indices.shuffle(&mut rng);\n\n        Ok((0..batch_size)\n            .into_par_iter()\n            .map(move |i| {\n                let mut sampled = random_values[i];\n                if i < positive_number{\n                    let (src, dst) = self.get_node_ids_from_edge_id(sampled % edges_number);\n                    (indices[i], src, dst, true)\n                } else {\n                    for _ in 0..maximal_sampling_attempts {\n                        // split the random u64 into 2 u32 and mod them to have\n                        // usable nodes (this is slightly biased towards low values)\n                        let src = fast_u32_modulo((sampled & 0xffffffff) as u32, nodes_number);\n                        let dst = fast_u32_modulo((sampled >> 32) as u32, nodes_number);\n\n                        if avoid_false_negatives && self.has_edge_by_node_ids(src, dst) {\n                            sampled = xorshift(sampled);\n                            continue;\n                        }\n\n                        if let Some(g) = &graph_to_avoid {\n                            if g.has_edge_by_node_ids(src, dst)  {\n                                sampled = xorshift(sampled);\n                                continue;\n                            }\n                        }\n\n                        if graph_has_no_self_loops && src == dst {\n                            sampled = xorshift(sampled);\n                            continue;\n                        }\n\n                        return (indices[i], src, dst, false);\n                    }\n                    panic!(\n                        concat!(\n                            \"Executed more than {} attempts to sample a negative edge.\\n\",\n                            \"If your graph is so small that you see this error, you may want to consider \",\n                            \"using one of the edge embedding transformer from the Embiggen library.\"\n                        ),\n                        maximal_sampling_attempts\n                    );\n                }\n            }))",
        "doc": [
            "Return vector of edges to be inserted in the holdout."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "compute_edge_ids_vector",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "include_all_edge_types",
                "bool"
            ]
        ],
        "return_type": "Vec<EdgeT>",
        "body": "if include_all_edge_types {\n            let (min_edge_id, max_edge_id) =\n                self.get_unchecked_minmax_edge_ids_by_node_ids(src, dst);\n            (min_edge_id..max_edge_id).collect::<Vec<EdgeT>>()\n        } else {\n            vec![edge_id]\n        }",
        "doc": [
            "Return whether nodes are remappable to those of the given graph.",
            "",
            "# Arguments",
            "other: &Graph - graph towards remap the nodes to.",
            "",
            "# Example",
            "A graph is always remappable to itself:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(graph.are_nodes_remappable(&graph));",
            "```",
            "Two different graphs, like Cora and STRING, are not remappable:",
            "```rust",
            "# let cora = graph::test_utilities::load_cora().unwrap();",
            "# let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(!cora.are_nodes_remappable(&ppi));",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "compute_edge_ids_vector",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "include_all_edge_types",
                "bool"
            ]
        ],
        "return_type": "Vec<EdgeT>",
        "body": "if include_all_edge_types {\n            let (min_edge_id, max_edge_id) =\n                self.get_unchecked_minmax_edge_ids_by_node_ids(src, dst);\n            (min_edge_id..max_edge_id).collect::<Vec<EdgeT>>()\n        } else {\n            vec![edge_id]\n        }",
        "doc": [
            "Return whether nodes are remappable to those of the given graph.",
            "",
            "# Arguments",
            "other: &Graph - graph towards remap the nodes to.",
            "",
            "# Example",
            "A graph is always remappable to itself:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(graph.are_nodes_remappable(&graph));",
            "```",
            "Two different graphs, like Cora and STRING, are not remappable:",
            "```rust",
            "# let cora = graph::test_utilities::load_cora().unwrap();",
            "# let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(!cora.are_nodes_remappable(&ppi));",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "are_nodes_remappable",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "other",
                "&Graph"
            ]
        ],
        "return_type": "bool",
        "body": "if self.get_nodes_number() != other.get_nodes_number() {\n            return false;\n        }\n        self.iter_nodes().all(|(_, node_name, _, node_type)| {\n            other.has_node_with_type_by_node_name(&node_name, node_type)\n        })",
        "doc": [
            "Return graph remapped towards nodes of the given graph.",
            "",
            "# Arguments",
            "",
            "* other: &Graph - The graph to remap towards.",
            "* verbose: bool - whether to show a loding bar.",
            "",
            "# Example",
            "A graph is always remappable to itself:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert_eq!(graph, graph.remap(&graph, false).unwrap());",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "remap",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "other",
                "&Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "let pb = get_loading_bar(\n            verbose,\n            format!(\"Building remapped {}\", self.name).as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n\n        if !self.are_nodes_remappable(&other) {\n            return Err(\"The two graphs nodes sets are not remappable one-another.\".to_owned());\n        }\n\n        Graph::from_integer_unsorted(\n            self.iter_edge_with_type_and_weight(true)\n                .progress_with(pb)\n                .map(|(_, _, src_name, _, dst_name, _, edge_type, weight)| {\n                    Ok((\n                        other.get_unchecked_node_id_by_node_name(&src_name),\n                        other.get_unchecked_node_id_by_node_name(&dst_name),\n                        edge_type.and_then(|et| {\n                            self.get_unchecked_edge_type_id_by_edge_type_name(Some(et.as_str()))\n                        }),\n                        weight,\n                    ))\n                }),\n            other.nodes.clone(),\n            other.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.directed,\n            self.name.clone(),\n            false,\n            self.has_edge_types(),\n            self.has_weights(),\n            verbose,\n            self.has_singletons(),\n            self.has_singleton_nodes_with_self_loops(),\n            self.has_trap_nodes(),\n        )",
        "doc": [
            "Returns boolean representing if given node is a singleton.",
            "",
            "The following works for traps and singletons.",
            "TODO: THIS IS SOMETHING TO BE GENERALIZED FOR DIRECTED GRAPHS.",
            "",
            "# Arguments",
            "",
            "`node_id`: NodeT - The node to be checked for."
        ]
    },
    {
        "modifiers": "pub",
        "name": "remap",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "other",
                "&Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "let pb = get_loading_bar(\n            verbose,\n            format!(\"Building remapped {}\", self.name).as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n\n        if !self.are_nodes_remappable(&other) {\n            return Err(\"The two graphs nodes sets are not remappable one-another.\".to_owned());\n        }\n\n        Graph::from_integer_unsorted(\n            self.iter_edge_with_type_and_weight(true)\n                .progress_with(pb)\n                .map(|(_, _, src_name, _, dst_name, _, edge_type, weight)| {\n                    Ok((\n                        other.get_unchecked_node_id_by_node_name(&src_name),\n                        other.get_unchecked_node_id_by_node_name(&dst_name),\n                        edge_type.and_then(|et| {\n                            self.get_unchecked_edge_type_id_by_edge_type_name(Some(et.as_str()))\n                        }),\n                        weight,\n                    ))\n                }),\n            other.nodes.clone(),\n            other.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.directed,\n            self.name.clone(),\n            false,\n            self.has_edge_types(),\n            self.has_weights(),\n            verbose,\n            self.has_singletons(),\n            self.has_singleton_nodes_with_self_loops(),\n            self.has_trap_nodes(),\n        )",
        "doc": [
            "Returns boolean representing if given node is a singleton.",
            "",
            "The following works for traps and singletons.",
            "TODO: THIS IS SOMETHING TO BE GENERALIZED FOR DIRECTED GRAPHS.",
            "",
            "# Arguments",
            "",
            "`node_id`: NodeT - The node to be checked for."
        ]
    },
    {
        "modifiers": "pub",
        "name": "is_singleton_by_node_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<bool, String>",
        "body": "Ok(self.has_singletons() && self.get_node_degree_by_node_id(node_id)? == 0)",
        "doc": [
            "Returns boolean representing if given node is a singleton with self-loops.",
            "",
            "# Arguments",
            "",
            "`node_id`: NodeT - The node to be checked for."
        ]
    },
    {
        "modifiers": "pub",
        "name": "is_singleton_with_self_loops_by_node_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "bool",
        "body": "self.has_singleton_nodes_with_self_loops()\n            && self\n                .iter_node_neighbours_ids(node_id)\n                .all(|dst| dst == node_id)",
        "doc": [
            "Returns boolean representing if given node is a singleton.",
            "",
            "# Arguments",
            "`node_name`: &str - The node name to be checked for."
        ]
    },
    {
        "modifiers": "pub",
        "name": "is_singleton_by_node_name",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "Result<bool, String>",
        "body": "self.is_singleton_by_node_id(self.get_node_id_by_node_name(node_name)?)",
        "doc": [
            "Returns whether the graph has the given node name.",
            "",
            "# Arguments",
            "",
            "* `node_name`: &str - Name of the node.",
            "",
            "# Examples",
            "To check if a node appears in the graph you can use:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let node_name = \"ENSP00000000233\";",
            "let unexistent_node_name = \"I_do_not_exist!\";",
            "assert!(graph.has_node_by_node_name(node_name));",
            "assert!(!graph.has_node_by_node_name(unexistent_node_name));",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_node_by_node_name",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_node_id_by_node_name(node_name).is_ok()"
    },
    {
        "modifiers": "pub",
        "name": "has_edge_by_node_ids",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_edge_id_by_node_ids(src, dst).is_ok()",
        "doc": [
            "Returns boolean representing if edge passing between given nodes exists.",
            "",
            "# Arguments",
            "",
            "* src: NodeT - The source node of the edge.",
            "* dst: NodeT - The destination node of the edge.",
            "* edge_type: Option<EdgeTypeT> - The (optional) edge type.",
            "",
            "TODO: add example!"
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_edge_with_type_by_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "edge_type",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_edge_id_with_type_by_node_ids(src, dst, edge_type)\n            .is_ok()",
        "doc": [
            "Returns boolean representing if given node is a trap.",
            "",
            "# Arguments",
            "",
            "* `node` - Integer ID of the node, if this is bigger that the number of nodes it will panic.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "is_node_trap_by_node_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node",
                "NodeT"
            ]
        ],
        "return_type": "Result<bool, String>",
        "body": "Ok(self.get_node_degree_by_node_id(node)? == 0)",
        "doc": [
            "Returns whether the given node name and node type name exist in current graph.",
            "",
            "# Arguments",
            "",
            "* node_name: String - The node name.",
            "* node_type_name: String - The node type name.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_node_with_type_by_node_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_name",
                "&str"
            ],
            [
                "node_type_name",
                "Option<Vec<String>>"
            ]
        ],
        "return_type": "bool",
        "body": "match self.get_node_id_by_node_name(node_name) {\n            Err(_) => false,\n            Ok(node_id) => {\n                let our_node_types = self.get_node_type_name_by_node_id(node_id);\n                match (our_node_types, node_type_name) {\n                    (Err(_), None) => true,\n                    (Ok(None), None) => true,\n                    (Ok(Some(mut our_nts)), Some(mut other_nts)) => {\n                        our_nts.sort();\n                        other_nts.sort();\n                        our_nts == other_nts\n                    }\n                    _ => false,\n                }\n            }\n        }",
        "doc": [
            "Returns boolean representing if edge passing between given nodes exists.",
            "",
            "# Arguments",
            "",
            "* src: String - The source node name of the edge.",
            "* dst: String - The destination node name of the edge.",
            "* edge_type: Option<String> - The (optional) edge type name.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_edge_with_type_by_node_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src_name",
                "&str"
            ],
            [
                "dst_name",
                "&str"
            ],
            [
                "edge_type_name",
                "Option<&String>"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_edge_id_with_type_by_node_names(src_name, dst_name, edge_type_name)\n            .is_ok()"
    },
    {
        "modifiers": "pub",
        "name": "has_edge_by_node_names",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "src_name",
                "&str"
            ],
            [
                "dst_name",
                "&str"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_edge_id_by_node_names(src_name, dst_name).is_ok()",
        "doc": [
            "Return a roaringbitmap with the node ids to keep.",
            "",
            "If both node\\_names and node\\_types are specified the result will be the",
            "union of both queries.",
            "",
            "# Arguments",
            "* `node_names` - The nodes to keep as strings",
            "* `node_types` - The nodes types to keep as strings",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_edge_by_node_names",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "src_name",
                "&str"
            ],
            [
                "dst_name",
                "&str"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_edge_id_by_node_names(src_name, dst_name).is_ok()",
        "doc": [
            "Return a roaringbitmap with the node ids to keep.",
            "",
            "If both node\\_names and node\\_types are specified the result will be the",
            "union of both queries.",
            "",
            "# Arguments",
            "* `node_names` - The nodes to keep as strings",
            "* `node_types` - The nodes types to keep as strings",
            ""
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_filter_bitmap",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_names",
                "Option<Vec<String>>"
            ],
            [
                "node_types",
                "Option<Vec<Option<String>>>"
            ]
        ],
        "return_type": "Result<Option<RoaringBitmap>, String>",
        "body": "let mut node_ids = RoaringBitmap::new();\n\n        if let Some(ns) = node_names {\n            node_ids.extend(\n                ns.iter()\n                    .map(|node_name| self.get_node_id_by_node_name(node_name))\n                    .collect::<Result<Vec<NodeT>, String>>()?,\n            );\n        }\n\n        if let Some(ndt) = node_types {\n            let node_type_ids = self.get_node_type_ids_by_node_type_names(ndt)?;\n            node_ids.extend(self.iter_node_ids().filter_map(|(node_id, nts)| {\n                if nts.map_or_else(\n                    //DEFAULT\n                    || node_type_ids.contains(&None),\n                    // If some\n                    |ns| {\n                        ns.into_iter()\n                            .any(|node_type_name| node_type_ids.contains(&Some(node_type_name)))\n                    },\n                ) {\n                    Some(node_id)\n                } else {\n                    None\n                }\n            }));\n        }\n\n        Ok(optionify!(node_ids))",
        "doc": [
            "Enable extra perks that buys you time as you accept to spend more memory.",
            "",
            "# Arguments",
            "* `vector_sources`: bool, whether to cache sources into a vector for faster walks.",
            "* `vector_destinations`: bool, whether to cache destinations into a vector for faster walks.",
            "* `vector_outbounds`: bool, whether to cache outbounds into a vector for faster walks.",
            "* `cache_size`: Option<f64>, percentage of nodes destinations to cache. This cannot be used with the vector destinations."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_filter_bitmap",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_names",
                "Option<Vec<String>>"
            ],
            [
                "node_types",
                "Option<Vec<Option<String>>>"
            ]
        ],
        "return_type": "Result<Option<RoaringBitmap>, String>",
        "body": "let mut node_ids = RoaringBitmap::new();\n\n        if let Some(ns) = node_names {\n            node_ids.extend(\n                ns.iter()\n                    .map(|node_name| self.get_node_id_by_node_name(node_name))\n                    .collect::<Result<Vec<NodeT>, String>>()?,\n            );\n        }\n\n        if let Some(ndt) = node_types {\n            let node_type_ids = self.get_node_type_ids_by_node_type_names(ndt)?;\n            node_ids.extend(self.iter_node_ids().filter_map(|(node_id, nts)| {\n                if nts.map_or_else(\n                    //DEFAULT\n                    || node_type_ids.contains(&None),\n                    // If some\n                    |ns| {\n                        ns.into_iter()\n                            .any(|node_type_name| node_type_ids.contains(&Some(node_type_name)))\n                    },\n                ) {\n                    Some(node_id)\n                } else {\n                    None\n                }\n            }));\n        }\n\n        Ok(optionify!(node_ids))",
        "doc": [
            "Enable extra perks that buys you time as you accept to spend more memory.",
            "",
            "# Arguments",
            "* `vector_sources`: bool, whether to cache sources into a vector for faster walks.",
            "* `vector_destinations`: bool, whether to cache destinations into a vector for faster walks.",
            "* `vector_outbounds`: bool, whether to cache outbounds into a vector for faster walks.",
            "* `cache_size`: Option<f64>, percentage of nodes destinations to cache. This cannot be used with the vector destinations."
        ]
    },
    {
        "modifiers": "pub",
        "name": "enable",
        "args": [
            [
                "self",
                "&mut self"
            ],
            [
                "vector_sources",
                "bool"
            ],
            [
                "vector_destinations",
                "bool"
            ],
            [
                "vector_outbounds",
                "bool"
            ],
            [
                "cache_size",
                "Option<f64>"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "if vector_destinations {\n            if self.destinations.is_none() {\n                self.destinations = Some(self.get_destinations(true));\n            }\n        } else {\n            self.destinations = None;\n        }\n        if vector_sources {\n            if self.sources.is_none() {\n                self.sources = Some(self.get_sources(true));\n            }\n        } else {\n            self.sources = None;\n        }\n        if vector_outbounds {\n            if self.outbounds.is_none() {\n                self.outbounds = Some(self.get_outbounds());\n            }\n        } else {\n            self.outbounds = None;\n        }\n        if let Some(cs) = cache_size {\n            if vector_destinations {\n                return Err(\"You cannot use cache if you enable the destinations vector\".to_owned());\n            }\n            if cs <= 0.0 || cs >= 1.0 {\n                return Err(\"Cache size must be between strictly 0 and 1, otherwise just enable the destinations vector.\".to_owned());\n            }\n            let cached_nodes_number: NodeT = (self.get_nodes_number() as f64 * cs) as NodeT;\n            if cached_nodes_number == 0 || cached_nodes_number == self.get_nodes_number() {\n                return Err(\"Required cached nodes number cannot be 0 or all the nodes.\".to_owned());\n            }\n            self.cached_destinations = Some(\n                self.get_top_k_central_nodes_ids(cached_nodes_number)\n                    .par_iter()\n                    .map(|node_id| {\n                        (\n                            *node_id,\n                            self.iter_node_neighbours_ids(*node_id)\n                                .collect::<Vec<NodeT>>(),\n                        )\n                    })\n                    .collect::<HashMap<NodeT, Vec<NodeT>>>(),\n            );\n        } else {\n            self.cached_destinations = None;\n        }\n        Ok(())",
        "doc": [
            "Disable all extra perks, reducing memory impact but incresing time requirements."
        ]
    },
    {
        "modifiers": "pub",
        "name": "disable_all",
        "args": [
            [
                "self",
                "mut self"
            ]
        ],
        "body": "self.destinations = None;\n        self.sources = None;\n        self.outbounds = None;\n        self.cached_destinations = None;",
        "doc": [
            "Returns list of nodes of the various strongly connected components.",
            "",
            "This is an implementation of Tarjan algorithm.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "disable_all",
        "args": [
            [
                "self",
                "mut self"
            ]
        ],
        "body": "self.destinations = None;\n        self.sources = None;\n        self.outbounds = None;\n        self.cached_destinations = None;",
        "doc": [
            "Returns list of nodes of the various strongly connected components.",
            "",
            "This is an implementation of Tarjan algorithm.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "strongly_connected_components",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Vec<HashSet<NodeT>>",
        "body": "let mut indexed_mask: Vec<bool> = vec![false; self.get_nodes_number() as usize];\n        let mut stacked_mask: Vec<bool> = vec![false; self.get_nodes_number() as usize];\n        let mut low_indices: Vec<NodeT> = vec![0; self.get_nodes_number() as usize];\n        let mut indices: Vec<NodeT> = vec![0; self.get_nodes_number() as usize];\n        let mut components_stack: Vec<NodeT> = Vec::new();\n        let mut components: Vec<HashSet<NodeT>> = Vec::new();\n        let mut common_index = 0;\n        let mut recurse: bool;\n        for node in 0..self.get_nodes_number() {\n            if !indexed_mask[node as usize] {\n                let mut to_visit: Vec<(NodeT, usize)> = vec![(node, 0)];\n                while !to_visit.is_empty() {\n                    let (src, i) = to_visit.pop().unwrap();\n                    if !indexed_mask[src as usize] {\n                        low_indices[src as usize] = common_index;\n                        indices[src as usize] = common_index;\n                        indexed_mask[src as usize] = true;\n                        stacked_mask[src as usize] = true;\n                        common_index += 1;\n                        components_stack.push(src);\n                    }\n                    recurse = false;\n                    let (_min, _max) = self.get_minmax_edge_ids_by_source_node_id(src);\n                    // Consider successors of source node\n                    for (j, dst) in ((_min + i as EdgeT).._max)\n                        .map(|edge_id| self.get_destination_node_id_by_edge_id(edge_id).unwrap())\n                        .enumerate()\n                    {\n                        if !indexed_mask[dst as usize] {\n                            // Successor w has not yet been visited; recurse on it\n                            to_visit.push((src, i + j + 1));\n                            to_visit.push((dst, 0));\n                            recurse = true;\n                            break;\n                        } else if stacked_mask[dst as usize] {\n                            // Successor w is in stack S and hence in the current SCC\n                            // If w is not on stack, then (v, w) is an edge pointing to an SCC already found and must be ignored\n                            // Note: The next line may look odd - but is correct.\n                            // It says w.index not w.lowlink; that is deliberate and from the original paper\n                            low_indices[src as usize] =\n                                min(low_indices[src as usize], indices[dst as usize]);\n                        }\n                    }\n\n                    if recurse {\n                        continue;\n                    }\n\n                    // If source is a root node, pop the stack and generate an SCC\n                    if low_indices[src as usize] == indices[src as usize] {\n                        // start a new strongly connected component\n                        let mut new_component: HashSet<NodeT> = HashSet::new();\n                        loop {\n                            let dst = components_stack.pop().unwrap();\n                            stacked_mask[dst as usize] = false;\n                            new_component.insert(dst);\n                            if dst == src {\n                                break;\n                            }\n                        }\n                        components.push(new_component);\n                    }\n\n                    if !to_visit.is_empty() {\n                        let (root, _) = to_visit.last().unwrap();\n                        low_indices[*root as usize] =\n                            min(low_indices[*root as usize], low_indices[src as usize]);\n                    }\n                }\n            }\n        }\n        components",
        "doc": [
            "Return the src, dst, edge type and weight of a given edge id"
        ]
    },
    {
        "modifiers": "pub",
        "name": "strongly_connected_components",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Vec<HashSet<NodeT>>",
        "body": "let mut indexed_mask: Vec<bool> = vec![false; self.get_nodes_number() as usize];\n        let mut stacked_mask: Vec<bool> = vec![false; self.get_nodes_number() as usize];\n        let mut low_indices: Vec<NodeT> = vec![0; self.get_nodes_number() as usize];\n        let mut indices: Vec<NodeT> = vec![0; self.get_nodes_number() as usize];\n        let mut components_stack: Vec<NodeT> = Vec::new();\n        let mut components: Vec<HashSet<NodeT>> = Vec::new();\n        let mut common_index = 0;\n        let mut recurse: bool;\n        for node in 0..self.get_nodes_number() {\n            if !indexed_mask[node as usize] {\n                let mut to_visit: Vec<(NodeT, usize)> = vec![(node, 0)];\n                while !to_visit.is_empty() {\n                    let (src, i) = to_visit.pop().unwrap();\n                    if !indexed_mask[src as usize] {\n                        low_indices[src as usize] = common_index;\n                        indices[src as usize] = common_index;\n                        indexed_mask[src as usize] = true;\n                        stacked_mask[src as usize] = true;\n                        common_index += 1;\n                        components_stack.push(src);\n                    }\n                    recurse = false;\n                    let (_min, _max) = self.get_minmax_edge_ids_by_source_node_id(src);\n                    // Consider successors of source node\n                    for (j, dst) in ((_min + i as EdgeT).._max)\n                        .map(|edge_id| self.get_destination_node_id_by_edge_id(edge_id).unwrap())\n                        .enumerate()\n                    {\n                        if !indexed_mask[dst as usize] {\n                            // Successor w has not yet been visited; recurse on it\n                            to_visit.push((src, i + j + 1));\n                            to_visit.push((dst, 0));\n                            recurse = true;\n                            break;\n                        } else if stacked_mask[dst as usize] {\n                            // Successor w is in stack S and hence in the current SCC\n                            // If w is not on stack, then (v, w) is an edge pointing to an SCC already found and must be ignored\n                            // Note: The next line may look odd - but is correct.\n                            // It says w.index not w.lowlink; that is deliberate and from the original paper\n                            low_indices[src as usize] =\n                                min(low_indices[src as usize], indices[dst as usize]);\n                        }\n                    }\n\n                    if recurse {\n                        continue;\n                    }\n\n                    // If source is a root node, pop the stack and generate an SCC\n                    if low_indices[src as usize] == indices[src as usize] {\n                        // start a new strongly connected component\n                        let mut new_component: HashSet<NodeT> = HashSet::new();\n                        loop {\n                            let dst = components_stack.pop().unwrap();\n                            stacked_mask[dst as usize] = false;\n                            new_component.insert(dst);\n                            if dst == src {\n                                break;\n                            }\n                        }\n                        components.push(new_component);\n                    }\n\n                    if !to_visit.is_empty() {\n                        let (root, _) = to_visit.last().unwrap();\n                        low_indices[*root as usize] =\n                            min(low_indices[*root as usize], low_indices[src as usize]);\n                    }\n                }\n            }\n        }\n        components",
        "doc": [
            "Return the src, dst, edge type and weight of a given edge id"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_quadruple",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "(NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>)",
        "body": "let (src, dst, edge_type) = self.get_edge_triple(edge_id);\n        (\n            src,\n            dst,\n            edge_type,\n            self.get_unchecked_weight_by_edge_id(edge_id),\n        )",
        "doc": [
            "Return the src, dst, edge type of a given edge id"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_triple",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "(NodeT, NodeT, Option<EdgeTypeT>)",
        "body": "let (src, dst) = self.get_node_ids_from_edge_id(edge_id);\n        (src, dst, self.get_unchecked_edge_type_by_edge_id(edge_id))",
        "doc": [
            "Return vector with top k central node Ids.",
            "",
            "# Arguments",
            "",
            "* k: NodeT - Number of central nodes to extract."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_top_k_central_nodes_ids",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "k",
                "NodeT"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "let mut nodes_degrees: Vec<(NodeT, NodeT)> = (0..self.get_nodes_number())\n            .map(|node_id| (self.get_node_degree_by_node_id(node_id).unwrap(), node_id))\n            .collect();\n        nodes_degrees.par_sort_unstable();\n        nodes_degrees.reverse();\n        nodes_degrees[0..k as usize]\n            .iter()\n            .map(|(_, node_id)| *node_id)\n            .collect()",
        "doc": [
            "Return vector with top k central node names.",
            "",
            "# Arguments",
            "",
            "* k: NodeT - Number of central nodes to extract."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_top_k_central_node_names",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "k",
                "NodeT"
            ]
        ],
        "return_type": "Vec<String>",
        "body": "self.get_top_k_central_nodes_ids(k)\n            .into_iter()\n            .map(|node_id| self.get_node_name_by_node_id(node_id).unwrap())\n            .collect()",
        "doc": [
            "Returns node type of given node.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - node whose node type is to be returned.",
            "",
            "# Examples",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The node type id of node {} is {:?}\", 0, graph.get_node_type_id_by_node_id(0));",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_type_id_by_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<Option<Vec<NodeTypeT>>, String>",
        "body": "if let Some(nt) = &self.node_types {\n            return if node_id <= nt.ids.len() as NodeT {\n                Ok(nt.ids[node_id as usize].clone())\n            } else {\n                Err(format!(\n                    \"The node_index {} is too big for the node_types vector which has len {}\",\n                    node_id,\n                    nt.ids.len()\n                ))\n            };\n        }\n\n        Err(String::from(\n            \"Node types are not defined for current graph instance.\",\n        ))",
        "doc": [
            "Returns edge type of given edge.",
            "",
            "# Arguments",
            "",
            "* edge_id: EdgeT - edge whose edge type is to be returned.",
            "",
            "# Examples",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The edge type id of edge {} is {:?}\", 0, graph.get_edge_type_id_by_edge_id(0));",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_type_id_by_edge_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Result<Option<EdgeTypeT>, String>",
        "body": "if let Some(et) = &self.edge_types {\n            return if edge_id <= et.ids.len() as EdgeT {\n                Ok(self.get_unchecked_edge_type_by_edge_id(edge_id))\n            } else {\n                Err(format!(\n                    \"The edge_index {} is too big for the edge_types vector which has len {}\",\n                    edge_id,\n                    et.ids.len()\n                ))\n            };\n        }\n        Err(String::from(\n            \"Edge types are not defined for current graph instance.\",\n        ))",
        "doc": [
            "Returns option with the node type of the given node id.",
            "TODO: MOST LIKELY THIS SHOULD BE CHANGED!!!"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_type_name_by_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<Option<Vec<String>>, String>",
        "body": "match &self.node_types.is_some() {\n            true => Ok(match self.get_unchecked_node_type_id_by_node_id(node_id) {\n                Some(node_type_id) => {\n                    Some(self.get_node_type_names_by_node_type_ids(node_type_id)?)\n                }\n                None => None,\n            }),\n            false => Err(\"Node types not available for the current graph instance.\".to_string()),\n        }",
        "doc": [
            "Returns option with the edge type of the given edge id.",
            "TODO: complete docstring and add example!",
            "TODO: THIS SHOULD RETURN A RESULT!"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_type_name_by_edge_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Result<Option<String>, String>",
        "body": "self.get_edge_type_id_by_edge_id(edge_id)?\n            .map_or(Ok(None), |x| {\n                Ok(Some(self.get_edge_type_name_by_edge_type_id(x)?))\n            })",
        "doc": [
            "Return edge type name of given edge type.",
            "",
            "# Arguments",
            "* edge_type_id: EdgeTypeT - Id of the edge type."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_type_name_by_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type_id",
                "EdgeTypeT"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "self.edge_types.as_ref().map_or(\n            Err(\"Edge types not available for the current graph instance.\".to_string()),\n            |ets| ets.translate(edge_type_id),\n        )",
        "doc": [
            "Returns weight of the given edge id.",
            "",
            "# Arguments",
            "* `edge_id`: EdgeT - The edge ID whose weight is to be returned.",
            "",
            "# Examples",
            "To get the weight of a given `edge_id` you can run:",
            "```rust",
            "# let weighted_graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "# let unweighted_graph = graph::test_utilities::load_ppi(true, true, false, true, false, false).unwrap();",
            "let edge_id = 0;",
            "let unexistent_edge_id = 123456789;",
            "assert!(weighted_graph.get_weight_by_edge_id(edge_id).is_ok());",
            "assert!(weighted_graph.get_weight_by_edge_id(unexistent_edge_id).is_err());",
            "assert!(unweighted_graph.get_weight_by_edge_id(edge_id).is_err());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_weight_by_edge_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "self.weights.as_ref().map_or(\n            Err(\"The current graph instance does not have weights!\".to_string()),\n            |weights| weights.get(edge_id as usize).map_or(\n                Err(format!(\n                    \"The given edge_id {} is higher than the number of available directed edges {}.\",\n                    edge_id,\n                    self.get_directed_edges_number()\n                )),\n                |value| Ok(*value)\n            )\n        )",
        "doc": [
            "Returns weight of the given node ids.",
            "",
            "# Arguments",
            "* `src`: NodeT - The node ID of the source node.",
            "* `dst`: NodeT - The node ID of the destination node.",
            "",
            "# Examples",
            "To get the weight of a given `src` and `dst` you can run:",
            "```rust",
            "# let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "let src = 0;",
            "let dst = 1;",
            "assert!(weighted_graph.get_weight_by_node_ids(src, dst).is_ok());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_weight_by_node_ids",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "self.get_weight_by_edge_id(self.get_edge_id_by_node_ids(src, dst)?)",
        "doc": [
            "Returns weight of the given node ids and edge type.",
            "",
            "# Arguments",
            "* `src`: NodeT - The node ID of the source node.",
            "* `dst`: NodeT - The node ID of the destination node.",
            "* `edge_type`: Option<EdgeTypeT> - The edge type ID of the edge.",
            "",
            "# Examples",
            "To get the weight of a given `src` and `dst` and `edge_type` you can run:",
            "```rust",
            "# let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "let src = 0;",
            "let dst = 1;",
            "let edge_type = Some(0);",
            "assert!(weighted_graph.get_weight_with_type_by_node_ids(src, dst, edge_type).is_ok());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_weight_with_type_by_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "edge_type",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "self.get_weight_by_edge_id(self.get_edge_id_with_type_by_node_ids(src, dst, edge_type)?)",
        "doc": [
            "Returns weight of the given node names and edge type.",
            "",
            "# Arguments",
            "* `src`: &str - The node name of the source node.",
            "* `dst`: &str - The node name of the destination node.",
            "* `edge_type`: Option<&String> - The edge type name of the edge.",
            "",
            "# Examples",
            "To get the weight of a given `src` and `dst` and `edge_type` you can run:",
            "```rust",
            "# let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "let src = \"ENSP00000000233\";",
            "let dst = \"ENSP00000432568\";",
            "let edge_type = Some(\"red\".to_string());",
            "assert!(weighted_graph.get_weight_with_type_by_node_names(src, dst, edge_type.as_ref()).is_ok());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_weight_with_type_by_node_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "&str"
            ],
            [
                "dst",
                "&str"
            ],
            [
                "edge_type",
                "Option<&String>"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "self.get_weight_by_edge_id(self.get_edge_id_with_type_by_node_names(src, dst, edge_type)?)",
        "doc": [
            "Returns weight of the given node names.",
            "",
            "# Arguments",
            "* `src_name`: &str - The node name of the source node.",
            "* `dst_name`: &str - The node name of the destination node.",
            "",
            "# Examples",
            "To get the weight of a given `src_name` and `dst_name` you can run:",
            "```rust",
            "# let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "let src_name = \"ENSP00000000233\";",
            "let dst_name = \"ENSP00000432568\";",
            "assert!(weighted_graph.get_weight_by_node_names(src_name, dst_name).is_ok());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_weight_by_node_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src_name",
                "&str"
            ],
            [
                "dst_name",
                "&str"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "self.get_weight_by_edge_id(self.get_edge_id_by_node_names(src_name, dst_name)?)",
        "doc": [
            "Returns result with the node name."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_name_by_node_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "match node_id < self.get_nodes_number() {\n            true => Ok(self.nodes.unchecked_translate(node_id)),\n            false => Err(format!(\n                \"Given node_id {} is greater than number of nodes in the graph ({}).\",\n                node_id,\n                self.get_nodes_number()\n            )),\n        }",
        "doc": [
            "Returns result with the node id."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_id_by_node_name",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "match self.nodes.get(node_name) {\n            Some(node_id) => Ok(*node_id),\n            None => Err(format!(\n                \"Given node name {} is not available in current graph.\",\n                node_name\n            )),\n        }",
        "doc": [
            "Return node type ID for the given node name if available.",
            "",
            "# Arguments",
            "",
            "* `node_name`: &str - Name of the node.",
            "",
            "# Examples",
            "To get the node type ID for a given node name you can run:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let node_name = \"ENSP00000000233\";",
            "println!(\"The node type ID of node {} is {:?}.\", node_name, graph.get_node_type_id_by_node_name(node_name).unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_type_id_by_node_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "Result<Option<Vec<NodeTypeT>>, String>",
        "body": "self.get_node_type_id_by_node_id(self.get_node_id_by_node_name(node_name)?)",
        "doc": [
            "Return node type name for the given node name if available.",
            "",
            "# Arguments",
            "",
            "* `node_name`: &str - Name of the node.",
            "",
            "# Examples",
            "To get the node type name for a given node name you can run:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let node_name = \"ENSP00000000233\";",
            "println!(\"The node type of node {} is {:?}\", node_name, graph.get_node_type_name_by_node_name(node_name).unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_type_name_by_node_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "Result<Option<Vec<String>>, String>",
        "body": "self.get_node_type_name_by_node_id(self.get_node_id_by_node_name(node_name)?)",
        "doc": [
            "TODO: add doc"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_count_by_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "Result<EdgeT, String>",
        "body": "if !self.has_edge_types() {\n            return Err(\"Current graph does not have edge types!\".to_owned());\n        }\n        if let Some(et) = &edge_type {\n            if self.get_edge_types_number() <= *et {\n                return Err(format!(\n                    \"Given edge type ID {} is bigger than number of edge types in the graph {}.\",\n                    self.get_edge_types_number(),\n                    et\n                ));\n            }\n        }\n        Ok(self.get_unchecked_edge_count_by_edge_type_id(edge_type))",
        "doc": [
            "TODO: add doc"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_type_id_by_edge_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type_name",
                "Option<&str>"
            ]
        ],
        "return_type": "Result<Option<EdgeTypeT>, String>",
        "body": "match (&self.edge_types, edge_type_name) {\n            (None, _) => Err(\"Current graph does not have edge types.\".to_owned()),\n            (Some(_), None) => Ok(None),\n            (Some(ets), Some(etn)) => match ets.get(etn) {\n                Some(edge_type_id) => Ok(Some(*edge_type_id)),\n                None => Err(format!(\n                    \"Given edge type name {} is not available in current graph.\",\n                    etn\n                )),\n            },\n        }",
        "doc": [
            "TODO: add doc"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_count_by_edge_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type",
                "Option<&str>"
            ]
        ],
        "return_type": "Result<EdgeT, String>",
        "body": "self.get_edge_count_by_edge_type_id(self.get_edge_type_id_by_edge_type_name(edge_type)?)",
        "doc": [
            "TODO: add doc"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_type_id_by_node_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type_name",
                "&str"
            ]
        ],
        "return_type": "Result<NodeTypeT, String>",
        "body": "if let Some(ets) = &self.node_types {\n            return match ets.get(node_type_name) {\n                Some(node_type_id) => Ok(*node_type_id),\n                None => Err(format!(\n                    \"Given node type name {} is not available in current graph.\",\n                    node_type_name\n                )),\n            };\n        }\n        Err(\"Current graph does not have node types.\".to_owned())",
        "doc": [
            "TODO: add doc"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_count_by_node_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type",
                "Option<NodeTypeT>"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "if !self.has_node_types() {\n            return Err(\"Current graph does not have node types!\".to_owned());\n        }\n        if node_type.map_or(false, |nt| self.get_node_types_number() <= nt) {\n            return Err(format!(\n                \"Given node type ID {:?} is bigger than number of node types in the graph {}.\",\n                node_type,\n                self.get_node_types_number()\n            ));\n        }\n        Ok(self.get_unchecked_node_count_by_node_type_id(node_type))",
        "doc": [
            "TODO: add docstring"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_count_by_node_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type_name",
                "Option<&str>"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "self.get_node_count_by_node_type_id(\n            node_type_name.map_or(Ok::<_, String>(None), |ntn| {\n                Ok(Some(self.get_node_type_id_by_node_type_name(ntn)?))\n            })?,\n        )",
        "doc": [
            "TODO!: add unchecked version of this method!",
            "TODO: add docstring and example!"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_destination_node_id_by_edge_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "if edge_id >= self.get_directed_edges_number() {\n            return Err(format!(\n                \"The edge ID {} is higher than the number of available directed edges {}.\",\n                edge_id,\n                self.get_directed_edges_number()\n            ));\n        }\n        Ok(match &self.destinations {\n            Some(destinations) => destinations[edge_id as usize],\n            None => self.get_node_ids_from_edge_id(edge_id).1,\n        })",
        "doc": [
            "Return vector of destinations for the given source node ID.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - Node ID whose neighbours are to be retrieved.",
            "",
            "# Example",
            "To retrieve the neighbours of a given node `src` you can use:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "# let node_id = 0;",
            "println!(\"The neighbours of the node {} are {:?}.\", node_id, graph.get_node_neighbours_by_node_id(node_id).unwrap());",
            "let unavailable_node = 2349765432;",
            "assert!(graph.get_node_neighbours_by_node_id(unavailable_node).is_err());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_neighbours_by_node_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<Vec<NodeT>, String>",
        "body": "if node_id >= self.get_nodes_number() {\n            return Err(format!(\n                \"The node ID {} is higher than the number of available nodes {}.\",\n                node_id,\n                self.get_nodes_number()\n            ));\n        }\n        Ok(self\n            .iter_unchecked_edge_ids_by_source_node_id(node_id)\n            .map(move |edge_id| self.get_destination_node_id_by_edge_id(edge_id).unwrap())\n            .collect())",
        "doc": [
            "Return vector of destinations for the given source node name.",
            "",
            "# Arguments",
            "",
            "* `node_name`: &str - Node ID whose neighbours are to be retrieved.",
            "",
            "# Example",
            "To retrieve the neighbours of a given node `src` you can use:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let node_id = 0;",
            "println!(\"The neighbours of the node {} are {:?}.\", node_id, graph.get_node_neighbours_by_node_id(node_id).unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_neighbours_by_node_name",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "Result<Vec<NodeT>, String>",
        "body": "self.get_node_neighbours_by_node_id(self.get_node_id_by_node_name(node_name)?)",
        "doc": [
            "Return vector of destination names for the given source node name.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - Node ID whose neighbours are to be retrieved.",
            "",
            "# Example",
            "To retrieve the neighbours of a given node `src` you can use:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let node_name = \"ENSP00000000233\";",
            "println!(\"The neighbours of the node {} are {:?}.\", node_name, graph.get_node_neighbour_names_by_node_name(node_name).unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_neighbour_names_by_node_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "Result<Vec<String>, String>",
        "body": "Ok(self\n            .iter_node_neighbours(self.get_node_id_by_node_name(node_name)?)\n            .collect())",
        "doc": [
            "Return edge ID without any checks for given tuple of nodes and edge type.",
            "",
            "This method will return an error if the graph does not contain the",
            "requested edge with edge type.",
            "",
            "# Arguments",
            "`src`: NodeT - Source node of the edge.",
            "`dst`: NodeT - Destination node of the edge.",
            "`edge_type`: Option<EdgeTypeT> - Edge Type of the edge.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_id_with_type_by_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "edge_type",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "Result<EdgeT, String>",
        "body": "let edge_id = self.edge_types.as_ref().map_or_else(\n            || self.get_edge_id_by_node_ids(src, dst).ok(),\n            |ets| {\n                self.get_edge_ids_by_node_ids(src, dst)\n                    .and_then(|mut edge_ids| {\n                        edge_ids.find(|edge_id| ets.ids[*edge_id as usize] == edge_type)\n                    })\n            },\n        );\n        // TODO: change using a map_err!\n        match edge_id {\n            Some(e) => Ok(e),\n            None => Err(format!(\n                concat!(\n                    \"The current graph instance does not contain the required edge composed of \",\n                    \"source node ID {}, destination node ID {} and edge ID {:?}.\"\n                ),\n                src, dst, edge_type\n            )),\n        }"
    },
    {
        "modifiers": "pub",
        "name": "get_edge_id_by_node_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src_name",
                "&str"
            ],
            [
                "dst_name",
                "&str"
            ]
        ],
        "return_type": "Result<EdgeT, String>",
        "body": "// TODO REFACTOR CODE to be cleaner!\n        let edge_id =\n            if let (Some(src), Some(dst)) = (self.nodes.get(src_name), self.nodes.get(dst_name)) {\n                self.get_edge_id_by_node_ids(*src, *dst).ok()\n            } else {\n                None\n            };\n        match edge_id {\n            Some(e) => Ok(e),\n            None => Err(format!(\n                concat!(\n                    \"The current graph instance does not contain the required edge composed of \",\n                    \"source node name {} and destination node name {}.\"\n                ),\n                src_name, dst_name\n            )),\n        }"
    },
    {
        "modifiers": "pub",
        "name": "get_edge_id_with_type_by_node_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src_name",
                "&str"
            ],
            [
                "dst_name",
                "&str"
            ],
            [
                "edge_type_name",
                "Option<&String>"
            ]
        ],
        "return_type": "Result<EdgeT, String>",
        "body": "if let (Some(src), Some(dst)) = (self.nodes.get(src_name), self.nodes.get(dst_name)) {\n            self.get_edge_id_with_type_by_node_ids(\n                *src,\n                *dst,\n                self.get_edge_type_id_by_edge_type_name(edge_type_name.map(|x| x.as_str()))?,\n            )\n        } else {\n            Err(format!(\n                concat!(\n                    \"The current graph instance does not contain the required edge composed of \",\n                    \"source node name {}, destination node name {} and edge name {:?}.\"\n                ),\n                src_name, dst_name, edge_type_name\n            ))\n        }",
        "doc": [
            "Return translated edge types from string to internal edge ID.",
            "",
            "# Arguments",
            "",
            "* `edge_types`: Vec<String> - Vector of edge types to be converted."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_type_ids_by_edge_type_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_types",
                "Vec<Option<String>>"
            ]
        ],
        "return_type": "Result<Vec<Option<EdgeTypeT>>, String>",
        "body": "match &self.edge_types {\n                None => Err(String::from(\"Current graph does not have edge types.\")),\n                Some(ets) => {\n                    edge_types\n                    .iter()\n                    .map(|edge_type_name|\n                        match edge_type_name {\n                            None=> Ok(None),\n                            Some(et) => {\n                                match ets.get(et) {\n                                    Some(edge_type_id) => Ok(Some(*edge_type_id)),\n                                    None => Err(format!(\n                                        \"The edge type {} does not exist in current graph. The available edge types are {}.\",\n                                        et,\n                                        ets.keys().join(\", \")\n                                    ))\n                                }\n                            }\n                        }\n                    )\n                .collect::<Result<Vec<Option<EdgeTypeT>>, String>>()\n            }\n        }",
        "doc": [
            "Return translated node types from string to internal node ID.",
            "",
            "# Arguments",
            "",
            "* `node_types`: Vec<String> - Vector of node types to be converted."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_type_ids_by_node_type_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_types",
                "Vec<Option<String>>"
            ]
        ],
        "return_type": "Result<Vec<Option<NodeTypeT>>, String>",
        "body": "match &self.node_types {\n            None => Err(String::from(\"Current graph does not have node types.\")),\n            Some(nts) => {\n                node_types\n                .iter()\n                .map(|node_type_name|\n                    match node_type_name {\n                        None => Ok(None),\n                        Some(nt) => {\n                            match nts.get(nt) {\n                                Some(node_type_id) => Ok(Some(*node_type_id)),\n                                None => Err(format!(\n                                    \"The node type {} does not exist in current graph. The available node types are {}.\",\n                                    nt,\n                                    nts.keys().join(\", \")\n                                )),\n                            }\n                        }\n                    })\n                .collect::<Result<Vec<Option<NodeTypeT>>, String>>()\n            }\n        }",
        "doc": [
            "Return range of outbound edges IDs for all the edges bewteen the given",
            "source and destination nodes.",
            "This operation is meaningfull only in a multigraph.",
            "",
            "# Arguments",
            "",
            "* src: NodeT - Source node.",
            "* dst: NodeT - Destination node.",
            ""
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_minmax_edge_ids_by_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "Option<(EdgeT, EdgeT)>",
        "body": "self.get_edge_id_by_node_ids(src, dst).ok().map(|min_edge| {\n            (\n                min_edge,\n                self.get_unchecked_edge_id_from_tuple(src, dst + 1),\n            )\n        })",
        "doc": [
            "Return range of outbound edges IDs which have as source the given Node.",
            "",
            "# Arguments",
            "",
            "* src: NodeT - Node for which we need to compute the outbounds range.",
            ""
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_minmax_edge_ids_by_source_node_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "src",
                "NodeT"
            ]
        ],
        "return_type": "(EdgeT, EdgeT)",
        "body": "match &self.outbounds {\n            Some(outbounds) => {\n                let min_edge_id = if src == 0 {\n                    0\n                } else {\n                    outbounds[src as usize - 1]\n                };\n                (min_edge_id, outbounds[src as usize])\n            }\n            None => {\n                let min_edge_id: EdgeT = self.get_unchecked_edge_id_from_tuple(src, 0);\n                (\n                    min_edge_id,\n                    match &self.cached_destinations {\n                        Some(cds) => match cds.get(&src) {\n                            Some(destinations) => destinations.len() as EdgeT + min_edge_id,\n                            None => self.get_unchecked_edge_id_from_tuple(src + 1, 0),\n                        },\n                        None => self.get_unchecked_edge_id_from_tuple(src + 1, 0),\n                    },\n                )\n            }\n        }",
        "doc": [
            "Returns option of range of multigraph minimum and maximum edge ids with same source and destination nodes and different edge type.",
            "",
            "# Arguments",
            "",
            "* `src` - Source node of the edge.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_ids_by_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "Option<impl Iterator<Item = EdgeT>>",
        "body": "self.get_minmax_edge_ids_by_node_ids(src, dst)\n            .map(|(min_edge_id, max_edge_id)| min_edge_id..max_edge_id)",
        "doc": [
            "Return node type name of given node type.",
            "",
            "There is no need for a unchecked version since we will have to map",
            "on the note_types anyway.",
            "",
            "# Arguments",
            "* node_type_id: Vec<NodeTypeT> - Id of the node type."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_type_name_by_node_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type_id",
                "NodeTypeT"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "self.node_types.as_ref().map_or(\n            Err(\"Node types not available for the current graph instance.\".to_string()),\n            |nts| nts.translate(node_type_id),\n        )",
        "doc": [
            "Return node type name of given node type.",
            "",
            "# Arguments",
            "* node_type_ids: Vec<NodeTypeT> - Id of the node type."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_type_names_by_node_type_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type_ids",
                "Vec<NodeTypeT>"
            ]
        ],
        "return_type": "Result<Vec<String>, String>",
        "body": "self.node_types.as_ref().map_or(\n            Err(\"Node types not available for the current graph instance.\".to_string()),\n            |nts| nts.translate_vector(node_type_ids),\n        )",
        "doc": [
            "Returns the number of outbound neighbours of given node.",
            "",
            "This is implemented as proposed by [S. Vigna here](http://vigna.di.unimi.it/ftp/papers/Broadword.pdf).",
            "",
            "# Arguments",
            "",
            "* `node_id` - Integer ID of the node.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_degree_by_node_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "if node_id >= self.get_nodes_number() {\n            return Err(format!(\n                \"The node ID {} is higher than the number of available nodes {}.\",\n                node_id,\n                self.get_nodes_number()\n            ));\n        }\n        let (min_edge_id, max_edge_id) = self.get_minmax_edge_ids_by_source_node_id(node_id);\n        Ok((max_edge_id - min_edge_id) as NodeT)",
        "doc": [
            "Return graph filtered by given weights range.",
            "",
            "# Arguments",
            "",
            "* node_names: Option<Vec<String>> - The node names to keep.",
            "* node_types: Option<Vec<String>> - The node types to keep.",
            "* edge_types: Option<Vec<String>> - The edge types to keep.",
            "* min_weight: Option<WeightT> - Minimum weight to use to filter edges.",
            "* max_weight: Option<WeightT> - Maximum weight to use to filter edges.",
            "* verbose: bool - whether to show the loading bar.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_degree_by_node_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "if node_id >= self.get_nodes_number() {\n            return Err(format!(\n                \"The node ID {} is higher than the number of available nodes {}.\",\n                node_id,\n                self.get_nodes_number()\n            ));\n        }\n        let (min_edge_id, max_edge_id) = self.get_minmax_edge_ids_by_source_node_id(node_id);\n        Ok((max_edge_id - min_edge_id) as NodeT)",
        "doc": [
            "Return graph filtered by given weights range.",
            "",
            "# Arguments",
            "",
            "* node_names: Option<Vec<String>> - The node names to keep.",
            "* node_types: Option<Vec<String>> - The node types to keep.",
            "* edge_types: Option<Vec<String>> - The edge types to keep.",
            "* min_weight: Option<WeightT> - Minimum weight to use to filter edges.",
            "* max_weight: Option<WeightT> - Maximum weight to use to filter edges.",
            "* verbose: bool - whether to show the loading bar.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "filter",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_names",
                "Option<Vec<String>>"
            ],
            [
                "node_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "edge_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "min_weight",
                "Option<WeightT>"
            ],
            [
                "max_weight",
                "Option<WeightT>"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "if let (Some(min_w), Some(max_w)) = (min_weight, max_weight) {\n            if min_w >= max_w {\n                return Err(format!(\n                    \"The given minimum weight ({}) is greater or equal than the given maximum weight ({})!\",\n                    min_w, max_w\n                ));\n            }\n        }\n\n        let pb = get_loading_bar(\n            verbose,\n            format!(\"Building filtered {}\", self.name).as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n\n        let node_ids = self.get_filter_bitmap(node_names, node_types)?;\n        let edge_types_ids = edge_types.map_or(Ok::<_, String>(None), |ets| {\n            Ok(Some(self.get_edge_type_ids_by_edge_type_names(ets)?))\n        });\n        let edge_types_ids = edge_types_ids?;\n\n        Graph::build_graph(\n            self.iter_edge_with_type_and_weight_ids(true)\n                .progress_with(pb)\n                .filter_map(|(_, src, dst, edge_type, weight)| {\n                    if let Some(nis) = &node_ids {\n                        if !nis.contains(src) || !nis.contains(dst) {\n                            return None;\n                        }\n                    }\n                    if let (Some(_min), Some(w)) = (min_weight, weight) {\n                        if _min > w {\n                            return None;\n                        }\n                    }\n                    if let (Some(_max), Some(w)) = (max_weight, weight) {\n                        if w >= _max {\n                            return None;\n                        }\n                    }\n                    if let Some(ets) = &edge_types_ids {\n                        if !ets.contains(&edge_type) {\n                            return None;\n                        }\n                    }\n                    Some(Ok((src, dst, edge_type, weight)))\n                }),\n            self.get_directed_edges_number() as usize,\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.directed,\n            true,\n            self.name.clone(),\n            false,\n            self.has_edge_types(),\n            self.has_weights(),\n            true,\n            true,\n            true,\n        )",
        "doc": [
            "Returns product of degrees of given nodes.",
            "",
            "# Arguments",
            "",
            "* `one` - Integer ID of the first node.",
            "* `two` - Integer ID of the second node.",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The degrees_product between 0 and 1 is {}\", graph.degrees_product(0, 1).unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "filter",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_names",
                "Option<Vec<String>>"
            ],
            [
                "node_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "edge_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "min_weight",
                "Option<WeightT>"
            ],
            [
                "max_weight",
                "Option<WeightT>"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "if let (Some(min_w), Some(max_w)) = (min_weight, max_weight) {\n            if min_w >= max_w {\n                return Err(format!(\n                    \"The given minimum weight ({}) is greater or equal than the given maximum weight ({})!\",\n                    min_w, max_w\n                ));\n            }\n        }\n\n        let pb = get_loading_bar(\n            verbose,\n            format!(\"Building filtered {}\", self.name).as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n\n        let node_ids = self.get_filter_bitmap(node_names, node_types)?;\n        let edge_types_ids = edge_types.map_or(Ok::<_, String>(None), |ets| {\n            Ok(Some(self.get_edge_type_ids_by_edge_type_names(ets)?))\n        });\n        let edge_types_ids = edge_types_ids?;\n\n        Graph::build_graph(\n            self.iter_edge_with_type_and_weight_ids(true)\n                .progress_with(pb)\n                .filter_map(|(_, src, dst, edge_type, weight)| {\n                    if let Some(nis) = &node_ids {\n                        if !nis.contains(src) || !nis.contains(dst) {\n                            return None;\n                        }\n                    }\n                    if let (Some(_min), Some(w)) = (min_weight, weight) {\n                        if _min > w {\n                            return None;\n                        }\n                    }\n                    if let (Some(_max), Some(w)) = (max_weight, weight) {\n                        if w >= _max {\n                            return None;\n                        }\n                    }\n                    if let Some(ets) = &edge_types_ids {\n                        if !ets.contains(&edge_type) {\n                            return None;\n                        }\n                    }\n                    Some(Ok((src, dst, edge_type, weight)))\n                }),\n            self.get_directed_edges_number() as usize,\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.directed,\n            true,\n            self.name.clone(),\n            false,\n            self.has_edge_types(),\n            self.has_weights(),\n            true,\n            true,\n            true,\n        )",
        "doc": [
            "Returns product of degrees of given nodes.",
            "",
            "# Arguments",
            "",
            "* `one` - Integer ID of the first node.",
            "* `two` - Integer ID of the second node.",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The degrees_product between 0 and 1 is {}\", graph.degrees_product(0, 1).unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "degrees_product",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "one",
                "NodeT"
            ],
            [
                "two",
                "NodeT"
            ]
        ],
        "return_type": "Result<usize, String>",
        "body": "if one >= self.get_nodes_number() || two >= self.get_nodes_number() {\n            return Err(format!(\n                concat!(\n                    \"One or more of the given nodes indices ({}, {}) are \",\n                    \"biggen than the number of nodes present in the graph ({}).\"\n                ),\n                one,\n                two,\n                self.get_nodes_number()\n            ));\n        }\n        Ok(self.get_node_degree_by_node_id(one).unwrap() as usize\n            * self.get_node_degree_by_node_id(two).unwrap() as usize)",
        "doc": [
            "Returns the Jaccard index for the two given nodes.",
            "",
            "# Arguments",
            "",
            "* `one` - Integer ID of the first node.",
            "* `two` - Integer ID of the second node.",
            "",
            "# References",
            "[D. Liben-Nowell, J. Kleinberg.",
            "The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The Jaccard Index between node 1 and node 2 is {}\", graph.jaccard_index(1, 2).unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "jaccard_index",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "one",
                "NodeT"
            ],
            [
                "two",
                "NodeT"
            ]
        ],
        "return_type": "Result<f64, String>",
        "body": "if one >= self.get_nodes_number() || two >= self.get_nodes_number() {\n            return Err(format!(\n                concat!(\n                    \"One or more of the given nodes indices ({}, {}) are \",\n                    \"biggen than the number of nodes present in the graph ({}).\"\n                ),\n                one,\n                two,\n                self.get_nodes_number()\n            ));\n        }\n\n        if self.is_node_trap_by_node_id(one).unwrap() || self.is_node_trap_by_node_id(two).unwrap()\n        {\n            return Ok(0.0f64);\n        }\n\n        let one_neighbors: HashSet<NodeT> = self.iter_node_neighbours_ids(one).collect();\n        let two_neighbors: HashSet<NodeT> = self.iter_node_neighbours_ids(two).collect();\n        let intersections: HashSet<NodeT> = one_neighbors\n            .intersection(&two_neighbors)\n            .cloned()\n            .collect();\n\n        Ok(intersections.len() as f64 / (one_neighbors.len() + two_neighbors.len()) as f64)",
        "doc": [
            "Returns the Adamic/Adar Index for the given pair of nodes.",
            "",
            "# Arguments:",
            "",
            "* `one` - Integer ID of the first node.",
            "* `two` - Integer ID of the second node.",
            "",
            "# Implementation details",
            "Since the Adamic/Adar Index is only defined for graph not containing",
            "node traps (nodes without any outbound edge) and must support all kind",
            "of graphs, the sinks node are excluded from",
            "the computation because they would result in an infinity.",
            "",
            "# References",
            "[D. Liben-Nowell, J. Kleinberg.",
            "The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The Adamic/Adar Index between node 1 and node 2 is {}\", graph.adamic_adar_index(1, 2).unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "adamic_adar_index",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "one",
                "NodeT"
            ],
            [
                "two",
                "NodeT"
            ]
        ],
        "return_type": "Result<f64, String>",
        "body": "if self.is_node_trap_by_node_id(one)? || self.is_node_trap_by_node_id(two)? {\n            return Ok(0.0f64);\n        }\n\n        let one_neighbors: HashSet<NodeT> = self.iter_node_neighbours_ids(one).collect();\n        let two_neighbors: HashSet<NodeT> = self.iter_node_neighbours_ids(two).collect();\n        let intersections: HashSet<NodeT> = one_neighbors\n            .intersection(&two_neighbors)\n            .cloned()\n            .collect();\n\n        Ok(intersections\n            .par_iter()\n            .filter(|node| !self.is_node_trap_by_node_id(**node).unwrap())\n            .map(|node| 1.0 / (self.get_node_degree_by_node_id(*node).unwrap() as f64).ln())\n            .sum())",
        "doc": [
            "Returns the Resource Allocation Index for the given pair of nodes.",
            "",
            "# Arguments:",
            "",
            "* `one` - Integer ID of the first node.",
            "* `two` - Integer ID of the second node.",
            "",
            "# References",
            "[T. Zhou, L. Lu, Y.-C. Zhang.",
            "Predicting missing links via local information.",
            "Eur. Phys. J. B 71 (2009) 623.](http://arxiv.org/pdf/0901.0553.pdf)",
            "",
            "# Implementation details",
            "Since the Resource Allocation Index is only defined for graph not",
            "containing node traps (nodes without any outbound edge) and",
            "must support all kind of graphs, the sinks node are excluded from",
            "the computation because they would result in an infinity.",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The Resource Allocation Index between node 1 and node 2 is {}\", graph.resource_allocation_index(1, 2).unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "resource_allocation_index",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "one",
                "NodeT"
            ],
            [
                "two",
                "NodeT"
            ]
        ],
        "return_type": "Result<f64, String>",
        "body": "if self.is_node_trap_by_node_id(one)? || self.is_node_trap_by_node_id(two)? {\n            return Ok(0.0f64);\n        }\n\n        let one_neighbors: HashSet<NodeT> = self.iter_node_neighbours_ids(one).collect();\n        let two_neighbors: HashSet<NodeT> = self.iter_node_neighbours_ids(two).collect();\n        let intersections: HashSet<NodeT> = one_neighbors\n            .intersection(&two_neighbors)\n            .cloned()\n            .collect();\n\n        Ok(intersections\n            .par_iter()\n            .filter(|node| !self.is_node_trap_by_node_id(**node).unwrap())\n            .map(|node| 1.0 / self.get_node_degree_by_node_id(*node).unwrap() as f64)\n            .sum())",
        "doc": [
            "Returns the traps rate of the graph.",
            "",
            "THIS IS EXPERIMENTAL AND MUST BE PROVEN!",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The Graph rate is {}\", graph.traps_rate());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "traps_rate",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "f64",
        "body": "(0..self.get_nodes_number())\n            .into_par_iter()\n            .map(|node| {\n                if !self.is_node_trap_by_node_id(node).unwrap() {\n                    self.iter_node_neighbours_ids(node)\n                        .map(|dst| self.is_node_trap_by_node_id(dst).unwrap() as usize as f64)\n                        .sum::<f64>()\n                        / self.get_node_degree_by_node_id(node).unwrap() as f64\n                } else {\n                    1.0\n                }\n            })\n            .sum::<f64>()\n            / self.get_nodes_number() as f64",
        "doc": [
            "Returns mean node degree of the graph.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The mean node degree of the graph is  {}\", graph.get_node_degrees_mean().unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_degrees_mean",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<f64, String>",
        "body": "if !self.has_nodes() {\n            return Err(\n                \"The mean of the node degrees is not defined on an empty graph\".to_string()\n            );\n        }\n        Ok(\n            self.get_directed_edges_number() as f64 / self.get_nodes_number() as f64\n        )",
        "doc": [
            "Returns number of undirected edges of the graph.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of undirected edges of the graph is  {}\", graph.get_undirected_edges_number());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_undirected_edges_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "(self.get_directed_edges_number() - self.get_self_loop_number()) / 2\n            + self.get_self_loop_number()",
        "doc": [
            "Returns number of undirected edges of the graph.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of unique undirected edges of the graph is  {}\", graph.get_unique_undirected_edges_number());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_unique_undirected_edges_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "(self.unique_edges_number - self.get_unique_self_loop_number() as EdgeT) / 2\n            + self.get_unique_self_loop_number() as EdgeT",
        "doc": [
            "Returns number of edges of the graph.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of edges of the graph is  {}\", graph.get_edges_number());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edges_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "match self.directed {\n            true => self.get_directed_edges_number(),\n            false => self.get_undirected_edges_number(),\n        }",
        "doc": [
            "Returns number of unique edges of the graph.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of edges of the graph is  {}\", graph.get_unique_edges_number());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_unique_edges_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "match self.directed {\n            true => self.get_unique_directed_edges_number(),\n            false => self.get_unique_undirected_edges_number(),\n        }",
        "doc": [
            "Returns median node degree of the graph",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The median node degree of the graph is  {}\", graph.get_node_degrees_median().unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_degrees_median",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "if !self.has_nodes() {\n            return Err(\n                \"The median of the node degrees is not defined on an empty graph\".to_string()\n            );\n        }\n        let mut degrees = self.get_node_degrees();\n        degrees.par_sort_unstable();\n        Ok(degrees[(self.get_nodes_number() / 2) as usize])",
        "doc": [
            "Returns maximum node degree of the graph",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The maximum node degree of the graph is  {}\", graph.get_max_node_degree().unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_max_node_degree",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "self.get_node_degrees().into_iter().max()\n            .ok_or(\"The maximum node degree of a graph with no nodes is not defined.\".to_string())",
        "doc": [
            "Returns minimum node degree of the graph",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The minimum node degree of the graph is  {}\", graph.get_min_node_degree().unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_min_node_degree",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "self.get_node_degrees().into_iter().min()\n        .ok_or(\"The minimum node degree of a graph with no nodes is not defined.\".to_string())",
        "doc": [
            "Returns mode node degree of the graph",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The mode node degree of the graph is  {}\", graph.get_node_degrees_mode().unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_degrees_mode",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "if !self.has_nodes() {\n            return Err(\n                \"The mode of the node degrees is not defined on an empty graph\".to_string()\n            );\n        }\n\n        let mut occurrences: HashMap<NodeT, usize> = HashMap::new();\n\n        for value in self.get_node_degrees() {\n            *occurrences.entry(value).or_insert(0) += 1;\n        }\n        Ok(\n            occurrences\n                .into_iter()\n                .max_by_key(|&(_, count)| count)\n                .map(|(val, _)| val)\n                .unwrap()\n        )",
        "doc": [
            "Returns number of self-loops, including also those in eventual multi-edges.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of self-loops in the graph is  {}\", graph.get_self_loop_number());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_self_loop_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.self_loop_number",
        "doc": [
            "Returns number of unique self-loops, excluding those in eventual multi-edges.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of unique self-loops in the graph is  {}\", graph.get_unique_self_loop_number());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_unique_self_loop_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.unique_self_loop_number",
        "doc": [
            "Returns rate of self-loops.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The rate of self-loops in the graph is  {}\", graph.get_self_loop_rate());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_self_loop_rate",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "f64",
        "body": "self.get_self_loop_number() as f64 / self.get_directed_edges_number() as f64",
        "doc": [
            "Returns number a triple with (number of components, number of nodes of the smallest component, number of nodes of the biggest component )"
        ]
    },
    {
        "modifiers": "pub",
        "name": "connected_components_number",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "(NodeT, NodeT, NodeT)",
        "body": "info!(\"Computing connected components number.\");\n        if self.directed {\n            let (_, _, components_number, min_component_size, max_component_size) =\n                self.spanning_arborescence_kruskal(verbose);\n            (components_number, min_component_size, max_component_size)\n        } else {\n            info!(\"Executing undirected parallel version of connected components.\");\n            let (_, components_number, min_component_size, max_component_size) =\n                self.connected_components(verbose).unwrap();\n            (components_number, min_component_size, max_component_size)\n        }",
        "doc": [
            "Returns number of singleton nodes within the graph.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The graph contains {} singleton nodes\", graph.get_singleton_nodes_number());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_singleton_nodes_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "NodeT",
        "body": "if let Some(d) = self\n            .get_nodes_number()\n            .checked_sub(self.get_not_singleton_nodes_number())\n        {\n            return d;\n        }\n        panic!(\"{:#4?}\", self);",
        "doc": [
            "Returns number of singleton nodes with self-loops within the graph.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The graph contains {} singleton nodes with self-loops\", graph.get_singleton_nodes_with_self_loops_number());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_singleton_nodes_with_self_loops_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.singleton_nodes_with_self_loops_number",
        "doc": [
            "Returns number of not singleton nodes within the graph.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The graph contains {} not singleton nodes\", graph.get_not_singleton_nodes_number());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_not_singleton_nodes_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.not_singleton_nodes_number",
        "doc": [
            "Returns density of the graph.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The graph density is {}\", graph.get_density().unwrap());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_density",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<f64, String>",
        "body": "if !self.has_nodes() {\n            return Err(\"The density of an empty graph is undefined.\".to_string());\n        }\n        if !self.has_edges() {\n            return Ok(0.0);\n        }\n        let nodes_number = self.get_nodes_number() as EdgeT;\n        let total_nodes_number = nodes_number\n            * match self.has_selfloops() {\n                true => nodes_number,\n                false => nodes_number - 1,\n            };\n        Ok(\n            self.unique_edges_number as f64 / total_nodes_number as f64\n        )",
        "doc": [
            "Returns report relative to the graph metrics",
            "",
            "The report includes a few useful metrics like:",
            "",
            "* degrees_median: the median degree of the nodes.",
            "* degrees_mean: the mean degree of the nodes.",
            "* degrees_mode: the mode degree of the nodes.",
            "* min_degree: the max degree of the nodes.",
            "* max_degree: the min degree of the nodes.",
            "* nodes_number: the number of nodes in the graph.",
            "* edges_number: the number of edges in the graph.",
            "* unique_node_types_number: the number of different node types in the graph.",
            "* unique_edge_types_number: the number of different edge types in the graph.",
            "* traps_rate: probability to end up in a trap when starting into any given node.",
            "* selfloops_rate: pecentage of edges that are selfloops.",
            "* bidirectional_rate: rate of edges that are bidirectional.",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "graph.report();",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "report",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "DefaultHashMap<&str, String>",
        "body": "let mut report: DefaultHashMap<&str, String> = DefaultHashMap::new();\n\n        if self.has_nodes() {\n            report.insert(\"density\",  self.get_density().unwrap().to_string());\n            report.insert(\"min_degree\", self.get_min_node_degree().unwrap().to_string());\n            report.insert(\"max_degree\", self.get_max_node_degree().unwrap().to_string());\n            report.insert(\"degree_mean\", self.get_node_degrees_mean().unwrap().to_string());\n        }\n\n        report.insert(\"name\", self.name.clone());\n        report.insert(\"nodes_number\", self.get_nodes_number().to_string());\n        report.insert(\"edges_number\", self.get_directed_edges_number().to_string());\n        report.insert(\n            \"undirected_edges_number\",\n            self.get_undirected_edges_number().to_string(),\n        );\n        report.insert(\"directed\", self.is_directed().to_string());\n        report.insert(\"has_weights\", self.has_weights().to_string());\n        report.insert(\"has_edge_types\", self.has_edge_types().to_string());\n        report.insert(\"has_node_types\", self.has_node_types().to_string());\n        report.insert(\"self_loops_number\", self.get_self_loop_number().to_string());\n        report.insert(\"self_loops_rate\", self.get_self_loop_rate().to_string());\n        report.insert(\"singletons\", self.get_singleton_nodes_number().to_string());\n        report.insert(\n            \"unique_node_types_number\",\n            self.get_node_types_number().to_string(),\n        );\n        report.insert(\n            \"unique_edge_types_number\",\n            self.get_edge_types_number().to_string(),\n        );\n        report"
    },
    {
        "modifiers": "",
        "name": "shared_components_number",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "nodes_components",
                "&[NodeT]"
            ],
            [
                "other",
                "&Graph"
            ]
        ],
        "return_type": "NodeT",
        "body": "other\n            .iter_nodes()\n            .filter_map(\n                |(_, node_name, _, _)| match self.get_node_id_by_node_name(&node_name) {\n                    Ok(node_id) => Some(nodes_components[node_id as usize]),\n                    Err(_) => None,\n                },\n            )\n            .unique()\n            .count() as NodeT",
        "doc": [
            "Return number of distinct components that are merged by the other graph in current graph.bitvec",
            "",
            "# Arguments",
            "* `nodes_components`: &[NodeT] - Slice with the node components.",
            "* `other`: &Graph - Graph from where to extract the edge list."
        ]
    },
    {
        "modifiers": "",
        "name": "merged_components_number",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "nodes_components",
                "&[NodeT]"
            ],
            [
                "other",
                "&Graph"
            ]
        ],
        "return_type": "NodeT",
        "body": "other\n            .iter_edges(false)\n            .filter_map(|(_, _, src_name, _, dst_name)| {\n                match (\n                    self.get_node_id_by_node_name(&src_name),\n                    self.get_node_id_by_node_name(&dst_name),\n                ) {\n                    (Ok(src_id), Ok(dst_id)) => {\n                        let src_component_number = nodes_components[src_id as usize];\n                        let dst_component_number = nodes_components[dst_id as usize];\n                        match src_component_number == dst_component_number {\n                            true => None,\n                            false => Some(vec![src_component_number, dst_component_number]),\n                        }\n                    }\n                    _ => None,\n                }\n            })\n            .flatten()\n            .unique()\n            .count() as NodeT",
        "doc": [
            "Return rendered textual report about the graph overlaps.",
            "",
            "# Arguments",
            "",
            "- `other`: &Graph - graph to create overlap report with.",
            "- `verbose`: bool - whether to shor the loading bars."
        ]
    },
    {
        "modifiers": "pub",
        "name": "overlap_textual_report",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "other",
                "&Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "// Checking if overlap is allowed\n        self.validate_operator_terms(other)?;\n        // Get overlapping nodes\n        let overlapping_nodes_number = self\n            .iter_nodes()\n            .filter(|(_, node_name, _, node_type)| {\n                other.has_node_with_type_by_node_name(node_name, node_type.clone())\n            })\n            .count();\n        // Get overlapping edges\n        let overlapping_edges_number = self\n            .par_iter_edge_with_type(self.directed)\n            .filter(|(_, _, src_name, _, dst_name, _, edge_type_name)| {\n                other.has_edge_with_type_by_node_names(src_name, dst_name, edge_type_name.as_ref())\n            })\n            .count();\n        // Get number of overlapping components\n        let first_nodes_components = self.get_node_components_vector(verbose);\n        let second_nodes_components = other.get_node_components_vector(verbose);\n        let first_components_number = first_nodes_components.iter().unique().count() as NodeT;\n        let second_components_number = second_nodes_components.iter().unique().count() as NodeT;\n        let first_shared_components_number =\n            self.shared_components_number(&first_nodes_components, other);\n        let second_shared_components_number =\n            other.shared_components_number(&second_nodes_components, self);\n        // Get number of overlapping components\n        let first_merged_components_number =\n            self.merged_components_number(&first_nodes_components, other);\n        let second_merged_components_number =\n            other.merged_components_number(&second_nodes_components, self);\n\n        let first_edges = match self.directed {\n            true => self.get_directed_edges_number(),\n            false => self.get_undirected_edges_number(),\n        };\n        let second_edges = match other.directed {\n            true => other.get_directed_edges_number(),\n            false => other.get_undirected_edges_number(),\n        };\n        // Building up the report\n        Ok(format!(\n            concat!(\n                \"The graph {first_graph} and the graph {second_graph} share {nodes_number} nodes and {edges_number} edges. \",\n                \"By percent, {first_graph} shares {first_node_percentage:.2}% ({nodes_number} out of {first_nodes}) of its nodes and {first_edge_percentage:.2}% ({edges_number} out of {first_edges}) of its edges with {second_graph}. \",\n                \"{second_graph} shares {second_node_percentage:.2}% ({nodes_number} out of {second_nodes}) of its nodes and {second_edge_percentage:.2}% ({edges_number} out of {second_edges}) of its edges with {first_graph}. \",\n                \"Nodes from {first_graph} appear in {first_components_statement} components of {second_graph}{first_merged_components_statement}. \",\n                \"Similarly, nodes from {second_graph} appear in {second_components_statement} components of {first_graph}{second_merged_components_statement}. \",\n            ),\n            first_graph=self.get_name(),\n            second_graph=other.get_name(),\n            nodes_number=overlapping_nodes_number,\n            edges_number=overlapping_edges_number,\n            first_nodes=self.get_nodes_number(),\n            second_nodes=other.get_nodes_number(),\n            first_edges=first_edges,\n            second_edges=second_edges,\n            first_components_statement = match second_shared_components_number== second_components_number{\n                true=> \"all the\".to_owned(),\n                false => format!(\n                    \"{second_shared_components_number} of the {second_components_number}\",\n                    second_shared_components_number=second_shared_components_number,\n                    second_components_number=second_components_number\n                )\n            },\n            second_components_statement = match first_shared_components_number== first_components_number{\n                true=> \"all the\".to_owned(),\n                false => format!(\n                    \"{first_shared_components_number} of the {first_components_number}\",\n                    first_shared_components_number=first_shared_components_number,\n                    first_components_number=first_components_number\n                )\n            },\n            first_merged_components_statement = match second_components_number > 1 {\n                false=>\"\".to_owned(),\n                true=>format!(\n                    \": of these, {edges_number} connected by edges of {first_graph}\",\n                    first_graph=self.name,\n                    edges_number= match second_merged_components_number {\n                        d if d==0=>\"none are\".to_owned(),\n                        d if d==1=>\"one is\".to_owned(),\n                        d if d==second_components_number=>\"all components are\".to_owned(),\n                        _ => format!(\"{} components are\", second_merged_components_number)\n                    })\n                },\n            second_merged_components_statement = match first_components_number > 1 {\n                false=>\"\".to_owned(),\n                true=>format!(\n                    \": of these, {edges_number} connected by edges of {second_graph}\",\n                    second_graph=other.name,\n                    edges_number= match first_merged_components_number {\n                        d if d==0=>\"none are\".to_owned(),\n                        d if d==1=>\"one is\".to_owned(),\n                        d if d==first_components_number=>\"all components are\".to_owned(),\n                        _ => format!(\"{} components are\", first_merged_components_number)\n                    })\n                },\n            first_node_percentage=100.0*(overlapping_nodes_number as f64 / self.get_nodes_number() as f64),\n            second_node_percentage=100.0*(overlapping_nodes_number as f64 / other.get_nodes_number() as f64),\n            first_edge_percentage=100.0*(overlapping_edges_number as f64 / first_edges as f64),\n            second_edge_percentage=100.0*(overlapping_edges_number as f64 / second_edges as f64),\n        ))"
    },
    {
        "modifiers": "",
        "name": "format_list",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "list",
                "&[String]"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "if list.is_empty() {\n            return Err(\"Cannot format a list with no elements.\".to_owned());\n        }\n        if list.len() == 1 {\n            return Ok(list.first().unwrap().clone());\n        }\n        let all_minus_last: String = list[0..list.len() - 1].join(\", \");\n        Ok(format!(\n            \"{all_minus_last} and {last}\",\n            all_minus_last = all_minus_last,\n            last = list.last().unwrap()\n        ))",
        "doc": [
            "Return formatted node list.",
            "",
            "# Arguments",
            "* `node_list`: &[NodeT] - list of nodes to be formatted."
        ]
    },
    {
        "modifiers": "",
        "name": "format_node_list",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node_list",
                "&[NodeT]"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "self.format_list(\n            node_list\n                .iter()\n                .map(|node_id| {\n                    format!(\n                        \"{node_name} (degree {node_degree})\",\n                        node_name = self.get_node_name_by_node_id(*node_id).unwrap(),\n                        node_degree = self.get_node_degree_by_node_id(*node_id).unwrap()\n                    )\n                })\n                .collect::<Vec<String>>()\n                .as_slice(),\n        )",
        "doc": [
            "Return formatted node type list.",
            "",
            "# Arguments",
            "* `node_types_list`: &[NodeT] - list of nodes to be formatted."
        ]
    },
    {
        "modifiers": "",
        "name": "format_node_type_list",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_types_list",
                "&[(NodeTypeT, usize)]"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "self.format_list(\n            node_types_list\n                .iter()\n                .map(|(node_type_id, number)| {\n                    format!(\n                        \"{node_type} (nodes number {node_degree})\",\n                        node_type = self\n                            .get_node_type_name_by_node_type_id(*node_type_id)\n                            .unwrap(),\n                        node_degree = number\n                    )\n                })\n                .collect::<Vec<String>>()\n                .as_slice(),\n        )",
        "doc": [
            "Return formatted edge type list.",
            "",
            "# Arguments",
            "* `edge_types_list`: &[edgeT] - list of edges to be formatted."
        ]
    },
    {
        "modifiers": "",
        "name": "format_edge_type_list",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_types_list",
                "&[(EdgeTypeT, usize)]"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "self.format_list(\n            edge_types_list\n                .iter()\n                .map(|(edge_type_id, _)| {\n                    self.get_edge_type_name_by_edge_type_id(*edge_type_id)\n                        .unwrap()\n                        .clone()\n                })\n                .collect::<Vec<String>>()\n                .as_slice(),\n        )",
        "doc": [
            "Return rendered textual report of the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "textual_report",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "{\n            let ptr = self.cached_report.read();\n            if let Some(report) = &*ptr{\n                return Ok(report.clone());\n            }\n        }\n\n        if !self.has_nodes(){\n            return Ok(format!(\n                \"The graph {} is empty.\",\n                self.get_name()\n            ));\n        }\n\n        let mut ptr = self.cached_report.write();\n        // THis is not a duplicate of above because we need to \n        // check if another thread already filled the cache\n        if let Some(report) = &*ptr{\n            return Ok(report.clone());\n        }\n\n        let (connected_components_number, minimum_connected_component, maximum_connected_component) =\n            self.connected_components_number(verbose);\n\n        let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        let hash = hasher.finish();\n\n        *ptr = Some(format!(\n            concat!(\n                \"The {direction} {graph_type} {name} has {nodes_number} nodes{node_types}{singletons} and {edges_number} {weighted} edges{edge_types}, of which {self_loops}{self_loops_multigraph_connector}{multigraph_edges}. \",\n                \"The graph is {quantized_density} as it has a density of {density:.5} and {connected_components}. \",\n                \"The graph median node degree is {median_node_degree}, the mean node degree is {mean_node_degree:.2}, and the node degree mode is {mode_node_degree}. \",\n                \"The top {most_common_nodes_number} most central nodes are {central_nodes}. \",\n                \"The hash of the graph is {hash:08x}.\"\n            ),\n            hash = hash,\n            direction = match self.directed {\n                true=> \"directed\",\n                false => \"undirected\"\n            }.to_owned(),\n            graph_type = match self.is_multigraph() {\n                true=> \"multigraph\",\n                false => \"graph\"\n            }.to_owned(),\n            name = self.name,\n            nodes_number = self.get_nodes_number(),\n            edges_number = self.get_edges_number(),\n            weighted = match self.has_weights(){\n                true=> \"weighted\",\n                false=> \"unweighted\"\n            }.to_owned(),\n            self_loops = match self.has_selfloops() {\n                true => format!(\"{} are self-loops\", self.get_self_loop_number()),\n                false => \"none are self-loops\".to_owned()\n            },\n            self_loops_multigraph_connector = match self.is_multigraph() {\n                true => \" and \".to_owned(),\n                false => \"\".to_owned()\n            },\n            multigraph_edges = match self.is_multigraph() {\n                true=>match self.get_multigraph_edges_number()>0 {\n                    true => format!(\"{} are parallel\", self.get_multigraph_edges_number()),\n                    false => \"none are parallel\".to_owned()\n                },\n                false=>\"\".to_owned()\n            },\n            node_types= match self.get_node_types_number() {\n                ntn if ntn==1 => format!(\n                    \" with a single node type: {node_type}\",\n                    node_type={\n                        let node_types = self.get_node_type_counts()?;\n                        self.format_node_type_list(node_types.most_common().as_slice())?\n                    }\n                ),\n                ntn if ntn > 1 => format!(\n                    \" with {node_types_number} different {multilabel}node types: {most_common_node_types}{unknown_node_types}.\",\n                    node_types_number=ntn,\n                    multilabel=match self.has_multilabel_node_types(){\n                        true=>\"multi-label \",\n                        false=>\"\"\n                    },\n                    most_common_node_types={\n                        let node_types = self.get_node_type_counts()?;\n                        let most_common = node_types.most_common();\n                        match most_common.len()>5 {\n                            true=>format!(\" the 5 most common are {}\", self.format_node_type_list(most_common[0..5].as_ref())?),\n                            false=>self.format_node_type_list(most_common.as_slice())?\n                        }\n                    },\n                    unknown_node_types={\n                        match self.has_unknown_node_types(){\n                            true=>{\n                                let unknown_nodes_number=self.get_unknown_node_types_number();\n                                let percentage = 100.0*(unknown_nodes_number as f64 / self.get_nodes_number() as f64);\n                                format!(\" and there are {} unknown node types ({:.2}%)\", unknown_nodes_number, percentage)\n                            },\n                            false=>\"\".to_owned()\n                        }\n                    }\n                ),\n                _ => \"\".to_owned()\n            },\n            singletons = match self.has_singletons() {\n                true => format!(\n                    \" There are {singleton_number} singleton nodes{self_loop_singleton},\", \n                    singleton_number=self.get_singleton_nodes_number(),\n                    self_loop_singleton=match self.has_singleton_nodes_with_self_loops(){\n                        true=>format!(\" ({} have self-loops)\", match self.get_singleton_nodes_number()==self.get_singleton_nodes_with_self_loops_number(){\n                            true=>\"all\".to_owned(),\n                            false=>format!(\"{} of these\", self.get_singleton_nodes_with_self_loops_number())\n                        }),\n                        false=>\"\".to_owned()\n                    }\n                ),\n                false => \"\".to_owned()\n            },\n            edge_types= match self.get_edge_types_number() {\n                etn if etn==1 => format!(\n                    \" with a single edge type: {edge_type}\",\n                    edge_type={\n                        let edge_types = self.get_edge_type_counts()?;\n                        self.format_edge_type_list(edge_types.most_common().as_slice())?\n                    }\n                ),\n                etn if etn > 1 => format!(\n                    \" with {edge_types_number} different edge types: {most_common_edge_types}{unknown_edge_types}\",\n                    edge_types_number=etn,\n                    most_common_edge_types={\n                        let edge_types = self.get_edge_type_counts()?;\n                        let most_common = edge_types.most_common();\n                        match most_common.len()>5 {\n                            true=>format!(\" the 5 most common are {}\", self.format_edge_type_list(most_common[0..5].as_ref())?),\n                            false=>self.format_edge_type_list(most_common.as_slice())?\n                        }\n                    },\n                    unknown_edge_types={\n                        match self.has_unknown_edge_types(){\n                            true=>{\n                                let unknown_edges_number=self.get_unknown_edge_types_number();\n                                let percentage = 100.0*(unknown_edges_number as f64 / self.get_directed_edges_number() as f64);\n                                format!(\". There are {} unknown edge types ({:.2}%).\", unknown_edges_number, percentage)\n                            },\n                            false=>\"\".to_owned()\n                        }\n                    }\n                ),\n                _ => \"\".to_owned()\n            },\n            quantized_density = match self.get_density().unwrap() {\n                d if d < 0.0001 => \"extremely sparse\".to_owned(),\n                d if d < 0.001 => \"quite sparse\".to_owned(),\n                d if d < 0.01 => \"sparse\".to_owned(),\n                d if d < 0.1 => \"dense\".to_owned(),\n                d if d < 0.5 => \"quite dense\".to_owned(),\n                d if (d - 1.0).abs() < f64::EPSILON => \"complete\".to_owned(),\n                d if d <= 1.0 => \"extremely dense\".to_owned(),\n                d => unreachable!(format!(\"Unreacheable density case {}\", d))\n            },\n            density=self.get_density().unwrap(),\n            connected_components=match connected_components_number> 1{\n                true=>format!(\n                    \"has {components_number} connected components, where the component with most nodes has {maximum_connected_component} and the component with the least nodes has {minimum_connected_component}\",\n                    components_number=connected_components_number,\n                    maximum_connected_component=match maximum_connected_component==1{\n                        true=>\"a single node\".to_owned(),\n                        false=>format!(\"{} nodes\", maximum_connected_component)\n                    },\n                    minimum_connected_component=match minimum_connected_component==1{\n                        true=>\"a single node\".to_owned(),\n                        false=>format!(\"{} nodes\", minimum_connected_component)\n                    }\n                ),\n                false=>\"is connected, as it has a single component\".to_owned()\n            },\n            median_node_degree=self.get_node_degrees_median().unwrap(),\n            mean_node_degree=self.get_node_degrees_mean().unwrap(),\n            mode_node_degree=self.get_node_degrees_mode().unwrap(),\n            most_common_nodes_number=std::cmp::min(5, self.get_nodes_number()),\n            central_nodes = self.format_node_list(self.get_top_k_central_nodes_ids(std::cmp::min(5, self.get_nodes_number())).as_slice())?\n        ));\n\n        Ok(ptr.clone().unwrap())",
        "doc": [
            "Returns a **NEW** Graph that does not have the required attributes.",
            "",
            "## Implementation details",
            "",
            "### How the collapse of multigraphs is handled",
            "We keep only the first edge when a multigraph is collapsed while removing",
            "the edge types, in the order provided when first reading from the CSV file.",
            "",
            "### Generation of new singleton nodes when removeping edges",
            "Some of the remove operations allowed in this method might lead to the",
            "generation of new singleton nodes that will not be handled within this",
            "function call even if you provide the flag singletons to true, but you",
            "will need to call the method again if you want to get reed of also those",
            "newly created singleton nodes.",
            "",
            "# Arguments",
            "* `allow_nodes_set`: Option<HashSet<String>> - Optional set of nodes names to keep.",
            "* `deny_nodes_set`: Option<HashSet<String>> - Optional set of nodes names to remove.",
            "* `allow_node_types_set`: Option<HashSet<String>> - Optional set of node type names to keep.",
            "* `deny_node_types_set`: Option<HashSet<String>> - Optional set of node type names to remove.",
            "* `allow_edge_set`: Option<HashSet<EdgeT>>- Optional set of numeric edge IDs to keep.",
            "* `deny_edge_set`: Option<HashSet<EdgeT>>- Optional set of numeric edge IDs to remove.",
            "* `allow_edge_types_set`: Option<HashSet<String>> - Optional set of edge type names to keep.",
            "* `deny_edge_types_set`: Option<HashSet<String>> - Optional set of edge type names to remove.",
            "* `weights`: bool - whether to remove the weights.",
            "* `node_types`: bool - whether to remove the node types.",
            "* `edge_types`: bool - whether to remove the edge types.",
            "* `singletons`: bool - whether to remove the singleton nodes.",
            "* `selfloops`: bool - whether to remove edges with self-loops.",
            "* `verbose`: bool - whether to show a loading bar while building the graph.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "textual_report",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "{\n            let ptr = self.cached_report.read();\n            if let Some(report) = &*ptr{\n                return Ok(report.clone());\n            }\n        }\n\n        if !self.has_nodes(){\n            return Ok(format!(\n                \"The graph {} is empty.\",\n                self.get_name()\n            ));\n        }\n\n        let mut ptr = self.cached_report.write();\n        // THis is not a duplicate of above because we need to \n        // check if another thread already filled the cache\n        if let Some(report) = &*ptr{\n            return Ok(report.clone());\n        }\n\n        let (connected_components_number, minimum_connected_component, maximum_connected_component) =\n            self.connected_components_number(verbose);\n\n        let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        let hash = hasher.finish();\n\n        *ptr = Some(format!(\n            concat!(\n                \"The {direction} {graph_type} {name} has {nodes_number} nodes{node_types}{singletons} and {edges_number} {weighted} edges{edge_types}, of which {self_loops}{self_loops_multigraph_connector}{multigraph_edges}. \",\n                \"The graph is {quantized_density} as it has a density of {density:.5} and {connected_components}. \",\n                \"The graph median node degree is {median_node_degree}, the mean node degree is {mean_node_degree:.2}, and the node degree mode is {mode_node_degree}. \",\n                \"The top {most_common_nodes_number} most central nodes are {central_nodes}. \",\n                \"The hash of the graph is {hash:08x}.\"\n            ),\n            hash = hash,\n            direction = match self.directed {\n                true=> \"directed\",\n                false => \"undirected\"\n            }.to_owned(),\n            graph_type = match self.is_multigraph() {\n                true=> \"multigraph\",\n                false => \"graph\"\n            }.to_owned(),\n            name = self.name,\n            nodes_number = self.get_nodes_number(),\n            edges_number = self.get_edges_number(),\n            weighted = match self.has_weights(){\n                true=> \"weighted\",\n                false=> \"unweighted\"\n            }.to_owned(),\n            self_loops = match self.has_selfloops() {\n                true => format!(\"{} are self-loops\", self.get_self_loop_number()),\n                false => \"none are self-loops\".to_owned()\n            },\n            self_loops_multigraph_connector = match self.is_multigraph() {\n                true => \" and \".to_owned(),\n                false => \"\".to_owned()\n            },\n            multigraph_edges = match self.is_multigraph() {\n                true=>match self.get_multigraph_edges_number()>0 {\n                    true => format!(\"{} are parallel\", self.get_multigraph_edges_number()),\n                    false => \"none are parallel\".to_owned()\n                },\n                false=>\"\".to_owned()\n            },\n            node_types= match self.get_node_types_number() {\n                ntn if ntn==1 => format!(\n                    \" with a single node type: {node_type}\",\n                    node_type={\n                        let node_types = self.get_node_type_counts()?;\n                        self.format_node_type_list(node_types.most_common().as_slice())?\n                    }\n                ),\n                ntn if ntn > 1 => format!(\n                    \" with {node_types_number} different {multilabel}node types: {most_common_node_types}{unknown_node_types}.\",\n                    node_types_number=ntn,\n                    multilabel=match self.has_multilabel_node_types(){\n                        true=>\"multi-label \",\n                        false=>\"\"\n                    },\n                    most_common_node_types={\n                        let node_types = self.get_node_type_counts()?;\n                        let most_common = node_types.most_common();\n                        match most_common.len()>5 {\n                            true=>format!(\" the 5 most common are {}\", self.format_node_type_list(most_common[0..5].as_ref())?),\n                            false=>self.format_node_type_list(most_common.as_slice())?\n                        }\n                    },\n                    unknown_node_types={\n                        match self.has_unknown_node_types(){\n                            true=>{\n                                let unknown_nodes_number=self.get_unknown_node_types_number();\n                                let percentage = 100.0*(unknown_nodes_number as f64 / self.get_nodes_number() as f64);\n                                format!(\" and there are {} unknown node types ({:.2}%)\", unknown_nodes_number, percentage)\n                            },\n                            false=>\"\".to_owned()\n                        }\n                    }\n                ),\n                _ => \"\".to_owned()\n            },\n            singletons = match self.has_singletons() {\n                true => format!(\n                    \" There are {singleton_number} singleton nodes{self_loop_singleton},\", \n                    singleton_number=self.get_singleton_nodes_number(),\n                    self_loop_singleton=match self.has_singleton_nodes_with_self_loops(){\n                        true=>format!(\" ({} have self-loops)\", match self.get_singleton_nodes_number()==self.get_singleton_nodes_with_self_loops_number(){\n                            true=>\"all\".to_owned(),\n                            false=>format!(\"{} of these\", self.get_singleton_nodes_with_self_loops_number())\n                        }),\n                        false=>\"\".to_owned()\n                    }\n                ),\n                false => \"\".to_owned()\n            },\n            edge_types= match self.get_edge_types_number() {\n                etn if etn==1 => format!(\n                    \" with a single edge type: {edge_type}\",\n                    edge_type={\n                        let edge_types = self.get_edge_type_counts()?;\n                        self.format_edge_type_list(edge_types.most_common().as_slice())?\n                    }\n                ),\n                etn if etn > 1 => format!(\n                    \" with {edge_types_number} different edge types: {most_common_edge_types}{unknown_edge_types}\",\n                    edge_types_number=etn,\n                    most_common_edge_types={\n                        let edge_types = self.get_edge_type_counts()?;\n                        let most_common = edge_types.most_common();\n                        match most_common.len()>5 {\n                            true=>format!(\" the 5 most common are {}\", self.format_edge_type_list(most_common[0..5].as_ref())?),\n                            false=>self.format_edge_type_list(most_common.as_slice())?\n                        }\n                    },\n                    unknown_edge_types={\n                        match self.has_unknown_edge_types(){\n                            true=>{\n                                let unknown_edges_number=self.get_unknown_edge_types_number();\n                                let percentage = 100.0*(unknown_edges_number as f64 / self.get_directed_edges_number() as f64);\n                                format!(\". There are {} unknown edge types ({:.2}%).\", unknown_edges_number, percentage)\n                            },\n                            false=>\"\".to_owned()\n                        }\n                    }\n                ),\n                _ => \"\".to_owned()\n            },\n            quantized_density = match self.get_density().unwrap() {\n                d if d < 0.0001 => \"extremely sparse\".to_owned(),\n                d if d < 0.001 => \"quite sparse\".to_owned(),\n                d if d < 0.01 => \"sparse\".to_owned(),\n                d if d < 0.1 => \"dense\".to_owned(),\n                d if d < 0.5 => \"quite dense\".to_owned(),\n                d if (d - 1.0).abs() < f64::EPSILON => \"complete\".to_owned(),\n                d if d <= 1.0 => \"extremely dense\".to_owned(),\n                d => unreachable!(format!(\"Unreacheable density case {}\", d))\n            },\n            density=self.get_density().unwrap(),\n            connected_components=match connected_components_number> 1{\n                true=>format!(\n                    \"has {components_number} connected components, where the component with most nodes has {maximum_connected_component} and the component with the least nodes has {minimum_connected_component}\",\n                    components_number=connected_components_number,\n                    maximum_connected_component=match maximum_connected_component==1{\n                        true=>\"a single node\".to_owned(),\n                        false=>format!(\"{} nodes\", maximum_connected_component)\n                    },\n                    minimum_connected_component=match minimum_connected_component==1{\n                        true=>\"a single node\".to_owned(),\n                        false=>format!(\"{} nodes\", minimum_connected_component)\n                    }\n                ),\n                false=>\"is connected, as it has a single component\".to_owned()\n            },\n            median_node_degree=self.get_node_degrees_median().unwrap(),\n            mean_node_degree=self.get_node_degrees_mean().unwrap(),\n            mode_node_degree=self.get_node_degrees_mode().unwrap(),\n            most_common_nodes_number=std::cmp::min(5, self.get_nodes_number()),\n            central_nodes = self.format_node_list(self.get_top_k_central_nodes_ids(std::cmp::min(5, self.get_nodes_number())).as_slice())?\n        ));\n\n        Ok(ptr.clone().unwrap())",
        "doc": [
            "Returns a **NEW** Graph that does not have the required attributes.",
            "",
            "## Implementation details",
            "",
            "### How the collapse of multigraphs is handled",
            "We keep only the first edge when a multigraph is collapsed while removing",
            "the edge types, in the order provided when first reading from the CSV file.",
            "",
            "### Generation of new singleton nodes when removeping edges",
            "Some of the remove operations allowed in this method might lead to the",
            "generation of new singleton nodes that will not be handled within this",
            "function call even if you provide the flag singletons to true, but you",
            "will need to call the method again if you want to get reed of also those",
            "newly created singleton nodes.",
            "",
            "# Arguments",
            "* `allow_nodes_set`: Option<HashSet<String>> - Optional set of nodes names to keep.",
            "* `deny_nodes_set`: Option<HashSet<String>> - Optional set of nodes names to remove.",
            "* `allow_node_types_set`: Option<HashSet<String>> - Optional set of node type names to keep.",
            "* `deny_node_types_set`: Option<HashSet<String>> - Optional set of node type names to remove.",
            "* `allow_edge_set`: Option<HashSet<EdgeT>>- Optional set of numeric edge IDs to keep.",
            "* `deny_edge_set`: Option<HashSet<EdgeT>>- Optional set of numeric edge IDs to remove.",
            "* `allow_edge_types_set`: Option<HashSet<String>> - Optional set of edge type names to keep.",
            "* `deny_edge_types_set`: Option<HashSet<String>> - Optional set of edge type names to remove.",
            "* `weights`: bool - whether to remove the weights.",
            "* `node_types`: bool - whether to remove the node types.",
            "* `edge_types`: bool - whether to remove the edge types.",
            "* `singletons`: bool - whether to remove the singleton nodes.",
            "* `selfloops`: bool - whether to remove edges with self-loops.",
            "* `verbose`: bool - whether to show a loading bar while building the graph.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "remove",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "allow_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "deny_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "allow_node_types_set",
                "Option<HashSet<String>>"
            ],
            [
                "deny_node_types_set",
                "Option<HashSet<String>>"
            ],
            [
                "allow_edge_set",
                "Option<HashSet<EdgeT>>"
            ],
            [
                "deny_edge_set",
                "Option<HashSet<EdgeT>>"
            ],
            [
                "allow_edge_types_set",
                "Option<HashSet<String>>"
            ],
            [
                "deny_edge_types_set",
                "Option<HashSet<String>>"
            ],
            [
                "weights",
                "bool"
            ],
            [
                "node_types",
                "bool"
            ],
            [
                "edge_types",
                "bool"
            ],
            [
                "singletons",
                "bool"
            ],
            [
                "selfloops",
                "bool"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "let pb_edges = get_loading_bar(\n            verbose,\n            format!(\n                \"Building edges of graph {} without required attributes\",\n                self.name\n            )\n            .as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n        let pb_nodes = get_loading_bar(\n            verbose,\n            format!(\n                \"Building nodes of graph {} without required attributes\",\n                self.name\n            )\n            .as_ref(),\n            self.get_nodes_number() as usize,\n        );\n\n        Graph::from_string_sorted(\n            self.iter_edge_with_type_and_weight(true)\n                .progress_with(pb_edges)\n                .filter_map(\n                    |(edge_id, _, src_name, _, dst_name, _, edge_type, weight)| {\n                        // If an allow edge set was provided\n                        if let Some(aes) = &allow_edge_set {\n                            // We check that the current edge ID is within the edge set.\n                            if !aes.contains(&edge_id) {\n                                return None;\n                            }\n                        }\n                        // If selfloops need to be filtered out.\n                        if selfloops && src_name == dst_name {\n                            return None;\n                        }\n                        // If a deny edge set was provided\n                        if let Some(des) = &deny_edge_set {\n                            // We check that the current edge ID is NOT within the edge set.\n                            if des.contains(&edge_id) {\n                                return None;\n                            }\n                        }\n                        // If an allow nodes set was provided\n                        if let Some(ans) = &allow_nodes_set {\n                            // We check that the current source or destination node name is within the edge set.\n                            if !ans.contains(&src_name) || !ans.contains(&dst_name) {\n                                return None;\n                            }\n                        }\n                        // If a deny nodes set was provided\n                        if let Some(dns) = &deny_nodes_set {\n                            // We check that the current source or destination node name is NOT within the edge set.\n                            if dns.contains(&src_name) || dns.contains(&dst_name) {\n                                return None;\n                            }\n                        }\n                        // If the allow edge types set was provided\n                        if let (Some(aets), Some(et)) = (&allow_edge_types_set, &edge_type) {\n                            // We check that the current edge type name is within the edge type set.\n                            if !aets.contains(et) {\n                                return None;\n                            }\n                        }\n                        // If the deny edge types set was provided\n                        if let (Some(dets), Some(et)) = (&deny_edge_types_set, &edge_type) {\n                            // We check that the current edge type name is NOT within the edge type set.\n                            if dets.contains(et) {\n                                return None;\n                            }\n                        }\n\n                        if allow_node_types_set.is_some() || deny_node_types_set.is_some() {\n                            let src_node_type = self.get_unchecked_node_type_id_by_node_id(\n                                self.get_unchecked_node_id_by_node_name(&src_name),\n                            );\n                            let dst_node_type = self.get_unchecked_node_type_id_by_node_id(\n                                self.get_unchecked_node_id_by_node_name(&dst_name),\n                            );\n                            // If the graph has node types\n                            if let (Some(src_nt), Some(dst_nt)) = (src_node_type, dst_node_type) {\n                                let node_type_names = self\n                                    .get_node_type_names_by_node_type_ids(\n                                        src_nt.into_iter().chain(dst_nt.into_iter()).collect(),\n                                    )\n                                    .unwrap();\n                                // If the allow node types set was provided\n                                if let Some(ants) = &allow_node_types_set {\n                                    // We check that the current node type name is NOT within the node type set.\n                                    if node_type_names\n                                        .iter()\n                                        .any(|node_type_name| !ants.contains(node_type_name))\n                                    {\n                                        return None;\n                                    }\n                                }\n                                // If the deny node types set was provided\n                                if let Some(dnts) = &deny_node_types_set {\n                                    // We check that the current node type name is NOT within the node type set.\n                                    if node_type_names\n                                        .iter()\n                                        .any(|node_type_name| dnts.contains(node_type_name))\n                                    {\n                                        return None;\n                                    }\n                                }\n                            }\n                        }\n\n                        Some(Ok((\n                            src_name,\n                            dst_name,\n                            match edge_types {\n                                false => edge_type,\n                                true => None,\n                            },\n                            match weights {\n                                false => weight,\n                                true => None,\n                            },\n                        )))\n                    },\n                ),\n            Some(self.iter_nodes().progress_with(pb_nodes).filter_map(\n                |(node_id, node_name, _, node_type_names)| {\n                    if singletons && self.is_singleton_by_node_name(&node_name).unwrap() {\n                        return None;\n                    }\n                    // If singletons and selfloops need to be removed.\n                    // We need to check all the destinations of the node if they are equal\n                    // with the source node, as in multigraphs there may be multiple selfloops of different\n                    // node types.\n                    if singletons\n                        && selfloops\n                        && self.is_singleton_with_self_loops_by_node_id(node_id)\n                    {\n                        return None;\n                    }\n                    if let Some(ans) = &allow_nodes_set {\n                        if !ans.contains(&node_name) {\n                            return None;\n                        }\n                    }\n                    if let Some(dns) = &deny_nodes_set {\n                        if dns.contains(&node_name) {\n                            return None;\n                        }\n                    }\n                    if let (Some(ants), Some(nts)) = (&allow_node_types_set, &node_type_names) {\n                        // We check that the current node type name is NOT within the node type set.\n                        if nts\n                            .iter()\n                            .any(|node_type_name| !ants.contains(node_type_name))\n                        {\n                            return None;\n                        }\n                    }\n                    if let (Some(dnts), Some(nts)) = (&deny_node_types_set, &node_type_names) {\n                        // We check that the current node type name is NOT within the node type set.\n                        if nts\n                            .iter()\n                            .any(|node_type_name| dnts.contains(node_type_name))\n                        {\n                            return None;\n                        }\n                    }\n                    Some(Ok((\n                        node_name,\n                        match node_types {\n                            false => node_type_names,\n                            true => None,\n                        },\n                    )))\n                },\n            )),\n            self.directed,\n            true,\n            false,\n            true,\n            true,\n            true,\n            self.get_directed_edges_number() as usize, // Approximation of expected edges number.\n            self.get_nodes_number(),                   // Approximation of expected nodes number.\n            false,\n            false,\n            false,\n            false,\n            self.has_node_types() && !node_types,\n            self.has_edge_types() && !edge_types,\n            self.has_weights() && !weights,\n            // TODO: This may be made more precise!\n            true,\n            self.has_selfloops() && !selfloops,\n            true,\n            self.get_name(),\n        )",
        "doc": [
            "remove all the components that are not connected to interesting",
            "nodes and edges.",
            "",
            "# Arguments",
            "* `node_names` : Option<Vec<String>> - The name of the nodes of which components to keep.",
            "* `node_types` : Option<Vec<String>> - The types of the nodes of which components to keep.",
            "* `edge_types` : Option<Vec<String>> - The types of the edges of which components to keep.",
            "* `minimum_component_size`: Option<NodeT> - Optional, Minimum size of the components to keep.",
            "* `top_k_components`: Option<NodeT> - Optional, number of components to keep sorted by number of nodes.",
            "* `verbose`: bool - whether to show the loading bar."
        ]
    },
    {
        "modifiers": "pub",
        "name": "remove_components",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_names",
                "Option<Vec<String>>"
            ],
            [
                "node_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "edge_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "minimum_component_size",
                "Option<NodeT>"
            ],
            [
                "top_k_components",
                "Option<NodeT>"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "let mut keep_components = RoaringBitmap::new();\n        let components_vector = self.get_node_components_vector(verbose);\n\n        // Extend the components so the include the given node Ids and node types.\n        if let Some(node_ids) = self.get_filter_bitmap(node_names, node_types)? {\n            keep_components.extend(\n                node_ids\n                    .iter()\n                    .map(|node_id| components_vector[node_id as usize]),\n            );\n        }\n\n        // Extend the components to keep those that include the given edge types.\n        if let Some(ets) = edge_types {\n            let edge_types_ids: HashSet<Option<EdgeTypeT>> = self\n                .get_edge_type_ids_by_edge_type_names(ets)?\n                .into_iter()\n                .collect();\n\n            let pb = get_loading_bar(\n                verbose,\n                &format!(\n                    \"Computing which components are to keep for the graph {}\",\n                    &self.name\n                ),\n                self.get_directed_edges_number() as usize,\n            );\n\n            self.iter_edges_with_type_ids(self.directed)\n                .progress_with(pb)\n                .for_each(|(_, src, dst, edge_type)| {\n                    if edge_types_ids.contains(&edge_type) {\n                        keep_components.insert(components_vector[src as usize]);\n                        keep_components.insert(components_vector[dst as usize]);\n                    }\n                });\n        }\n\n        // Create the components counter\n        let component_counts: Vec<(NodeT, NodeT)> =\n            Counter::init(components_vector.clone()).most_common_ordered();\n\n        println!(\"Count components {:?}\", component_counts);\n\n        // Insert the top k biggest components components\n        if let Some(tkc) = top_k_components {\n            for (i, (component_id, _)) in component_counts.iter().enumerate() {\n                if i < tkc as usize {\n                    keep_components.insert(*component_id);\n                }\n            }\n        }\n\n        // Remove components smaller than the given amount\n        if let Some(mcs) = &minimum_component_size {\n            component_counts\n                .iter()\n                .for_each(|(component, component_size)| {\n                    if *component_size < *mcs {\n                        keep_components.remove(*component);\n                    }\n                });\n        }\n\n        let pb = get_loading_bar(\n            verbose,\n            &format!(\n                \"Building edge list with only required components {}\",\n                &self.name\n            ),\n            self.get_directed_edges_number() as usize,\n        );\n        let pb_nodes = get_loading_bar(\n            verbose,\n            &format!(\n                \"Building node list with only required components {}\",\n                &self.name\n            ),\n            self.get_nodes_number() as usize,\n        );\n\n        let min_component_size = keep_components\n            .iter()\n            .map(|component_id| component_counts[component_id as usize].1)\n            .min();\n\n        Graph::from_string_sorted(\n            self.iter_edge_with_type_and_weight(true)\n                .progress_with(pb)\n                .filter_map(\n                    |(_, src, src_name, _, dst_name, _, edge_type_name, weight)| {\n                        // we just check src because dst is trivially in the same component as src\n                        match keep_components.contains(components_vector[src as usize]) {\n                            true => Some(Ok((src_name, dst_name, edge_type_name, weight))),\n                            false => None,\n                        }\n                    },\n                ),\n            Some(self.iter_nodes().progress_with(pb_nodes).filter_map(\n                |(node_id, node_name, _, node_type_names)| {\n                    match keep_components.contains(components_vector[node_id as usize]) {\n                        true => Some(Ok((node_name, node_type_names))),\n                        false => None,\n                    }\n                },\n            )),\n            self.directed,\n            true,\n            false,\n            true,\n            true,\n            true,\n            self.get_directed_edges_number() as usize, // Approximation of expected edges number.\n            self.get_nodes_number(),                   // Approximation of expected nodes number.\n            false,\n            false,\n            false,\n            false,\n            self.has_node_types(),\n            self.has_edge_types(),\n            self.has_weights(),\n            min_component_size.as_ref().map_or(true, |mcs| *mcs <= 1),\n            self.has_singleton_nodes_with_self_loops()\n                && min_component_size.as_ref().map_or(true, |mcs| *mcs <= 1),\n            self.has_trap_nodes(),\n            self.get_name(),\n        )",
        "doc": [
            "Set the name of the graph.",
            "",
            "# Arguments",
            "",
            "* name: String - Name of the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "remove_components",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_names",
                "Option<Vec<String>>"
            ],
            [
                "node_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "edge_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "minimum_component_size",
                "Option<NodeT>"
            ],
            [
                "top_k_components",
                "Option<NodeT>"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "let mut keep_components = RoaringBitmap::new();\n        let components_vector = self.get_node_components_vector(verbose);\n\n        // Extend the components so the include the given node Ids and node types.\n        if let Some(node_ids) = self.get_filter_bitmap(node_names, node_types)? {\n            keep_components.extend(\n                node_ids\n                    .iter()\n                    .map(|node_id| components_vector[node_id as usize]),\n            );\n        }\n\n        // Extend the components to keep those that include the given edge types.\n        if let Some(ets) = edge_types {\n            let edge_types_ids: HashSet<Option<EdgeTypeT>> = self\n                .get_edge_type_ids_by_edge_type_names(ets)?\n                .into_iter()\n                .collect();\n\n            let pb = get_loading_bar(\n                verbose,\n                &format!(\n                    \"Computing which components are to keep for the graph {}\",\n                    &self.name\n                ),\n                self.get_directed_edges_number() as usize,\n            );\n\n            self.iter_edges_with_type_ids(self.directed)\n                .progress_with(pb)\n                .for_each(|(_, src, dst, edge_type)| {\n                    if edge_types_ids.contains(&edge_type) {\n                        keep_components.insert(components_vector[src as usize]);\n                        keep_components.insert(components_vector[dst as usize]);\n                    }\n                });\n        }\n\n        // Create the components counter\n        let component_counts: Vec<(NodeT, NodeT)> =\n            Counter::init(components_vector.clone()).most_common_ordered();\n\n        println!(\"Count components {:?}\", component_counts);\n\n        // Insert the top k biggest components components\n        if let Some(tkc) = top_k_components {\n            for (i, (component_id, _)) in component_counts.iter().enumerate() {\n                if i < tkc as usize {\n                    keep_components.insert(*component_id);\n                }\n            }\n        }\n\n        // Remove components smaller than the given amount\n        if let Some(mcs) = &minimum_component_size {\n            component_counts\n                .iter()\n                .for_each(|(component, component_size)| {\n                    if *component_size < *mcs {\n                        keep_components.remove(*component);\n                    }\n                });\n        }\n\n        let pb = get_loading_bar(\n            verbose,\n            &format!(\n                \"Building edge list with only required components {}\",\n                &self.name\n            ),\n            self.get_directed_edges_number() as usize,\n        );\n        let pb_nodes = get_loading_bar(\n            verbose,\n            &format!(\n                \"Building node list with only required components {}\",\n                &self.name\n            ),\n            self.get_nodes_number() as usize,\n        );\n\n        let min_component_size = keep_components\n            .iter()\n            .map(|component_id| component_counts[component_id as usize].1)\n            .min();\n\n        Graph::from_string_sorted(\n            self.iter_edge_with_type_and_weight(true)\n                .progress_with(pb)\n                .filter_map(\n                    |(_, src, src_name, _, dst_name, _, edge_type_name, weight)| {\n                        // we just check src because dst is trivially in the same component as src\n                        match keep_components.contains(components_vector[src as usize]) {\n                            true => Some(Ok((src_name, dst_name, edge_type_name, weight))),\n                            false => None,\n                        }\n                    },\n                ),\n            Some(self.iter_nodes().progress_with(pb_nodes).filter_map(\n                |(node_id, node_name, _, node_type_names)| {\n                    match keep_components.contains(components_vector[node_id as usize]) {\n                        true => Some(Ok((node_name, node_type_names))),\n                        false => None,\n                    }\n                },\n            )),\n            self.directed,\n            true,\n            false,\n            true,\n            true,\n            true,\n            self.get_directed_edges_number() as usize, // Approximation of expected edges number.\n            self.get_nodes_number(),                   // Approximation of expected nodes number.\n            false,\n            false,\n            false,\n            false,\n            self.has_node_types(),\n            self.has_edge_types(),\n            self.has_weights(),\n            min_component_size.as_ref().map_or(true, |mcs| *mcs <= 1),\n            self.has_singleton_nodes_with_self_loops()\n                && min_component_size.as_ref().map_or(true, |mcs| *mcs <= 1),\n            self.has_trap_nodes(),\n            self.get_name(),\n        )",
        "doc": [
            "Set the name of the graph.",
            "",
            "# Arguments",
            "",
            "* name: String - Name of the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "set_name",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "name",
                "String"
            ]
        ],
        "body": "self.invalidate_report();\n        self.name = name;",
        "doc": [
            "Invalidate the cache for the textual report.",
            "This should be called as the first line of every methods that either get",
            "a mutable reference to self or get ownership of self."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "invalidate_report",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "body": "*self.cached_report.write() = None;",
        "doc": [
            "Replace all edge types (if present) and set all the edge to edge_type.",
            "",
            "# Arguments",
            "- `edge_type`: String - The edge type to assing to all the edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "set_all_edge_types",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "ut self"
            ],
            [
                "edge_type",
                "S"
            ]
        ],
        "return_type": "Graph",
        "body": "self.invalidate_report();\n        let mut vocabulary = Vocabulary::default();\n        vocabulary.insert(edge_type.into()).unwrap();\n        vocabulary.build_reverse_mapping().unwrap();\n        let edge_types = EdgeTypeVocabulary::from_structs(\n            vec![Some(0); self.get_directed_edges_number() as usize],\n            vocabulary,\n        );\n        self.edge_types = Some(edge_types);\n        self",
        "doc": [
            "Replace all node types (if present) and set all the node to node_type.",
            "",
            "# Arguments",
            "- `node_type`: String - The node type to assing to all the nodes."
        ]
    },
    {
        "modifiers": "pub",
        "name": "set_all_node_types",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "ut self"
            ],
            [
                "node_type",
                "S"
            ]
        ],
        "return_type": "Graph",
        "body": "self.invalidate_report();\n        let mut vocabulary = Vocabulary::default();\n        vocabulary.insert(node_type.into()).unwrap();\n        vocabulary.build_reverse_mapping().unwrap();\n        let node_types = NodeTypeVocabulary::from_structs(\n            vec![Some(vec![0]); self.get_nodes_number() as usize],\n            Some(vocabulary),\n        );\n        self.node_types = node_types;\n        self",
        "doc": [
            "Return the base weighted transitions.",
            "",
            "# Arguments",
            "",
            "* min_edge_id: EdgeT - The minimum edge id.",
            "* max_edge_id: EdgeT - The maximum edge id.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "set_all_node_types",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "ut self"
            ],
            [
                "node_type",
                "S"
            ]
        ],
        "return_type": "Graph",
        "body": "self.invalidate_report();\n        let mut vocabulary = Vocabulary::default();\n        vocabulary.insert(node_type.into()).unwrap();\n        vocabulary.build_reverse_mapping().unwrap();\n        let node_types = NodeTypeVocabulary::from_structs(\n            vec![Some(vec![0]); self.get_nodes_number() as usize],\n            Some(vocabulary),\n        );\n        self.node_types = node_types;\n        self",
        "doc": [
            "Return the base weighted transitions.",
            "",
            "# Arguments",
            "",
            "* min_edge_id: EdgeT - The minimum edge id.",
            "* max_edge_id: EdgeT - The maximum edge id.",
            ""
        ]
    },
    {
        "modifiers": "",
        "name": "get_weighted_transitions",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "min_edge_id",
                "EdgeT"
            ],
            [
                "max_edge_id",
                "EdgeT"
            ],
            [
                "probabilistic_indices",
                "&Option<Vec<u64>>"
            ]
        ],
        "return_type": "Vec<WeightT>",
        "body": "match &probabilistic_indices {\n            Some(indices) => match &self.weights {\n                Some(ws) => indices\n                    .iter()\n                    .map(|edge_id| ws[*edge_id as usize])\n                    .collect(),\n                // Otherwise we return an uniform vector.\n                None => vec![1.0; indices.len()],\n            },\n            None => match &self.weights {\n                Some(ws) => ws[(min_edge_id as usize)..(max_edge_id as usize)].to_vec(),\n                // Otherwise we return an uniform vector.\n                None => vec![1.0; (max_edge_id - min_edge_id) as usize],\n            },\n        }",
        "doc": [
            "Updates the the transitions probability score for the change of the node type.",
            "",
            "Specifically, we multiply the transition score by the given `change_node_type_weight`",
            "when the node type changes.",
            "",
            "# Arguments",
            "",
            "node: NodeT - Source node.",
            "transition: &mut Vec<WeightT> - Vector of transitions to update.",
            "destinations: impl Iterator<Item = NodeT> - Iterator of the destinations.",
            "change_node_type_weight: ParamsT - The weight to multiply the transition by if there is a change of node type.",
            ""
        ]
    },
    {
        "modifiers": "",
        "name": "update_node_transition",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "transition",
                "&mut Vec<WeightT>"
            ],
            [
                "destinations",
                "impl Iterator<Item = NodeT>"
            ],
            [
                "change_node_type_weight",
                "ParamsT"
            ]
        ],
        "body": "//############################################################\n        //# Handling of the change node type parameter               #\n        //############################################################\n\n        if not_one(change_node_type_weight) {\n            // If the node types were given:\n            if let Some(nt) = &self.node_types {\n                // if the destination node type matches the neighbour\n                // destination node type (we are not changing the node type)\n                // we weigth using the provided change_node_type_weight weight.\n\n                transition\n                    .iter_mut()\n                    .zip(destinations)\n                    .for_each(|(transition_value, dst)| {\n                        if nt.ids[node as usize] != nt.ids[dst as usize] {\n                            *transition_value *= change_node_type_weight\n                        }\n                    });\n            }\n        }",
        "doc": [
            "Return the node transition weights and the related node and edges.",
            "",
            "# Arguments",
            "",
            "* node: NodeT, the previous node from which to compute the transitions, if this is bigger that the number of nodes it will panic.",
            "* walk_weights: WalkWeights, the weights for the weighted random walks.",
            ""
        ]
    },
    {
        "modifiers": "",
        "name": "get_node_transition",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "walk_weights",
                "&WalkWeights"
            ],
            [
                "min_edge_id",
                "EdgeT"
            ],
            [
                "max_edge_id",
                "EdgeT"
            ],
            [
                "destinations",
                "&[NodeT]"
            ],
            [
                "probabilistic_indices",
                "&Option<Vec<u64>>"
            ]
        ],
        "return_type": "Vec<WeightT>",
        "body": "// Retrieve the data to compute the update transition\n        let mut transition =\n            self.get_weighted_transitions(min_edge_id, max_edge_id, probabilistic_indices);\n\n        // Compute the transition weights relative to the node weights.\n        self.update_node_transition(\n            node,\n            &mut transition,\n            destinations.iter().cloned(),\n            walk_weights.change_node_type_weight,\n        );\n\n        transition",
        "doc": [
            "Return the edge transition weights and the related node and edges.",
            "",
            "# Arguments",
            "",
            "* edge: EdgeT - the previous edge from which to compute the transitions.",
            "* weights: WalkWeights - Weights to use for the weighted walk."
        ]
    },
    {
        "modifiers": "",
        "name": "get_edge_transition",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "edge_id",
                "EdgeT"
            ],
            [
                "walk_weights",
                "&WalkWeights"
            ],
            [
                "min_edge_id",
                "EdgeT"
            ],
            [
                "max_edge_id",
                "EdgeT"
            ],
            [
                "destinations",
                "&[NodeT]"
            ],
            [
                "previous_destinations",
                "&[NodeT]"
            ],
            [
                "probabilistic_indices",
                "&Option<Vec<u64>>"
            ],
            [
                "has_selfloop",
                "bool"
            ]
        ],
        "return_type": "(Vec<WeightT>, EdgeT)",
        "body": "let mut transition =\n            self.get_weighted_transitions(min_edge_id, max_edge_id, probabilistic_indices);\n\n        // Compute the transition weights relative to the node weights.\n        self.update_node_transition(\n            dst,\n            &mut transition,\n            destinations.iter().cloned(),\n            walk_weights.change_node_type_weight,\n        );\n\n        //############################################################\n        //# Handling of the change edge type parameter               #\n        //############################################################\n\n        // If the edge types were given:\n        if not_one(walk_weights.change_edge_type_weight) {\n            if let Some(ets) = &self.edge_types {\n                //# If the neighbour edge type matches the previous\n                //# edge type (we are not changing the edge type)\n                //# we weigth using the provided change_edge_type_weight weight.\n                let this_type: Option<EdgeTypeT> = ets.ids[edge_id as usize];\n                transition\n                    .iter_mut()\n                    .zip(min_edge_id..max_edge_id)\n                    .for_each(|(transition_value, edge_id)| {\n                        if this_type == ets.ids[edge_id as usize] {\n                            *transition_value /= walk_weights.change_edge_type_weight\n                        }\n                    });\n            }\n        }\n\n        //###############################################################\n        //# Handling of the P & Q parameters: the node2vec coefficients #\n        //###############################################################\n        match (\n            not_one(walk_weights.return_weight),\n            not_one(walk_weights.explore_weight),\n        ) {\n            (false, false) => {}\n            (false, true) => {\n                update_explore_weight_transition(\n                    &mut transition,\n                    destinations,\n                    previous_destinations,\n                    walk_weights.explore_weight,\n                    src,\n                    dst,\n                );\n            }\n            (true, false) => {\n                update_return_weight_transition(\n                    &mut transition,\n                    destinations,\n                    src,\n                    dst,\n                    walk_weights.return_weight,\n                    has_selfloop,\n                );\n            }\n            (true, true) => {\n                update_return_explore_weight_transition(\n                    &mut transition,\n                    destinations,\n                    previous_destinations,\n                    walk_weights.return_weight,\n                    walk_weights.explore_weight,\n                    src,\n                    dst,\n                );\n            }\n        }\n\n        (transition, min_edge_id)",
        "doc": [
            "Return new sampled node with the transition edge used.",
            "",
            "# Arguments",
            "",
            "* node: NodeT, the previous node from which to compute the transitions.",
            "* random_state: u64, the random_state to use for extracting the node.",
            ""
        ]
    },
    {
        "modifiers": "",
        "name": "extract_uniform_node",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ]
        ],
        "return_type": "NodeT",
        "body": "let (min_edge, max_edge) = self.get_minmax_edge_ids_by_source_node_id(node);\n        let sampled_offset = sample_uniform((max_edge - min_edge) as u64, random_state);\n\n        match self\n            .cached_destinations\n            .as_ref()\n            .and_then(|cds| cds.get(&node))\n        {\n            Some(dsts) => dsts[sampled_offset],\n            None => self\n                .get_destination_node_id_by_edge_id(min_edge + sampled_offset as EdgeT)\n                .unwrap(),\n        }",
        "doc": [
            "Return new sampled node with the transition edge used.",
            "",
            "# Arguments",
            "",
            "* node: NodeT, the previous node from which to compute the transitions.",
            "* random_state: usize, the random_state to use for extracting the node.",
            "* walk_weights: WalkWeights, the weights for the weighted random walks."
        ]
    },
    {
        "modifiers": "",
        "name": "extract_node",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "walk_weights",
                "&WalkWeights"
            ],
            [
                "min_edge_id",
                "EdgeT"
            ],
            [
                "max_edge_id",
                "EdgeT"
            ],
            [
                "destinations",
                "&[NodeT]"
            ],
            [
                "probabilistic_indices",
                "&Option<Vec<u64>>"
            ]
        ],
        "return_type": "(NodeT, EdgeT)",
        "body": "let mut weights = self.get_node_transition(\n            node,\n            walk_weights,\n            min_edge_id,\n            max_edge_id,\n            destinations,\n            probabilistic_indices,\n        );\n        let sampled_offset = sample(&mut weights, random_state);\n        let edge_id = match probabilistic_indices {\n            Some(inds) => inds[sampled_offset],\n            None => min_edge_id + sampled_offset as EdgeT,\n        };\n\n        let destination = match self\n            .cached_destinations\n            .as_ref()\n            .and_then(|cds| cds.get(&node))\n        {\n            Some(dsts) => dsts[sampled_offset],\n            None => self.get_destination_node_id_by_edge_id(edge_id).unwrap(),\n        };\n        (destination, edge_id)",
        "doc": [
            "Return new random edge with given weights.",
            "",
            "# Arguments",
            "",
            "* `src`: NodeT - Current source node id.",
            "* `dst`: NodeT - Current destination node id.",
            "* `edge`: EdgeT - Current edge id.",
            "* `random_state`: NodeT - The random state to use to sample the next edge id.",
            "* `walk_weights`: &WalkWeights - Struct with the weights to use to update the transitions.",
            "* `min_edge_id`: EdgeT - Minimum edge id to sample for given destination node id.",
            "* `max_edge_id`: EdgeT - Maximum edge id to sample for given destination node id.",
            "* `destinations`: &[NodeT] - Current destinations slice.",
            "* `previous_destinations`: &[NodeT] - Previous destination slice.",
            "* `probabilistic_indices`: &Option<Vec<u64>> - Probabilistic indices, used when max neighbours is provided.",
            ""
        ]
    },
    {
        "modifiers": "",
        "name": "extract_edge",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "edge",
                "EdgeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "walk_weights",
                "&WalkWeights"
            ],
            [
                "min_edge_id",
                "EdgeT"
            ],
            [
                "max_edge_id",
                "EdgeT"
            ],
            [
                "destinations",
                "&[NodeT]"
            ],
            [
                "previous_destinations",
                "&[NodeT]"
            ],
            [
                "probabilistic_indices",
                "&Option<Vec<u64>>"
            ]
        ],
        "return_type": "(NodeT, EdgeT)",
        "body": "let (mut weights, min_edge_id) = self.get_edge_transition(\n            src,\n            dst,\n            edge,\n            walk_weights,\n            min_edge_id,\n            max_edge_id,\n            destinations,\n            previous_destinations,\n            probabilistic_indices,\n            self.has_selfloops(),\n        );\n        let sampled_offset = sample(&mut weights, random_state as u64);\n        let edge_id = match probabilistic_indices {\n            Some(inds) => inds[sampled_offset],\n            None => min_edge_id + sampled_offset as EdgeT,\n        };\n        let destination = match self\n            .cached_destinations\n            .as_ref()\n            .and_then(|cds| cds.get(&dst))\n        {\n            Some(dsts) => dsts[sampled_offset],\n            None => self.get_destination_node_id_by_edge_id(edge_id).unwrap(),\n        };\n        (destination, edge_id)",
        "doc": [
            "Return vector of walks run on each non-trap node of the graph.",
            "",
            "# Arguments",
            "",
            "* parameters: WalksParameters - the weighted walks parameters.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "random_walks_iter",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "quantity",
                "NodeT"
            ],
            [
                "parameters",
                "&'a WalksParameters"
            ]
        ],
        "return_type": "Result<impl IndexedParallelIterator<Item = Vec<NodeT>> + 'a, String>",
        "body": "if !self.has_edges() {\n            return Err(\n                \"It does not make sense to compute a random walk on an empty graph.\".to_string(),\n            );\n        }\n        let factor = 0xDEAD;\n        let random_state = splitmix64(parameters.random_state.wrapping_mul(factor) as u64);\n        self.walk_iter(\n            quantity,\n            move |index| {\n                let local_index = index % quantity;\n                let random_source_id =\n                    splitmix64(random_state + local_index.wrapping_mul(factor) as u64) as NodeT;\n                (\n                    splitmix64(random_state + index.wrapping_mul(factor) as u64),\n                    self.get_unique_source(\n                        random_source_id % self.get_unique_source_nodes_number(),\n                    ),\n                )\n            },\n            parameters,\n        )",
        "doc": [
            "Return vector of walks run on a random subset of the not trap nodes.",
            "",
            "# Arguments",
            "",
            "* parameters: WalksParameters - the weighted walks parameters.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "complete_walks_iter",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "parameters",
                "&'a WalksParameters"
            ]
        ],
        "return_type": "Result<impl IndexedParallelIterator<Item = Vec<NodeT>> + 'a, String>",
        "body": "if !self.has_edges() {\n            return Err(\n                \"It does not make sense to compute a random walk on an empty graph.\".to_string(),\n            );\n        }\n        let factor = 0xDEAD;\n        let random_state = splitmix64(parameters.random_state.wrapping_mul(factor) as u64);\n        self.walk_iter(\n            self.get_unique_source_nodes_number(),\n            move |index| {\n                (\n                    splitmix64(random_state + index.wrapping_mul(factor) as u64),\n                    self.get_unique_source(index as NodeT % self.get_unique_source_nodes_number()),\n                )\n            },\n            parameters,\n        )",
        "doc": [
            "Returns vector of walks.",
            "",
            "# Arguments",
            "",
            "* parameters: WalksParameters - the weighted walks parameters.",
            ""
        ]
    },
    {
        "modifiers": "",
        "name": "walk_iter",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "quantity",
                "NodeT"
            ],
            [
                "to_node",
                "impl Fn(NodeT) -> (u64, NodeT) + Sync + Send + 'a"
            ],
            [
                "parameters",
                "&'a WalksParameters"
            ]
        ],
        "return_type": "Result<impl IndexedParallelIterator<Item = Vec<NodeT>> + 'a, String>",
        "body": "if self.directed {\n            return Err(\"Not supporting directed walks as of now.\".to_owned());\n        }\n\n        // Validate if given parameters are compatible with current graph.\n        parameters.validate(&self)?;\n\n        let total_iterations = quantity * parameters.iterations;\n        info!(\"Starting random walk.\");\n\n        // If the graph does not have any weights and the parameters\n        // for the walks are all equal to 1, we can use the first-order\n        // random walk algorithm.\n        let use_uniform = !self.has_weights() && parameters.is_first_order_walk();\n\n        let walks = (0..total_iterations).into_par_iter().map(move |index| {\n            let (random_state, node) = to_node(index);\n            let mut walk = match use_uniform {\n                true => self.uniform_walk(\n                    node,\n                    random_state,\n                    parameters.single_walk_parameters.walk_length,\n                ),\n                false => self.single_walk(node, random_state, &parameters.single_walk_parameters),\n            };\n\n            if let Some(dense_node_mapping) = &parameters.dense_node_mapping {\n                walk.iter_mut()\n                    .for_each(|node| *node = *dense_node_mapping.get(node).unwrap());\n            }\n            walk\n        });\n\n        Ok(walks)",
        "doc": [
            "Returns single walk from given node.",
            "",
            "This method assumes that there are no traps in the graph.",
            "",
            "# Arguments",
            "",
            "* node: NodeT - Node from where to start the random walks.",
            "* random_state: usize, the random_state to use for extracting the nodes and edges.",
            "* parameters: SingleWalkParameters - Parameters for the single walk.",
            ""
        ]
    },
    {
        "modifiers": "",
        "name": "single_walk",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "parameters",
                "&SingleWalkParameters"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "let (min_edge_id, max_edge_id, destinations, indices) =\n            self.get_node_edges_and_destinations(parameters.max_neighbours, random_state, node);\n        let (dst, edge) = self.extract_node(\n            node,\n            random_state,\n            &parameters.weights,\n            min_edge_id,\n            max_edge_id,\n            self.get_destinations_slice(min_edge_id, max_edge_id, node, &destinations),\n            &indices,\n        );\n\n        let mut result = Vec::with_capacity(parameters.walk_length as usize);\n        result.push(node);\n        result.push(dst);\n        // We iterate two times before because we need to parse the two initial nodes\n\n        let mut previous_min_edge_id = min_edge_id;\n        let mut previous_max_edge_id = max_edge_id;\n        let mut previous_destinations = destinations;\n        let mut previous_src = node;\n        let mut previous_dst = dst;\n        let mut previous_edge = edge;\n\n        for i in 2..parameters.walk_length {\n            let (min_edge_id, max_edge_id, destinations, indices) = self\n                .get_node_edges_and_destinations(\n                    parameters.max_neighbours,\n                    random_state + i,\n                    previous_dst,\n                );\n            let (dst, edge) = self.extract_edge(\n                previous_src,\n                previous_dst,\n                previous_edge,\n                random_state + i,\n                &parameters.weights,\n                min_edge_id,\n                max_edge_id,\n                self.get_destinations_slice(min_edge_id, max_edge_id, previous_dst, &destinations),\n                self.get_destinations_slice(\n                    previous_min_edge_id,\n                    previous_max_edge_id,\n                    previous_src,\n                    &previous_destinations,\n                ),\n                &indices,\n            );\n\n            previous_min_edge_id = min_edge_id;\n            previous_max_edge_id = max_edge_id;\n            previous_destinations = destinations;\n            previous_src = previous_dst;\n            previous_dst = dst;\n            previous_edge = edge;\n            result.push(dst);\n        }\n\n        result",
        "doc": [
            "Returns single walk from given node.",
            "",
            "This method assumes that there are no traps in the graph.",
            "",
            "# Arguments",
            "",
            "* node: NodeT - Node from where to start the random walks.",
            "* random_state: usize - the random_state to use for extracting the nodes and edges.",
            "* walk_length: u64 - Length of the random walk.",
            ""
        ]
    },
    {
        "modifiers": "",
        "name": "uniform_walk",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "walk_length",
                "u64"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "// We iterate one time before because we need to parse the initial node.\n        (0..1)\n            .map(move |_| node)\n            .chain((1..walk_length).scan(node, move |node, iteration| {\n                *node = self.extract_uniform_node(*node, random_state + iteration);\n                Some(*node)\n            }))\n            .collect()",
        "attrs": [
            "inline(always)"
        ]
    },
    {
        "modifiers": "",
        "name": "uniform_walk",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "walk_length",
                "u64"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "// We iterate one time before because we need to parse the initial node.\n        (0..1)\n            .map(move |_| node)\n            .chain((1..walk_length).scan(node, move |node, iteration| {\n                *node = self.extract_uniform_node(*node, random_state + iteration);\n                Some(*node)\n            }))\n            .collect()",
        "attrs": [
            "inline(always)"
        ]
    },
    {
        "modifiers": "pub",
        "name": "encode_edge",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "u64",
        "body": "encode_edge(src, dst, self.node_bits)",
        "attrs": [
            "inline(always)"
        ]
    },
    {
        "modifiers": "pub",
        "name": "decode_edge",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "edge",
                "u64"
            ]
        ],
        "return_type": "(NodeT, NodeT)",
        "body": "decode_edge(edge, self.node_bits, self.node_bit_mask)",
        "attrs": [
            "inline(always)"
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_node_ids_from_edge_id",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "(NodeT, NodeT)",
        "body": "if let (Some(sources), Some(destinations)) = (&self.sources, &self.destinations) {\n            return (sources[edge_id as usize], destinations[edge_id as usize]);\n        }\n        self.decode_edge(self.edges.unchecked_select(edge_id))",
        "attrs": [
            "inline(always)"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_id_by_node_ids",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "Result<EdgeT, String>",
        "body": "match self\n            .edges\n            .rank(self.encode_edge(src, dst))\n            .map(|value| value as EdgeT) {\n                Some(edge_id) => Ok(edge_id),\n                None => Err(format!(\"The edge composed by the source node {} and destination node {} does not exist in this graph.\", src, dst))\n            }",
        "attrs": [
            "inline(always)"
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unchecked_edge_id_from_tuple",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.edges.unchecked_rank(self.encode_edge(src, dst)) as EdgeT",
        "attrs": [
            "inline(always)"
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unique_source",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "source_id",
                "NodeT"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.unique_sources\n            .as_ref()\n            .map_or(source_id, |x| x.unchecked_select(source_id as u64) as NodeT)",
        "doc": [
            "Return vector of tuple of Node IDs that form the edges of the required bipartite graph.",
            "",
            "# Arguments",
            "`removed_existing_edges`: Option<bool> - whether to filter out the existing edges. By default, true.",
            "`first_nodes_set`: Option<HashMap<String>> - Optional set of nodes to use to create the first set of nodes of the graph.",
            "`second_nodes_set`: Option<HashMap<String>> - Optional set of nodes to use to create the second set of nodes of the graph.",
            "`first_node_types_set`: Option<HashMap<String>> - Optional set of node types to create the first set of nodes of the graph.",
            "`second_node_types_set`: Option<HashMap<String>> - Optional set of node types to create the second set of nodes of the graph."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "get_unique_source",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "source_id",
                "NodeT"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.unique_sources\n            .as_ref()\n            .map_or(source_id, |x| x.unchecked_select(source_id as u64) as NodeT)",
        "doc": [
            "Return vector of tuple of Node IDs that form the edges of the required bipartite graph.",
            "",
            "# Arguments",
            "`removed_existing_edges`: Option<bool> - whether to filter out the existing edges. By default, true.",
            "`first_nodes_set`: Option<HashMap<String>> - Optional set of nodes to use to create the first set of nodes of the graph.",
            "`second_nodes_set`: Option<HashMap<String>> - Optional set of nodes to use to create the second set of nodes of the graph.",
            "`first_node_types_set`: Option<HashMap<String>> - Optional set of node types to create the first set of nodes of the graph.",
            "`second_node_types_set`: Option<HashMap<String>> - Optional set of node types to create the second set of nodes of the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_bipartite_edges",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "removed_existing_edges",
                "Option<bool>"
            ],
            [
                "first_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "second_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "first_node_types_set",
                "Option<HashSet<String>>"
            ],
            [
                "second_node_types_set",
                "Option<HashSet<String>>"
            ]
        ],
        "return_type": "Result<Vec<Vec<NodeT>>, String>",
        "body": "let removed_existing_edges_unwrapped = removed_existing_edges.unwrap_or(true);\n        let (first_nodes, second_nodes): (Vec<NodeT>, Vec<NodeT>) = [\n            (first_nodes_set, first_node_types_set),\n            (second_nodes_set, second_node_types_set),\n        ]\n        .iter()\n        .map(|(node_set, node_type_set)| {\n            self.iter_nodes()\n                .filter_map(|(node_id, node_name, _, node_type)| {\n                    if let Some(ans) = &node_set {\n                        if !ans.contains(&node_name) {\n                            return None;\n                        }\n                    }\n                    if let (Some(ants), Some(nt)) = (&node_type_set, &node_type) {\n                        if nt\n                            .iter()\n                            .any(|node_type_name| !ants.contains(node_type_name))\n                        {\n                            return None;\n                        }\n                    }\n                    Some(node_id)\n                })\n                .collect::<Vec<NodeT>>()\n        })\n        .collect_tuple()\n        .unwrap();\n\n        if first_nodes.is_empty() {\n            return Err(\"The first nodes set of required bipartite graph is empty!\".to_owned());\n        }\n\n        if second_nodes.is_empty() {\n            return Err(\"The second nodes set of required bipartite graph is empty!\".to_owned());\n        }\n\n        if first_nodes\n            .par_iter()\n            .any(|src| second_nodes.binary_search(src).is_ok())\n        {\n            return Err(\n                \"The giving node sets of the required bipartite graph have shared nodes.\"\n                    .to_owned(),\n            );\n        }\n\n        Ok(first_nodes\n            .par_iter()\n            .flat_map(|src| {\n                second_nodes\n                    .iter()\n                    .filter_map(|dst| {\n                        if removed_existing_edges_unwrapped && self.has_edge_by_node_ids(*src, *dst)\n                        {\n                            return None;\n                        }\n                        Some(vec![*src, *dst])\n                    })\n                    .collect::<Vec<Vec<NodeT>>>()\n            })\n            .collect())",
        "doc": [
            "Return vector of tuple of Node IDs that form the edges of the required bipartite graph.",
            "",
            "# Arguments",
            "`removed_existing_edges`: Option<bool> - whether to filter out the existing edges. By default, true.",
            "`first_nodes_set`: Option<HashMap<String>> - Optional set of nodes to use to create the first set of nodes of the graph.",
            "`second_nodes_set`: Option<HashMap<String>> - Optional set of nodes to use to create the second set of nodes of the graph.",
            "`first_node_types_set`: Option<HashMap<String>> - Optional set of node types to create the first set of nodes of the graph.",
            "`second_node_types_set`: Option<HashMap<String>> - Optional set of node types to create the second set of nodes of the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_bipartite_edge_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "removed_existing_edges",
                "Option<bool>"
            ],
            [
                "first_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "second_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "first_node_types_set",
                "Option<HashSet<String>>"
            ],
            [
                "second_node_types_set",
                "Option<HashSet<String>>"
            ]
        ],
        "return_type": "Result<Vec<Vec<String>>, String>",
        "body": "Ok(self\n            .get_bipartite_edges(\n                removed_existing_edges,\n                first_nodes_set,\n                second_nodes_set,\n                first_node_types_set,\n                second_node_types_set,\n            )?\n            .iter()\n            .map(|nodes| {\n                nodes\n                    .iter()\n                    .map(|node| self.get_node_name_by_node_id(*node).unwrap())\n                    .collect::<Vec<String>>()\n            })\n            .collect::<Vec<Vec<String>>>())",
        "doc": [
            "Return vector of tuple of Node IDs that form the edges of the required star.",
            "",
            "# Arguments",
            "`central_node`: String - Name of the node to use as center of the star.",
            "`removed_existing_edges`: Option<bool> - whether to filter out the existing edges. By default, true.",
            "`star_points_nodes_set`: Option<HashMap<String>> - Optional set of nodes to use to create the set of star points.",
            "`star_points_node_types_set`: Option<HashMap<String>> - Optional set of node types to create the set of star points."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_star_edges",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "central_node",
                "String"
            ],
            [
                "removed_existing_edges",
                "Option<bool>"
            ],
            [
                "star_points_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "star_points_node_types_set",
                "Option<HashSet<String>>"
            ]
        ],
        "return_type": "Result<Vec<Vec<NodeT>>, String>",
        "body": "self.get_bipartite_edges(\n            removed_existing_edges,\n            Some(vec![central_node].into_iter().collect::<HashSet<String>>()),\n            star_points_nodes_set,\n            None,\n            star_points_node_types_set,\n        )",
        "doc": [
            "Return vector of tuple of Node names that form the edges of the required star.",
            "",
            "# Arguments",
            "`central_node`: String - Name of the node to use as center of the star.",
            "`removed_existing_edges`: Option<bool> - whether to filter out the existing edges. By default, true.",
            "`star_points_nodes_set`: Option<HashMap<String>> - Optional set of nodes to use to create the set of star points.",
            "`star_points_node_types_set`: Option<HashMap<String>> - Optional set of node types to create the set of star points."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_star_edge_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "central_node",
                "String"
            ],
            [
                "removed_existing_edges",
                "Option<bool>"
            ],
            [
                "star_points_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "star_points_node_types_set",
                "Option<HashSet<String>>"
            ]
        ],
        "return_type": "Result<Vec<Vec<String>>, String>",
        "body": "self.get_bipartite_edge_names(\n            removed_existing_edges,\n            Some(vec![central_node].into_iter().collect::<HashSet<String>>()),\n            star_points_nodes_set,\n            None,\n            star_points_node_types_set,\n        )",
        "doc": [
            "Return vector of tuple of Node IDs that form the edges of the required clique.",
            "",
            "# Arguments",
            "`directed`: Option<bool> - whether to return the edges as directed or undirected. By default, equal to the graph.",
            "`allow_self_loops`: Option<bool> - whether to allow self-loops in the clique. By default, equal to the graph.",
            "`removed_existing_edges`: Option<bool> - whether to filter out the existing edges. By default, true.",
            "`allow_node_type_set`: Option<HashSet<String>> - Node types to include in the clique.",
            "`allow_node_set`: Option<HashSet<String>> - Nodes to include i the clique."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_clique_edges",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "Option<bool>"
            ],
            [
                "allow_self_loops",
                "Option<bool>"
            ],
            [
                "removed_existing_edges",
                "Option<bool>"
            ],
            [
                "allow_node_type_set",
                "Option<HashSet<String>>"
            ],
            [
                "allow_node_set",
                "Option<HashSet<String>>"
            ]
        ],
        "return_type": "Vec<Vec<NodeT>>",
        "body": "let directed_unwrapped = directed.unwrap_or(self.directed);\n        let allow_self_loops_unwrapped = allow_self_loops.unwrap_or_else(|| self.has_selfloops());\n        let removed_existing_edges_unwrapped = removed_existing_edges.unwrap_or(true);\n        let nodes: Vec<NodeT> = self\n            .iter_nodes()\n            .filter_map(|(node_id, node_name, _, node_type)| {\n                if let (Some(ants), Some(nt)) = (&allow_node_type_set, &node_type) {\n                    if nt\n                        .iter()\n                        .any(|node_type_name| !ants.contains(node_type_name))\n                    {\n                        return None;\n                    }\n                }\n                if let Some(ans) = &allow_node_set {\n                    if !ans.contains(&node_name) {\n                        return None;\n                    }\n                }\n                Some(node_id)\n            })\n            .collect();\n\n        nodes\n            .par_iter()\n            .flat_map(|src| {\n                nodes\n                    .iter()\n                    .filter_map(|dst| {\n                        if !allow_self_loops_unwrapped && src == dst {\n                            return None;\n                        }\n                        if !directed_unwrapped && src > dst {\n                            return None;\n                        }\n                        if removed_existing_edges_unwrapped && self.has_edge_by_node_ids(*src, *dst)\n                        {\n                            return None;\n                        }\n                        Some(vec![*src, *dst])\n                    })\n                    .collect::<Vec<Vec<NodeT>>>()\n            })\n            .collect()",
        "doc": [
            "Return vector of tuple of Node names that form the edges of the required clique.",
            "",
            "# Arguments",
            "`directed`: Option<bool> - whether to return the edges as directed or undirected. By default, equal to the graph.",
            "`allow_self_loops`: Option<bool> - whether to allow self-loops in the clique. By default, equal to the graph.",
            "`removed_existing_edges`: Option<bool> - whether to filter out the existing edges. By default, true.",
            "`allow_node_type_set`: Option<HashSet<String>> - Node types to include in the clique.",
            "`allow_node_set`: Option<HashSet<String>> - Nodes to include i the clique."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_clique_edge_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "Option<bool>"
            ],
            [
                "allow_self_loops",
                "Option<bool>"
            ],
            [
                "removed_existing_edges",
                "Option<bool>"
            ],
            [
                "allow_node_type_set",
                "Option<HashSet<String>>"
            ],
            [
                "allow_node_set",
                "Option<HashSet<String>>"
            ]
        ],
        "return_type": "Vec<Vec<String>>",
        "body": "self.get_clique_edges(\n            directed,\n            allow_self_loops,\n            removed_existing_edges,\n            allow_node_type_set,\n            allow_node_set,\n        )\n        .iter()\n        .map(|nodes| {\n            nodes\n                .iter()\n                .map(|node| self.get_node_name_by_node_id(*node).unwrap())\n                .collect::<Vec<String>>()\n        })\n        .collect::<Vec<Vec<String>>>()",
        "doc": [
            "Return if the graph has any nodes.",
            "",
            "# Example",
            "To check if the graph has nodes you can use:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert_eq!(graph.has_nodes(), true);",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_clique_edge_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "Option<bool>"
            ],
            [
                "allow_self_loops",
                "Option<bool>"
            ],
            [
                "removed_existing_edges",
                "Option<bool>"
            ],
            [
                "allow_node_type_set",
                "Option<HashSet<String>>"
            ],
            [
                "allow_node_set",
                "Option<HashSet<String>>"
            ]
        ],
        "return_type": "Vec<Vec<String>>",
        "body": "self.get_clique_edges(\n            directed,\n            allow_self_loops,\n            removed_existing_edges,\n            allow_node_type_set,\n            allow_node_set,\n        )\n        .iter()\n        .map(|nodes| {\n            nodes\n                .iter()\n                .map(|node| self.get_node_name_by_node_id(*node).unwrap())\n                .collect::<Vec<String>>()\n        })\n        .collect::<Vec<Vec<String>>>()",
        "doc": [
            "Return if the graph has any nodes.",
            "",
            "# Example",
            "To check if the graph has nodes you can use:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert_eq!(graph.has_nodes(), true);",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_nodes",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_nodes_number() > 0",
        "doc": [
            "Return if the graph has any edges.",
            "",
            "# Example",
            "To check if the current graph has edges you can use:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert_eq!(graph.has_edges(), true);",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_edges",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_edges_number() > 0",
        "doc": [
            "Return name of the graph.",
            "",
            "# Example",
            "To the retrieve the name of the current graph instance you can use:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert_eq!(graph.get_name(), \"STRING PPI\".to_string());",
            "println!(\"The name of the current graph is {}.\", graph.get_name());",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_name",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "String",
        "body": "self.name.clone()",
        "doc": [
            "Return the number of traps (nodes without any outgoing edges that are not singletons)",
            "This also includes nodes with only a self-loops, therefore singletons with",
            "only a self-loops are not considered traps because you could make a walk on them.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"There are {} trap nodes in the current graph.\", graph.get_trap_nodes_number());",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_trap_nodes_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "(self.get_not_singleton_nodes_number() + self.get_singleton_nodes_with_self_loops_number()\n            - self.get_unique_source_nodes_number()) as EdgeT",
        "doc": [
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "if graph.has_trap_nodes(){",
            "println!(\"There are {} trap nodes in the current graph.\", graph.get_trap_nodes_number());",
            "} else {",
            "println!(\"There are no trap nodes in the current graph.\");",
            "}",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_trap_nodes",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_trap_nodes_number() > 0",
        "doc": [
            "Returns boolean representing if graph is directed.",
            "",
            "# Example",
            "```rust",
            "let directed_string_ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(directed_string_ppi.is_directed());",
            "let undirected_string_ppi = graph::test_utilities::load_ppi(true, true, true, false, false, false).unwrap();",
            "assert!(!undirected_string_ppi.is_directed());",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "is_directed",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.directed",
        "doc": [
            "Returns boolean representing whether graph has weights.",
            "",
            "# Example",
            "```rust",
            "let weights_string_ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(weights_string_ppi.has_weights());",
            "let unweights_string_ppi = graph::test_utilities::load_ppi(true, true, false, true, false, false).unwrap();",
            "assert!(!unweights_string_ppi.has_weights());",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_weights",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.weights.is_some()",
        "doc": [
            "Returns boolean representing whether graph has edge types.",
            "",
            "# Example",
            "```rust",
            "let string_ppi_with_edge_types = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(string_ppi_with_edge_types.has_edge_types());",
            "let string_ppi_without_edge_types = graph::test_utilities::load_ppi(true, false, true, true, false, false).unwrap();",
            "assert!(!string_ppi_without_edge_types.has_edge_types());",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_edge_types",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.edge_types.is_some()",
        "doc": [
            "Returns boolean representing if graph has self-loops.",
            "",
            "# Example",
            "```rust",
            "let string_ppi_with_selfloops = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(string_ppi_with_selfloops.has_selfloops());",
            "let string_ppi_without_selfloops = graph::test_utilities::load_ppi(true, false, true, true, false, true).unwrap();",
            "assert!(!string_ppi_without_selfloops.has_selfloops());",
            "```",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_selfloops",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.self_loop_number > 0",
        "doc": [
            "Returns boolean representing if graph has singletons.",
            "",
            "# Example",
            "```rust",
            "# let graph_with_singletons = graph::test_utilities::load_ppi(true, true, true, false, false, false).unwrap();",
            "assert!(graph_with_singletons.has_singletons());",
            "let graph_without_singletons = graph_with_singletons.remove(",
            "None, None, None, None, None, None, None, None, false, false, true, true, false, false,",
            ").unwrap();",
            "assert!(!graph_without_singletons.has_singletons());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_singletons",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_singleton_nodes_number() > 0",
        "doc": [
            "Returns boolean representing if graph has singletons."
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_singleton_nodes_with_self_loops",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_singleton_nodes_with_self_loops_number() > 0",
        "doc": [
            "Return vector of the non-unique source nodes.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_sources",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "self.par_iter_sources_ids(directed).collect()",
        "doc": [
            "Return vector of the non-unique source nodes names.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_source_names",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Vec<String>",
        "body": "self.par_iter_sources_ids(directed)\n            .map(|src| self.get_node_name_by_node_id(src).unwrap())\n            .collect()",
        "doc": [
            "Return vector on the (non unique) destination nodes of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_destinations",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "self.par_iter_destinations_ids(directed).collect()",
        "doc": [
            "Return vector of the non-unique destination nodes names.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_destination_names",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Vec<String>",
        "body": "self.par_iter_destinations_ids(directed)\n            .map(|dst| self.get_node_name_by_node_id(dst).unwrap())\n            .collect()",
        "doc": [
            "Return vector with the sorted nodes names."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_names",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Vec<String>",
        "body": "self.nodes.reverse_map.clone()",
        "doc": [
            "Return vector with the sorted nodes Ids."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_nodes",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "(0..self.get_nodes_number()).collect()",
        "doc": [
            "Return the edge types of the edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_types",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<Vec<Option<EdgeTypeT>>, String>",
        "body": "if !self.has_edge_types() {\n            return Err(\"The current graph instance does not have edge types!\".to_string());\n        }\n        Ok(self.edge_types.as_ref().map(|ets| ets.ids.clone()).unwrap())",
        "doc": [
            "Return the edge types names."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_type_names",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Option<Vec<String>>",
        "body": "self.edge_types\n            .as_ref()\n            .map(|ets| ets.vocabulary.reverse_map.clone())",
        "doc": [
            "Return the node types of the nodes."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_types",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<Vec<Option<Vec<NodeTypeT>>>, String>",
        "body": "if !self.has_node_types() {\n            return Err(\"The current graph instance does not have nodes!\".to_string());\n        }\n        Ok(self.node_types.as_ref().map(|nts| nts.ids.clone()).unwrap())",
        "doc": [
            "Return the weights of the edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_weights",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<Vec<WeightT>, String>",
        "body": "if !self.has_weights() {\n            return Err(\"The current graph instance does not have weights!\".to_string());\n        }\n        Ok(self.weights.clone().unwrap())",
        "doc": [
            "Return the minimum weight, if graph has weights."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_min_weight",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "self.weights.as_ref().map_or(\n            Err(\"The current graph instance does not have weights!\".to_string()),\n            |ws| {\n                Ok(ws\n                    .par_iter()\n                    .cloned()\n                    .reduce(|| f32::INFINITY, |a, b| a.min(b)))\n            },\n        )",
        "doc": [
            "Return the maximum weight, if graph has weights."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_max_weight",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "self.weights.as_ref().map_or(\n            Err(\"The current graph instance does not have weights!\".to_string()),\n            |ws| {\n                Ok(ws\n                    .par_iter()\n                    .cloned()\n                    .reduce(|| f32::NEG_INFINITY, |a, b| a.max(b)))\n            },\n        )",
        "doc": [
            "Return the node types names."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_type_names",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Option<Vec<String>>",
        "body": "self.node_types\n            .as_ref()\n            .map(|nts| nts.vocabulary.reverse_map.clone())",
        "doc": [
            "Return number of the unique edges in the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_unique_directed_edges_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.unique_edges_number",
        "doc": [
            "Return maximum encodable edge number."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_max_encodable_edge_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "encode_max_edge(\n            self.get_nodes_number(),\n            get_node_bits(self.get_nodes_number()),\n        )",
        "doc": [
            "Return the nodes mapping."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_nodes_mapping",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "HashMap<String, NodeT>",
        "body": "self.nodes.map.clone()",
        "doc": [
            "Return vector with the sorted edge Ids."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edges",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Vec<Vec<NodeT>>",
        "body": "self.par_iter_edge_ids(directed)\n            .map(|(_, src, dst)| vec![src, dst])\n            .collect()",
        "doc": [
            "Return vector with the sorted edge names."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_names",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Vec<(String, String)>",
        "body": "self.par_iter_edges(directed)\n            .map(|(_, _, src_name, _, dst_name)| (src_name, dst_name))\n            .collect()",
        "doc": [
            "Returns boolean representing if graph has node types."
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_node_types",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.node_types.is_some()",
        "doc": [
            "Returns boolean representing if graph has multilabel node types."
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_multilabel_node_types",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.node_types\n            .as_ref()\n            .map_or(false, |nt| nt.is_multilabel())",
        "doc": [
            "Returns number of unknown node types."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_unknown_node_types_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.node_types\n            .as_ref()\n            .map_or(0, |nt| nt.get_unknown_count())",
        "doc": [
            "Returns minimum number of node types."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_minimum_node_types_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.node_types\n            .as_ref()\n            .map_or(0, |et| et.min_node_type_count())",
        "doc": [
            "Returns whether there are unknown node types."
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_unknown_node_types",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_unknown_node_types_number() > 0",
        "doc": [
            "Returns number of unknown edge types."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_unknown_edge_types_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.edge_types\n            .as_ref()\n            .map_or(0, |et| et.get_unknown_count())",
        "doc": [
            "Returns minimum number of edge types."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_minimum_edge_types_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.edge_types\n            .as_ref()\n            .map_or(0, |et| et.min_edge_type_count())",
        "doc": [
            "Returns whether there are unknown edge types."
        ]
    },
    {
        "modifiers": "pub",
        "name": "has_unknown_edge_types",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_unknown_edge_types_number() > 0",
        "doc": [
            "Returns number of nodes in the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_nodes_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.nodes.len() as NodeT",
        "doc": [
            "Return a vector with the components each node belongs to.",
            "",
            "E.g. If we have two components `[0, 2, 3]` and `[1, 4, 5]` the result will look like",
            "`[0, 1, 0, 0, 1, 1]`",
            "",
            "# Arguments",
            "* `verbose`: bool - whether to show the loading bar."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_components_vector",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "match self.directed {\n            true => self.spanning_arborescence_kruskal(verbose).1,\n            false => self.connected_components(verbose).unwrap().0,\n        }",
        "doc": [
            "Returns number of directed edges in the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_directed_edges_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.edges.len() as EdgeT",
        "doc": [
            "Returns number of edge types in the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_types_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "EdgeTypeT",
        "body": "self.edge_types\n            .as_ref()\n            .map_or(0, |ets| ets.len() as EdgeTypeT)",
        "doc": [
            "Returns number of node types in the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_types_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "NodeTypeT",
        "body": "self.node_types\n            .as_ref()\n            .map_or(0, |nts| nts.len() as NodeTypeT)",
        "doc": [
            "Returns the degree of every node in the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_degrees",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "self.iter_node_degrees().collect()",
        "doc": [
            "Return set of nodes that are not singletons."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_not_singletons",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "self.iter_edge_ids(false)\n            .flat_map(|(_, src, dst)| once(src).chain(once(dst)))\n            .unique()\n            .collect()",
        "doc": [
            "Return mapping from instance not trap nodes to dense nodes."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_dense_node_mapping",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "HashMap<NodeT, NodeT>",
        "body": "self.get_not_singletons()\n            .into_iter()\n            .enumerate()\n            .map(|(i, node)| (node as NodeT, i as NodeT))\n            .collect()",
        "doc": [
            "Return if there are multiple edges between two nodes"
        ]
    },
    {
        "modifiers": "pub",
        "name": "is_multigraph",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_multigraph_edges_number() > 0",
        "doc": [
            "Return number of edges that have multigraph syblings."
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_multigraph_edges_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.get_directed_edges_number() - self.unique_edges_number",
        "doc": [
            "Return vector with node degrees"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_outbounds",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Vec<EdgeT>",
        "body": "(0..self.get_nodes_number())\n            .into_par_iter()\n            .map(|src| self.get_unchecked_edge_id_from_tuple(src as NodeT + 1, 0))\n            .collect()",
        "doc": [
            "Returns number of the source nodes.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of sources of the graph (not trap nodes) is {}\", graph.get_unique_source_nodes_number());",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_unique_source_nodes_number",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.unique_sources\n            .as_ref()\n            .map_or(self.get_nodes_number(), |x| x.len() as NodeT)",
        "doc": [
            "Returns edge type counts.",
            "",
            "# Arguments",
            "",
            "None",
            "",
            "# Examples",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "for (edge_type_id, count) in graph.get_edge_type_counts().unwrap().iter() {",
            "println!(\"edge type id {}: count: {}\", edge_type_id, count);",
            "}",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_type_counts",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<Counter<EdgeTypeT, usize>, String>",
        "body": "if let Some(et) = &self.edge_types {\n            Ok(Counter::init(\n                et.ids.iter().filter_map(|edge_type| *edge_type),\n            ))\n        } else {\n            Err(String::from(\n                \"Edge types are not defined for current graph instance.\",\n            ))\n        }",
        "doc": [
            "Returns edge type counts hashmap.",
            "",
            "# Arguments",
            "",
            "None",
            "",
            "# Examples",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "for (edge_type_id, count) in graph.get_edge_type_counts().unwrap().iter() {",
            "println!(\"edge type id {}: count: {}\", edge_type_id, count);",
            "}",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_edge_type_counts_hashmap",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<HashMap<EdgeTypeT, usize>, String>",
        "body": "Ok(self.get_edge_type_counts()?.into_map())",
        "doc": [
            "Returns node type counts.",
            "",
            "# Arguments",
            "",
            "None",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "for (node_type_id, count) in graph.get_node_type_counts().unwrap().iter() {",
            "println!(\"node type id {}: count: {}\", node_type_id, count);",
            "}",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_type_counts",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<Counter<NodeTypeT, usize>, String>",
        "body": "if let Some(nt) = &self.node_types {\n            Ok(Counter::init(\n                nt.ids\n                    .iter()\n                    .filter_map(|node_type| node_type.clone())\n                    .flatten(),\n            ))\n        } else {\n            Err(String::from(\n                \"Node types are not defined for current graph instance.\",\n            ))\n        }",
        "doc": [
            "Returns node type counts hashmap.",
            "",
            "# Arguments",
            "",
            "None",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "for (node_type_id, count) in graph.get_node_type_counts().unwrap().iter() {",
            "println!(\"node type id {}: count: {}\", node_type_id, count);",
            "}",
            "```"
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_type_counts_hashmap",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<HashMap<EdgeTypeT, usize>, String>",
        "body": "Ok(self.get_node_type_counts()?.into_map())",
        "doc": [
            "Returns range of the edge ids of edges starting from the given source node.",
            "",
            "# Arguments",
            "",
            "* `src` - Source node of the edge.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "get_node_type_counts_hashmap",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Result<HashMap<EdgeTypeT, usize>, String>",
        "body": "Ok(self.get_node_type_counts()?.into_map())",
        "doc": [
            "Returns range of the edge ids of edges starting from the given source node.",
            "",
            "# Arguments",
            "",
            "* `src` - Source node of the edge.",
            ""
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "iter_unchecked_edge_ids_by_source_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ]
        ],
        "return_type": "impl Iterator<Item = EdgeT>+ '_",
        "body": "let (min_edge_id, max_edge_id) = self.get_minmax_edge_ids_by_source_node_id(src);\n        min_edge_id..max_edge_id",
        "doc": [
            "Return iterator on the node degrees of the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_node_degrees",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "impl Iterator<Item = NodeT>+ '_",
        "body": "(0..self.get_nodes_number()).map(move |node| self.get_node_degree_by_node_id(node).unwrap())",
        "doc": [
            "Return iterator on the node degrees of the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "par_iter_node_degrees",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = NodeT>+ '_",
        "body": "(0..self.get_nodes_number())\n            .into_par_iter()\n            .map(move |node| self.get_node_degree_by_node_id(node).unwrap())",
        "doc": [
            "Return iterator over NodeT of destinations of the given node src."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "iter_node_neighbours_ids",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "src",
                "NodeT"
            ]
        ],
        "return_type": "impl Iterator<Item = NodeT>+ '_",
        "body": "// TODO this could be replaced with the new elias-fano iters\n        self.iter_unchecked_edge_ids_by_source_node_id(src)\n            .map(move |edge_id| self.get_destination_node_id_by_edge_id(edge_id).unwrap())",
        "doc": [
            "Return iterator over NodeT of destinations of the given node src."
        ]
    },
    {
        "modifiers": "pub(crate)",
        "name": "iter_node_neighbours",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "src",
                "NodeT"
            ]
        ],
        "return_type": "impl Iterator<Item = String>+ '_",
        "body": "self.iter_unchecked_edge_ids_by_source_node_id(src)\n            .map(move |edge_id| {\n                self.get_unchecked_node_name_by_node_id(\n                    self.get_destination_node_id_by_edge_id(edge_id).unwrap(),\n                )\n            })",
        "doc": [
            "Return iterator on the (non unique) source nodes of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_sources_ids",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<Item = NodeT>+ '_",
        "body": "self.iter_edge_ids(directed).map(move |(_, src, _)| src)",
        "doc": [
            "Return parallel iterator on the (non unique) source nodes of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "par_iter_sources_ids",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = NodeT>+ '_",
        "body": "self.par_iter_edge_ids(directed).map(move |(_, src, _)| src)",
        "doc": [
            "Return iterator on the (non unique) destination nodes of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_destinations_ids",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<Item = NodeT>+ '_",
        "body": "self.iter_edge_ids(directed).map(move |(_, _, dst)| dst)",
        "doc": [
            "Return parallel iterator on the (non unique) destination nodes of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "par_iter_destinations_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = NodeT>+ '_",
        "body": "self.par_iter_edge_ids(directed).map(move |(_, _, dst)| dst)",
        "doc": [
            "Return iterator on the node of the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_node_ids",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "impl Iterator<Item = (NodeT, Option<Vec<NodeTypeT>>)>+ '_",
        "body": "(0..self.get_nodes_number())\n            .map(move |node_id| (node_id, self.get_unchecked_node_type_id_by_node_id(node_id)))",
        "doc": [
            "Return iterator on the node of the graph as Strings."
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_nodes",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "impl Iterator<Item = (NodeT, String, Option<Vec<NodeTypeT>>, Option<Vec<String>>)>+ '_",
        "body": "self.iter_node_ids().map(move |(node_id, node_types)| {\n            (\n                node_id,\n                self.nodes.unchecked_translate(node_id),\n                node_types,\n                self.get_node_type_name_by_node_id(node_id).unwrap_or(None),\n            )\n        })",
        "doc": [
            "Return iterator on the edges of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_edge_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Box<dyn Iterator<Item = (EdgeT, NodeT, NodeT)> + '_>",
        "body": "if self.sources.is_some() && self.destinations.is_some() {\n            return Box::new(\n                (0..self.get_directed_edges_number()).filter_map(move |edge_id| {\n                    let (src, dst) = self.get_node_ids_from_edge_id(edge_id);\n                    if !directed && src > dst {\n                        return None;\n                    }\n                    Some((edge_id, src, dst))\n                }),\n            );\n        }\n        Box::new(\n            self.edges\n                .iter()\n                .enumerate()\n                .filter_map(move |(edge_id, edge)| {\n                    let (src, dst) = self.decode_edge(edge);\n                    if !directed && src > dst {\n                        return None;\n                    }\n                    Some((edge_id as EdgeT, src, dst))\n                }),\n        )",
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_edges",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<Item = (EdgeT, NodeT, String, NodeT, String)>+ '_",
        "body": "self.iter_edge_ids(directed)\n            .map(move |(edge_id, src, dst)| {\n                (\n                    edge_id,\n                    src,\n                    self.get_unchecked_node_name_by_node_id(src),\n                    dst,\n                    self.get_unchecked_node_name_by_node_id(dst),\n                )\n            })",
        "doc": [
            "Return iterator on the edges of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "par_iter_edge_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = (EdgeT, NodeT, NodeT)>+ '_",
        "body": "self.edges\n            .par_enumerate()\n            .filter_map(move |(edge_id, edge)| {\n                let (src, dst) = self.decode_edge(edge);\n                if !directed && src > dst {\n                    return None;\n                }\n                Some((edge_id as EdgeT, src, dst))\n            })",
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "par_iter_edges",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = (EdgeT, NodeT, String, NodeT, String)>+ '_",
        "body": "self.par_iter_edge_ids(directed)\n            .map(move |(edge_id, src, dst)| {\n                (\n                    edge_id,\n                    src,\n                    self.get_unchecked_node_name_by_node_id(src),\n                    dst,\n                    self.get_unchecked_node_name_by_node_id(dst),\n                )\n            })",
        "doc": [
            "Return iterator on the edges of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_edges_with_type_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>)>+ '_",
        "body": "self.iter_edge_ids(directed)\n            .map(move |(edge_id, src, dst)| {\n                (\n                    edge_id,\n                    src,\n                    dst,\n                    self.get_unchecked_edge_type_by_edge_id(edge_id),\n                )\n            })",
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_edges_with_type",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<\n        Item = (\n            EdgeT,\n            NodeT,\n            String,\n            NodeT,\n            String,\n            Option<EdgeTypeT>,\n            Option<String>,\n        ),\n    >+ '_",
        "body": "self.iter_edges(directed)\n            .map(move |(edge_id, src, src_name, dst, dst_name)| {\n                let edge_type_id = self.get_unchecked_edge_type_by_edge_id(edge_id);\n                (\n                    edge_id,\n                    src,\n                    src_name,\n                    dst,\n                    dst_name,\n                    edge_type_id,\n                    self.get_unchecked_edge_type_name_by_edge_type_id(edge_type_id),\n                )\n            })",
        "doc": [
            "Return iterator on the edges of the graph with the ids and string name.",
            "The result is (edge_id, src, src_name, dst, dst_name, edge_type, edge_type_name)",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "par_iter_edge_with_type",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<\n        Item = (\n            EdgeT,\n            NodeT,\n            String,\n            NodeT,\n            String,\n            Option<EdgeTypeT>,\n            Option<String>,\n        ),\n    >+ '_",
        "body": "self.par_iter_edges(directed)\n            .map(move |(edge_id, src, src_name, dst, dst_name)| {\n                let edge_type_id = self.get_unchecked_edge_type_by_edge_id(edge_id);\n                (\n                    edge_id,\n                    src,\n                    src_name,\n                    dst,\n                    dst_name,\n                    edge_type_id,\n                    self.get_unchecked_edge_type_name_by_edge_type_id(edge_type_id),\n                )\n            })",
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "par_iter_edge_with_type_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>)>+ '_",
        "body": "self.par_iter_edge_ids(directed)\n            .map(move |(edge_id, src, dst)| {\n                (\n                    edge_id,\n                    src,\n                    dst,\n                    self.get_unchecked_edge_type_by_edge_id(edge_id),\n                )\n            })",
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "par_iter_edge_with_type_and_weight",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<\n        Item = (\n            EdgeT,\n            NodeT,\n            String,\n            NodeT,\n            String,\n            Option<EdgeTypeT>,\n            Option<String>,\n            Option<WeightT>,\n        ),\n    >+ '_",
        "body": "self.par_iter_edge_with_type(directed).map(\n            move |(edge_id, src, src_name, dst, dst_name, edge_type, edge_type_name)| {\n                (\n                    edge_id,\n                    src,\n                    src_name,\n                    dst,\n                    dst_name,\n                    edge_type,\n                    edge_type_name,\n                    self.get_unchecked_weight_by_edge_id(edge_id),\n                )\n            },\n        )",
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_edge_with_type_and_weight",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<\n        Item = (\n            EdgeT,\n            NodeT,\n            String,\n            NodeT,\n            String,\n            Option<EdgeTypeT>,\n            Option<String>,\n            Option<WeightT>,\n        ),\n    >+ '_",
        "body": "self.iter_edges_with_type(directed).map(\n            move |(edge_id, src, src_name, dst, dst_name, edge_type, edge_type_name)| {\n                (\n                    edge_id,\n                    src,\n                    src_name,\n                    dst,\n                    dst_name,\n                    edge_type,\n                    edge_type_name,\n                    self.get_unchecked_weight_by_edge_id(edge_id),\n                )\n            },\n        )",
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "par_iter_edge_with_type_and_weight_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>)>+ '_",
        "body": "self.par_iter_edge_with_type_ids(directed)\n            .map(move |(edge_id, src, dst, edge_type)| {\n                (\n                    edge_id,\n                    src,\n                    dst,\n                    edge_type,\n                    self.get_unchecked_weight_by_edge_id(edge_id),\n                )\n            })",
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_edge_with_type_and_weight_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>)>+ '_",
        "body": "self.iter_edges_with_type_ids(directed)\n            .map(move |(edge_id, src, dst, edge_type)| {\n                (\n                    edge_id,\n                    src,\n                    dst,\n                    edge_type,\n                    self.get_unchecked_weight_by_edge_id(edge_id),\n                )\n            })",
        "doc": [
            "Return iterator on the edges of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool, whether to filter out the undirected edges."
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_unique_edges",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Box<dyn Iterator<Item = (NodeT, NodeT)> + '_>",
        "body": "if self.sources.is_some() && self.destinations.is_some() {\n            return Box::new(\n                (0..self.get_directed_edges_number()).filter_map(move |edge_id| {\n                    let (src, dst) = self.get_node_ids_from_edge_id(edge_id);\n                    if edge_id > 0 {\n                        let (last_src, last_dst) = self.get_node_ids_from_edge_id(edge_id - 1);\n                        if last_src == src && last_dst == dst {\n                            return None;\n                        }\n                    }\n                    if !directed && src > dst {\n                        return None;\n                    }\n                    Some((src, dst))\n                }),\n            );\n        }\n        Box::new(self.edges.iter_uniques().filter_map(move |edge| {\n            let (src, dst) = self.decode_edge(edge);\n            if !directed && src > dst {\n                return None;\n            }\n            Some((src, dst))\n        }))",
        "doc": [
            "Return iterator on the unique sources of the graph."
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_unique_sources",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Box<dyn Iterator<Item = NodeT> + '_>",
        "body": "if let Some(x) = &self.unique_sources {\n            return Box::new(x.iter().map(|source| source as NodeT));\n        }\n        Box::new((0..self.get_nodes_number()).map(|source| source))",
        "doc": [
            "Return graph renderized from given files.",
            "",
            "# Arguments",
            "",
            "* `edge_file_reader`: EdgeFileReader - Reader of the edge file.",
            "* `node_file_reader`: Option<NodeFileReader> - Reader of the node file.",
            "* `directed`: bool - whether the graph is to be read as directed or undirected.",
            "* `directed_edge_list`: bool - whether to read the edge list as directed.",
            "TODO UPDATE!!"
        ]
    },
    {
        "modifiers": "pub",
        "name": "iter_unique_sources",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "Box<dyn Iterator<Item = NodeT> + '_>",
        "body": "if let Some(x) = &self.unique_sources {\n            return Box::new(x.iter().map(|source| source as NodeT));\n        }\n        Box::new((0..self.get_nodes_number()).map(|source| source))",
        "doc": [
            "Return graph renderized from given files.",
            "",
            "# Arguments",
            "",
            "* `edge_file_reader`: EdgeFileReader - Reader of the edge file.",
            "* `node_file_reader`: Option<NodeFileReader> - Reader of the node file.",
            "* `directed`: bool - whether the graph is to be read as directed or undirected.",
            "* `directed_edge_list`: bool - whether to read the edge list as directed.",
            "TODO UPDATE!!"
        ]
    },
    {
        "modifiers": "pub",
        "name": "from_sorted_csv",
        "generics": "S: Clone + Into<String>",
        "args": [
            [
                "edge_file_reader",
                "EdgeFileReader"
            ],
            [
                "node_file_reader",
                "Option<NodeFileReader>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ],
            [
                "edges_number",
                "usize"
            ],
            [
                "nodes_number",
                "NodeT"
            ],
            [
                "name",
                "S"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "edge_file_reader = edge_file_reader.set_graph_name(name.clone().into());\n        node_file_reader = node_file_reader.map(|nfr| nfr.set_graph_name(name.clone().into()));\n        Graph::from_string_sorted(\n            edge_file_reader.read_lines()?,\n            node_file_reader\n                .as_ref()\n                .map_or(Ok::<_, String>(None), |nfr| Ok(Some(nfr.read_lines()?)))?,\n            directed,\n            directed_edge_list,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.ignore_duplicates),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.csv_is_correct),\n            edge_file_reader.reader.ignore_duplicates,\n            edge_file_reader.reader.csv_is_correct,\n            edges_number,\n            nodes_number,\n            edge_file_reader.numeric_edge_type_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_ids),\n            edge_file_reader.numeric_node_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_type_ids),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.has_node_types()),\n            edge_file_reader.has_edge_types(),\n            edge_file_reader.has_weights(),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.might_have_singletons),\n            edge_file_reader.might_have_singletons_with_selfloops,\n            edge_file_reader.might_have_trap_nodes,\n            name,\n        )",
        "doc": [
            "Return graph renderized from given files.",
            "",
            "# Arguments",
            "",
            "* `edge_file_reader`: EdgeFileReader - Reader of the edge file.",
            "* `node_file_reader`: Option<NodeFileReader> - Reader of the node file.",
            "* `directed`: bool - whether the graph is to be read as directed or undirected.",
            "* `directed_edge_list`: bool - whether to read the edge list as directed."
        ]
    },
    {
        "modifiers": "pub",
        "name": "from_unsorted_csv",
        "generics": "S: Clone + Into<String>",
        "args": [
            [
                "edge_file_reader",
                "EdgeFileReader"
            ],
            [
                "node_file_reader",
                "Option<NodeFileReader>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ],
            [
                "name",
                "S"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "edge_file_reader = edge_file_reader.set_graph_name(name.clone().into());\n        node_file_reader = node_file_reader.map(|nfr| nfr.set_graph_name(name.clone().into()));\n        Graph::from_string_unsorted(\n            edge_file_reader.read_lines()?,\n            node_file_reader\n                .as_ref()\n                .map_or(Ok::<_, String>(None), |nfr| Ok(Some(nfr.read_lines()?)))?,\n            directed,\n            directed_edge_list,\n            name,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.ignore_duplicates),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.csv_is_correct),\n            edge_file_reader.reader.ignore_duplicates,\n            edge_file_reader.reader.csv_is_correct,\n            edge_file_reader.reader.verbose,\n            edge_file_reader.numeric_edge_type_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_ids),\n            edge_file_reader.numeric_node_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_type_ids),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.has_node_types()),\n            edge_file_reader.has_edge_types(),\n            edge_file_reader.has_weights(),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.might_have_singletons),\n            edge_file_reader.might_have_singletons_with_selfloops,\n            edge_file_reader.might_have_trap_nodes,\n        )"
    },
    {
        "modifiers": "pub",
        "name": "from_unsorted_csv",
        "generics": "S: Clone + Into<String>",
        "args": [
            [
                "edge_file_reader",
                "EdgeFileReader"
            ],
            [
                "node_file_reader",
                "Option<NodeFileReader>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ],
            [
                "name",
                "S"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "edge_file_reader = edge_file_reader.set_graph_name(name.clone().into());\n        node_file_reader = node_file_reader.map(|nfr| nfr.set_graph_name(name.clone().into()));\n        Graph::from_string_unsorted(\n            edge_file_reader.read_lines()?,\n            node_file_reader\n                .as_ref()\n                .map_or(Ok::<_, String>(None), |nfr| Ok(Some(nfr.read_lines()?)))?,\n            directed,\n            directed_edge_list,\n            name,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.ignore_duplicates),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.csv_is_correct),\n            edge_file_reader.reader.ignore_duplicates,\n            edge_file_reader.reader.csv_is_correct,\n            edge_file_reader.reader.verbose,\n            edge_file_reader.numeric_edge_type_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_ids),\n            edge_file_reader.numeric_node_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_type_ids),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.has_node_types()),\n            edge_file_reader.has_edge_types(),\n            edge_file_reader.has_weights(),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.might_have_singletons),\n            edge_file_reader.might_have_singletons_with_selfloops,\n            edge_file_reader.might_have_trap_nodes,\n        )"
    },
    {
        "modifiers": "pub",
        "name": "compute_hash",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "u64",
        "body": "let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        hasher.finish()"
    },
    {
        "modifiers": "pub",
        "name": "compute_hash",
        "args": [
            [
                "self",
                "self"
            ]
        ],
        "return_type": "u64",
        "body": "let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        hasher.finish()"
    },
    {
        "modifiers": "pub(crate)",
        "name": "build_graph",
        "generics": "S: Into<String>",
        "args": [
            [
                "edges_iter",
                "impl Iterator<Item = Result<Quadruple, String>>"
            ],
            [
                "edges_number",
                "usize"
            ],
            [
                "nodes",
                "Vocabulary<NodeT>"
            ],
            [
                "node_types",
                "Option<NodeTypeVocabulary>"
            ],
            [
                "edge_types_vocabulary",
                "Option<Vocabulary<EdgeTypeT>>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "edge_list_is_correct",
                "bool"
            ],
            [
                "name",
                "S"
            ],
            [
                "ignore_duplicated_edges",
                "bool"
            ],
            [
                "has_edge_types",
                "bool"
            ],
            [
                "has_weights",
                "bool"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "let (\n            edges,\n            unique_sources,\n            edge_types,\n            weights,\n            unique_edges_number,\n            self_loop_number,\n            unique_self_loop_number,\n            not_singleton_nodes_number,\n            singleton_nodes_with_self_loops_number,\n            node_bit_mask,\n            node_bits,\n        ) = parse_integer_edges(\n            edges_iter,\n            edges_number,\n            nodes.len() as NodeT,\n            edge_types_vocabulary,\n            ignore_duplicated_edges,\n            directed,\n            edge_list_is_correct,\n            has_edge_types,\n            has_weights,\n            might_have_singletons,\n            might_have_singletons_with_selfloops,\n            might_have_trap_nodes,\n        )?;\n\n        Ok(Graph::new(\n            directed,\n            unique_self_loop_number,\n            self_loop_number,\n            not_singleton_nodes_number,\n            singleton_nodes_with_self_loops_number,\n            unique_edges_number,\n            edges,\n            unique_sources,\n            nodes,\n            node_bit_mask,\n            node_bits,\n            edge_types,\n            name,\n            weights,\n            node_types,\n        ))",
        "doc": [
            "Create new Graph object from unsorted source.",
            "",
            "# Arguments",
            "",
            "TODO: UPDATE THE DOCSTRING!",
            "",
            "* edges_iterator: impl Iterator<Item = Result<StringQuadruple, String>>,",
            "Iterator of the edges.",
            "* nodes_iterator: Option<impl Iterator<Item = Result<(String, Option<String>), String>>>,",
            "Iterator of the nodes.",
            "* directed: bool,",
            "Wether the graph should be directed or undirected.",
            "* ignore_duplicated_nodes: bool,",
            "Wether to ignore duplicated nodes or to raise a proper exception.",
            "* ignore_duplicated_edges: bool,",
            "Wether to ignore duplicated edges or to raise a proper exception.",
            "* skip_self_loops: bool,",
            "Wether to skip self loops while reading the the edges iterator."
        ]
    },
    {
        "modifiers": "pub",
        "name": "from_string_unsorted",
        "generics": "S: Into<String>",
        "args": [
            [
                "edges_iterator",
                "impl Iterator<Item = Result<StringQuadruple, String>>"
            ],
            [
                "nodes_iterator",
                "Option<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>>>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ],
            [
                "name",
                "S"
            ],
            [
                "ignore_duplicated_nodes",
                "bool"
            ],
            [
                "node_list_is_correct",
                "bool"
            ],
            [
                "ignore_duplicated_edges",
                "bool"
            ],
            [
                "edge_list_is_correct",
                "bool"
            ],
            [
                "verbose",
                "bool"
            ],
            [
                "numeric_edge_type_ids",
                "bool"
            ],
            [
                "numeric_node_ids",
                "bool"
            ],
            [
                "numeric_edge_node_ids",
                "bool"
            ],
            [
                "numeric_node_types_ids",
                "bool"
            ],
            [
                "has_node_types",
                "bool"
            ],
            [
                "has_edge_types",
                "bool"
            ],
            [
                "has_weights",
                "bool"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "check_numeric_ids_compatibility(\n            nodes_iterator.is_some(),\n            numeric_node_ids,\n            numeric_edge_node_ids,\n        )?;\n\n        let (nodes, node_types) = parse_nodes(\n            nodes_iterator,\n            ignore_duplicated_nodes,\n            node_list_is_correct,\n            numeric_node_ids,\n            numeric_node_types_ids,\n            numeric_edge_node_ids,\n            has_node_types,\n        )?;\n\n        // This is not equivalent to nodes_iterator.is_some() because the iterator\n        // could also be empty, this is a corner-case that might happen when over-filtering\n        // or fuzzing or loading an empty file with improper configurations.\n        // There might be singletons if the user has told us that there might be singletons\n        // and the node list is not empty. If the node list is empty, then it is not possible\n        // to have singletons.\n        let might_have_singletons = !nodes.is_empty() && might_have_singletons;\n        // If the graph is undirected there cannot be trap nodes\n        let might_have_trap_nodes = directed && might_have_trap_nodes;\n\n        info!(\"Parse unsorted edges.\");\n        // TODO: ADD USE OF edge_list_is_correct\n        let (edges_number, edges_iterator, nodes, edge_types_vocabulary) =\n            parse_string_unsorted_edges(\n                edges_iterator,\n                nodes,\n                directed,\n                directed_edge_list,\n                edge_list_is_correct,\n                has_edge_types,\n                verbose,\n                numeric_edge_type_ids,\n            )?;\n\n        Graph::build_graph(\n            edges_iterator,\n            edges_number,\n            nodes,\n            node_types,\n            edge_types_vocabulary,\n            directed,\n            edge_list_is_correct || !directed_edge_list,\n            name,\n            ignore_duplicated_edges,\n            has_edge_types,\n            has_weights,\n            might_have_singletons,\n            might_have_singletons_with_selfloops,\n            might_have_trap_nodes,\n        )",
        "doc": [
            "Create new Graph object from unsorted source.",
            "",
            "# Arguments",
            "",
            "* edges_iterator: impl Iterator<Item = Result<StringQuadruple, String>>,",
            "Iterator of the edges.",
            "* nodes_iterator: Option<impl Iterator<Item = Result<(String, Option<String>), String>>>,",
            "Iterator of the nodes.",
            "* directed: bool,",
            "Wether the graph should be directed or undirected.",
            "* ignore_duplicated_nodes: bool,",
            "Wether to ignore duplicated nodes or to raise a proper exception.",
            "* ignore_duplicated_edges: bool,",
            "Wether to ignore duplicated edges or to raise a proper exception.",
            "* skip_self_loops: bool,",
            "Wether to skip self loops while reading the the edges iterator."
        ]
    },
    {
        "modifiers": "pub",
        "name": "from_integer_unsorted",
        "args": [
            [
                "edges_iterator",
                "impl Iterator<\n            Item = Result<(NodeT, NodeT, Option<NodeTypeT>, Option<WeightT>), String>,\n        >"
            ],
            [
                "nodes",
                "Vocabulary<NodeT>"
            ],
            [
                "node_types",
                "Option<NodeTypeVocabulary>"
            ],
            [
                "edge_types_vocabulary",
                "Option<Vocabulary<EdgeTypeT>>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "name",
                "String"
            ],
            [
                "ignore_duplicated_edges",
                "bool"
            ],
            [
                "has_edge_types",
                "bool"
            ],
            [
                "has_weights",
                "bool"
            ],
            [
                "verbose",
                "bool"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "let (edges_number, edges_iterator) =\n            parse_integer_unsorted_edges(edges_iterator, directed, true, verbose)?;\n\n        Graph::build_graph(\n            edges_iterator,\n            edges_number,\n            nodes,\n            node_types,\n            edge_types_vocabulary,\n            directed,\n            true,\n            name,\n            ignore_duplicated_edges,\n            has_edge_types,\n            has_weights,\n            might_have_singletons,\n            might_have_singletons_with_selfloops,\n            might_have_trap_nodes,\n        )",
        "doc": [
            "Create new Graph object from sorted sources."
        ]
    },
    {
        "modifiers": "pub",
        "name": "from_string_sorted",
        "generics": "S: Into<String>",
        "args": [
            [
                "edges_iterator",
                "impl Iterator<Item = Result<StringQuadruple, String>>"
            ],
            [
                "nodes_iterator",
                "Option<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>>>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ],
            [
                "ignore_duplicated_nodes",
                "bool"
            ],
            [
                "node_list_is_correct",
                "bool"
            ],
            [
                "ignore_duplicated_edges",
                "bool"
            ],
            [
                "edge_list_is_correct",
                "bool"
            ],
            [
                "edges_number",
                "usize"
            ],
            [
                "nodes_number",
                "NodeT"
            ],
            [
                "numeric_edge_type_ids",
                "bool"
            ],
            [
                "numeric_node_ids",
                "bool"
            ],
            [
                "numeric_edge_node_ids",
                "bool"
            ],
            [
                "numeric_node_types_ids",
                "bool"
            ],
            [
                "has_node_types",
                "bool"
            ],
            [
                "has_edge_types",
                "bool"
            ],
            [
                "has_weights",
                "bool"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ],
            [
                "name",
                "S"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "check_numeric_ids_compatibility(\n            nodes_iterator.is_some(),\n            numeric_node_ids,\n            numeric_edge_node_ids,\n        )?;\n        let (nodes, node_types) = parse_nodes(\n            nodes_iterator,\n            ignore_duplicated_nodes,\n            node_list_is_correct,\n            numeric_node_ids,\n            numeric_node_types_ids,\n            numeric_edge_node_ids,\n            has_node_types,\n        )?;\n\n        if !nodes.is_empty() {\n            nodes_number = nodes.len() as NodeT;\n        }\n\n        let (\n            edges,\n            unique_sources,\n            nodes,\n            edge_types,\n            weights,\n            unique_edges_number,\n            self_loop_number,\n            unique_self_loop_number,\n            not_singleton_nodes_number,\n            singleton_nodes_with_self_loops_number,\n            node_bit_mask,\n            node_bits,\n        ) = parse_string_edges(\n            edges_iterator,\n            edges_number,\n            nodes_number,\n            directed,\n            nodes,\n            numeric_edge_type_ids,\n            directed_edge_list,\n            edge_list_is_correct,\n            ignore_duplicated_edges,\n            has_edge_types,\n            has_weights,\n            might_have_singletons,\n            might_have_singletons_with_selfloops,\n            might_have_trap_nodes,\n        )?;\n\n        Ok(Graph::new(\n            directed,\n            unique_self_loop_number,\n            self_loop_number,\n            not_singleton_nodes_number,\n            singleton_nodes_with_self_loops_number,\n            unique_edges_number,\n            edges,\n            unique_sources,\n            nodes,\n            node_bit_mask,\n            node_bits,\n            edge_types,\n            name,\n            weights,\n            node_types,\n        ))",
        "doc": [
            "Returns Graph with given amount of negative edges as positive edges.",
            "",
            "The graph generated may be used as a testing negatives partition to be",
            "fed into the argument \"graph_to_avoid\" of the link_prediction or the",
            "skipgrams algorithm.",
            "",
            "",
            "# Arguments",
            "",
            "* `random_state`: EdgeT - random_state to use to reproduce negative edge set.",
            "* `negatives_number`: EdgeT - Number of negatives edges to include.",
            "* `seed_graph`: Option<Graph> - Optional graph to use to filter the negative edges. The negative edges generated when this variable is provided will always have a node within this graph.",
            "* `only_from_same_component`: bool - whether to sample negative edges only from nodes that are from the same component.",
            "* `verbose`: bool - whether to show the loading bar.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "from_string_sorted",
        "generics": "S: Into<String>",
        "args": [
            [
                "edges_iterator",
                "impl Iterator<Item = Result<StringQuadruple, String>>"
            ],
            [
                "nodes_iterator",
                "Option<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>>>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ],
            [
                "ignore_duplicated_nodes",
                "bool"
            ],
            [
                "node_list_is_correct",
                "bool"
            ],
            [
                "ignore_duplicated_edges",
                "bool"
            ],
            [
                "edge_list_is_correct",
                "bool"
            ],
            [
                "edges_number",
                "usize"
            ],
            [
                "nodes_number",
                "NodeT"
            ],
            [
                "numeric_edge_type_ids",
                "bool"
            ],
            [
                "numeric_node_ids",
                "bool"
            ],
            [
                "numeric_edge_node_ids",
                "bool"
            ],
            [
                "numeric_node_types_ids",
                "bool"
            ],
            [
                "has_node_types",
                "bool"
            ],
            [
                "has_edge_types",
                "bool"
            ],
            [
                "has_weights",
                "bool"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ],
            [
                "name",
                "S"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "check_numeric_ids_compatibility(\n            nodes_iterator.is_some(),\n            numeric_node_ids,\n            numeric_edge_node_ids,\n        )?;\n        let (nodes, node_types) = parse_nodes(\n            nodes_iterator,\n            ignore_duplicated_nodes,\n            node_list_is_correct,\n            numeric_node_ids,\n            numeric_node_types_ids,\n            numeric_edge_node_ids,\n            has_node_types,\n        )?;\n\n        if !nodes.is_empty() {\n            nodes_number = nodes.len() as NodeT;\n        }\n\n        let (\n            edges,\n            unique_sources,\n            nodes,\n            edge_types,\n            weights,\n            unique_edges_number,\n            self_loop_number,\n            unique_self_loop_number,\n            not_singleton_nodes_number,\n            singleton_nodes_with_self_loops_number,\n            node_bit_mask,\n            node_bits,\n        ) = parse_string_edges(\n            edges_iterator,\n            edges_number,\n            nodes_number,\n            directed,\n            nodes,\n            numeric_edge_type_ids,\n            directed_edge_list,\n            edge_list_is_correct,\n            ignore_duplicated_edges,\n            has_edge_types,\n            has_weights,\n            might_have_singletons,\n            might_have_singletons_with_selfloops,\n            might_have_trap_nodes,\n        )?;\n\n        Ok(Graph::new(\n            directed,\n            unique_self_loop_number,\n            self_loop_number,\n            not_singleton_nodes_number,\n            singleton_nodes_with_self_loops_number,\n            unique_edges_number,\n            edges,\n            unique_sources,\n            nodes,\n            node_bit_mask,\n            node_bits,\n            edge_types,\n            name,\n            weights,\n            node_types,\n        ))",
        "doc": [
            "Returns Graph with given amount of negative edges as positive edges.",
            "",
            "The graph generated may be used as a testing negatives partition to be",
            "fed into the argument \"graph_to_avoid\" of the link_prediction or the",
            "skipgrams algorithm.",
            "",
            "",
            "# Arguments",
            "",
            "* `random_state`: EdgeT - random_state to use to reproduce negative edge set.",
            "* `negatives_number`: EdgeT - Number of negatives edges to include.",
            "* `seed_graph`: Option<Graph> - Optional graph to use to filter the negative edges. The negative edges generated when this variable is provided will always have a node within this graph.",
            "* `only_from_same_component`: bool - whether to sample negative edges only from nodes that are from the same component.",
            "* `verbose`: bool - whether to show the loading bar.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "sample_negatives",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "EdgeT"
            ],
            [
                "negatives_number",
                "EdgeT"
            ],
            [
                "seed_graph",
                "Option<&Graph>"
            ],
            [
                "only_from_same_component",
                "bool"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "if negatives_number == 0 {\n            return Err(String::from(\"The number of negatives cannot be zero.\"));\n        }\n        let seed_nodes: Option<RoaringBitmap> = if let Some(sg) = &seed_graph {\n            if !self.overlaps(&sg)? {\n                return Err(String::from(\n                    \"The given seed graph does not overlap with the current graph instance.\",\n                ));\n            }\n            Some(\n                sg.iter_nodes()\n                    .map(|(_, node_name, _, _)| self.get_unchecked_node_id_by_node_name(&node_name))\n                    .collect::<RoaringBitmap>(),\n            )\n        } else {\n            None\n        };\n        // In a complete directed graph allowing selfloops with N nodes there are N^2\n        // edges. In a complete directed graph without selfloops there are N*(N-1) edges.\n        // We can rewrite the first formula as (N*(N-1)) + N.\n        //\n        // In a complete undirected graph allowing selfloops with N nodes there are\n        // (N*(N-1))/2 + N edges.\n\n        // Here we use unique edges number because on a multigraph the negative\n        // edges cannot have an edge type.\n        let nodes_number = self.get_nodes_number() as EdgeT;\n\n        // whether to sample negative edges only from the same connected component.\n        let (node_components, mut complete_edges_number) = if only_from_same_component {\n            let node_components = self.get_node_components_vector(verbose);\n            let complete_edges_number: EdgeT = Counter::init(node_components.clone())\n                .into_iter()\n                .map(|(_, nodes_number): (_, &usize)| {\n                    let mut edge_number = (*nodes_number * (*nodes_number - 1)) as EdgeT;\n                    if !self.is_directed() {\n                        edge_number /= 2;\n                    }\n                    edge_number\n                })\n                .sum();\n            (Some(node_components), complete_edges_number)\n        } else {\n            let mut edge_number = nodes_number * (nodes_number - 1);\n            if !self.is_directed() {\n                edge_number /= 2;\n            }\n            (None, edge_number)\n        };\n\n        // Here we compute the number of edges that a complete graph would have if it had the same number of nodes\n        // of the current graph. Moreover, the complete graph will have selfloops IFF the current graph has at\n        // least one of them.\n        if self.has_selfloops() {\n            complete_edges_number += nodes_number;\n        }\n\n        // Now we compute the maximum number of negative edges that we can actually generate\n        let max_negative_edges = complete_edges_number - self.get_unique_edges_number();\n\n        // We check that the number of requested negative edges is compatible with the\n        // current graph instance.\n        if negatives_number > max_negative_edges {\n            return Err(format!(\n                concat!(\n                    \"The requested negatives number {} is more than the \",\n                    \"number of negative edges that exist in the graph ({}).\"\n                ),\n                negatives_number, max_negative_edges\n            ));\n        }\n\n        // As the above check, it is not possible to generate some negative\n        // graphs when some conditions.\n        if negatives_number % 2 == 1 && !self.is_directed() && !self.has_selfloops() {\n            return Err(format!(\n                concat!(\n                    \"The requested negatives number {} is an odd number and \",\n                    \"the graph is neither directed nor has selfloops, so it is \",\n                    \"not possible to sample an odd number of edges.\"\n                ),\n                negatives_number\n            ));\n        }\n\n        let pb1 = get_loading_bar(\n            verbose,\n            \"Computing negative edges\",\n            negatives_number as usize,\n        );\n\n        // xorshift breaks if the random_state is zero\n        // so we initialize xor it with a constat\n        // to mitigate this problem\n        random_state ^= SEED_XOR as EdgeT;\n\n        let mut negative_edges_hashset = HashSet::with_capacity(negatives_number as usize);\n        let mut last_length = 0;\n        let mut sampling_round: usize = 0;\n\n        // randomly extract negative edges until we have the choosen number\n        while negative_edges_hashset.len() < negatives_number as usize {\n            // generate two random_states for reproducibility porpouses\n            let src_random_state = rand_u64(random_state);\n            let dst_random_state = rand_u64(src_random_state);\n            random_state = rand_u64(dst_random_state);\n\n            let tmp_tb = get_loading_bar(\n                verbose,\n                format!(\"Negatives sampling round {}\", sampling_round).as_ref(),\n                negatives_number as usize,\n            );\n            sampling_round += 1;\n\n            // generate the random edge-sources\n            let sampled_edge_ids = gen_random_vec(negatives_number as usize, src_random_state)\n                .into_par_iter()\n                .zip(gen_random_vec(negatives_number as usize, dst_random_state).into_par_iter())\n                // convert them to plain (src, dst)\n                .progress_with(tmp_tb)\n                .filter_map(|(src_seed, dst_seed)| {\n                    let src = sample_uniform(nodes_number as u64, src_seed as u64) as NodeT;\n                    let dst = sample_uniform(nodes_number as u64, dst_seed as u64) as NodeT;\n                    if !self.is_directed() && src > dst {\n                        return None;\n                    }\n\n                    if !self.has_selfloops() && src == dst {\n                        return None;\n                    }\n\n                    if let Some(sn) = &seed_nodes {\n                        if !sn.contains(src) && !sn.contains(dst) {\n                            return None;\n                        }\n                    }\n                    if let Some(ncs) = &node_components {\n                        if ncs[src as usize] != ncs[dst as usize] {\n                            return None;\n                        }\n                    }\n                    // If the edge is not a self-loop or the user allows self-loops and\n                    // the graph is directed or the edges are inserted in a way to avoid\n                    // inserting bidirectional edges.\n                    match self.has_edge_by_node_ids(src, dst) {\n                        true => None,\n                        false => Some(self.encode_edge(src, dst)),\n                    }\n                })\n                .collect::<Vec<EdgeT>>();\n\n            let pb3 = get_loading_bar(\n                verbose,\n                format!(\n                    \"Inserting negative graph edges (iteration {})\",\n                    sampling_round\n                )\n                .as_ref(),\n                negatives_number as usize,\n            );\n\n            for edge_id in sampled_edge_ids.iter().progress_with(pb3) {\n                if negative_edges_hashset.len() >= negatives_number as usize {\n                    break;\n                }\n                negative_edges_hashset.insert(*edge_id);\n            }\n\n            if sampling_round > 50000 {\n                panic!(\"Deadlock in sampling negatives!\");\n            }\n\n            pb1.inc((negative_edges_hashset.len() - last_length as usize) as u64);\n            last_length = negative_edges_hashset.len();\n        }\n\n        pb1.finish();\n\n        Graph::from_integer_unsorted(\n            negative_edges_hashset.into_iter().flat_map(|edge| {\n                let (src, dst) = self.decode_edge(edge);\n                if !self.is_directed() && src != dst {\n                    vec![Ok((src, dst, None, None)), Ok((dst, src, None, None))]\n                } else {\n                    vec![Ok((src, dst, None, None))]\n                }\n            }),\n            self.nodes.clone(),\n            self.node_types.clone(),\n            None,\n            self.directed,\n            format!(\"Negative {}\", self.name.clone()),\n            false,\n            false,\n            false,\n            verbose,\n            true,\n            self.has_selfloops(),\n            true,\n        )",
        "doc": [
            "Compute the training and validation elements number from the training rate"
        ]
    },
    {
        "modifiers": "",
        "name": "get_holdouts_elements_number",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "train_size",
                "f64"
            ],
            [
                "total_elements",
                "usize"
            ]
        ],
        "return_type": "Result<(usize, usize), String>",
        "body": "if train_size <= 0.0 || train_size >= 1.0 {\n            return Err(String::from(\"Train rate must be strictly between 0 and 1.\"));\n        }\n        if self.directed && self.get_directed_edges_number() == 1\n            || !self.directed && self.get_directed_edges_number() == 2\n        {\n            return Err(String::from(\n                \"The current graph instance has only one edge. You cannot build an holdout with one edge.\",\n            ));\n        }\n        let train_elements_number = (total_elements as f64 * train_size) as usize;\n        let valid_elements_number = total_elements - train_elements_number;\n\n        if train_elements_number == 0 || train_elements_number >= total_elements {\n            return Err(String::from(\n                \"The training set has 0 elements! Change the training rate.\",\n            ));\n        }\n        if valid_elements_number == 0 {\n            return Err(String::from(\n                \"The validation set has 0 elements! Change the training rate.\",\n            ));\n        }\n\n        Ok((train_elements_number, valid_elements_number))",
        "doc": [
            "Compute the training and validation edges number from the training rate"
        ]
    },
    {
        "modifiers": "",
        "name": "get_holdouts_edges_number",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "train_size",
                "f64"
            ],
            [
                "include_all_edge_types",
                "bool"
            ]
        ],
        "return_type": "Result<(EdgeT, EdgeT), String>",
        "body": "if self.directed && self.get_directed_edges_number() == 1\n            || !self.directed && self.get_directed_edges_number() == 2\n        {\n            return Err(String::from(\n                \"The current graph instance has only one edge. You cannot build an holdout with one edge.\",\n            ));\n        }\n        let total_edges_number = if include_all_edge_types {\n            self.unique_edges_number\n        } else {\n            self.get_directed_edges_number()\n        };\n\n        let (train_edges, test_edges) =\n            self.get_holdouts_elements_number(train_size, total_edges_number as usize)?;\n        Ok((train_edges as EdgeT, test_edges as EdgeT))"
    },
    {
        "modifiers": "",
        "name": "edge_holdout",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "EdgeT"
            ],
            [
                "valid_edges_number",
                "EdgeT"
            ],
            [
                "include_all_edge_types",
                "bool"
            ],
            [
                "user_condition",
                "impl Fn(EdgeT, NodeT, NodeT, Option<EdgeTypeT>) -> bool"
            ],
            [
                "verbose",
                "bool"
            ],
            [
                "train_graph_might_have_singletons",
                "bool"
            ],
            [
                "train_graph_might_have_singletons_with_selfloops",
                "bool"
            ]
        ],
        "return_type": "Result<(Graph, Graph), String>",
        "body": "let pb1 = get_loading_bar(\n            verbose,\n            \"Picking validation edges\",\n            valid_edges_number as usize,\n        );\n\n        // generate and shuffle the indices of the edges\n        let mut rng = SmallRng::seed_from_u64(random_state ^ SEED_XOR as EdgeT);\n        let mut edge_indices: Vec<EdgeT> = (0..self.get_directed_edges_number()).collect();\n        edge_indices.shuffle(&mut rng);\n\n        let mut valid_edges_bitmap = RoaringTreemap::new();\n        let mut last_length = 0;\n\n        for (edge_id, (src, dst, edge_type)) in edge_indices\n            .into_iter()\n            .map(|edge_id| (edge_id, self.get_edge_triple(edge_id)))\n        {\n            // If the graph is undirected and we have extracted an edge that is a\n            // simmetric one, we can skip this iteration.\n            if !self.directed && src > dst {\n                continue;\n            }\n\n            // We stop adding edges when we have reached the minimum amount.\n            if user_condition(edge_id, src, dst, edge_type) {\n                // Compute the forward edge ids that are required.\n                valid_edges_bitmap.extend(self.compute_edge_ids_vector(\n                    edge_id,\n                    src,\n                    dst,\n                    include_all_edge_types,\n                ));\n\n                // If the graph is undirected\n                if !self.directed {\n                    // we compute also the backward edge ids that are required.\n                    valid_edges_bitmap.extend(self.compute_edge_ids_vector(\n                        self.get_unchecked_edge_id_by_node_ids(dst, src, edge_type),\n                        dst,\n                        src,\n                        include_all_edge_types,\n                    ));\n                }\n                pb1.inc(valid_edges_bitmap.len() - last_length);\n                last_length = valid_edges_bitmap.len();\n            }\n\n            // We stop the iteration when we found all the edges.\n            if valid_edges_bitmap.len() >= valid_edges_number {\n                break;\n            }\n        }\n\n        if valid_edges_bitmap.len() < valid_edges_number {\n            let actual_valid_edges_number = valid_edges_bitmap.len();\n            return Err(format!(\n                concat!(\n                    \"With the given configuration for the holdout, it is not possible to \",\n                    \"generate a validation set composed of {valid_edges_number} edges from the current graph.\\n\",\n                    \"The validation set can be composed of at most {actual_valid_edges_number} edges.\\n\"\n                ),\n                valid_edges_number=valid_edges_number,\n                actual_valid_edges_number=actual_valid_edges_number,\n            ));\n        }\n\n        // Creating the loading bar for the building of both the training and validation.\n        let pb_valid = get_loading_bar(\n            verbose,\n            \"Building the valid partition\",\n            valid_edges_bitmap.len() as usize,\n        );\n        let pb_train = get_loading_bar(\n            verbose,\n            \"Building the train partition\",\n            (self.get_directed_edges_number() - valid_edges_bitmap.len()) as usize,\n        );\n\n        Ok((\n            Graph::build_graph(\n                (0..self.get_directed_edges_number())\n                    .filter(|edge_id| !valid_edges_bitmap.contains(*edge_id))\n                    .progress_with(pb_train)\n                    .map(|edge_id| Ok(self.get_edge_quadruple(edge_id))),\n                self.get_directed_edges_number() as usize - valid_edges_bitmap.len() as usize,\n                self.nodes.clone(),\n                self.node_types.clone(),\n                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n                self.directed,\n                true,\n                format!(\"{} training\", self.name.clone()),\n                true,\n                self.has_edge_types(),\n                self.has_weights(),\n                train_graph_might_have_singletons,\n                train_graph_might_have_singletons_with_selfloops,\n                true,\n            )?,\n            Graph::build_graph(\n                valid_edges_bitmap\n                    .iter()\n                    .progress_with(pb_valid)\n                    .map(|edge_id| Ok(self.get_edge_quadruple(edge_id))),\n                valid_edges_bitmap.len() as usize,\n                self.nodes.clone(),\n                self.node_types.clone(),\n                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n                self.directed,\n                true,\n                format!(\"{} testing\", self.name.clone()),\n                true,\n                self.has_edge_types(),\n                self.has_weights(),\n                true,\n                self.has_selfloops(),\n                true,\n            )?,\n        ))",
        "doc": [
            "Returns holdout for training ML algorithms on the graph structure.",
            "",
            "The holdouts returned are a tuple of graphs. The first one, which",
            "is the training graph, is garanteed to have the same number of",
            "graph components as the initial graph. The second graph is the graph",
            "meant for testing or validation of the algorithm, and has no garantee",
            "to be connected. It will have at most (1-train_size) edges,",
            "as the bound of connectivity which is required for the training graph",
            "may lead to more edges being left into the training partition.",
            "",
            "In the option where a list of edge types has been provided, these",
            "edge types will be those put into the validation set.",
            "",
            "# Arguments",
            "",
            "* `random_state`: NodeT - The random_state to use for the holdout,",
            "* `train_size`: f64 - Rate target to reserve for training.",
            "* `edge_types`: Option<Vec<String>> - Edge types to be selected for in the validation set.",
            "* `include_all_edge_types`: bool - whether to include all the edges between two nodes.",
            "* `verbose`: bool - whether to show the loading bar.",
            "",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "connected_holdout",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "EdgeT"
            ],
            [
                "train_size",
                "f64"
            ],
            [
                "edge_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "include_all_edge_types",
                "bool"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(Graph, Graph), String>",
        "body": "if train_size <= 0.0 || train_size >= 1.0 {\n            return Err(String::from(\"Train rate must be strictly between 0 and 1.\"));\n        }\n\n        let edge_type_ids = edge_types.map_or(Ok::<_, String>(None), |ets| {\n            Ok(Some(\n                self.get_edge_type_ids_by_edge_type_names(ets)?\n                    .into_iter()\n                    .collect::<HashSet<Option<EdgeTypeT>>>(),\n            ))\n        })?;\n\n        let tree = self\n            .random_spanning_arborescence_kruskal(random_state, &edge_type_ids, verbose)\n            .0;\n\n        let edge_factor = if self.is_directed() { 1 } else { 2 };\n        let train_edges_number = (self.get_directed_edges_number() as f64 * train_size) as usize;\n        let mut valid_edges_number =\n            (self.get_directed_edges_number() as f64 * (1.0 - train_size)) as EdgeT;\n\n        if let Some(etis) = &edge_type_ids {\n            let selected_edges_number: EdgeT = etis\n                .iter()\n                .map(|et| self.get_unchecked_edge_count_by_edge_type_id(*et) as EdgeT)\n                .sum();\n            valid_edges_number = (selected_edges_number as f64 * (1.0 - train_size)) as EdgeT;\n        }\n\n        if tree.len() * edge_factor > train_edges_number {\n            return Err(format!(\n                concat!(\n                    \"The given spanning tree of the graph contains {} edges \",\n                    \"that is more than the required training edges number {}.\\n\",\n                    \"This makes impossible to create a validation set using \",\n                    \"{} edges.\\nIf possible, you should increase the \",\n                    \"train_size parameter which is currently equal to \",\n                    \"{}.\\nThe deny map, by itself, is requiring at least \",\n                    \"a train rate of {}.\"\n                ),\n                tree.len() * edge_factor,\n                train_edges_number,\n                valid_edges_number,\n                train_size,\n                (tree.len() * edge_factor) as f64 / train_edges_number as f64\n            ));\n        }\n\n        self.edge_holdout(\n            random_state,\n            valid_edges_number,\n            include_all_edge_types,\n            |_, src, dst, edge_type| {\n                let is_in_tree = tree.contains(&(src, dst));\n                let singleton_self_loop =\n                    src == dst && self.get_node_degree_by_node_id(src).unwrap() == 1;\n                let correct_edge_type = edge_type_ids\n                    .as_ref()\n                    .map_or(true, |etis| etis.contains(&edge_type));\n                // The tree must not contain the provided edge ID\n                // And this is not a self-loop edge with degree 1\n                // And the edge type of the edge ID is within the provided edge type\n                !is_in_tree && !singleton_self_loop && correct_edge_type\n            },\n            verbose,\n            self.has_singletons(),\n            self.has_singleton_nodes_with_self_loops(),\n        )",
        "doc": [
            "Returns random holdout for training ML algorithms on the graph edges.",
            "",
            "The holdouts returned are a tuple of graphs. In neither holdouts the",
            "graph connectivity is necessarily preserved. To maintain that, use",
            "the method `connected_holdout`.",
            "",
            "# Arguments",
            "",
            "* `random_state`: NodeT - The random_state to use for the holdout,",
            "* `train_size`: f64 - rate target to reserve for training",
            "* `include_all_edge_types`: bool - whether to include all the edges between two nodes.",
            "* `edge_types`: Option<Vec<String>> - The edges to include in validation set.",
            "* `min_number_overlaps`: Option<usize> - The minimum number of overlaps to include the edge into the validation set.",
            "* `verbose`: bool - whether to show the loading bar.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "random_holdout",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "EdgeT"
            ],
            [
                "train_size",
                "f64"
            ],
            [
                "include_all_edge_types",
                "bool"
            ],
            [
                "edge_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "min_number_overlaps",
                "Option<EdgeT>"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(Graph, Graph), String>",
        "body": "let (_, valid_edges_number) =\n            self.get_holdouts_edges_number(train_size, include_all_edge_types)?;\n        let edge_type_ids = edge_types.map_or(Ok::<_, String>(None), |ets| {\n            Ok(Some(\n                self.get_edge_type_ids_by_edge_type_names(ets)?\n                    .into_iter()\n                    .collect::<HashSet<Option<EdgeTypeT>>>(),\n            ))\n        })?;\n        if min_number_overlaps.is_some() && !self.is_multigraph() {\n            return Err(\"Current graph is not a multigraph!\".to_string());\n        }\n        self.edge_holdout(\n            random_state,\n            valid_edges_number,\n            include_all_edge_types,\n            |_, src, dst, edge_type| {\n                // If a list of edge types was provided and the edge type\n                // of the current edge is not within the provided list,\n                // we skip the current edge.\n                if !edge_type_ids\n                    .as_ref()\n                    .map_or(true, |etis| etis.contains(&edge_type))\n                {\n                    return false;\n                }\n                // If a minimum number of overlaps was provided and the current\n                // edge has not the required minimum amount of overlaps.\n                if let Some(mno) = min_number_overlaps {\n                    if self.get_unchecked_edge_degreee_by_node_ids(src, dst) < mno {\n                        return false;\n                    }\n                }\n                // Otherwise we accept the provided edge for the validation set\n                true\n            },\n            verbose,\n            // Singletons may be generated during the holdouts process\n            true,\n            // Singletons with selfloops may be generated during the holdouts process only when there are selfloops in the graph\n            self.has_selfloops(),\n        )",
        "doc": [
            "Returns node-label holdout for training ML algorithms on the graph node labels.",
            "",
            "# Arguments",
            "",
            "* `train_size`: f64 - rate target to reserve for training,",
            "* `use_stratification`: bool - Whether to use node-label stratification,",
            "* `random_state`: NodeT - The random_state to use for the holdout,",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "node_label_holdout",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "train_size",
                "f64"
            ],
            [
                "use_stratification",
                "bool"
            ],
            [
                "random_state",
                "EdgeT"
            ]
        ],
        "return_type": "Result<(Graph, Graph), String>",
        "body": "if !self.has_node_types() {\n            return Err(\"The current graph does not have node types.\".to_string());\n        }\n        if use_stratification {\n            if self.has_multilabel_node_types() {\n                return Err(\"It is impossible to create a stratified holdout when the graph has multi-label node types.\".to_string());\n            }\n            if self.get_minimum_node_types_number() < 2 {\n                return Err(\"It is impossible to create a stratified holdout when the graph has node types with cardinality one.\".to_string());\n            }\n        }\n\n        // Compute the vectors with the indices of the nodes which node type matches\n        // therefore the expected shape is:\n        // (node_types_number, number of nodes of that node type)\n        let node_sets: Vec<Vec<NodeT>> = self\n            .node_types\n            .as_ref()\n            .map(|nts| {\n                if use_stratification {\n                    // Initialize the vectors for each node type\n                    let mut node_sets: Vec<Vec<NodeT>> =\n                        vec![Vec::new(); self.get_node_types_number() as usize];\n                    // itering over the indices and adding each node to the\n                    // vector of the corresponding node type.\n                    nts.ids.iter().enumerate().for_each(|(node_id, node_type)| {\n                        // if the node has a node_type\n                        if let Some(nt) = node_type {\n                            // Get the index of the correct node type vector.\n                            node_sets[nt[0] as usize].push(node_id as NodeT);\n                        };\n                    });\n\n                    node_sets\n                } else {\n                    // just compute a vector with a single vector of the indices\n                    //  of the nodes with node\n                    vec![nts\n                        .ids\n                        .iter()\n                        .enumerate()\n                        .filter_map(|(node_id, node_type)| {\n                            node_type.as_ref().map(|_| node_id as NodeT)\n                        })\n                        .collect()]\n                }\n            })\n            .unwrap();\n\n        // initialize the seed for a re-producible shuffle\n        let mut rnd = SmallRng::seed_from_u64(random_state ^ SEED_XOR as u64);\n\n        // Allocate the vectors for the nodes of each\n        let mut train_node_types = vec![None; self.get_nodes_number() as usize];\n        let mut test_node_types = vec![None; self.get_nodes_number() as usize];\n\n        for mut node_set in node_sets {\n            // Shuffle in a reproducible way the nodes of the current node_type\n            node_set.shuffle(&mut rnd);\n            // Compute how many of these nodes belongs to the training set\n            let (train_size, _) = self.get_holdouts_elements_number(train_size, node_set.len())?;\n            // add the nodes to the relative vectors\n            node_set[..train_size].iter().for_each(|node_id| {\n                train_node_types[*node_id as usize] =\n                    self.get_unchecked_node_type_id_by_node_id(*node_id)\n            });\n            node_set[train_size..].iter().for_each(|node_id| {\n                test_node_types[*node_id as usize] =\n                    self.get_unchecked_node_type_id_by_node_id(*node_id)\n            });\n        }\n\n        // Clone the current graph\n        // here we could manually initialize the clones so that we don't waste\n        // time and memory cloning the node_types which will be immediately\n        // overwrite. We argue that this should not be impactfull so we prefer\n        // to prioritze the simplicity of the code\n        let mut train_graph = self.clone();\n        let mut test_graph = self.clone();\n\n        // Replace the node_types with the one computes above\n        train_graph.node_types = NodeTypeVocabulary::from_structs(\n            train_node_types,\n            self.node_types.as_ref().map(|ntv| ntv.vocabulary.clone()),\n        );\n        test_graph.node_types = NodeTypeVocabulary::from_structs(\n            test_node_types,\n            self.node_types.as_ref().map(|ntv| ntv.vocabulary.clone()),\n        );\n\n        Ok((train_graph, test_graph))",
        "doc": [
            "Returns edge-label holdout for training ML algorithms on the graph edge labels.",
            "",
            "# Arguments",
            "",
            "* `train_size`: f64 - rate target to reserve for training,",
            "* `use_stratification`: bool - Whether to use edge-label stratification,",
            "* `random_state`: EdgeT - The random_state to use for the holdout,",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "edge_label_holdout",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "train_size",
                "f64"
            ],
            [
                "use_stratification",
                "bool"
            ],
            [
                "random_state",
                "EdgeT"
            ]
        ],
        "return_type": "Result<(Graph, Graph), String>",
        "body": "if !self.has_edge_types() {\n            return Err(\"The current graph does not have edge types.\".to_string());\n        }\n        if use_stratification && self.get_minimum_edge_types_number() < 2 {\n            return Err(\"It is impossible to create a stratified holdout when the graph has edge types with cardinality one.\".to_string());\n        }\n\n        // Compute the vectors with the indices of the edges which edge type matches\n        // therefore the expected shape is:\n        // (edge_types_number, number of edges of that edge type)\n        let edge_sets: Vec<Vec<EdgeT>> = self\n            .edge_types\n            .as_ref()\n            .map(|nts| {\n                if use_stratification {\n                    // Initialize the vectors for each edge type\n                    let mut edge_sets: Vec<Vec<EdgeT>> =\n                        vec![Vec::new(); self.get_edge_types_number() as usize];\n                    // itering over the indices and adding each edge to the\n                    // vector of the corresponding edge type.\n                    nts.ids.iter().enumerate().for_each(|(edge_id, edge_type)| {\n                        // if the edge has a edge_type\n                        if let Some(et) = edge_type {\n                            // Get the index of the correct edge type vector.\n                            edge_sets[*et as usize].push(edge_id as EdgeT);\n                        };\n                    });\n\n                    edge_sets\n                } else {\n                    // just compute a vector with a single vector of the indices\n                    //  of the edges with edge\n                    vec![nts\n                        .ids\n                        .iter()\n                        .enumerate()\n                        .filter_map(|(edge_id, edge_type)| {\n                            edge_type.as_ref().map(|_| edge_id as EdgeT)\n                        })\n                        .collect()]\n                }\n            })\n            .unwrap();\n\n        // initialize the seed for a re-producible shuffle\n        let mut rnd = SmallRng::seed_from_u64(random_state ^ SEED_XOR as u64);\n\n        // Allocate the vectors for the edges of each\n        let mut train_edge_types = vec![None; self.get_directed_edges_number() as usize];\n        let mut test_edge_types = vec![None; self.get_directed_edges_number() as usize];\n\n        for mut edge_set in edge_sets {\n            // Shuffle in a reproducible way the edges of the current edge_type\n            edge_set.shuffle(&mut rnd);\n            // Compute how many of these edges belongs to the training set\n            let (train_size, _) = self.get_holdouts_elements_number(train_size, edge_set.len())?;\n            // add the edges to the relative vectors\n            edge_set[..train_size].iter().for_each(|edge_id| {\n                train_edge_types[*edge_id as usize] =\n                    self.get_unchecked_edge_type_by_edge_id(*edge_id)\n            });\n            edge_set[train_size..].iter().for_each(|edge_id| {\n                test_edge_types[*edge_id as usize] =\n                    self.get_unchecked_edge_type_by_edge_id(*edge_id)\n            });\n        }\n\n        // Clone the current graph\n        // here we could manually initialize the clones so that we don't waste\n        // time and memory cloning the edge_types which will be immediately\n        // overwrite. We argue that this should not be impactfull so we prefer\n        // to prioritze the simplicity of the code\n        let mut train_graph = self.clone();\n        let mut test_graph = self.clone();\n\n        // Replace the edge_types with the one computes above\n        train_graph.edge_types = Some(EdgeTypeVocabulary::from_structs(\n            train_edge_types,\n            self.edge_types\n                .as_ref()\n                .map(|etv| etv.vocabulary.clone())\n                .unwrap(),\n        ));\n        test_graph.edge_types = Some(EdgeTypeVocabulary::from_structs(\n            test_edge_types,\n            self.edge_types\n                .as_ref()\n                .map(|etv| etv.vocabulary.clone())\n                .unwrap(),\n        ));\n\n        Ok((train_graph, test_graph))",
        "doc": [
            "Returns subgraph with given number of nodes.",
            "",
            "This method creates a subset of the graph starting from a random node",
            "sampled using given random_state and includes all neighbouring nodes until",
            "the required number of nodes is reached. All the edges connecting any",
            "of the selected nodes are then inserted into this graph.",
            "",
            "This is meant to execute distributed node embeddings.",
            "It may also sample singleton nodes.",
            "",
            "# Arguments",
            "",
            "* `random_state`: usize - Random random_state to use.",
            "* `nodes_number`: usize - Number of nodes to extract.",
            "* `verbose`: bool - whether to show the loading bar.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "random_subgraph",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "usize"
            ],
            [
                "nodes_number",
                "NodeT"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "if nodes_number <= 1 {\n            return Err(String::from(\"Required nodes number must be more than 1.\"));\n        }\n        let not_singleton_nodes_number = self.get_not_singleton_nodes_number();\n        if nodes_number > not_singleton_nodes_number {\n            return Err(format!(\n                concat!(\n                    \"Required number of nodes ({}) is more than available \",\n                    \"number of nodes ({}) that have edges in current graph.\"\n                ),\n                nodes_number, not_singleton_nodes_number\n            ));\n        }\n\n        // Creating the loading bars\n        let pb1 = get_loading_bar(verbose, \"Sampling nodes subset\", nodes_number as usize);\n        let pb2 = get_loading_bar(verbose, \"Computing subgraph edges\", nodes_number as usize);\n        let pb3 = get_loading_bar(\n            verbose,\n            \"Building subgraph\",\n            self.get_directed_edges_number() as usize,\n        );\n\n        // Creating the random number generator\n        let mut rnd = SmallRng::seed_from_u64((random_state ^ SEED_XOR) as u64);\n\n        // Nodes indices\n        let mut nodes: Vec<NodeT> = (0..self.get_nodes_number()).collect();\n\n        // Shuffling the components using the given random_state.\n        nodes.shuffle(&mut rnd);\n\n        // Initializing stack and set of nodes\n        let mut unique_nodes = RoaringBitmap::new();\n        let mut stack: Vec<NodeT> = Vec::new();\n\n        // We iterate on the components\n        'outer: for node in nodes.iter() {\n            // If the current node is a trap there is no need to continue with the current loop.\n            if self.is_node_trap_by_node_id(*node).unwrap() {\n                continue;\n            }\n            stack.push(*node);\n            while !stack.is_empty() {\n                let src = stack.pop().unwrap();\n                for dst in self.iter_node_neighbours_ids(src) {\n                    if !unique_nodes.contains(dst) && src != dst {\n                        stack.push(dst);\n                    }\n\n                    unique_nodes.insert(*node);\n                    unique_nodes.insert(dst);\n                    pb1.inc(2);\n\n                    // If we reach the desired number of unique nodes we can stop the iteration.\n                    if unique_nodes.len() as NodeT >= nodes_number {\n                        break 'outer;\n                    }\n                }\n            }\n        }\n\n        pb1.finish();\n\n        let edges_bitmap =\n            RoaringTreemap::from_iter(unique_nodes.iter().progress_with(pb2).flat_map(|src| {\n                let (min_edge_id, max_edge_id) = self.get_minmax_edge_ids_by_source_node_id(src);\n                (min_edge_id..max_edge_id)\n                    .filter(|edge_id| {\n                        unique_nodes\n                            .contains(self.get_destination_node_id_by_edge_id(*edge_id).unwrap())\n                    })\n                    .collect::<Vec<EdgeT>>()\n            }));\n\n        Graph::build_graph(\n            edges_bitmap\n                .iter()\n                .progress_with(pb3)\n                .map(|edge_id| Ok(self.get_edge_quadruple(edge_id))),\n            edges_bitmap.len() as usize,\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.directed,\n            true,\n            format!(\"{} subgraph\", self.name.clone()),\n            false,\n            self.has_edge_types(),\n            self.has_weights(),\n            true,\n            self.has_selfloops(),\n            true,\n        )",
        "doc": [
            "Returns train and test graph following kfold validation scheme.",
            "",
            "The edges are splitted into k chunks. The k_index-th chunk is used to build",
            "the validation graph, all the other edges create the training graph.",
            "",
            "# Arguments",
            "",
            "* `edge_types`: Option<Vec<String>> - Edge types to be selected when computing the folds",
            "(All the edge types not listed here will be always be used in the training set).",
            "* `k`: u64 - The number of folds.",
            "* `k_index`: u64 - Which fold to use for the validation.",
            "* `random_state`: NodeT - The random_state (seed) to use for the holdout,",
            "* `verbose`: bool - whether to show the loading bar.",
            ""
        ]
    },
    {
        "modifiers": "pub",
        "name": "kfold",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "k",
                "EdgeT"
            ],
            [
                "k_index",
                "u64"
            ],
            [
                "edge_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "random_state",
                "EdgeT"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(Graph, Graph), String>",
        "body": "if k == 1 {\n            return Err(String::from(\"Cannot do a k-fold with only one fold.\"));\n        }\n        if k_index >= k {\n            return Err(String::from(\n                \"The index of the k-fold must be strictly less than the number of folds.\",\n            ));\n        }\n\n        // If edge types is not None, to compute the chunks only use the edges\n        // of the chosen edge_types\n        let mut indices = if let Some(ets) = edge_types {\n            if ets.is_empty() {\n                return Err(String::from(\n                    \"Required edge types must be a non-empty list.\",\n                ));\n            }\n\n            let edge_type_ids = self\n                .get_edge_type_ids_by_edge_type_names(ets)?\n                .into_iter()\n                .collect::<HashSet<Option<EdgeTypeT>>>();\n\n            self.iter_edges_with_type_ids(self.directed)\n                .filter_map(|(edge_id, _, _, edge_type)| {\n                    if !edge_type_ids.contains(&edge_type) {\n                        return None;\n                    }\n                    Some(edge_id)\n                })\n                .collect::<Vec<EdgeT>>()\n        } else {\n            self.iter_edge_ids(self.directed)\n                .map(|(edge_id, _, _)| edge_id)\n                .collect::<Vec<EdgeT>>()\n        };\n\n        if k >= indices.len() as EdgeT {\n            return Err(String::from(\n                \"Cannot do a number of k-fold greater than the number of available edges.\",\n            ));\n        }\n\n        // if the graph has 8 edges and k = 3\n        // we want the chunks sized to be:\n        // 3, 3, 2\n\n        // if the graph has 4 edges and k = 3\n        // we want the chunks sized to be:\n        // 2, 1, 1\n\n        // shuffle the indices\n        let mut rng = SmallRng::seed_from_u64(random_state ^ SEED_XOR as EdgeT);\n        indices.shuffle(&mut rng);\n        // Get the k_index-th chunk\n        let chunk_size = indices.len() as f64 / k as f64;\n        let start = (k_index as f64 * chunk_size).ceil() as EdgeT;\n        let end = std::cmp::min(\n            indices.len() as EdgeT,\n            (((k_index + 1) as f64) * chunk_size).ceil() as EdgeT,\n        );\n        let chunk =\n            RoaringTreemap::from_iter(indices[start as usize..end as usize].iter().cloned());\n        // Create the two graphs\n        self.edge_holdout(\n            random_state,\n            end - start,\n            false,\n            |edge_id, _, _, _| chunk.contains(edge_id),\n            verbose,\n            true,\n            self.has_selfloops(),\n        )"
    }
]