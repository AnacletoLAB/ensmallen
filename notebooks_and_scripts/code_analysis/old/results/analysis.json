{
    "queries_walk.rs": {
        "imports": [
            "use super::*;",
            "use vec_rand::sorted_unique_sub_sampling;"
        ],
        "functions": [
            {
                "file": "queries_walk.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Walk Queries",
                    " These are the queries that are used mainly in the random walk."
                ],
                "doc": [
                    " Returns quadruple with minimum and maximum edge ids, destination nodes and its indices if subsampling was required.",
                    "",
                    " If max neighbours was provided the subsampling is done by using the",
                    " sorted unique sub-sampling (SUSS) algorithm.",
                    "",
                    " # Arguments",
                    " * `max_neighbours`: Option<NodeT> - Optional maximum number of neighbours to consider.",
                    " * `random_state`: u64 - The random state to use for the sampling if the maximum neighbours are asked.",
                    " * `source_node_id`: NodeT - The source node ID to extract edge IDs and destination node IDs."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "get_edges_and_destinations_from_source_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "max_neighbours",
                        "Option<NodeT>"
                    ],
                    [
                        "random_state",
                        "u64"
                    ],
                    [
                        "source_node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "(EdgeT, EdgeT, Option<Vec<NodeT>>, Option<Vec<u64>>)",
                "body": "// We retrieve the range of edge ids, the minimum and maximum value.\n        let (min_edge_id, max_edge_id) =\n            self.get_unchecked_minmax_edge_ids_from_source_node_id(source_node_id);\n\n        // We check if subsampling is enabled and if so, if it makes sense:\n        // that is, if the range of neighbours (max_edge_id-min_edge_id) is smaller\n        // than the required sub-sampling we do not use it as it would be useless.\n        if let Some(indices) = max_neighbours.and_then(|mn| {\n            sorted_unique_sub_sampling(min_edge_id, max_edge_id, mn as u64, random_state).ok()\n        }) {\n            let destinations: Vec<NodeT> = match self\n                .cached_destinations\n                .as_ref()\n                .and_then(|cds| cds.get(&source_node_id))\n            {\n                Some(dsts) => indices\n                    .iter()\n                    .map(|edge_id| dsts[(*edge_id - min_edge_id) as usize])\n                    .collect(),\n                None => indices\n                    .iter()\n                    .map(|edge_id| self.get_unchecked_destination_node_id_from_edge_id(*edge_id))\n                    .collect(),\n            };\n            return (min_edge_id, max_edge_id, Some(destinations), Some(indices));\n        }\n\n        // If the destinations are stored explicitly because the time-memory tradeoff is enabled we are done.\n        if self.destinations.is_some() {\n            return (min_edge_id, max_edge_id, None, None);\n        }\n\n        // Finally if we are using the cache without sub-sampling\n        let destinations = match self\n            .cached_destinations\n            .as_ref()\n            .map_or(false, |cds| cds.contains_key(&source_node_id))\n        {\n            true => None,\n            false => Some(\n                self.iter_unchecked_neighbour_node_ids_from_source_node_id(source_node_id)\n                    .collect(),\n            ),\n        };\n        (min_edge_id, max_edge_id, destinations, None)"
            },
            {
                "file": "queries_walk.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Walk Queries",
                    " These are the queries that are used mainly in the random walk."
                ],
                "doc": [
                    " Returns slice of destinations corresponding to given minmax edge ID and node.",
                    "",
                    " # Arguments",
                    " * `min_edge_id`: EdgeT - Minimum edge ID for the slice.",
                    " * `max_edge_id`: EdgeT - Maximum edge ID for the slice.",
                    " * `source_node_id`: NodeT - The source node ID.",
                    " * `destinations`: &'a Option<Vec<NodeT>> - The optional destinations slice that may have been provided when working with subsampling."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "get_destinations_slice",
                "generics": "'a",
                "args": [
                    [
                        "self",
                        "&'a self"
                    ],
                    [
                        "min_edge_id",
                        "EdgeT"
                    ],
                    [
                        "max_edge_id",
                        "EdgeT"
                    ],
                    [
                        "source_node_id",
                        "NodeT"
                    ],
                    [
                        "destinations",
                        "&'a Option<Vec<NodeT>>"
                    ]
                ],
                "return_type": "&'a [NodeT]",
                "body": "match (&self.destinations, &self.cached_destinations, destinations) {\n            (_, _, Some(dsts)) => &dsts.as_slice(),\n            (Some(dsts), None, None) => &dsts[min_edge_id as usize..max_edge_id as usize],\n            (None, Some(dsts), None) => dsts.get(&source_node_id).unwrap(),\n            _ => unreachable!(\n                \"It is not possible to have both destinations and cached destinations at once.\"\n            ),\n        }"
            }
        ]
    },
    "operators.rs": {
        "imports": [
            "use super::*;",
            "use std::ops;"
        ],
        "functions": [
            {
                "file": "operators.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "build_operator_graph_name",
                "args": [
                    [
                        "main",
                        "&Graph"
                    ],
                    [
                        "other",
                        "&Graph"
                    ],
                    [
                        "operator",
                        "String"
                    ]
                ],
                "return_type": "String",
                "body": "format!(\"({} {} {})\", main.name, operator, other.name)"
            },
            {
                "file": "operators.rs",
                "doc": [
                    " Return graph composed of the two near-incompatible graphs.",
                    "",
                    " The two graphs can have different nodes, edge types and node types.",
                    " These operators are slower than the generic integer operators since they",
                    " require a reverse mapping step.",
                    "",
                    " # Arguments",
                    "",
                    " * `main`: &Graph - The current graph instance.",
                    " * `other`: &Graph - The other graph.",
                    " * `operator`: String - The operator used.",
                    " * `graphs`: Vec<(&Graph, Option<&Graph>, Option<&Graph>)> - Graph list for the operation.",
                    " * `might_have_singletons`: bool - Whether we expect the graph to have singletons.",
                    " * `might_have_singletons_with_selfloops`: bool - Whether we expect the graph to have singletons with self-loops.",
                    " * `might_have_trap_nodes`: bool - Whether we expect the graph to have trap nodes."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "generic_string_operator",
                "args": [
                    [
                        "main",
                        "&Graph"
                    ],
                    [
                        "other",
                        "&Graph"
                    ],
                    [
                        "operator",
                        "String"
                    ],
                    [
                        "graphs",
                        "Vec<(&Graph, Option<&Graph>, Option<&Graph>)>"
                    ],
                    [
                        "might_have_singletons",
                        "bool"
                    ],
                    [
                        "might_have_singletons_with_selfloops",
                        "bool"
                    ],
                    [
                        "might_have_trap_nodes",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "// one: left hand side of the operator\n    // deny_graph: right hand edges \"deny list\"\n    // must_have_graph: right hand edges \"must have list\n    let edges_iterator = graphs\n        .iter()\n        .flat_map(|(one, deny_graph, must_have_graph)| {\n            one.iter_edge_node_names_and_edge_type_name_and_edge_weight(main.directed)\n                .filter(move |(_, _, src_name, _, dst_name, _, edge_type_name, _)| {\n                    // If the secondary graph is given\n                    // we filter out the edges that were previously added to avoid\n                    // introducing duplicates.\n                    // TODO: handle None type edge types and avoid duplicating those!\n                    if let Some(dg) = deny_graph {\n                        return !dg.has_edge_from_node_names_and_edge_type_name(\n                            src_name,\n                            dst_name,\n                            edge_type_name.as_deref(),\n                        );\n                    }\n                    if let Some(mhg) = must_have_graph {\n                        return mhg.has_edge_from_node_names_and_edge_type_name(\n                            src_name,\n                            dst_name,\n                            edge_type_name.as_deref(),\n                        );\n                    }\n                    true\n                })\n                .map(|(_, _, src_name, _, dst_name, _, edge_type_name, weight)| {\n                    Ok((src_name, dst_name, edge_type_name, weight))\n                })\n        });\n\n    // Chaining node types in a way that merges the information between\n    // two node type sets where one of the two has some unknown node types\n    let nodes_iterator = main\n        .iter_node_names_and_node_type_names()\n        .map(|(_, node_name, _, node_type_names)| {\n            let node_type_names = match node_type_names {\n                Some(ntns) => Some(ntns),\n                None => other\n                    .get_node_id_from_node_name(&node_name)\n                    .ok()\n                    .and_then(|node_id| other.get_node_type_names_from_node_id(node_id).unwrap()),\n            };\n            Ok((node_name, node_type_names))\n        })\n        .chain(\n            other\n                .iter_node_names_and_node_type_names()\n                .filter_map(|(_, node_name, _, node_type_names)| {\n                    match main.has_node_name(&node_name) {\n                        true => None,\n                        false => Some(Ok((node_name, node_type_names))),\n                    }\n                }),\n        );\n\n    Graph::from_string_unsorted(\n        edges_iterator,\n        Some(nodes_iterator),\n        main.directed,\n        false,\n        build_operator_graph_name(main, other, operator),\n        true,\n        true,\n        false,\n        true,\n        false,\n        false,\n        false,\n        false,\n        main.has_node_types(),\n        main.has_edge_types(),\n        main.has_edge_weights(),\n        might_have_singletons,\n        might_have_singletons_with_selfloops,\n        might_have_trap_nodes,\n        false,\n    )"
            },
            {
                "file": "operators.rs",
                "doc": [
                    " Return graph composed of the two compatible graphs.",
                    "",
                    " The two graphs CANNOT have different nodes, edge types and node types.",
                    " These operators are faster than the generic string operators since they",
                    " do NOT require a reverse mapping step.",
                    "",
                    " # Arguments",
                    "",
                    " * `main`: &Graph - The current graph instance.",
                    " * `other`: &Graph - The other graph.",
                    " * `operator`: String - The operator used.",
                    " * `graphs`: Vec<(&Graph, Option<&Graph>, Option<&Graph>)> - Graph list for the operation.",
                    " * `might_have_singletons`: bool - Whether we expect the graph to have singletons.",
                    " * `might_have_singletons_with_selfloops`: bool - Whether we expect the graph to have singletons with self-loops.",
                    " * `might_have_trap_nodes`: bool - Whether we expect the graph to have trap nodes."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "generic_integer_operator",
                "args": [
                    [
                        "main",
                        "&Graph"
                    ],
                    [
                        "other",
                        "&Graph"
                    ],
                    [
                        "operator",
                        "String"
                    ],
                    [
                        "graphs",
                        "Vec<(&Graph, Option<&Graph>, Option<&Graph>)>"
                    ],
                    [
                        "might_have_singletons",
                        "bool"
                    ],
                    [
                        "might_have_singletons_with_selfloops",
                        "bool"
                    ],
                    [
                        "might_have_trap_nodes",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "// one: left hand side of the operator\n    // deny_graph: right hand edges \"deny list\"\n    // must_have_graph: right hand edges \"must have list\n    let edges_iterator = graphs\n        .iter()\n        .flat_map(|(one, deny_graph, must_have_graph)| {\n            one.iter_edge_node_ids_and_edge_type_id_and_edge_weight(main.directed)\n                .filter(move |(_, src, dst, edge_type, _)| {\n                    // If the secondary graph is given\n                    // we filter out the edges that were previously added to avoid\n                    // introducing duplicates.\n                    if let Some(dg) = deny_graph {\n                        return !dg.has_edge_from_node_ids_and_edge_type_id(*src, *dst, *edge_type);\n                    }\n                    if let Some(mhg) = must_have_graph {\n                        return mhg.has_edge_from_node_ids_and_edge_type_id(*src, *dst, *edge_type);\n                    }\n                    true\n                })\n                .map(|(_, src, dst, edge_type, weight)| Ok((src, dst, edge_type, weight)))\n        });\n\n    let node_types = match (&main.node_types, &other.node_types) {\n        (Some(mnts), Some(onts)) => Some(match mnts == onts {\n            true => mnts.clone(),\n            false => {\n                let mut main_node_types = mnts.ids.clone();\n                main_node_types\n                    .iter_mut()\n                    .zip(onts.ids.iter())\n                    .for_each(|(mid, oid)| {\n                        if mid.is_none() {\n                            *mid = oid.clone();\n                        }\n                    });\n                NodeTypeVocabulary::from_structs(main_node_types, Some(mnts.vocabulary.clone()))\n                    .unwrap()\n            }\n        }),\n        (Some(mnts), _) => Some(mnts.clone()),\n        (_, Some(onts)) => Some(onts.clone()),\n        _ => None,\n    };\n\n    Graph::from_integer_unsorted(\n        edges_iterator,\n        main.nodes.clone(),\n        node_types,\n        main.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n        main.directed,\n        build_operator_graph_name(main, other, operator),\n        false,\n        main.has_edge_types(),\n        main.has_edge_weights(),\n        might_have_singletons,\n        might_have_singletons_with_selfloops,\n        might_have_trap_nodes,\n        false,\n    )"
            },
            {
                "file": "operators.rs",
                "doc": [
                    " Return result containing either empty tuple or error representing what makes impossible to combine the two graphs.",
                    "",
                    " # Arguments",
                    "",
                    " * `other`: &Graph - The other graph to validate operation with.",
                    "",
                    " # Raises",
                    " * If a graph is directed and the other is undirected.",
                    " * If one of the two graphs has edge weights and the other does not.",
                    " * If one of the two graphs has node types and the other does not.",
                    " * If one of the two graphs has edge types and the other does not."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "validate_operator_terms",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "other",
                        "&'b Graph"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "if self.directed != other.directed {\n            return Err(String::from(\n                \"The graphs must either be both directed or undirected.\",\n            ));\n        }\n\n        if self.has_edge_weights() != other.has_edge_weights() {\n            return Err(String::from(\n                \"Both graphs need to have weights or neither can.\",\n            ));\n        }\n\n        if self.has_node_types() != other.has_node_types() {\n            return Err(String::from(\n                \"Both graphs need to have node types or neither can.\",\n            ));\n        }\n\n        if self.has_edge_types() != other.has_edge_types() {\n            return Err(String::from(\n                \"Both graphs need to have edge types or neither can.\",\n            ));\n        }\n\n        Ok(())"
            },
            {
                "file": "operators.rs",
                "struct": "Graph",
                "doc": [
                    " Return true if the graphs are compatible.",
                    "",
                    " # Arguments",
                    "",
                    " * `other`: &Graph - The other graph.",
                    "",
                    " # Raises",
                    " * If a graph is directed and the other is undirected.",
                    " * If one of the two graphs has edge weights and the other does not.",
                    " * If one of the two graphs has node types and the other does not.",
                    " * If one of the two graphs has edge types and the other does not."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "is_compatible",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "other",
                        "&Graph"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "self.validate_operator_terms(other)?;\n        if self.nodes != other.nodes {\n            return Ok(false);\n        }\n        if let (Some(snts), Some(onts)) = (&self.node_types, &other.node_types) {\n            if snts.vocabulary != onts.vocabulary {\n                return Ok(false);\n            }\n        }\n        if let (Some(sets), Some(oets)) = (&self.edge_types, &other.edge_types) {\n            if sets.vocabulary != oets.vocabulary {\n                return Ok(false);\n            }\n        }\n        Ok(true)"
            },
            {
                "file": "operators.rs",
                "struct": "Graph",
                "doc": [
                    " Return graph composed of the two near-incompatible graphs.",
                    "",
                    " The two graphs can have different nodes, edge types and node types.",
                    " These operators are slower than the generic integer operators since they",
                    " require a reverse mapping step.",
                    "",
                    " # Arguments",
                    "",
                    " * `other`: &Graph - The other graph.",
                    " * `operator`: String - The operator used.",
                    " * `graphs`: Vec<(&Graph, Option<&Graph>, Option<&Graph>)> - Graph list for the operation.",
                    " * `might_have_singletons`: bool - Whether we expect the graph to have singletons.",
                    " * `might_have_singletons_with_selfloops`: bool - Whether we expect the graph to have singletons with self-loops.",
                    " * `might_have_trap_nodes`: bool - Whether we expect the graph to have trap nodes."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "generic_operator",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "other",
                        "&Graph"
                    ],
                    [
                        "operator",
                        "String"
                    ],
                    [
                        "graphs",
                        "Vec<(&Graph, Option<&Graph>, Option<&Graph>)>"
                    ],
                    [
                        "might_have_singletons",
                        "bool"
                    ],
                    [
                        "might_have_singletons_with_selfloops",
                        "bool"
                    ],
                    [
                        "might_have_trap_nodes",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "match self.is_compatible(other)? {\n            true => generic_integer_operator(\n                self,\n                other,\n                operator,\n                graphs,\n                might_have_singletons,\n                might_have_singletons_with_selfloops,\n                might_have_trap_nodes,\n            ),\n            false => generic_string_operator(\n                self,\n                other,\n                operator,\n                graphs,\n                might_have_singletons,\n                might_have_singletons_with_selfloops,\n                might_have_trap_nodes,\n            ),\n        }"
            },
            {
                "file": "operators.rs",
                "doc": [
                    " Return graph composed of the two graphs.",
                    "",
                    " The two graphs must have the same nodes, node types and edge types.",
                    "",
                    " # Arguments",
                    "",
                    " * `other`: &Graph - Graph to be summed.",
                    ""
                ],
                "attrs": [],
                "modifiers": "",
                "name": "bitor",
                "args": [
                    [
                        "self",
                        "self"
                    ],
                    [
                        "other",
                        "&'b Graph"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "self.generic_operator(\n            other,\n            \"|\".to_owned(),\n            vec![(self, None, None), (other, Some(self), None)],\n            // TODO: it is possible to make the following more precise!\n            self.has_singleton_nodes() || other.has_singleton_nodes(),\n            // TODO: it is possible to make the following more precise!\n            self.has_singleton_nodes_with_selfloops() || other.has_singleton_nodes_with_selfloops(),\n            // TODO: it is possible to make the following more precise!\n            self.has_trap_nodes() || other.has_trap_nodes(),\n        )"
            },
            {
                "file": "operators.rs",
                "doc": [
                    " Return graph composed of the two graphs.",
                    "",
                    " The two graphs must have the same nodes, node types and edge types.",
                    "",
                    " # Arguments",
                    "",
                    " * `other`: &Graph - Graph to be summed.",
                    ""
                ],
                "attrs": [],
                "modifiers": "",
                "name": "bitxor",
                "args": [
                    [
                        "self",
                        "self"
                    ],
                    [
                        "other",
                        "&'b Graph"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "self.generic_operator(\n            self,\n            \"^\".to_owned(),\n            vec![(self, Some(other), None), (other, Some(self), None)],\n            true,\n            // TODO: it is possible to make the following more precise!\n            self.has_selfloops() || other.has_selfloops(),\n            true,\n        )"
            },
            {
                "file": "operators.rs",
                "doc": [
                    " Return subtraction for graphs objects.",
                    "",
                    " The two graphs must have the same nodes, node types and edge types.",
                    "",
                    " # Arguments",
                    "",
                    " * `other`: &Graph - Graph to be subtracted.",
                    ""
                ],
                "attrs": [],
                "modifiers": "",
                "name": "sub",
                "args": [
                    [
                        "self",
                        "self"
                    ],
                    [
                        "other",
                        "&'b Graph"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "self.generic_operator(\n            other,\n            \"-\".to_owned(),\n            vec![(self, Some(other), None)],\n            true,\n            self.has_selfloops(),\n            true,\n        )"
            },
            {
                "file": "operators.rs",
                "doc": [
                    " Return graph obtained from the intersection of the two graph.",
                    "",
                    " The two graphs must have the same nodes, node types and edge types.",
                    "",
                    " # Arguments",
                    "",
                    " * `other`: &Graph - Graph to be subtracted.",
                    ""
                ],
                "attrs": [],
                "modifiers": "",
                "name": "bitand",
                "args": [
                    [
                        "self",
                        "self"
                    ],
                    [
                        "other",
                        "&'b Graph"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "self.generic_operator(\n            other,\n            \"&\".to_owned(),\n            vec![(self, None, Some(other))],\n            true,\n            self.has_selfloops() && other.has_selfloops(),\n            true,\n        )"
            }
        ]
    },
    "walks_parameters.rs": {
        "imports": [
            "use super::*;",
            "use std::collections::HashMap;"
        ],
        "functions": [
            {
                "file": "walks_parameters.rs",
                "struct": "WalkWeights",
                "trait": "Default",
                "impl_doc": [
                    " Struct to wrap walk weights.",
                    " Struct to wrap parameters relative to a single walk.",
                    " Struct to wrap parameters relative to a set of walks."
                ],
                "doc": [
                    " Create new WalkWeights object.",
                    "",
                    " The default WalkWeights object is parametrized to execute a first-order walk."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "default",
                "args": [],
                "return_type": "WalkWeights",
                "body": "WalkWeights {\n            return_weight: 1.0,\n            explore_weight: 1.0,\n            change_node_type_weight: 1.0,\n            change_edge_type_weight: 1.0,\n        }"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalkWeights",
                "doc": [
                    " Validate given weight and format the exception if necessary, eventually.",
                    "",
                    " # Arguments",
                    "",
                    " * `weight_name`: &str - name of the weight, used for building the exception.",
                    " * `weight`: Option<WeightT> - Value of the weight.",
                    "",
                    " TODO: is this a duplicate?"
                ],
                "attrs": [],
                "modifiers": "",
                "name": "validate_weight",
                "args": [
                    [
                        "weight_name",
                        "&str"
                    ],
                    [
                        "weight",
                        "WeightT"
                    ]
                ],
                "return_type": "Result<WeightT, String>",
                "body": "if weight <= 0.0 || !weight.is_finite() {\n            Err(format!(\n                concat!(\n                    \"Given '{}' ({}) \",\n                    \"is not a strictly positive real number.\"\n                ),\n                weight_name, weight\n            ))\n        } else {\n            Ok(weight)\n        }"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalkWeights",
                "doc": [
                    " Return boolean value representing if walk is of first order.",
                    "",
                    " # Example",
                    " The default parametrization defines a first order walk:",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalkWeights;",
                    " let weights = WalkWeights::default();",
                    " assert!(weights.is_first_order_walk());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_first_order_walk",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "let weights = vec![\n            self.change_node_type_weight,\n            self.change_edge_type_weight,\n            self.return_weight,\n            self.explore_weight,\n        ];\n        weights.iter().all(|weight| !not_one(*weight))"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "SingleWalkParameters",
                "doc": [
                    " Create new WalksParameters object.",
                    "",
                    " By default the object is parametrized for a simple first-order walk.",
                    "",
                    " # Arguments",
                    "",
                    " * `walk_length`: usize - Maximal walk_length of the walk.",
                    "",
                    " # Example",
                    " You can create a single walk parameters struct as follows:",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::SingleWalkParameters;",
                    " assert!(SingleWalkParameters::new(45).is_ok());",
                    " ```",
                    "",
                    " as long as you don't try to make a zero walk length you'll be fine:",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::SingleWalkParameters;",
                    " assert!(SingleWalkParameters::new(0).is_err());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "new",
                "args": [
                    [
                        "walk_length",
                        "u64"
                    ]
                ],
                "return_type": "Result<SingleWalkParameters, String>",
                "body": "if walk_length == 0 {\n            return Err(String::from(\"The provided lenght for the walk is zero!\"));\n        }\n        Ok(SingleWalkParameters {\n            walk_length,\n            weights: WalkWeights::default(),\n            max_neighbours: None,\n        })"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "SingleWalkParameters",
                "doc": [
                    " Return boolean value representing if walk is of first order.",
                    "",
                    " # Example",
                    " The default parametrization defines a first order walk:",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::SingleWalkParameters;",
                    " let weights = SingleWalkParameters::new(32).unwrap();",
                    " assert!(weights.is_first_order_walk());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_first_order_walk",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.weights.is_first_order_walk()"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalksParameters",
                "impl_doc": [
                    " Setters for the Walk's parameters"
                ],
                "doc": [
                    " Create new WalksParameters object.",
                    "",
                    " By default the object is parametrized for a simple first-order walk.",
                    "",
                    " # Arguments",
                    "",
                    " * `walk_length`: NodeT - Maximal walk_length of the walk.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "new",
                "args": [
                    [
                        "walk_length",
                        "u64"
                    ]
                ],
                "return_type": "Result<WalksParameters, String>",
                "body": "Ok(WalksParameters {\n            single_walk_parameters: SingleWalkParameters::new(walk_length)?,\n            iterations: 1,\n            random_state: (42 ^ SEED_XOR) as NodeT,\n            dense_node_mapping: None,\n        })"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalksParameters",
                "impl_doc": [
                    " Setters for the Walk's parameters"
                ],
                "doc": [
                    " Set the iterations.",
                    "",
                    " # Arguments",
                    "",
                    " * `iterations`: Option<NodeT> - Whether to show the loading bar or not.",
                    "",
                    " # Example",
                    " You can change the `iterations` parameter as follows:",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " assert!(WalksParameters::new(32).unwrap().set_iterations(Some(0)).is_err());",
                    " assert!(WalksParameters::new(32).unwrap().set_iterations(Some(2)).is_ok());",
                    " ```",
                    "",
                    " You can also call the method with an option None, in order to avoid a match",
                    " wrapper above. This will end up don't doing anything, just a passthrough.",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " assert!(WalksParameters::new(32).unwrap().set_iterations(None).is_ok());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_iterations",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "iterations",
                        "Option<NodeT>"
                    ]
                ],
                "return_type": "Result<WalksParameters, String>",
                "body": "if let Some(it) = iterations {\n            if it == 0 {\n                return Err(String::from(\n                    \"Iterations parameter must be a strictly positive integer.\",\n                ));\n            }\n            self.iterations = it;\n        }\n        Ok(self)"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalksParameters",
                "impl_doc": [
                    " Setters for the Walk's parameters"
                ],
                "doc": [
                    " Return the iterations.",
                    "",
                    " # Example",
                    " To retrieve the number of iterations you can do the following:",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " let mut walk_parameters = WalksParameters::new(32).unwrap();",
                    " assert_eq!(walk_parameters.get_iterations(), 1);",
                    " let iterations_number = 56;",
                    " walk_parameters = walk_parameters.set_iterations(Some(iterations_number)).unwrap();",
                    " assert_eq!(walk_parameters.get_iterations(), iterations_number);",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_iterations",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "NodeT",
                "body": "self.iterations"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalksParameters",
                "impl_doc": [
                    " Setters for the Walk's parameters"
                ],
                "doc": [
                    " Set the maximum neighbours number to consider, making the walk probabilistic.",
                    "",
                    " # Arguments",
                    "",
                    " * `max_neighbours`: Option<NodeT> - Number of neighbours to consider for each extraction.",
                    "",
                    " # Example",
                    " You can change the `max_neighbours` parameter as follows:",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " assert!(WalksParameters::new(32).unwrap().set_max_neighbours(Some(0)).is_err());",
                    " assert!(WalksParameters::new(32).unwrap().set_max_neighbours(Some(2)).is_ok());",
                    " ```",
                    "",
                    " You can also call the method with an option None, in order to avoid a match",
                    " wrapper above. This will end up don't doing anything, just a passthrough.",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " assert!(WalksParameters::new(32).unwrap().set_max_neighbours(None).is_ok());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_max_neighbours",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "max_neighbours",
                        "Option<NodeT>"
                    ]
                ],
                "return_type": "Result<WalksParameters, String>",
                "body": "if let Some(mn) = max_neighbours {\n            if mn == 0 {\n                return Err(String::from(\n                    \"max_neighbours parameter must be a strictly positive integer.\",\n                ));\n            }\n            self.single_walk_parameters.max_neighbours = Some(mn);\n        }\n        Ok(self)"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalksParameters",
                "impl_doc": [
                    " Setters for the Walk's parameters"
                ],
                "doc": [
                    " Set the random_state.",
                    "",
                    " # Arguments",
                    "",
                    " * `random_state`: Option<usize> - random_state for reproducible random walks.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_random_state",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "random_state",
                        "Option<usize>"
                    ]
                ],
                "return_type": "WalksParameters",
                "body": "if let Some(s) = random_state {\n            self.random_state = (s ^ SEED_XOR) as NodeT;\n        }\n        self"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalksParameters",
                "impl_doc": [
                    " Setters for the Walk's parameters"
                ],
                "doc": [
                    " Set the dense_node_mapping.",
                    "",
                    " The nodes mapping primary porpose is to map a sparse set of nodes into",
                    " a smaller dense set of nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * `dense_node_mapping`: Option<HashMap<NodeT, NodeT>> - mapping for the mapping the nodes of the walks.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_dense_node_mapping",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "dense_node_mapping",
                        "Option<HashMap<NodeT, NodeT>>"
                    ]
                ],
                "return_type": "WalksParameters",
                "body": "self.dense_node_mapping = dense_node_mapping;\n        self"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalksParameters",
                "impl_doc": [
                    " Setters for the Walk's parameters"
                ],
                "doc": [
                    " Set the return weight.",
                    "",
                    " # Arguments",
                    "",
                    " * `return_weight`: Option<WeightT> - weight for the exploitation factor.",
                    "",
                    " # Example",
                    " You can change the `return_weight` parameter as follows:",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " assert!(WalksParameters::new(32).unwrap().set_return_weight(Some(-1.0)).is_err());",
                    " assert!(WalksParameters::new(32).unwrap().set_return_weight(Some(2.0)).is_ok());",
                    " assert!(WalksParameters::new(32).unwrap().set_return_weight(Some(1.0)).is_ok());",
                    " assert!(WalksParameters::new(32).unwrap().set_return_weight(Some(1.0)).unwrap().is_first_order_walk());",
                    " ```",
                    "",
                    " You can also call the method with an option None, in order to avoid a match",
                    " wrapper above. This will end up don't doing anything, just a passthrough.",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " assert!(WalksParameters::new(32).unwrap().set_return_weight(None).unwrap().is_first_order_walk());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_return_weight",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "return_weight",
                        "Option<WeightT>"
                    ]
                ],
                "return_type": "Result<WalksParameters, String>",
                "body": "if let Some(rw) = return_weight {\n            self.single_walk_parameters.weights.return_weight =\n                WalkWeights::validate_weight(\"return_weight\", rw)?;\n        }\n        Ok(self)"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalksParameters",
                "impl_doc": [
                    " Setters for the Walk's parameters"
                ],
                "doc": [
                    " Set the explore weight.",
                    "",
                    " # Arguments",
                    "",
                    " * `explore_weight`: Option<WeightT> - weight for the exploration factor.",
                    "",
                    " # Example",
                    " You can change the `explore_weight` parameter as follows:",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " assert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(-1.0)).is_err());",
                    " assert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(2.0)).is_ok());",
                    " assert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(1.0)).is_ok());",
                    " assert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(1.0)).unwrap().is_first_order_walk());",
                    " ```",
                    "",
                    " You can also call the method with an option None, in order to avoid a match",
                    " wrapper above. This will end up don't doing anything, just a passthrough.",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " assert!(WalksParameters::new(32).unwrap().set_explore_weight(None).unwrap().is_first_order_walk());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_explore_weight",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "explore_weight",
                        "Option<WeightT>"
                    ]
                ],
                "return_type": "Result<WalksParameters, String>",
                "body": "if let Some(ew) = explore_weight {\n            self.single_walk_parameters.weights.explore_weight =\n                WalkWeights::validate_weight(\"explore_weight\", ew)?;\n        }\n        Ok(self)"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalksParameters",
                "impl_doc": [
                    " Setters for the Walk's parameters"
                ],
                "doc": [
                    " Set the change_node_type weight.",
                    "",
                    " # Arguments",
                    "",
                    " * `change_node_type_weight`: Option<WeightT> - weight for the exploration of different node types.",
                    "",
                    " # Example",
                    " You can change the `change_node_type_weight` parameter as follows:",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(-1.0)).is_err());",
                    " assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(2.0)).is_ok());",
                    " assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(1.0)).is_ok());",
                    " assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(1.0)).unwrap().is_first_order_walk());",
                    " ```",
                    "",
                    " You can also call the method with an option None, in order to avoid a match",
                    " wrapper above. This will end up don't doing anything, just a passthrough.",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(None).unwrap().is_first_order_walk());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_change_node_type_weight",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "change_node_type_weight",
                        "Option<WeightT>"
                    ]
                ],
                "return_type": "Result<WalksParameters, String>",
                "body": "if let Some(cntw) = change_node_type_weight {\n            self.single_walk_parameters.weights.change_node_type_weight =\n                WalkWeights::validate_weight(\"change_node_type_weight\", cntw)?;\n        }\n        Ok(self)"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalksParameters",
                "impl_doc": [
                    " Setters for the Walk's parameters"
                ],
                "doc": [
                    " Set the change_edge_type weight.",
                    "",
                    " # Arguments",
                    "",
                    " * `change_edge_type_weight`: Option<WeightT> - weight for the exploration of different node types.",
                    "",
                    " # Example",
                    " You can change the `change_edge_type_weight` parameter as follows:",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(-1.0)).is_err());",
                    " assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(2.0)).is_ok());",
                    " assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(1.0)).is_ok());",
                    " assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(1.0)).unwrap().is_first_order_walk());",
                    " ```",
                    " You can also call the method with an option None, in order to avoid a match",
                    " wrapper above. This will end up don't doing anything, just a passthrough.",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(None).unwrap().is_first_order_walk());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_change_edge_type_weight",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "change_edge_type_weight",
                        "Option<WeightT>"
                    ]
                ],
                "return_type": "Result<WalksParameters, String>",
                "body": "if let Some(cetw) = change_edge_type_weight {\n            self.single_walk_parameters.weights.change_edge_type_weight =\n                WalkWeights::validate_weight(\"change_edge_type_weight\", cetw)?;\n        }\n        Ok(self)"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalksParameters",
                "impl_doc": [
                    " Setters for the Walk's parameters"
                ],
                "doc": [
                    " Validate for graph.",
                    "",
                    " Check if walks parameters are compatible with given graph.",
                    "",
                    " # Arguments",
                    "",
                    " * `graph`: Graph - Graph object for which parameters are to be validated.",
                    "",
                    " # Example",
                    " A graph is always remappable to itself:",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " # let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " # let mut parameters = WalksParameters::new(32).unwrap();",
                    " assert!(parameters.set_dense_node_mapping(Some(ppi.get_dense_nodes_mapping())).validate(&ppi).is_ok());",
                    " ```",
                    " Two different graphs, like Cora and STRING, are not remappable:",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " # let cora = graph::test_utilities::load_cora();",
                    " # let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " # let mut parameters = WalksParameters::new(32).unwrap();",
                    " assert!(parameters.set_dense_node_mapping(Some(ppi.get_dense_nodes_mapping())).validate(&cora).is_err());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "validate",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "graph",
                        "&Graph"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "if let Some(dense_node_mapping) = &self.dense_node_mapping {\n            if !graph\n                .iter_unique_source_node_ids()\n                .all(|node| dense_node_mapping.contains_key(&(node as NodeT)))\n            {\n                return Err(String::from(concat!(\n                    \"Given nodes mapping does not contain \",\n                    \"one or more NOT trap nodes that may be extracted from walk.\"\n                )));\n            }\n        }\n\n        Ok(())"
            },
            {
                "file": "walks_parameters.rs",
                "struct": "WalksParameters",
                "impl_doc": [
                    " Setters for the Walk's parameters"
                ],
                "doc": [
                    " Return boolean value representing if walk is of first order.",
                    "",
                    " # Example",
                    " The default parametrization defines a first order walk:",
                    "",
                    " ```rust",
                    " # use graph::walks_parameters::WalksParameters;",
                    " assert!(WalksParameters::new(32).unwrap().is_first_order_walk());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_first_order_walk",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.single_walk_parameters.is_first_order_walk()"
            }
        ]
    },
    "trees.rs": {
        "imports": [
            "use super::*;",
            "use indicatif::ProgressIterator;",
            "use rayon::iter::IntoParallelRefMutIterator;",
            "use rayon::iter::ParallelIterator;",
            "use rayon::{iter::IntoParallelIterator, ThreadPool};",
            "use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};",
            "use std::sync::{Arc, Mutex};",
            "use std::{collections::HashSet, sync::atomic::AtomicU32};",
            "use vec_rand::xorshift::xorshift as rand_u64;"
        ],
        "functions": [
            {
                "file": "trees.rs",
                "doc": [
                    " Returns a rayon thread pool handling Creation errors.",
                    "",
                    " Getting a thread pool might return the error \"Resource temporarly unavailable\"",
                    " if the number of processes currently on the system is more than what set in",
                    " `ulimit -a`, which by default is 256851.",
                    "",
                    " Moreover, we return an error if the number of selected CPUS is 1 or less.",
                    " Because the algorithms which use the pool requires at least 2 threads, and",
                    " we generally provide also an optimized single-thread version."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "get_thread_pool",
                "args": [],
                "return_type": "Result<(usize, ThreadPool), String>",
                "body": "let cpu_number = rayon::current_num_threads();\n\n    if cpu_number <= 1 {\n        return Err(concat!(\n            \"Cannot execute the parallel connected_components method when\",\n            \" only a single CPU is made available.\\n\",\n            \"This might be an erroroneus configuration of the envionment\",\n            \" variable RAYON_NUM_THREADS.\\n\",\n            \"If you really want to compute the connected components with\",\n            \" these configurations, consider using random_spanning_arborescence_kruskal.\"\n        )\n        .to_string());\n    }\n\n    let mut attempts_left = 1_000_000;\n    loop {\n        match rayon::ThreadPoolBuilder::new()\n            .num_threads(cpu_number)\n            .build()\n        {\n            Ok(thread_pool) => return Ok((cpu_number, thread_pool)),\n            Err(internal_error) => {\n                if attempts_left == 0 {\n                    return Err(format!(\n                        concat!(\n                            \"Unknown error while trying to allocate the thread pool for \",\n                            \"executing the parallel connected components algorithm.\\n\",\n                            \"In our experience this happens once in every 100 milions calls\\n\",\n                            \"The interal error is {:?}.\"\n                        ),\n                        internal_error\n                    ));\n                }\n                let delay = std::time::Duration::from_millis(50);\n                std::thread::sleep(delay);\n                attempts_left -= 1;\n            }\n        }\n    }"
            },
            {
                "file": "trees.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Implementation of algorithms relative to trees.",
                    "",
                    " # Definitions",
                    " - **Self-loops**: Edges with source equal to the destination.",
                    " - **Singleton**: A node with no incident edges, (self-loops are not considered).",
                    " - **Spanning Tree**: A set of edges that allows to build a path between every",
                    "     node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
                    " - **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
                    "     with multiple components. Being a tree it trivially contains no self-loops.",
                    "     For a grpah with n nodes and c components the spanning arborescence will have",
                    "     n - c edges.",
                    " - **Component**: Set of nodes in which any two vertices in it are connected to",
                    "     each other by paths. A singleton is a component and so is a singleton with a",
                    "     self-loop."
                ],
                "doc": [
                    " Returns iterator over shuffled edge IDs and node IDs.",
                    "",
                    " # Arguments",
                    " * `random_state`: u64 - The random state to reproduce the given edge sampling."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "iter_edges_from_random_state",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "random_state",
                        "u64"
                    ]
                ],
                "return_type": "impl Iterator<Item = (EdgeT, NodeT, NodeT)> + '_",
                "body": "let edges_number = self.get_directed_edges_number();\n        // We execute two times the xorshift to improve the randomness of the seed.\n        let updated_random_state = rand_u64(rand_u64(random_state ^ SEED_XOR as u64));\n        (updated_random_state..edges_number + updated_random_state).filter_map(move |i| {\n            let edge_id = i % edges_number;\n            let (src, dst) = self.get_unchecked_node_ids_from_edge_id(edge_id);\n            match src == dst || !self.directed && src > dst {\n                true => None,\n                false => Some((edge_id, src, dst)),\n            }\n        })"
            },
            {
                "file": "trees.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Implementation of algorithms relative to trees.",
                    "",
                    " # Definitions",
                    " - **Self-loops**: Edges with source equal to the destination.",
                    " - **Singleton**: A node with no incident edges, (self-loops are not considered).",
                    " - **Spanning Tree**: A set of edges that allows to build a path between every",
                    "     node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
                    " - **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
                    "     with multiple components. Being a tree it trivially contains no self-loops.",
                    "     For a grpah with n nodes and c components the spanning arborescence will have",
                    "     n - c edges.",
                    " - **Component**: Set of nodes in which any two vertices in it are connected to",
                    "     each other by paths. A singleton is a component and so is a singleton with a",
                    "     self-loop."
                ],
                "doc": [
                    " Returns iterator over shuffled edge IDs and node IDs with preference to given edge types.",
                    "",
                    " # Arguments",
                    " * `random_state`: u64 - The random state to reproduce the given edge sampling.",
                    " * `undesired_edge_types`: &'a Option<HashSet<Option<EdgeTypeT>>> - The edge types whose edges are to leave as last.",
                    " * `verbose`: bool - Whether to show a loading bar."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "iter_on_edges_with_preference_from_random_state",
                "generics": "'a",
                "args": [
                    [
                        "self",
                        "&'a self"
                    ],
                    [
                        "random_state",
                        "u64"
                    ],
                    [
                        "undesired_edge_types",
                        "&'a Option<HashSet<Option<EdgeTypeT>>>"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "impl Iterator<Item = (NodeT, NodeT)> + 'a",
                "body": "let pb = get_loading_bar(\n            verbose,\n            format!(\"Building random spanning tree for {}\", self.name).as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n        let result: Box<dyn Iterator<Item = (NodeT, NodeT)>> = if let (Some(uet), _) =\n            (undesired_edge_types, &self.edge_types)\n        {\n            Box::new(\n                self.iter_edges_from_random_state(random_state)\n                    .filter_map(move |(edge_id, src, dst)| {\n                        if uet.contains(&self.get_unchecked_edge_type_id_from_edge_id(edge_id)) {\n                            return None;\n                        }\n                        Some((src, dst))\n                    })\n                    .chain(self.iter_edges_from_random_state(random_state).filter_map(\n                        move |(edge_id, src, dst)| {\n                            if !uet.contains(&self.get_unchecked_edge_type_id_from_edge_id(edge_id))\n                            {\n                                return None;\n                            }\n                            Some((src, dst))\n                        },\n                    )),\n            )\n        } else {\n            Box::new(\n                self.iter_edges_from_random_state(random_state)\n                    .map(|(_, src, dst)| (src, dst)),\n            )\n        };\n\n        result.progress_with(pb)"
            },
            {
                "file": "trees.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Implementation of algorithms relative to trees.",
                    "",
                    " # Definitions",
                    " - **Self-loops**: Edges with source equal to the destination.",
                    " - **Singleton**: A node with no incident edges, (self-loops are not considered).",
                    " - **Spanning Tree**: A set of edges that allows to build a path between every",
                    "     node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
                    " - **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
                    "     with multiple components. Being a tree it trivially contains no self-loops.",
                    "     For a grpah with n nodes and c components the spanning arborescence will have",
                    "     n - c edges.",
                    " - **Component**: Set of nodes in which any two vertices in it are connected to",
                    "     each other by paths. A singleton is a component and so is a singleton with a",
                    "     self-loop."
                ],
                "doc": [
                    " Returns set of edges composing a spanning tree and connected components.",
                    "",
                    " If the graph is composed of a single node with one or more self-loops,",
                    " we consider such a graph as a graph with an empty spanning tree, with",
                    " a single component of size one.",
                    "",
                    " # Arguments",
                    "",
                    " `edges`: impl Iterator<Item = (NodeT, NodeT)> + 'a - Iterator for the edges to explore. If sorted, computed a minimum spanning tree.",
                    "",
                    " # Returns",
                    " Tuple with:",
                    "     - Set of the edges",
                    "     - Vector of the nodes components",
                    "     - Total components number",
                    "     - Minimum component size",
                    "     - Maximum component size"
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "kruskal",
                "generics": "'a",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edges",
                        "impl Iterator<Item = (NodeT, NodeT)> + 'a"
                    ]
                ],
                "return_type": "(HashSet<(NodeT, NodeT)>, Vec<NodeT>, NodeT, NodeT, NodeT)",
                "body": "// If the graph does not have nodes, we return all\n        // results as empty to provide an uniform, though pathological,\n        // return value.\n        if !self.has_nodes() {\n            return (HashSet::new(), Vec::new(), 0, 0, 0);\n        }\n        // Similarly, when dealing with a graph with no edges, we define\n        // the spanning tree as empty and the components as the set of the\n        // nodes themselves. Since all nodes are singletons, both the\n        // maximum component size and minimum component size equals to one.\n        if !self.has_edges() {\n            return (\n                HashSet::new(),\n                self.get_node_ids(),\n                self.get_nodes_number(),\n                1,\n                1,\n            );\n        }\n\n        let nodes_number = self.get_nodes_number() as usize;\n        let mut tree = HashSet::with_capacity(self.get_nodes_number() as usize);\n        let mut components = vec![NOT_PRESENT; nodes_number];\n        let mut component_sizes: Vec<NodeT> = Vec::new();\n        let mut components_remapping: Vec<NodeT> = Vec::new();\n        let mut max_component_size: NodeT = 0;\n        let mut min_component_size = NodeT::MAX;\n\n        // When there are singleton nodes with self-loops,\n        // which is an arguability weird feature of some graphs,\n        // Kruskal fails to identify them because by definition\n        // a tree cannot contain self-loop.\n        // We call these nodes with one or more self-loops\n        // (in the case of a multigraph) `singletons with self-loops` for lack of\n        // a better term. These nodes are treated as nodes in their own\n        // component and their edges (the self-loops) are not added to the tree.\n        if self.has_disconnected_nodes() {\n            // When there are singleton nodes, the minimum component size\n            // surely becomes one.\n            min_component_size = 1;\n            // Similarly we need to bump up the max component size, as if\n            // this graph is composed of only singleton nodes with self-loops\n            // we would not iterate thorugh them in the Kruskal loop\n            // since it skips self-loops.\n            max_component_size = 1;\n            // We iterate through the singleton nodes and the singleton nodes\n            // with self-loops.\n            self.iter_singleton_node_ids()\n                .chain(self.iter_singleton_with_selfloops_node_ids())\n                .enumerate()\n                .for_each(|(component_number, node_id)| {\n                    components[node_id as usize] = component_number as NodeT;\n                });\n            // We can re-initialize the component sizes as the vector with\n            // all ones bit as the singleton nodes number.\n            component_sizes = vec![1; self.get_disconnected_nodes_number() as usize];\n            // Similarly, the components remapping can be initialized to a range.\n            components_remapping =\n                (0..self.get_disconnected_nodes_number()).collect::<Vec<NodeT>>();\n        }\n\n        edges.for_each(|(src, dst)| {\n            // If this is a self-loop we skip it.\n            if src == dst {\n                return;\n            }\n            let src_component = components[src as usize];\n            let dst_component = components[dst as usize];\n            match (src_component == NOT_PRESENT, dst_component == NOT_PRESENT) {\n                // If neither nodes have a component, they must be inserted\n                // both in the components vector and in the tree.\n                // The edge must be added to the three.\n                (true, true) => {\n                    let new_component_id = components_remapping.len() as NodeT;\n                    components[src as usize] = new_component_id;\n                    components[dst as usize] = new_component_id;\n                    components_remapping.push(new_component_id);\n                    component_sizes.push(2);\n                    max_component_size = max_component_size.max(2);\n                }\n                // If both nodes have a component, the two components must be merged\n                // if they are not the same one.\n                // The edge must be added to the three.\n                // The components mapping must be updated and afterwards the other nodes\n                // must be updated accordingly to this update.\n                (false, false) => {\n                    if src_component == dst_component {\n                        return;\n                    }\n                    let src_component = components_remapping[src_component as usize];\n                    let dst_component = components_remapping[dst_component as usize];\n                    if src_component == dst_component {\n                        return;\n                    }\n                    let (node_id_to_update, min_component_id, max_component_id) =\n                        match src_component < dst_component {\n                            true => (dst, src_component, dst_component),\n                            false => (src, dst_component, src_component),\n                        };\n\n                    // We update the node to update with the new component ID.\n                    components[node_id_to_update as usize] = min_component_id;\n\n                    // We merge the two component sizes.\n                    component_sizes[min_component_id as usize] +=\n                        component_sizes[max_component_id as usize];\n\n                    // We check if we have a new component size record\n                    max_component_size =\n                        max_component_size.max(component_sizes[min_component_id as usize]);\n\n                    // If the component we have removed and integrated with\n                    // the component with the smaller has a size greater than\n                    // one, we may need to remap some element of the component\n                    // to this new component.\n                    // Since the components within this loops start from edges\n                    // they cannot be smaller in cardinality than\n                    // two nodes.\n                    components_remapping\n                        .iter_mut()\n                        .zip(component_sizes.iter_mut())\n                        .for_each(|(component_id, component_size)| {\n                            // If one of other components is being remapped to\n                            // the maximum component, we need to update its value\n                            // to the new value this component is being remapped to.\n                            if *component_id == max_component_id {\n                                *component_id = min_component_id;\n                                // We need to invalidate the size of the component\n                                // we have remapped because otherwise we may count it\n                                // when computing the minimum component size.\n                                *component_size = NOT_PRESENT;\n                            }\n                        });\n                }\n                // If only one node has a component, the second node must be added.\n                _ => {\n                    let (component_id, not_inserted_node) = match src_component == NOT_PRESENT {\n                        true => (dst_component, src),\n                        false => (src_component, dst),\n                    };\n                    let component_id = components_remapping[component_id as usize];\n                    component_sizes[component_id as usize] += 1;\n                    max_component_size =\n                        max_component_size.max(component_sizes[component_id as usize]);\n                    components[not_inserted_node as usize] = component_id as NodeT;\n                }\n            };\n            tree.insert((src, dst));\n        });\n\n        // Remapping components to a dense remapping\n        let mut components_number = 0;\n        for i in 0..components_remapping.len() {\n            if components_remapping[i] >= components_number {\n                components_remapping[i] = components_number;\n                components_number += 1;\n            } else {\n                components_remapping[i] = components_remapping[components_remapping[i] as usize];\n            }\n        }\n\n        components.par_iter_mut().for_each(|remapped| {\n            *remapped = components_remapping[*remapped as usize];\n        });\n\n        // If the minimum component size is still bigger than one\n        // that is, we do not know alredy that there is a singleton\n        // we need to compute it.\n        if min_component_size > 1 {\n            min_component_size = match components_number {\n                1 => max_component_size,\n                2 => self.get_nodes_number() - max_component_size,\n                _ => component_sizes.into_par_iter().min().unwrap(),\n            };\n        }\n\n        (\n            tree,\n            components,\n            components_number as NodeT,\n            min_component_size,\n            max_component_size,\n        )"
            },
            {
                "file": "trees.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Implementation of algorithms relative to trees.",
                    "",
                    " # Definitions",
                    " - **Self-loops**: Edges with source equal to the destination.",
                    " - **Singleton**: A node with no incident edges, (self-loops are not considered).",
                    " - **Spanning Tree**: A set of edges that allows to build a path between every",
                    "     node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
                    " - **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
                    "     with multiple components. Being a tree it trivially contains no self-loops.",
                    "     For a grpah with n nodes and c components the spanning arborescence will have",
                    "     n - c edges.",
                    " - **Component**: Set of nodes in which any two vertices in it are connected to",
                    "     each other by paths. A singleton is a component and so is a singleton with a",
                    "     self-loop."
                ],
                "doc": [
                    " Returns set of edges composing a spanning tree and connected components.",
                    "",
                    " The spanning tree is NOT minimal.",
                    " The given random_state is NOT the root of the tree.",
                    "",
                    " This method, additionally, allows for undesired edge types to be",
                    " used to build the spanning tree only in extremis when it is utterly",
                    " necessary in order to complete the spanning arborescence.",
                    "",
                    " The quintuple returned contains:",
                    " - Set of the edges used in order to build the spanning arborescence.",
                    " - Vector of the connected component of each node.",
                    " - Number of connected components.",
                    " - Minimum component size.",
                    " - Maximum component size.",
                    "",
                    " # Arguments",
                    "",
                    " * `random_state`: EdgeT - The random_state to use for the holdout,",
                    " * `undesired_edge_types`: &Option<HashSet<Option<EdgeTypeT>>> - Which edge types id to try to avoid.",
                    " * `verbose`: bool - Whether to show a loading bar or not.",
                    "",
                    " # Example",
                    " To compute a random spanning arborescence using Kruskal you can use the following:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let (",
                    "     spanning_arborescence_set,",
                    "     connected_components_number,",
                    "     number_of_connected_components,",
                    "     minimum_component_size,",
                    "     maximum_component_size",
                    " ) = graph.random_spanning_arborescence_kruskal(",
                    "     42,",
                    "     &None,",
                    "     false",
                    " );",
                    " assert_eq!(connected_components_number.len(), graph.get_nodes_number() as usize);",
                    " assert!(minimum_component_size <= maximum_component_size);",
                    " assert!(maximum_component_size <= graph.get_nodes_number());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "random_spanning_arborescence_kruskal",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "random_state",
                        "EdgeT"
                    ],
                    [
                        "undesired_edge_types",
                        "&Option<HashSet<Option<EdgeTypeT>>>"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "(HashSet<(NodeT, NodeT)>, Vec<NodeT>, NodeT, NodeT, NodeT)",
                "body": "self.kruskal(self.iter_on_edges_with_preference_from_random_state(\n            random_state,\n            undesired_edge_types,\n            verbose,\n        ))"
            },
            {
                "file": "trees.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Implementation of algorithms relative to trees.",
                    "",
                    " # Definitions",
                    " - **Self-loops**: Edges with source equal to the destination.",
                    " - **Singleton**: A node with no incident edges, (self-loops are not considered).",
                    " - **Spanning Tree**: A set of edges that allows to build a path between every",
                    "     node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
                    " - **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
                    "     with multiple components. Being a tree it trivially contains no self-loops.",
                    "     For a grpah with n nodes and c components the spanning arborescence will have",
                    "     n - c edges.",
                    " - **Component**: Set of nodes in which any two vertices in it are connected to",
                    "     each other by paths. A singleton is a component and so is a singleton with a",
                    "     self-loop."
                ],
                "doc": [
                    " Returns consistent spanning arborescence using Kruskal.",
                    "",
                    " The spanning tree is NOT minimal.",
                    "",
                    " The quintuple returned contains:",
                    " - Set of the edges used in order to build the spanning arborescence.",
                    " - Vector of the connected component of each node.",
                    " - Number of connected components.",
                    " - Minimum component size.",
                    " - Maximum component size.",
                    "",
                    " # Arguments",
                    " * `verbose`: bool - Whether to show a loading bar or not.",
                    "",
                    " # Example",
                    " To compute a spanning arborescence using Kruskal you can use the following:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let (",
                    "     spanning_arborescence_set,",
                    "     connected_components_number,",
                    "     number_of_connected_components,",
                    "     minimum_component_size,",
                    "     maximum_component_size",
                    " ) = graph.spanning_arborescence_kruskal(",
                    "     false",
                    " );",
                    " assert_eq!(connected_components_number.len(), graph.get_nodes_number() as usize);",
                    " assert!(minimum_component_size <= maximum_component_size);",
                    " assert!(maximum_component_size <= graph.get_nodes_number());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "spanning_arborescence_kruskal",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "(HashSet<(NodeT, NodeT)>, Vec<NodeT>, NodeT, NodeT, NodeT)",
                "body": "let pb = get_loading_bar(\n            verbose,\n            &format!(\n                \"Computing spanning arborescence with Kruskal for {}\",\n                self.get_name()\n            ),\n            self.get_unique_edges_number() as usize,\n        );\n        self.kruskal(\n            self.iter_unique_edge_node_ids(self.directed)\n                .progress_with(pb),\n        )"
            },
            {
                "file": "trees.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Implementation of algorithms relative to trees.",
                    "",
                    " # Definitions",
                    " - **Self-loops**: Edges with source equal to the destination.",
                    " - **Singleton**: A node with no incident edges, (self-loops are not considered).",
                    " - **Spanning Tree**: A set of edges that allows to build a path between every",
                    "     node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
                    " - **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
                    "     with multiple components. Being a tree it trivially contains no self-loops.",
                    "     For a grpah with n nodes and c components the spanning arborescence will have",
                    "     n - c edges.",
                    " - **Component**: Set of nodes in which any two vertices in it are connected to",
                    "     each other by paths. A singleton is a component and so is a singleton with a",
                    "     self-loop."
                ],
                "doc": [
                    " Returns set of edges composing a spanning arborescence.",
                    "",
                    " This is the implementaiton of [A Fast, Parallel Spanning Tree Algorithm for Symmetric Multiprocessors (SMPs)](https://smartech.gatech.edu/bitstream/handle/1853/14355/GT-CSE-06-01.pdf)",
                    " by David A. Bader and Guojing Cong.",
                    "",
                    " The returned tuple contains:",
                    " - The number edges required in order to build the spanning arborescence.",
                    " - Iterator over the edges used in order to build the spanning arborescence.",
                    "",
                    " # Arguments",
                    " * `verbose`: bool - Whether to show a loading bar or not.",
                    "",
                    " # Raises",
                    " * If this method is called on a directed graph.",
                    " * If the system configuration does not allow for the creation of the thread pool."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "spanning_arborescence",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(usize, impl Iterator<Item = (NodeT, NodeT)> + '_), String>",
                "body": "self.must_be_undirected()?;\n        let nodes_number = self.get_nodes_number() as usize;\n        let mut parents = vec![NOT_PRESENT; nodes_number];\n        let (cpu_number, pool) = get_thread_pool()?;\n        let shared_stacks: Arc<Vec<Mutex<Vec<NodeT>>>> = Arc::from(\n            (0..std::cmp::max(cpu_number - 1, 1))\n                .map(|_| Mutex::from(Vec::new()))\n                .collect::<Vec<Mutex<Vec<NodeT>>>>(),\n        );\n        let active_nodes_number = AtomicUsize::new(0);\n        let completed = AtomicBool::new(false);\n        let total_inserted_edges = AtomicUsize::new(0);\n        let thread_safe_parents = ThreadDataRaceAware {\n            value: std::cell::UnsafeCell::new(&mut parents),\n        };\n\n        // since we were able to build a stub tree with cpu.len() leafs,\n        // we spawn the treads and make anyone of them build the sub-trees.\n        pool.scope(|s| {\n            // for each leaf of the previous stub tree start a DFS keeping track\n            // of which nodes we visited and updating accordingly the parents vector.\n            // the nice trick here is that, since all the leafs are part of the same tree,\n            // if two processes find the same node, we don't care which one of the two take\n            // it so we can proceed in a lockless fashion (and maybe even without atomics\n            // if we manage to remove the colors vecotr and only keep the parents one)\n            s.spawn(|_| {\n                let pb = get_loading_bar(\n                    verbose,\n                    format!(\"Computing spanning tree of graph {}\", self.get_name()).as_ref(),\n                    nodes_number,\n                );\n                let parents = thread_safe_parents.value.get();\n                (0..nodes_number).progress_with(pb).for_each(|src| {\n                    // If the node has already been explored we skip ahead.\n                    if unsafe { (*parents)[src] != NOT_PRESENT} {\n                        return;\n                    }\n\n                    // find the first not explored node (this is guardanteed to be in a new component)\n                    if self.is_unchecked_singleton_from_node_id(src as NodeT) {\n                        // We set singletons as self-loops for now.\n                        unsafe{ (*parents)[src] = src as NodeT };\n                        return;\n                    }\n                    loop {\n                        if unsafe { (*parents)[src] != NOT_PRESENT} {\n                            break;\n                        }\n                        if active_nodes_number.load(Ordering::SeqCst) == 0 {\n                            if unsafe { (*parents)[src] != NOT_PRESENT} {\n                                break;\n                            }\n                            unsafe {\n                                (*parents)[src] = src as NodeT;\n                            }\n                            shared_stacks[0].lock().expect(\"The lock is poisoned from the panic of another thread\")\n                                .push(src as NodeT);\n                            active_nodes_number.fetch_add(1, Ordering::SeqCst);\n                            break;\n                        }\n                    }\n                });\n                completed.store(true, Ordering::SeqCst);\n            });\n            (0..shared_stacks.len()).for_each(|_| {\n                s.spawn(|_| 'outer: loop {\n                    let thread_id = rayon::current_thread_index().expect(\"current_thread_id not called from a rayon thread. This should not be possible because this is in a Rayon Thread Pool.\");\n                    let src = 'inner: loop {\n                        {\n                            for mut stack in (thread_id..(shared_stacks.len() + thread_id))\n                                .map(|id| shared_stacks[id % shared_stacks.len()].lock().expect(\"The lock is poisoned from the panic of another thread\"))\n                            {\n                                if let Some(src) = stack.pop() {\n                                    break 'inner src;\n                                }\n                            }\n\n                            if completed.load(Ordering::SeqCst) {\n                                break 'outer;\n                            }\n                        }\n                    };\n                    let parents = thread_safe_parents.value.get();\n                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(src)\n                        .for_each(|dst| unsafe {\n                            if (*parents)[dst as usize] == NOT_PRESENT {\n                                (*parents)[dst as usize] = src;\n                                total_inserted_edges.fetch_add(1, Ordering::SeqCst);\n                                active_nodes_number.fetch_add(1, Ordering::SeqCst);\n                                shared_stacks[rand_u64(dst as u64) as usize % shared_stacks.len()]\n                                    .lock()\n                                    .expect(\"The lock is poisoned from the panic of another thread\")\n                                    .push(dst);\n                            }\n                        });\n                    active_nodes_number.fetch_sub(1, Ordering::SeqCst);\n                });\n            });\n        });\n\n        // convert the now completed parents vector to a list of tuples representing the edges\n        // of the spanning arborescense.\n        Ok((\n            // Number of edges inserted\n            total_inserted_edges.load(Ordering::SeqCst),\n            // Return an iterator over all the edges in the spanning arborescence\n            parents.into_iter().enumerate().filter_map(|(src, dst)| {\n                if src as NodeT == dst {\n                    return None;\n                }\n                Some((src as NodeT, dst))\n            }),\n        ))"
            },
            {
                "file": "trees.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Implementation of algorithms relative to trees.",
                    "",
                    " # Definitions",
                    " - **Self-loops**: Edges with source equal to the destination.",
                    " - **Singleton**: A node with no incident edges, (self-loops are not considered).",
                    " - **Spanning Tree**: A set of edges that allows to build a path between every",
                    "     node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
                    " - **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
                    "     with multiple components. Being a tree it trivially contains no self-loops.",
                    "     For a grpah with n nodes and c components the spanning arborescence will have",
                    "     n - c edges.",
                    " - **Component**: Set of nodes in which any two vertices in it are connected to",
                    "     each other by paths. A singleton is a component and so is a singleton with a",
                    "     self-loop."
                ],
                "doc": [
                    " Compute the connected components building in parallel a spanning tree using [bader's algorithm](https://www.sciencedirect.com/science/article/abs/pii/S0743731505000882).",
                    "",
                    " **This works only for undirected graphs.**",
                    "",
                    " This method is **not thread save and not deterministic** but by design of the algorithm this",
                    " shouldn't matter but if we will encounter non-detemristic bugs here is where we want to look.",
                    "",
                    " The returned quadruple contains:",
                    " - Vector of the connected component for each node.",
                    " - Number of connected components.",
                    " - Minimum connected component size.",
                    " - Maximum connected component size.",
                    "",
                    " # Arguments",
                    "",
                    " * `verbose`: bool - Whether to show a loading bar or not.",
                    "",
                    " # Example",
                    " ```rust",
                    "  # #![feature(impl_trait_in_bindings)]",
                    "  # use graph::Graph;",
                    "  // Graph is a weightless graph with the edges",
                    "  // [(0, 1), (1, 4), (2, 3)]",
                    "  # let edge: Vec<Result<(String, String, Option<String>, Option<f32>), String>> = vec![",
                    "  #        Ok((\"0\".to_string(), \"1\".to_string(), None, None)),",
                    "  #        Ok((\"1\".to_string(), \"4\".to_string(), None, None)),",
                    "  #        Ok((\"2\".to_string(), \"3\".to_string(), None, None)),",
                    "  #     ];",
                    "  #",
                    "  # let nodes = None.map(|x: Vec<Result<(String, Option<Vec<String>>), String>>| x.into_iter());",
                    "  #",
                    "  # let graph = Graph::from_string_unsorted(",
                    "  #     edge.into_iter(),",
                    "  #     nodes,      // nodes",
                    "  #     false,     // directed",
                    "  #     false,      // directe edge list",
                    "  #     \"test graph\",// name",
                    "  #     false,     // ignore_duplicated_nodes",
                    "  #     true,     // node_list_is_correct",
                    "  #     false,     // ignore_duplicated_nodes",
                    "  #     true,     // node_list_is_correct",
                    "  #     false,     // numeric_edge_types_ids",
                    "  #     false,     // numeric_node_ids",
                    "  #     false,     // numeric_edge_node_ids",
                    "  #     false,     // numeric_node_types_ids",
                    "  #     false,     // has_node_types",
                    "  #     false,     // has_edge_types",
                    "  #     false,     // has_edge_weights",
                    "  #     true,    // maybe_has_singleton",
                    "  #     true,    // maybe_has_singleton_with_selfloops",
                    "  #     true,    // maybe_has_node_traps",
                    "  #     false,     // verbose",
                    "  # ).unwrap();",
                    " let (components, number_of_components, smallest, biggest) =",
                    "     graph.connected_components(false).unwrap();",
                    "",
                    " //   nodes names:       0  1  4  2  3",
                    " assert_eq!(components, [0, 0, 0, 1, 1].to_vec());",
                    "",
                    " assert_eq!(number_of_components, 2);",
                    " assert_eq!(smallest, 2); // the size of the smallest component",
                    " assert_eq!(biggest, 3);  // the size of the biggest component",
                    " ```",
                    "",
                    " # Raises",
                    " * If the given graph is directed.",
                    " * If the system configuration does not allow for the creation of the thread pool."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "connected_components",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(Vec<NodeT>, NodeT, NodeT, NodeT), String>",
                "body": "self.must_be_undirected()?;\n        if !self.has_nodes() {\n            return Ok((Vec::new(), 0, 0, 0));\n        }\n        if self.get_edges_number() == 0 {\n            return Ok((\n                self.iter_node_ids().collect(),\n                self.get_nodes_number(),\n                1,\n                1,\n            ));\n        }\n        let components = self\n            .iter_node_ids()\n            .map(|_| AtomicU32::new(NOT_PRESENT))\n            .collect::<Vec<_>>();\n        let mut min_component_size: NodeT = NodeT::MAX;\n        let mut max_component_size: NodeT = 0;\n        let mut components_number: NodeT = 0;\n        let (cpu_number, pool) = get_thread_pool()?;\n        let shared_stacks: Arc<Vec<Mutex<Vec<NodeT>>>> = Arc::from(\n            (0..std::cmp::max(cpu_number - 1, 1))\n                .map(|_| Mutex::from(Vec::new()))\n                .collect::<Vec<Mutex<Vec<NodeT>>>>(),\n        );\n        let active_nodes_number = AtomicUsize::new(0);\n        let current_component_size = AtomicU32::new(0);\n        let completed = AtomicBool::new(false);\n        let thread_safe_min_component_size = ThreadDataRaceAware {\n            value: std::cell::UnsafeCell::new(&mut min_component_size),\n        };\n        let thread_safe_max_component_size = ThreadDataRaceAware {\n            value: std::cell::UnsafeCell::new(&mut max_component_size),\n        };\n        let thread_safe_components_number = ThreadDataRaceAware {\n            value: std::cell::UnsafeCell::new(&mut components_number),\n        };\n\n        // since we were able to build a stub tree with cpu.len() leafs,\n        // we spawn the treads and make anyone of them build the sub-trees.\n        pool.scope(|s| {\n            // for each leaf of the previous stub tree start a DFS keeping track\n            // of which nodes we visited and updating accordingly the components vector.\n            // the nice trick here is that, since all the leafs are part of the same tree,\n            // if two processes find the same node, we don't care which one of the two take\n            // it so we can proceed in a lockless fashion (and maybe even without atomics\n            // if we manage to remove the colors vecotr and only keep the components one)\n            s.spawn(|_| {\n                let pb = get_loading_bar(\n                    verbose,\n                    format!(\n                        \"Computing connected components of graph {}\",\n                        self.get_name()\n                    )\n                    .as_ref(),\n                    self.get_nodes_number() as usize,\n                );\n                let min_component_size = thread_safe_min_component_size.value.get();\n                let max_component_size = thread_safe_max_component_size.value.get();\n                let components_number = thread_safe_components_number.value.get();\n                self.iter_node_ids()\n                    .progress_with(pb)\n                    .for_each(|src| {\n                        // If the node has already been explored we skip ahead.\n                        if components[src as usize].load(Ordering::Relaxed) != NOT_PRESENT {\n                            return;\n                        }\n\n                        // find the first not explored node (this is guardanteed to be in a new component)\n                        if self.has_disconnected_nodes()\n                            && (self.is_unchecked_singleton_from_node_id(src)\n                                || self.is_singleton_with_selfloops_from_node_id(src))\n                        {\n                            // We set singletons as self-loops for now.\n                            unsafe {\n                                components[src as usize]\n                                    .store(**components_number, Ordering::Relaxed);\n                                **components_number += 1;\n                                **min_component_size = 1;\n                                **max_component_size = (**max_component_size).max(1);\n                            }\n                            return;\n                        }\n\n                        loop {\n                            // if the node has been now mapped to a component by anyone of the\n                            // parallel threads, move on to the next node.\n                            if components[src as usize].load(Ordering::Relaxed) != NOT_PRESENT {\n                                break;\n                            }\n                            // Otherwise, Check if the parallel threads are finished\n                            // and are all waiting for a new node to explore.\n                            // In that case add the currently not explored node to the\n                            // work stack of the first thread.\n                            if active_nodes_number.load(Ordering::Relaxed) == 0 {\n                                // The check here might seems redundant but its' needed\n                                // to prevent data races.\n                                //\n                                // If the last parallel thread finishes its stack between the\n                                // presence check above and the active nodes numbers check\n                                // the src node will never increase the component size and thus\n                                // leading to wrong results.\n                                if components[src as usize].load(Ordering::Relaxed) != NOT_PRESENT {\n                                    break;\n                                }\n                                let ccs =\n                                    current_component_size.swap(1, Ordering::Relaxed) as NodeT;\n                                unsafe {\n                                    **max_component_size = (**max_component_size).max(ccs);\n                                    if ccs > 1 {\n                                        **min_component_size = (**min_component_size).min(ccs);\n                                    }\n                                    components[src as usize]\n                                        .store(**components_number, Ordering::Relaxed);\n                                    **components_number += 1;\n                                }\n                                active_nodes_number.fetch_add(1, Ordering::Relaxed);\n                                shared_stacks[0].lock().expect(\"The lock is poisoned from the panic of another thread\").push(src);\n                                break;\n                            }\n                            // Otherwise, Loop until the parallel threads are finished.\n                        }\n                    });\n                completed.store(true, Ordering::Relaxed);\n            });\n\n            // Spawn the parallel threads that handle the components mapping,\n            // these threads use work-stealing, meaning that if their stack is empty,\n            // they will steal nodes from the stack of another random thread.\n            (0..shared_stacks.len()).for_each(|_| {\n                s.spawn(|_| 'outer: loop {\n                    // get the id, we use this as an idex for the stacks vector.\n                    let thread_id = rayon::current_thread_index().expect(\"current_thread_id not called from a rayon thread. This should not be possible because this is in a Rayon Thread Pool.\");\n\n                    let src = 'inner: loop {\n                        {\n                            for mut stack in (thread_id..(shared_stacks.len() + thread_id))\n                                .map(|id| shared_stacks[id % shared_stacks.len()].lock().expect(\"The lock is poisoned from the panic of another thread\"))\n                            {\n                                if let Some(src) = stack.pop() {\n                                    break 'inner src;\n                                }\n                            }\n\n                            if completed.load(Ordering::Relaxed) {\n                                break 'outer;\n                            }\n                        }\n                    };\n\n                    let src_component = components[src as usize].load(Ordering::Relaxed);\n                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(src)\n                        .for_each(|dst| {\n                            if components[dst as usize].swap(src_component, Ordering::SeqCst)\n                                == NOT_PRESENT\n                            {\n                                active_nodes_number.fetch_add(1, Ordering::SeqCst);\n                                current_component_size.fetch_add(1, Ordering::SeqCst);\n                                shared_stacks[rand_u64(dst as u64) as usize % shared_stacks.len()]\n                                    .lock()\n                                    .expect(\"The lock is poisoned from the panic of another thread\")\n                                    .push(dst);\n                            }\n                        });\n                    active_nodes_number.fetch_sub(1, Ordering::SeqCst);\n                });\n            });\n        });\n\n        let ccs = current_component_size.load(Ordering::SeqCst);\n        max_component_size = max_component_size.max(ccs);\n        if ccs > 1 {\n            min_component_size = min_component_size.min(ccs);\n        }\n\n        Ok((\n            unsafe { std::mem::transmute::<Vec<AtomicU32>, Vec<NodeT>>(components) },\n            components_number,\n            min_component_size,\n            max_component_size,\n        ))"
            }
        ]
    },
    "csv_file_writer.rs": {
        "imports": [
            "use super::*;",
            "use indicatif::ProgressIterator;",
            "use std::{fs::File, io::prelude::*, io::BufWriter};"
        ],
        "functions": [
            {
                "file": "csv_file_writer.rs",
                "struct": "CSVFileWriter",
                "impl_doc": [
                    " Structure that saves the common parameters for reading csv files.",
                    "",
                    " # Attributes",
                    " * path: String - The path where to save the file. E.g. \"/tmp/test.csv\"",
                    " * `verbose`: bool - If the progress bars and logging must be displayed.",
                    " * separator: String - The separator to use, usually, this is \"\\t\" for tsv and \",\" for csv.",
                    " * header: bool - If the file (will / must) have the header with the titles of the columns.",
                    " # Builder methods"
                ],
                "doc": [
                    " Return new CSVFileWriter object.",
                    "",
                    " # Arguments",
                    "",
                    " * path: String - Path where to store/load the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "new",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "path",
                        "S"
                    ]
                ],
                "return_type": "CSVFileWriter",
                "body": "CSVFileWriter {\n            path: path.into(),\n            verbose: true,\n            separator: \"\\t\".to_string(),\n            header: true,\n        }"
            },
            {
                "file": "csv_file_writer.rs",
                "struct": "CSVFileWriter",
                "impl_doc": [
                    " Structure that saves the common parameters for reading csv files.",
                    "",
                    " # Attributes",
                    " * path: String - The path where to save the file. E.g. \"/tmp/test.csv\"",
                    " * `verbose`: bool - If the progress bars and logging must be displayed.",
                    " * separator: String - The separator to use, usually, this is \"\\t\" for tsv and \",\" for csv.",
                    " * header: bool - If the file (will / must) have the header with the titles of the columns.",
                    " # Builder methods"
                ],
                "doc": [
                    " Write given rows iterator to file.",
                    "",
                    " # Arguments",
                    "",
                    " * `lines_number`: u64 - Number of lines to expect to write out.",
                    " * `header`: Vec<String> - The header to write out, if so required.",
                    " * `values`: impl Iterator<Item = Vec<String>> - Iterator of rows to write out."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "write_lines",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "lines_number",
                        "usize"
                    ],
                    [
                        "header",
                        "Vec<String>"
                    ],
                    [
                        "values",
                        "impl Iterator<Item = Vec<String>>"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "let pb = get_loading_bar(self.verbose, \"Writing to file\", lines_number);\n\n        let file = match File::create(self.path.clone()) {\n            Ok(f) => Ok(f),\n            Err(_) => Err(format!(\"Cannot open in writing the file {}\", self.path)),\n        }?;\n\n        let mut stream = BufWriter::new(file);\n\n        if self.header {\n            let mut line = header.join(&self.separator);\n            line.push('\\n');\n            match stream.write(line.as_bytes()) {\n                Ok(_) => Ok(()),\n                Err(_) => {\n                    Err(\"Cannot write the header. There might have been an I/O error.\".to_string())\n                }\n            }?;\n        }\n\n        for (i, value) in values.progress_with(pb).enumerate() {\n            let mut line = value.join(&self.separator);\n            line.push('\\n');\n            match stream.write(line.as_bytes()) {\n                Ok(_) => Ok(()),\n                Err(_) => Err(format!(\n                    \"Cannot write the {i} line. There might have been an I/O error.\",\n                    i = i\n                )),\n            }?;\n        }\n\n        match stream.flush() {\n            Ok(_) => Ok(()),\n            Err(_) => Err(\"Unable to close file. There might have been an I/O error.\".to_string()),\n        }"
            },
            {
                "file": "csv_file_writer.rs",
                "doc": [
                    " Return formatted vector of rows.",
                    "",
                    " # Arguments",
                    "",
                    " * `number_of_columns`: usize - Total number of columns to renderize.",
                    " * `pairs`: Vec<(String, usize)> - Vector of tuples of column names and their position."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "compose_lines",
                "args": [
                    [
                        "number_of_columns",
                        "usize"
                    ],
                    [
                        "pairs",
                        "Vec<(String"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "let mut values = vec![\"\".to_string(); number_of_columns];\n    for (name, pos) in pairs {\n        values[pos] = name\n    }\n    values"
            }
        ]
    },
    "graph.rs": {
        "imports": [
            "use super::*;",
            "use bitvec::prelude::*;",
            "use elias_fano_rust::EliasFano;",
            "use rayon::prelude::*;",
            "use roaring::RoaringBitmap;",
            "use std::collections::HashMap;"
        ],
        "functions": [
            {
                "file": "graph.rs",
                "struct": "Graph",
                "impl_doc": [
                    " A graph representation optimized for executing random walks on huge graphs.",
                    "",
                    " This class should be initialized using the two constructors:",
                    " `graph::Graph::new_directed` or `graph::Graph::new_undirected`",
                    "",
                    " # Example",
                    " Load the graph Cora:",
                    " ```rust",
                    " use graph::*;",
                    "",
                    " // Create the edge file reader",
                    " let edges_reader = EdgeFileReader::new(\"tests/data/cora/edges.tsv\").unwrap()",
                    "     .set_separator(Some(\"\\t\")).unwrap()",
                    "     .set_verbose(Some(false))",
                    "     .set_sources_column(Some(\"subject\")).unwrap()",
                    "     .set_destinations_column(Some(\"object\")).unwrap()",
                    "     .set_default_weight(Some(1.0))",
                    "     .set_edge_types_column(Some(\"edge_type\")).unwrap();",
                    "",
                    " // Create the node file reader",
                    " let nodes_reader = Some(",
                    "     NodeFileReader::new(\"tests/data/cora/nodes.tsv\").unwrap()",
                    "         .set_separator(Some(\"\\t\")).unwrap()",
                    "         .set_nodes_column(Some(\"id\")).unwrap()",
                    "         .set_verbose(Some(false))",
                    "         .set_node_types_column(Some(\"node_type\")).unwrap(),",
                    " );",
                    "",
                    " // Load the graph",
                    " let mut cora = Graph::from_unsorted_csv(",
                    "     edges_reader,",
                    "     nodes_reader,",
                    "     false,          // if the graph is Directed",
                    "     false,          // if the edge list is Directed",
                    "     \"Cora\".to_string()",
                    "    ).unwrap();",
                    "",
                    " // Enable Speed-ups but it uses more memory.",
                    " cora.enable(true, true, true, None).unwrap();",
                    " ```",
                    " # Graph utility methods"
                ],
                "doc": [],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "new",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "unique_selfloop_number",
                        "NodeT"
                    ],
                    [
                        "selfloop_number",
                        "EdgeT"
                    ],
                    [
                        "connected_nodes_number",
                        "NodeT"
                    ],
                    [
                        "singleton_nodes_with_selfloops_number",
                        "NodeT"
                    ],
                    [
                        "unique_edges_number",
                        "EdgeT"
                    ],
                    [
                        "edges",
                        "EliasFano"
                    ],
                    [
                        "unique_sources",
                        "Option<EliasFano>"
                    ],
                    [
                        "nodes",
                        "Vocabulary<NodeT>"
                    ],
                    [
                        "node_bit_mask",
                        "EdgeT"
                    ],
                    [
                        "node_bits",
                        "u8"
                    ],
                    [
                        "edge_types",
                        "Option<EdgeTypeVocabulary>"
                    ],
                    [
                        "name",
                        "S"
                    ],
                    [
                        "weights",
                        "Option<Vec<WeightT>>"
                    ],
                    [
                        "min_edge_weight",
                        "Option<WeightT>"
                    ],
                    [
                        "max_edge_weight",
                        "Option<WeightT>"
                    ],
                    [
                        "node_types",
                        "Option<NodeTypeVocabulary>"
                    ],
                    [
                        "connected_nodes",
                        "Option<BitVec<Lsb0, u8>>"
                    ],
                    [
                        "singleton_nodes_with_selfloops",
                        "Option<RoaringBitmap>"
                    ],
                    [
                        "min_node_degree",
                        "NodeT"
                    ],
                    [
                        "max_node_degree",
                        "NodeT"
                    ]
                ],
                "return_type": "Graph",
                "body": "Graph {\n            directed,\n            unique_selfloop_number,\n            selfloop_number,\n            connected_nodes_number,\n            singleton_nodes_with_selfloops_number,\n            unique_edges_number,\n            edges,\n            unique_sources,\n            node_bit_mask,\n            node_bits,\n            weights,\n            min_edge_weight,\n            max_edge_weight,\n            min_node_degree,\n            max_node_degree,\n            node_types: node_types.map(|nts| nts.set_numeric_ids(false)),\n            edge_types: edge_types.map(|ets| ets.set_numeric_ids(false)),\n            nodes: nodes.set_numeric_ids(false),\n            sources: None,\n            destinations: None,\n            cumulative_node_degrees: None,\n            cached_destinations: None,\n            name: name.into(),\n            connected_nodes,\n            singleton_nodes_with_selfloops,\n            cached_report: ClonableRwLock::new(None),\n        }"
            },
            {
                "file": "graph.rs",
                "struct": "Graph",
                "impl_doc": [
                    " A graph representation optimized for executing random walks on huge graphs.",
                    "",
                    " This class should be initialized using the two constructors:",
                    " `graph::Graph::new_directed` or `graph::Graph::new_undirected`",
                    "",
                    " # Example",
                    " Load the graph Cora:",
                    " ```rust",
                    " use graph::*;",
                    "",
                    " // Create the edge file reader",
                    " let edges_reader = EdgeFileReader::new(\"tests/data/cora/edges.tsv\").unwrap()",
                    "     .set_separator(Some(\"\\t\")).unwrap()",
                    "     .set_verbose(Some(false))",
                    "     .set_sources_column(Some(\"subject\")).unwrap()",
                    "     .set_destinations_column(Some(\"object\")).unwrap()",
                    "     .set_default_weight(Some(1.0))",
                    "     .set_edge_types_column(Some(\"edge_type\")).unwrap();",
                    "",
                    " // Create the node file reader",
                    " let nodes_reader = Some(",
                    "     NodeFileReader::new(\"tests/data/cora/nodes.tsv\").unwrap()",
                    "         .set_separator(Some(\"\\t\")).unwrap()",
                    "         .set_nodes_column(Some(\"id\")).unwrap()",
                    "         .set_verbose(Some(false))",
                    "         .set_node_types_column(Some(\"node_type\")).unwrap(),",
                    " );",
                    "",
                    " // Load the graph",
                    " let mut cora = Graph::from_unsorted_csv(",
                    "     edges_reader,",
                    "     nodes_reader,",
                    "     false,          // if the graph is Directed",
                    "     false,          // if the edge list is Directed",
                    "     \"Cora\".to_string()",
                    "    ).unwrap();",
                    "",
                    " // Enable Speed-ups but it uses more memory.",
                    " cora.enable(true, true, true, None).unwrap();",
                    " ```",
                    " # Graph utility methods"
                ],
                "doc": [
                    " Return whether given graph has any edge overlapping with current graph.",
                    "",
                    " # Arguments",
                    "",
                    " * `other`: &Graph - The graph to check against.",
                    "",
                    " # Example",
                    " You can whether two graphs are overlapping as follows:",
                    " ```rust",
                    " # let ppi = graph::test_utilities::load_ppi(true, true, false, false, false, false);",
                    " # let cora = graph::test_utilities::load_cora();",
                    " assert!(ppi.overlaps(&ppi).unwrap());",
                    " assert!(cora.overlaps(&cora).unwrap());",
                    " assert!(!ppi.overlaps(&cora).unwrap());",
                    " assert!(!cora.overlaps(&ppi).unwrap());",
                    " let (train, test) = ppi.random_holdout(",
                    "     42,",
                    "     0.8,",
                    "     false,",
                    "     None,",
                    "     None,",
                    "     false",
                    " ).unwrap();",
                    " assert!(ppi.overlaps(&train).unwrap());",
                    " assert!(ppi.overlaps(&test).unwrap());",
                    " assert!(train.overlaps(&ppi).unwrap());",
                    " assert!(test.overlaps(&ppi).unwrap());",
                    " assert!(!train.overlaps(&test).unwrap());",
                    " assert!(!test.overlaps(&train).unwrap());",
                    " ```",
                    "",
                    " # Raises",
                    " * If a graph is directed and the other is undirected.",
                    " * If one of the two graphs has edge weights and the other does not.",
                    " * If one of the two graphs has node types and the other does not.",
                    " * If one of the two graphs has edge types and the other does not."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "overlaps",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "other",
                        "&Graph"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "Ok(match self.is_compatible(other)? {\n            true => other\n                .par_iter_edge_node_ids_and_edge_type_id(other.directed)\n                .any(|(_, src, dst, et)| {\n                    self.has_edge_from_node_ids_and_edge_type_id(src, dst, et)\n                }),\n            false => other\n                .par_iter_edge_node_names_and_edge_type_name(other.directed)\n                .any(|(_, _, src_name, _, dst_name, _, edge_type_name)| {\n                    self.has_edge_from_node_names_and_edge_type_name(\n                        &src_name,\n                        &dst_name,\n                        edge_type_name.as_deref(),\n                    )\n                }),\n        })"
            },
            {
                "file": "graph.rs",
                "struct": "Graph",
                "impl_doc": [
                    " A graph representation optimized for executing random walks on huge graphs.",
                    "",
                    " This class should be initialized using the two constructors:",
                    " `graph::Graph::new_directed` or `graph::Graph::new_undirected`",
                    "",
                    " # Example",
                    " Load the graph Cora:",
                    " ```rust",
                    " use graph::*;",
                    "",
                    " // Create the edge file reader",
                    " let edges_reader = EdgeFileReader::new(\"tests/data/cora/edges.tsv\").unwrap()",
                    "     .set_separator(Some(\"\\t\")).unwrap()",
                    "     .set_verbose(Some(false))",
                    "     .set_sources_column(Some(\"subject\")).unwrap()",
                    "     .set_destinations_column(Some(\"object\")).unwrap()",
                    "     .set_default_weight(Some(1.0))",
                    "     .set_edge_types_column(Some(\"edge_type\")).unwrap();",
                    "",
                    " // Create the node file reader",
                    " let nodes_reader = Some(",
                    "     NodeFileReader::new(\"tests/data/cora/nodes.tsv\").unwrap()",
                    "         .set_separator(Some(\"\\t\")).unwrap()",
                    "         .set_nodes_column(Some(\"id\")).unwrap()",
                    "         .set_verbose(Some(false))",
                    "         .set_node_types_column(Some(\"node_type\")).unwrap(),",
                    " );",
                    "",
                    " // Load the graph",
                    " let mut cora = Graph::from_unsorted_csv(",
                    "     edges_reader,",
                    "     nodes_reader,",
                    "     false,          // if the graph is Directed",
                    "     false,          // if the edge list is Directed",
                    "     \"Cora\".to_string()",
                    "    ).unwrap();",
                    "",
                    " // Enable Speed-ups but it uses more memory.",
                    " cora.enable(true, true, true, None).unwrap();",
                    " ```",
                    " # Graph utility methods"
                ],
                "doc": [
                    " Return true if given graph edges are all contained within current graph.",
                    "",
                    " # Arguments",
                    "",
                    " * `other`: &Graph - The graph to check against.",
                    "",
                    " # Example",
                    " You can whether two graphs contain one another as follows:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, false, false, false, false);",
                    " let (train, test) = graph.random_holdout(",
                    "     42,",
                    "     0.8,",
                    "     false,",
                    "     None,",
                    "     None,",
                    "     false",
                    " ).unwrap();",
                    " assert!(graph.contains(&train).unwrap());",
                    " assert!(graph.contains(&test).unwrap());",
                    " assert!(!train.contains(&graph).unwrap());",
                    " assert!(!test.contains(&graph).unwrap());",
                    " assert!(!train.contains(&test).unwrap());",
                    " assert!(!test.contains(&train).unwrap());",
                    " ```",
                    "",
                    " # Raises",
                    " * If a graph is directed and the other is undirected.",
                    " * If one of the two graphs has edge weights and the other does not.",
                    " * If one of the two graphs has node types and the other does not.",
                    " * If one of the two graphs has edge types and the other does not."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "contains",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "other",
                        "&Graph"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "Ok(match self.is_compatible(other)? {\n            true => other\n                .par_iter_edge_node_ids_and_edge_type_id(other.directed)\n                .all(|(_, src, dst, et)| {\n                    self.has_edge_from_node_ids_and_edge_type_id(src, dst, et)\n                }),\n            false => other\n                .par_iter_edge_node_names_and_edge_type_name(other.directed)\n                .all(|(_, _, src_name, _, dst_name, _, edge_type_name)| {\n                    self.has_edge_from_node_names_and_edge_type_name(\n                        &src_name,\n                        &dst_name,\n                        edge_type_name.as_deref(),\n                    )\n                }),\n        })"
            }
        ]
    },
    "preprocessing.rs": {
        "imports": [
            "use super::*;",
            "use atomic_float::AtomicF64;",
            "use bitvec::prelude::*;",
            "use indicatif::{ParallelProgressIterator, ProgressIterator};",
            "use itertools::Itertools;",
            "use num_traits::Pow;",
            "use rand::rngs::StdRng;",
            "use rand::seq::SliceRandom;",
            "use rand::SeedableRng;",
            "use rayon::prelude::*;",
            "use std::collections::{HashMap, VecDeque};",
            "use vec_rand::gen_random_vec;",
            "use vec_rand::xorshift::xorshift;"
        ],
        "functions": [
            {
                "file": "preprocessing.rs",
                "doc": [
                    " Computes val % n using lemires fast method for u32.",
                    " https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/",
                    " This is supposed to be ~5 times faster."
                ],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "",
                "name": "fast_u32_modulo",
                "args": [
                    [
                        "val",
                        "u32"
                    ],
                    [
                        "n",
                        "u32"
                    ]
                ],
                "return_type": "u32",
                "body": "((val as u64 * n as u64) >> 32) as u32"
            },
            {
                "file": "preprocessing.rs",
                "doc": [
                    " Return training batches for Word2Vec models.",
                    "",
                    " The batch is composed of a tuple as the following:",
                    "",
                    " - (Contexts indices, central nodes indices): the tuple of nodes",
                    "",
                    " This does not provide any output value as the model uses NCE loss",
                    " and basically the central nodes that are fed as inputs work as the",
                    " outputs value.",
                    "",
                    " # Arguments",
                    "",
                    " * `sequences`: impl ParallelIterator<Item = Vec<NodeT>> + 'a - the sequence of sequences of integers to preprocess.",
                    " * `window_size`: usize - Window size to consider for the sequences.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "word2vec",
                "generics": "'a",
                "args": [
                    [
                        "sequences",
                        "impl ParallelIterator<Item = Vec<NodeT>> + 'a"
                    ],
                    [
                        "window_size",
                        "usize"
                    ]
                ],
                "return_type": "impl ParallelIterator<Item = (Vec<NodeT>, NodeT)> + 'a",
                "body": "sequences.flat_map_iter(move |sequence| {\n        let sequence_length = sequence.len();\n        if sequence_length < window_size * 2 + 1 {\n            panic!(\n                \"\n            Cannot compute word2vec, got a sequence of length {} and window size {}.\n            for the current window_size the minimum sequence length required is {}\",\n                sequence_length,\n                window_size,\n                window_size * 2 + 1,\n            );\n        }\n        (window_size..(sequence_length - window_size)).map(move |i| {\n            (\n                (i - window_size..i)\n                    .chain(i + 1..window_size + i + 1)\n                    .map(|j| sequence[j])\n                    .collect(),\n                sequence[i],\n            )\n        })\n    })"
            },
            {
                "file": "preprocessing.rs",
                "doc": [
                    " Return triple with CSR representation of cooccurrence matrix.",
                    "",
                    " The first vector has the sources, the second vector the destinations",
                    " and the third one contains the min-max normalized frequencies.",
                    "",
                    " # Arguments",
                    "",
                    " * `sequences`: impl ParallelIterator<Item = Vec<NodeT>> - the sequence of sequences of integers to preprocess.",
                    " * `window_size`: Option<usize> - Window size to consider for the sequences.",
                    " * `verbose`: Option<bool> - Whether to show the progress bars. The default behaviour is false.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "cooccurence_matrix",
                "args": [
                    [
                        "sequences",
                        "impl ParallelIterator<Item = Vec<NodeT>>"
                    ],
                    [
                        "window_size",
                        "usize"
                    ],
                    [
                        "number_of_sequences",
                        "usize"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(usize, impl Iterator<Item = (NodeT, NodeT, f64)>), String>",
                "body": "let mut cooccurence_matrix: HashMap<(NodeT, NodeT), f64> = HashMap::new();\n    let mut max_frequency = 0.0;\n    let pb1 = get_loading_bar(verbose, \"Computing frequencies\", number_of_sequences);\n\n    // TODO!: Avoid this collect and create the cooccurrence matrix in a parallel way.\n    // We are currently working on this but is terribly non-trivial,\n    // as most parallel implementations end up being slower than sequential\n    // ones or require massive amounts of additional memory.\n    let vec = sequences.collect::<Vec<Vec<NodeT>>>();\n    vec.iter().progress_with(pb1).for_each(|sequence| {\n        let walk_length = sequence.len();\n        for (central_index, &central_word_id) in sequence.iter().enumerate() {\n            let upperbound = std::cmp::min(1 + window_size, walk_length - central_index);\n\n            for distance in 1..upperbound {\n                let context_id = sequence[central_index + distance];\n\n                let (smaller, bigger) = (\n                    std::cmp::min(central_word_id, context_id),\n                    std::cmp::max(central_word_id, context_id),\n                );\n\n                let freq = 1.0 / distance as f64;\n\n                // Get the current value for this pair of nodes\n                let ptr = cooccurence_matrix\n                    .entry((smaller, bigger))\n                    .and_modify(|e| *e += freq)\n                    .or_insert(freq);\n                // Update the max\n                if *ptr > max_frequency {\n                    max_frequency = *ptr;\n                }\n            }\n        }\n    });\n\n    let number_of_elements = cooccurence_matrix.len();\n    let pb2 = get_loading_bar(\n        verbose,\n        \"Converting mapping into CSR matrix\",\n        cooccurence_matrix.len(),\n    );\n    Ok((\n        number_of_elements,\n        cooccurence_matrix\n            .into_iter()\n            .progress_with(pb2)\n            .map(move |((word, context), frequency)| (word, context, frequency / max_frequency)),\n    ))"
            },
            {
                "file": "preprocessing.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Preprocessing for ML algorithms on graph."
                ],
                "doc": [
                    " Return training batches for Node2Vec models.",
                    "",
                    " The batch is composed of a tuple as the following:",
                    "",
                    " - (Contexts indices, central nodes indices): the tuple of nodes",
                    "",
                    " This does not provide any output value as the model uses NCE loss",
                    " and basically the central nodes that are fed as inputs work as the",
                    " outputs value.",
                    "",
                    " # Arguments",
                    "",
                    " * `walk_parameters`: &'a WalksParameters - the weighted walks parameters.",
                    " * `quantity`: NodeT - Number of nodes to consider.",
                    " * `window_size`: usize - Window size to consider for the sequences.",
                    "",
                    " # Raises",
                    " * If the graph does not contain edges.",
                    " * If the graph is directed.",
                    " * If the given walks parameters are not compatible with the current graph instance."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "node2vec",
                "generics": "'a",
                "args": [
                    [
                        "self",
                        "&'a self"
                    ],
                    [
                        "walk_parameters",
                        "&'a WalksParameters"
                    ],
                    [
                        "quantity",
                        "NodeT"
                    ],
                    [
                        "window_size",
                        "usize"
                    ]
                ],
                "return_type": "Result<impl ParallelIterator<Item = (Vec<NodeT>, NodeT)> + 'a, String>",
                "body": "Ok(word2vec(\n            self.iter_random_walks(quantity, walk_parameters)?,\n            window_size,\n        ))"
            },
            {
                "file": "preprocessing.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Preprocessing for ML algorithms on graph."
                ],
                "doc": [
                    " Return triple with CSR representation of cooccurrence matrix.",
                    "",
                    " The first vector has the sources, the second vector the destinations",
                    " and the third one contains the min-max normalized frequencies.",
                    "",
                    " # Arguments",
                    "",
                    " * `walks_parameters`: &'a WalksParameters - the walks parameters.",
                    " * `window_size`: usize - Window size to consider for the sequences.",
                    " * `verbose`: bool - Whether to show the progress bars. The default behaviour is false.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "cooccurence_matrix",
                "generics": "'a",
                "args": [
                    [
                        "self",
                        "&'a self"
                    ],
                    [
                        "walks_parameters",
                        "&'a WalksParameters"
                    ],
                    [
                        "window_size",
                        "usize"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(usize, impl Iterator<Item = (NodeT, NodeT, f64)> + 'a), String>",
                "body": "self.must_have_edges()?;\n        let walks = self.iter_complete_walks(walks_parameters)?;\n        cooccurence_matrix(\n            walks,\n            window_size,\n            (self.get_unique_source_nodes_number() * walks_parameters.iterations) as usize,\n            verbose,\n        )"
            },
            {
                "file": "preprocessing.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Preprocessing for ML algorithms on graph."
                ],
                "doc": [
                    " Return iterator over neighbours for the given node ID, optionally including given node ID.",
                    "",
                    " This method is meant to be used to predict node labels using the NoLaN model.",
                    "",
                    " If you need to predict the node label of a node, not during training,",
                    " use `max_neighbours=None`.",
                    "",
                    " # Arguments",
                    "",
                    " * `central_node_id`: NodeT - The node ID to retrieve neighbours for.",
                    " * `random_state`: u64 - The random state to use to extract the neighbours.",
                    " * `include_central_node`: bool - Whether to include the node ID in the returned iterator.",
                    " * `offset`: NodeT - Offset for padding porposes.",
                    " * `max_neighbours`: Option<NodeT> - Number of maximum neighbours to consider.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "get_neighbours_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "central_node_id",
                        "NodeT"
                    ],
                    [
                        "random_state",
                        "u64"
                    ],
                    [
                        "include_central_node",
                        "bool"
                    ],
                    [
                        "offset",
                        "NodeT"
                    ],
                    [
                        "max_neighbours",
                        "Option<NodeT>"
                    ]
                ],
                "return_type": "impl Iterator<Item = NodeT> + '_",
                "body": "(if include_central_node {\n            vec![central_node_id]\n        } else {\n            vec![]\n        })\n        .into_iter()\n        .chain(\n            self.get_unchecked_destination_node_ids_from_node_id(\n                central_node_id,\n                random_state,\n                max_neighbours,\n            )\n            .into_iter(),\n        )\n        .map(move |node_id| node_id + offset)"
            },
            {
                "file": "preprocessing.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Preprocessing for ML algorithms on graph."
                ],
                "doc": [
                    " Return tuple with iterator over neighbours for the given node ID, optionally including given node ID, and node type.",
                    "",
                    " This method is meant to be used to predict node labels using the NoLaN model.",
                    "",
                    " If you need to predict the node label of a node, not during training,",
                    " use `max_neighbours=None`.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_id`: NodeT - The node ID to retrieve neighbours for.",
                    " * `random_state`: u64 - The random state to use to extract the neighbours.",
                    " * `include_central_node`: bool - Whether to include the node ID in the returned iterator.",
                    " * `offset`: NodeT - Offset for padding porposes.",
                    " * `max_neighbours`: Option<NodeT> - Number of maximum neighbours to consider.",
                    "",
                    " # Safety",
                    " The method will return a None node type also when the graph does",
                    " not contain node types.",
                    " Return iterator over neighbours for the given node IDs, optionally including given the node IDs, and node type.",
                    "",
                    " This method is meant to be used to predict node labels using the NoLaN model.",
                    "",
                    " If you need to predict the node label of a node, not during training,",
                    " use `max_neighbours=None`.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_ids`: Vec<NodeT> - The node ID to retrieve neighbours for.",
                    " * `random_state`: u64 - The random state to use to extract the neighbours.",
                    " * `include_central_node`: bool - Whether to include the node ID in the returned iterator.",
                    " * `offset`: NodeT - Offset for padding porposes.",
                    " * `max_neighbours`: Option<NodeT> - Number of maximum neighbours to consider.",
                    "",
                    " # Example",
                    " Suppose you want to the get the neighbours of the first 10 nodes:",
                    " ```rust",
                    " # use rayon::iter::ParallelIterator;",
                    " # use graph::NodeT;",
                    " # use rayon::iter::IndexedParallelIterator;",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, false, false, false);",
                    " let node_ids = (0..10).collect::<Vec<NodeT>>();",
                    " let include_central_nodes = true;",
                    " let offset = 0;",
                    " let max_neighbours = 5;",
                    " let iterator = graph.get_node_label_prediction_tuple_from_node_ids(",
                    "    node_ids.clone(), 42, include_central_nodes, offset, Some(max_neighbours)",
                    " ).unwrap();",
                    " iterator.enumerate().for_each(|(i, (neighbours_iter, labels))|{",
                    "     for (j, node_id) in neighbours_iter.enumerate(){",
                    "         if j==0 && include_central_nodes{",
                    "             assert!(node_id==node_ids[i]);",
                    "         }",
                    "         assert!(",
                    "             max_neighbours + include_central_nodes as NodeT > j as NodeT,",
                    "             \"The index {} is higher than the given maximum neighbours number {}!\",",
                    "             j,",
                    "             max_neighbours",
                    "         );",
                    "     }",
                    " });",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph does not contain node type IDs."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_label_prediction_tuple_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_ids",
                        "Vec<NodeT>"
                    ],
                    [
                        "random_state",
                        "u64"
                    ],
                    [
                        "include_central_node",
                        "bool"
                    ],
                    [
                        "offset",
                        "NodeT"
                    ],
                    [
                        "max_neighbours",
                        "Option<NodeT>"
                    ]
                ],
                "return_type": "Result<\n        impl Iterator<Item = (impl Iterator<Item = NodeT> + '_, Option<Vec<NodeTypeT>>)> + '_,\n        String,\n    >",
                "body": "self.must_have_node_types()?;\n        Ok(node_ids.into_iter().map(move |node_id| unsafe {\n            self.get_node_label_prediction_tuple_from_node_id(\n                node_id,\n                random_state,\n                include_central_node,\n                offset,\n                max_neighbours,\n            )\n        }))"
            },
            {
                "file": "preprocessing.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Preprocessing for ML algorithms on graph."
                ],
                "doc": [
                    " Returns triple with the ids of source nodes, destination nodes and labels for training model for link prediction.",
                    "",
                    " # Arguments",
                    "",
                    " * `idx`: u64 - The index of the batch to generate, behaves like a random random_state,",
                    " * `batch_size`: usize - The maximal size of the batch to generate,",
                    " * `negative_samples`: f64 - The component of netagetive samples to use,",
                    " * `avoid_false_negatives`: bool - Whether to remove the false negatives when generated. It should be left to false, as it has very limited impact on the training, but enabling this will slow things down.",
                    " * `maximal_sampling_attempts`: usize - Number of attempts to execute to sample the negative edges.",
                    " * `graph_to_avoid`: &'a Option<&Graph> - The graph whose edges are to be avoided during the generation of false negatives,",
                    "",
                    " # Raises",
                    " * If the given amount of negative samples is not a positive finite real value."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "link_prediction_ids",
                "generics": "'a",
                "args": [
                    [
                        "self",
                        "&'a self"
                    ],
                    [
                        "idx",
                        "u64"
                    ],
                    [
                        "batch_size",
                        "usize"
                    ],
                    [
                        "negative_samples",
                        "f64"
                    ],
                    [
                        "avoid_false_negatives",
                        "bool"
                    ],
                    [
                        "maximal_sampling_attempts",
                        "usize"
                    ],
                    [
                        "graph_to_avoid",
                        "&'a Option<&Graph>"
                    ]
                ],
                "return_type": "Result<impl ParallelIterator<Item = (usize, NodeT, NodeT, bool)> + 'a, String>",
                "body": "// xor the random_state with a constant so that we have a good amount of 0s and 1s in the number\n        // even with low values (this is needed becasue the random_state 0 make xorshift return always 0)\n        let random_state = idx ^ SEED_XOR as u64;\n\n        if negative_samples < 0.0 || !negative_samples.is_finite() {\n            return Err(\"Negative sample must be a posive real value.\".to_string());\n        }\n\n        // The number of negatives is given by computing their fraction of batchsize\n        let negative_number: usize =\n            ((batch_size as f64 / (1.0 + negative_samples)) * negative_samples) as usize;\n        // All the remaining values then are positives\n        let positive_number: usize = batch_size - negative_number;\n        let graph_has_no_selfloops = !self.has_selfloops();\n\n        let edges_number = self.get_directed_edges_number() as u64;\n        let nodes_number = self.get_nodes_number() as u32;\n\n        let mut rng: StdRng = SeedableRng::seed_from_u64(random_state);\n        let random_values = gen_random_vec(batch_size, random_state);\n        let mut indices: Vec<usize> = (0..batch_size).collect();\n        indices.shuffle(&mut rng);\n\n        Ok((0..batch_size)\n            .into_par_iter()\n            .map(move |i| {\n                let mut sampled = random_values[i];\n                if i < positive_number{\n                    let (src, dst) = self.get_unchecked_node_ids_from_edge_id(sampled % edges_number);\n                    (indices[i], src, dst, true)\n                } else {\n                    for _ in 0..maximal_sampling_attempts {\n                        // split the random u64 into 2 u32 and mod them to have\n                        // usable nodes (this is slightly biased towards low values)\n                        let src = fast_u32_modulo((sampled & 0xffffffff) as u32, nodes_number);\n                        let dst = fast_u32_modulo((sampled >> 32) as u32, nodes_number);\n\n                        if avoid_false_negatives && self.has_edge_from_node_ids(src, dst) {\n                            sampled = xorshift(sampled);\n                            continue;\n                        }\n\n                        if let Some(g) = &graph_to_avoid {\n                            if g.has_edge_from_node_ids(src, dst)  {\n                                sampled = xorshift(sampled);\n                                continue;\n                            }\n                        }\n\n                        if graph_has_no_selfloops && src == dst {\n                            sampled = xorshift(sampled);\n                            continue;\n                        }\n\n                        return (indices[i], src, dst, false);\n                    }\n                    panic!(\n                        concat!(\n                            \"Executed more than {} attempts to sample a negative edge.\\n\",\n                            \"If your graph is so small that you see this error, you may want to consider \",\n                            \"using one of the edge embedding transformer from the Embiggen library.\"\n                        ),\n                        maximal_sampling_attempts\n                    );\n                }\n            }))"
            },
            {
                "file": "preprocessing.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Preprocessing for ML algorithms on graph."
                ],
                "doc": [
                    " Returns triple with the degrees of source nodes, destination nodes and labels for training model for link prediction.",
                    " This method is just for setting the lowerbound on the simplest possible model.",
                    "",
                    " # Arguments",
                    "",
                    " * `idx`: u64 - The index of the batch to generate, behaves like a random random_state,",
                    " * `batch_size`: usize - The maximal size of the batch to generate,",
                    " * `normalize`: bool - Divide the degrees by the max, this way the values are in [0, 1],",
                    " * `negative_samples`: f64 - The component of netagetive samples to use,",
                    " * `avoid_false_negatives`: bool - Whether to remove the false negatives when generated. It should be left to false, as it has very limited impact on the training, but enabling this will slow things down.",
                    " * `maximal_sampling_attempts`: usize - Number of attempts to execute to sample the negative edges.",
                    " * `graph_to_avoid`: &'a Option<&Graph> - The graph whose edges are to be avoided during the generation of false negatives,",
                    "",
                    " # Raises",
                    " * If the given amount of negative samples is not a positive finite real value."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "link_prediction_degrees",
                "generics": "'a",
                "args": [
                    [
                        "self",
                        "&'a self"
                    ],
                    [
                        "idx",
                        "u64"
                    ],
                    [
                        "batch_size",
                        "usize"
                    ],
                    [
                        "normalize",
                        "bool"
                    ],
                    [
                        "negative_samples",
                        "f64"
                    ],
                    [
                        "avoid_false_negatives",
                        "bool"
                    ],
                    [
                        "maximal_sampling_attempts",
                        "usize"
                    ],
                    [
                        "graph_to_avoid",
                        "&'a Option<&Graph>"
                    ]
                ],
                "return_type": "Result<impl ParallelIterator<Item = (usize, f64, f64, bool)> + 'a, String>",
                "body": "let iter = self.link_prediction_ids(\n            idx,\n            batch_size,\n            negative_samples,\n            avoid_false_negatives,\n            maximal_sampling_attempts,\n            graph_to_avoid,\n        )?;\n\n        let max_degree = match normalize {\n            true => self.get_max_node_degree()? as f64,\n            false => 1.0,\n        };\n\n        Ok(iter.map(move |(index, src, dst, label)| {\n            (\n                index,\n                self.get_unchecked_unweighted_node_degree_from_node_id(src) as f64 / max_degree,\n                self.get_unchecked_unweighted_node_degree_from_node_id(dst) as f64 / max_degree,\n                label,\n            )\n        }))"
            },
            {
                "file": "preprocessing.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Preprocessing for ML algorithms on graph."
                ],
                "doc": [
                    " Returns all available edge prediction metrics for given edges.",
                    "",
                    " The metrics returned are, in order:",
                    " - Adamic Adar index",
                    " - Jaccard Coefficient",
                    " - Resource Allocation index",
                    " - Normalized preferential attachment score",
                    "",
                    " # Arguments",
                    " source_node_ids: Vec<NodeT> - List of source node IDs.",
                    " destination_node_ids: Vec<NodeT> - List of destination node IDs.",
                    "",
                    " # Safety",
                    " If one of the given nodes does not exists in the graph, i.e. that is",
                    " higher than the number of nodes in the graph, the method will panic",
                    " and crash.",
                    "",
                    " Returns okapi node features propagation within given maximal distance.",
                    "",
                    " # Arguments",
                    " * `features`: Vec<Option<Vec<f64>>> - The features to propagate. Use None to represent eventual unknown features.",
                    " * `iterations`: Option<usize> - The number of iterations to execute. By default one.",
                    " * `maximal_distance`: Option<usize> - The distance to consider for the cooccurrences. The default value is 3.",
                    " * `k1`: Option<f64> - The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.",
                    " * `b`: Option<f64> - The b parameter from okapi. Tipicaly 0.75.",
                    " * `include_central_node`: Option<bool> - Whether to include the central node. By default true.",
                    " * `verbose`: Option<bool> - Whether to show loading bar.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types.",
                    "",
                    " # References",
                    " The algorithm implemented is a generalization of the OKAPI BM25 TFIDF",
                    " algorithm generalized for graphs."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_okapi_bm25_node_feature_propagation",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "features",
                        "Vec<Vec<f64>>"
                    ],
                    [
                        "iterations",
                        "Option<usize>"
                    ],
                    [
                        "maximal_distance",
                        "Option<usize>"
                    ],
                    [
                        "k1",
                        "Option<f64>"
                    ],
                    [
                        "b",
                        "Option<f64>"
                    ],
                    [
                        "include_central_node",
                        "Option<bool>"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Vec<Vec<f64>>, String>",
                "body": "// The graph must have nodes to support node feature propagation\n        self.must_have_nodes()?;\n        // Validate the provided features\n        validate_features(&features, self.get_nodes_number() as usize)?;\n        // We use as default distance 3\n        let maximal_distance = maximal_distance.unwrap_or(3);\n        // K1 values are typically between 1.2 and 2.0 in absence of additional\n        // tuning of the model.\n        let k1 = k1.unwrap_or(1.5);\n        // b values are tipically equal to 0.75 in abscence of additional tuning.\n        let b = b.unwrap_or(0.75);\n        // By default we only execute 1 iteration\n        let iterations = iterations.unwrap_or(1);\n        // The number of iterations must be equal or greater than one.\n        if iterations == 0 {\n            return Err(\n                \"The number of iterations must be a strictly positive integer.\".to_string(),\n            );\n        }\n        // By default we include the features of the central node.\n        // This is a bias in the context of labels.\n        let include_central_node = include_central_node.unwrap_or(true);\n        // Get the number of possible elements in the features vocabulary\n        let features_number = features[0].len() as usize;\n        // Get the number of 'documents'\n        let nodes_number = self.get_nodes_number() as usize;\n        // Loading bar\n        let iterations_progress_bar = get_loading_bar(\n            verbose.unwrap_or(true) && iterations > 1,\n            \"Iterating features propagation\",\n            nodes_number,\n        );\n        // Execute the propagation\n        for _ in (0..iterations).progress_with(iterations_progress_bar) {\n            // Computing the inverse document features (IDF)\n            let inverse_document_frequencies = (0..features_number)\n                .map(|feature_number| {\n                    let feature_sum = self\n                        .iter_node_ids()\n                        .map(|node_id| (features[node_id as usize][feature_number] > 0.0) as NodeT)\n                        .sum::<NodeT>();\n                    // Definition of the IDF from Okapi, generalized for the\n                    // real frequencies.\n                    ((nodes_number as f64 - feature_sum as f64 + 0.5) / (feature_sum as f64 + 0.5)\n                        + 1.0)\n                        .ln()\n                })\n                .collect::<Vec<f64>>();\n            let total_document_size = AtomicF64::new(0.0);\n            // Creating loading bar\n            let pb = get_loading_bar(\n                verbose.unwrap_or(true),\n                \"Computing new co-occurrences\",\n                nodes_number,\n            );\n            // Update features\n            features = self\n                .par_iter_node_ids()\n                .progress_with(pb)\n                .map(|node_id| {\n                    // Create a new empty queue.\n                    let mut neighbours_stack = VecDeque::with_capacity(nodes_number);\n                    // Put the distance of the original node as 0.\n                    neighbours_stack.push_front((node_id, 0));\n                    // Create a binary mask for the visited node.\n                    let mut visited = bitvec![Lsb0, u8; 0; nodes_number];\n                    // Initialize the sum of the features\n                    let mut document_features_sum = 0.0;\n                    // We set the current root node as visited\n                    unsafe { *visited.get_unchecked_mut(node_id as usize) = true };\n                    // We initialize the local weighted co-occurrences\n                    let mut cooccurrences = if include_central_node {\n                        features[node_id as usize].clone()\n                    } else {\n                        vec![0.0; features_number]\n                    };\n                    // Iterating over\n                    while let Some((current_node_id, distance)) = neighbours_stack.pop_back() {\n                        let new_distance = distance + 1;\n                        self.iter_unchecked_neighbour_node_ids_from_source_node_id(current_node_id)\n                            .for_each(|neighbour_node_id| {\n                                if visited[neighbour_node_id as usize] {\n                                    return;\n                                }\n                                unsafe {\n                                    *visited.get_unchecked_mut(neighbour_node_id as usize) = true\n                                };\n                                features[neighbour_node_id as usize]\n                                    .iter()\n                                    .cloned()\n                                    .enumerate()\n                                    .for_each(|(i, feature)| {\n                                        let normalized_feature =\n                                            feature / (new_distance as f64).pow(2);\n                                        document_features_sum += normalized_feature;\n                                        cooccurrences[i] += normalized_feature;\n                                    });\n                                if new_distance <= maximal_distance {\n                                    neighbours_stack.push_front((neighbour_node_id, new_distance));\n                                }\n                            });\n                    }\n                    total_document_size\n                        .fetch_add(document_features_sum, std::sync::atomic::Ordering::Relaxed);\n                    cooccurrences\n                })\n                .collect::<Vec<Vec<f64>>>();\n            // Computing average document size\n            let average_document_size = total_document_size\n                .load(std::sync::atomic::Ordering::Relaxed)\n                / nodes_number as f64;\n            // Creating loading bar\n            let pb = get_loading_bar(\n                verbose.unwrap_or(true),\n                \"Propagating features\",\n                nodes_number,\n            );\n            features\n                .par_iter_mut()\n                .progress_with(pb)\n                .for_each(|node_cooccurrences| {\n                    let document_features_sum = node_cooccurrences.iter().sum::<f64>();\n                    if document_features_sum > 0.0 {\n                        node_cooccurrences.iter_mut().enumerate().for_each(\n                            |(node_type, cooccurrence)| {\n                                *cooccurrence = inverse_document_frequencies[node_type]\n                                    * ((*cooccurrence * (k1 + 1.0))\n                                        / (*cooccurrence\n                                            + k1 * (1.0 - b\n                                                + b * document_features_sum\n                                                    / average_document_size)));\n                            },\n                        );\n                    }\n                });\n            // We have to run a min-max scaling because otherwise\n            // the biases caused by a large BFS exploration will obscure the\n            // local variance.\n            let min_max = (0..features_number)\n                .map(|feature_number| {\n                    self.iter_node_ids()\n                        .map(|node_id| features[node_id as usize][feature_number])\n                        .minmax()\n                        .into_option()\n                        .unwrap()\n                })\n                .collect::<Vec<_>>();\n            features.par_iter_mut().for_each(|node_features| {\n                node_features.iter_mut().zip(min_max.iter()).for_each(\n                    |(feature, &(min_feature, max_feature))| {\n                        *feature =\n                            (*feature - min_feature) / (max_feature - min_feature + f64::EPSILON);\n                    },\n                );\n            });\n        }\n        Ok(features)"
            },
            {
                "file": "preprocessing.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Preprocessing for ML algorithms on graph."
                ],
                "doc": [
                    " Returns okapi node label propagation within given maximal distance.",
                    "",
                    " # Arguments",
                    " * `iterations`: Option<usize> - The number of iterations to execute. By default one.",
                    " * `maximal_distance`: Option<usize> - The distance to consider for the cooccurrences. The default value is 3.",
                    " * `k1`: Option<f64> - The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.",
                    " * `b`: Option<f64> - The b parameter from okapi. Tipicaly 0.75.",
                    " * `verbose`: Option<bool> - Whether to show loading bar.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types.",
                    "",
                    " # References",
                    " The algorithm implemented is a generalization of the OKAPI BM25 TFIDF",
                    " algorithm generalized for graphs."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_okapi_bm25_node_label_propagation",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "iterations",
                        "Option<usize>"
                    ],
                    [
                        "maximal_distance",
                        "Option<usize>"
                    ],
                    [
                        "k1",
                        "Option<f64>"
                    ],
                    [
                        "b",
                        "Option<f64>"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Vec<Vec<f64>>, String>",
                "body": "self.get_okapi_bm25_node_feature_propagation(\n            self.get_one_hot_encoded_node_types()?\n                .into_iter()\n                .map(|dummies| {\n                    dummies\n                        .into_iter()\n                        .map(|dummie| if dummie { 1.0 } else { 0.0 })\n                        .collect()\n                })\n                .collect(),\n            iterations,\n            maximal_distance,\n            k1,\n            b,\n            Some(false),\n            verbose,\n        )"
            }
        ]
    },
    "utils.rs": {
        "imports": [
            "use super::*;",
            "use indicatif::{ProgressBar, ProgressStyle};"
        ],
        "functions": [
            {
                "file": "utils.rs",
                "doc": [
                    " Take a vector and make it a None if its empty, Some(vector) otherwise"
                ],
                "attrs": [
                    "#[macro_export]"
                ],
                "modifiers": "pub",
                "name": "get_loading_bar",
                "args": [
                    [
                        "verbose",
                        "bool"
                    ],
                    [
                        "desc",
                        "&str"
                    ],
                    [
                        "total_iterations",
                        "usize"
                    ]
                ],
                "return_type": "ProgressBar",
                "body": "if verbose {\n        let pb = ProgressBar::new(total_iterations as u64);\n        let candidate_iterations = total_iterations as u64 / 1000;\n        let candidate_iterations = candidate_iterations.max(1);\n        pb.set_draw_delta(candidate_iterations);\n        pb.set_style(ProgressStyle::default_bar().template(&format!(\n            \"{desc} {{spinner:.green}} [{{elapsed_precise}}] [{{bar:40.cyan/blue}}] ({{pos}}/{{len}}, ETA {{eta}})\",\n            desc=desc\n        )));\n        pb\n    } else {\n        ProgressBar::hidden()\n    }"
            },
            {
                "file": "utils.rs",
                "doc": [
                    " Validated the provided features.",
                    "",
                    " Specifically, the features must:",
                    " - Be provided for all of the expected elements.",
                    " - Be non-empty.",
                    " - Be of a consistent size, that is the number of features for each element must be equal.",
                    "",
                    " # Arguments",
                    " * `features`: Vec<Vec<f64>> - The features to validate.",
                    " * `expected_elements_number`: usize - The number of expected elements."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "validate_features",
                "args": [
                    [
                        "features",
                        "&Vec<Vec<f64>>"
                    ],
                    [
                        "expected_elements_number",
                        "usize"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "if features.len() != expected_elements_number {\n        return Err(format!(\n            concat!(\n                \"The expected features vector length was expected to be {}, \",\n                \"but is {}.\"\n            ),\n            expected_elements_number,\n            features.len()\n        ));\n    }\n    let expected_node_features_length = features.first().unwrap().len();\n    if expected_node_features_length == 0 {\n        return Err(\"The node features length must be greater than zero.\".to_string());\n    }\n    for node_features in features.iter() {\n        if expected_node_features_length != node_features.len() {\n            return Err(format!(\n                concat!(\n                    \"The node features length needs to be consistent: the expected \",\n                    \"size was {} while the found length was {}.\"\n                ),\n                expected_node_features_length,\n                node_features.len()\n            ));\n        }\n    }\n    Ok(())"
            },
            {
                "file": "utils.rs",
                "doc": [
                    " Return true if the given weight is near to one."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "not_one",
                "args": [
                    [
                        "weight",
                        "WeightT"
                    ]
                ],
                "return_type": "bool",
                "body": "(weight - 1.0).abs() > WeightT::EPSILON"
            },
            {
                "file": "utils.rs",
                "struct": "Graph",
                "doc": [
                    " Return vector of edges to be inserted in the holdout."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "compute_edge_ids_vector",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ],
                    [
                        "include_all_edge_types",
                        "bool"
                    ]
                ],
                "return_type": "Vec<EdgeT>",
                "body": "if include_all_edge_types {\n            let (min_edge_id, max_edge_id) =\n                self.get_unchecked_minmax_edge_ids_from_node_ids(src, dst);\n            (min_edge_id..max_edge_id).collect::<Vec<EdgeT>>()\n        } else {\n            vec![edge_id]\n        }"
            },
            {
                "file": "utils.rs",
                "doc": [
                    " Return validated weight.",
                    "",
                    " A weight, to be valid in the context of graph machine learning",
                    " as we have defined, must be strictly positive and non infinite.",
                    "",
                    " # Arguments",
                    "",
                    " * `weight`: WeightT - The weight to validate.",
                    "",
                    " # Example",
                    " The weight can be validated as follows:",
                    " ```rust",
                    " # use graph::utils::validate_weight;",
                    " assert!(validate_weight(0.0).is_err());",
                    " assert!(validate_weight(-1.0).is_ok());",
                    " assert!(validate_weight(2.0).is_ok());",
                    " assert_eq!(validate_weight(2.0).unwrap(), 2.0);",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "validate_weight",
                "args": [
                    [
                        "weight",
                        "WeightT"
                    ]
                ],
                "return_type": "Result<WeightT, String>",
                "body": "if weight.is_finite() && weight != 0.0 {\n        Ok(weight)\n    } else {\n        Err(format!(\n            \"The weight is '{}' but the weights must be non-zero and finite.\",\n            weight\n        ))\n    }"
            },
            {
                "file": "utils.rs",
                "doc": [
                    " Return given weight parsed from string to float.",
                    "",
                    " # Arguments",
                    "",
                    " * `weight`: String - The weight to be parsed.",
                    "",
                    " # Example",
                    " The weight can be validated as follows:",
                    " ```rust",
                    " # use graph::utils::parse_weight;",
                    " assert!(parse_weight(\"0.0\".to_string()).is_ok());",
                    " assert!(parse_weight(\"-1.0\".to_string()).is_ok());",
                    " assert!(parse_weight(\"2.0\".to_string()).is_ok());",
                    " assert!(parse_weight(\"2ghgjh.0\".to_string()).is_err());",
                    " assert_eq!(parse_weight(\"2.0\".to_string()).unwrap(), 2.0);",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "parse_weight",
                "args": [
                    [
                        "weight",
                        "String"
                    ]
                ],
                "return_type": "Result<WeightT, String>",
                "body": "weight\n        .parse::<WeightT>()\n        .map_err(|_| format!(\"Cannot parse weight {} as a float.\", weight))"
            },
            {
                "file": "utils.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "argmax",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Option<(usize, T)>;\n}\n\nimpl<T: PartialOrd + Copy> ArgMax<T> for Vec<T>",
                "body": "fn argmax(&self) -> Option<(usize, T)> {\n        self.iter()\n            .enumerate()\n            .fold(None, |current_max, (i, &value)| {\n                current_max.map_or(Some((i, value)), |(j, current_max_value)| {\n                    Some(if value > current_max_value {\n                        (i, value)\n                    } else {\n                        (j, current_max_value)\n                    })\n                })\n            })\n    }"
            }
        ]
    },
    "csv_file_reader.rs": {
        "imports": [
            "use indicatif::ProgressIterator;",
            "use itertools::Itertools;",
            "use std::{fs::File, io::prelude::*, io::BufReader};",
            "use crate::utils::get_loading_bar;"
        ],
        "functions": [
            {
                "file": "csv_file_reader.rs",
                "struct": "CSVFileReader",
                "impl_doc": [
                    " Structure that saves the common parameters for reading csv files.",
                    " # Builder methods"
                ],
                "doc": [
                    " Return new CSVFileReader object.",
                    "",
                    " # Arguments",
                    "",
                    " * path: String - Path where to store/load the file.",
                    " * list_name: String - Name of the list that is being loaded.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "new",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "path",
                        "S"
                    ],
                    [
                        "list_name",
                        "String"
                    ]
                ],
                "return_type": "Result<CSVFileReader, String>",
                "body": "let path = path.into();\n        // check file existance\n        match File::open(&path) {\n            Ok(_) => Ok(CSVFileReader {\n                path,\n                verbose: true,\n                separator: \"\\t\".to_string(),\n                header: true,\n                rows_to_skip: 0,\n                ignore_duplicates: true,\n                csv_is_correct: false,\n                max_rows_number: None,\n                comment_symbol: None,\n                list_name,\n                graph_name: \"Graph\".to_string(),\n            }),\n            Err(_) => Err(format!(\"Cannot open the file at {}\", path)),\n        }"
            },
            {
                "file": "csv_file_reader.rs",
                "struct": "CSVFileReader",
                "impl_doc": [
                    " Structure that saves the common parameters for reading csv files.",
                    " # Builder methods"
                ],
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "get_buffer_reader",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<BufReader<File>, String>",
                "body": "let file = File::open(&self.path);\n        file.map_or_else(\n            |_| Err(format!(\"Cannot open the file at {}\", self.path)),\n            |file| Ok(BufReader::new(file)),\n        )"
            },
            {
                "file": "csv_file_reader.rs",
                "struct": "CSVFileReader",
                "impl_doc": [
                    " Structure that saves the common parameters for reading csv files.",
                    " # Builder methods"
                ],
                "doc": [
                    " Read the whole file and return how many rows it has."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "count_rows",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<usize, String>",
                "body": "Ok(std::cmp::min(\n            self.get_buffer_reader()?.lines().count(),\n            self.max_rows_number.unwrap_or(u64::MAX) as usize,\n        ))"
            },
            {
                "file": "csv_file_reader.rs",
                "struct": "CSVFileReader",
                "impl_doc": [
                    " Structure that saves the common parameters for reading csv files.",
                    " # Builder methods"
                ],
                "doc": [
                    " Return list of components of the header."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_header",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<String>, String>",
                "body": "if let Some(first_line) = self.get_lines_iterator(false)?.next() {\n            Ok(first_line?\n                .split(&self.separator)\n                .map(|s| s.to_string())\n                .collect::<Vec<String>>())\n        } else {\n            Err(\"The given file has no lines!\".to_string())\n        }"
            },
            {
                "file": "csv_file_reader.rs",
                "struct": "CSVFileReader",
                "impl_doc": [
                    " Structure that saves the common parameters for reading csv files.",
                    " # Builder methods"
                ],
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_lines_iterator",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "skip_header",
                        "bool"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = Result<String, String>> + '_, String>",
                "body": "let rows_to_skip = match skip_header {\n            true => match (self.rows_to_skip as u64).checked_add(self.header as u64) {\n                Some(v) => Ok(v),\n                None => Err(concat!(\n                    \"This overflow was caused because rows to skip = 2**64 - 1\",\n                    \"and header is set to true which causes to skip one extra line.\",\n                    \"Do you **really** want to skip 18446744073709551615 lines? Bad person. Bad.\"\n                )),\n            }?,\n            false => self.rows_to_skip as u64,\n        } as usize;\n        Ok(self.get_buffer_reader()?\n            .lines()\n            .map(|line| match line {\n                Ok(l)=>Ok(l),\n                Err(_)=>Err(\"There might have been an I/O error or the line could contains bytes that are not valid UTF-8\".to_string()),\n            })\n            .filter_ok(move |line| !line.is_empty() && match &self.comment_symbol {\n                Some(cs) => !line.starts_with(cs),\n                _ => true,\n            })\n            .skip(rows_to_skip))"
            },
            {
                "file": "csv_file_reader.rs",
                "struct": "CSVFileReader",
                "impl_doc": [
                    " Structure that saves the common parameters for reading csv files.",
                    " # Builder methods"
                ],
                "doc": [
                    " Return elements of the first line not to be skipped."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_elements_per_line",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<usize, String>",
                "body": "let first_line = self.get_lines_iterator(true)?.next();\n        match first_line {\n            Some(fl) => {\n                match fl {\n                    Ok(f) => {\n                        Ok(f.matches(&self.separator).count() + 1)\n                    },\n                    Err(_) => Err(\"There might have been an I/O error or the line could contains bytes that are not valid UTF-8\".to_string())\n                }\n            },\n            None => Err(concat!(\n                \"Unable to read the first non skipped line of the file.\\n\",\n                \"The file has possibly less than the expected amount of lines\"\n            ).to_string())\n        }"
            },
            {
                "file": "csv_file_reader.rs",
                "struct": "CSVFileReader",
                "impl_doc": [
                    " Structure that saves the common parameters for reading csv files.",
                    " # Builder methods"
                ],
                "doc": [
                    " Return iterator that read a CSV file rows."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "read_lines",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = Result<Vec<Option<String>>, String>> + '_, String>",
                "body": "let pb = get_loading_bar(\n            self.verbose,\n            format!(\"Reading {}'s {}\", self.graph_name, self.list_name).as_ref(),\n            if self.verbose { self.count_rows()? } else { 0 },\n        );\n\n        let number_of_elements_per_line = self.get_elements_per_line()?;\n        Ok(self\n            .get_lines_iterator(true)?\n            .progress_with(pb)\n            // skip empty lines\n            .take(self.max_rows_number.unwrap_or(u64::MAX) as usize)\n            // Handling NaN values and padding them to the number of rows\n            .map_ok(move |line| {\n                let mut elements: Vec<Option<String>> = line\n                    .split(&self.separator)\n                    .map(|element| match element.is_empty() {\n                        true => None,\n                        false => Some(element.to_string()),\n                    })\n                    .collect();\n                elements.resize(number_of_elements_per_line, None);\n                elements\n            }))"
            },
            {
                "file": "csv_file_reader.rs",
                "struct": "CSVFileReader",
                "impl_doc": [
                    " Structure that saves the common parameters for reading csv files.",
                    " # Builder methods"
                ],
                "doc": [
                    " Return number of the given column in header.",
                    "",
                    " # Arguments",
                    "",
                    " * column_name: String - Column to get the number of.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_column_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "column_name",
                        "String"
                    ]
                ],
                "return_type": "Result<usize, String>",
                "body": "let header = self.get_header()?;\n\n        match header.iter().position(|x| *x == column_name) {\n            Some(column_number) => Ok(column_number),\n            None => Err(format!(\n                \"The column '{}' is not present in the header\\n{:?}\",\n                column_name, header\n            )),\n        }"
            }
        ]
    },
    "remap.rs": {
        "imports": [
            "use super::*;",
            "use indicatif::ProgressIterator;"
        ],
        "functions": [
            {
                "file": "remap.rs",
                "struct": "Graph",
                "doc": [
                    " Return whether nodes are remappable to those of the given graph.",
                    "",
                    " # Arguments",
                    " * `other`: &Graph - graph towards remap the nodes to.",
                    "",
                    " # Example",
                    " A graph is always remappable to itself:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(graph.are_nodes_remappable(&graph));",
                    " ```",
                    " Two different graphs, like Cora and STRING, are not remappable:",
                    " ```rust",
                    " # let cora = graph::test_utilities::load_cora();",
                    " # let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(!cora.are_nodes_remappable(&ppi));",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "are_nodes_remappable",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "other",
                        "&Graph"
                    ]
                ],
                "return_type": "bool",
                "body": "if self.get_nodes_number() != other.get_nodes_number() {\n            return false;\n        }\n        self.iter_node_names_and_node_type_names().all(|(_, node_name, _, node_type)| {\n            other.has_node_name_and_node_type_name(&node_name, node_type)\n        })"
            },
            {
                "file": "remap.rs",
                "struct": "Graph",
                "doc": [
                    " Return graph remapped towards nodes of the given graph.",
                    "",
                    " # Arguments",
                    "",
                    " * `other`: &Graph - The graph to remap towards.",
                    " * `verbose`: bool - Whether to show a loding bar.",
                    "",
                    " # Example",
                    " A graph is always remappable to itself:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert_eq!(graph, graph.remap(&graph, false).unwrap());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remap",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "other",
                        "&Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let pb = get_loading_bar(\n            verbose,\n            format!(\"Building remapped {}\", self.name).as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n\n        if !self.are_nodes_remappable(&other) {\n            return Err(\"The two graphs nodes sets are not remappable one-another.\".to_owned());\n        }\n\n        Graph::from_integer_unsorted(\n            self.iter_edge_node_names_and_edge_type_name_and_edge_weight(true)\n                .progress_with(pb)\n                .map(|(_, _, src_name, _, dst_name, _, edge_type, weight)| {\n                    Ok((\n                        other.get_unchecked_node_id_from_node_name(&src_name),\n                        other.get_unchecked_node_id_from_node_name(&dst_name),\n                        edge_type.and_then(|et| {\n                            self.get_unchecked_edge_type_id_from_edge_type_name(et.as_str())\n                        }),\n                        weight,\n                    ))\n                }),\n            other.nodes.clone(),\n            other.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.directed,\n            self.name.clone(),\n            false,\n            self.has_edge_types(),\n            self.has_edge_weights(),\n            self.has_singleton_nodes(),\n            self.has_singleton_nodes_with_selfloops(),\n            self.has_trap_nodes(),\n            verbose,\n        )"
            }
        ]
    },
    "edge_file_reader.rs": {
        "imports": [
            "use itertools::Itertools;",
            "use super::*;"
        ],
        "functions": [
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Return new EdgeFileReader object.",
                    "",
                    " # Arguments",
                    "",
                    " * reader: CSVFilereader - Path where to store/load the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "new",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "path",
                        "S"
                    ]
                ],
                "return_type": "Result<EdgeFileReader, String>",
                "body": "Ok(EdgeFileReader {\n            reader: CSVFileReader::new(path, \"edge list\".to_owned())?,\n            sources_column_number: 0,\n            destinations_column_number: 1,\n            edge_types_column_number: None,\n            default_edge_type: None,\n            weights_column_number: None,\n            default_weight: None,\n            skip_selfloops: false,\n            numeric_edge_type_ids: false,\n            numeric_node_ids: false,\n            skip_weights_if_unavailable: false,\n            skip_edge_types_if_unavailable: false,\n            might_have_singletons_with_selfloops: true,\n            might_have_trap_nodes: true,\n        })"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column of the source nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * sources_column: Option<String> - The source nodes column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_sources_column",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "sources_column",
                        "Option<S>"
                    ]
                ],
                "return_type": "Result<EdgeFileReader, String>",
                "body": "if let Some(column) = sources_column {\n            let column = column.into();\n            if column.is_empty() {\n                return Err(\"The given node types column is empty.\".to_owned());\n            }\n\n            match self.reader.get_column_number(column) {\n                Ok(ecn) => {\n                    self = self.set_sources_column_number(Some(ecn))?;\n                }\n                Err(e) => {\n                    if !self.skip_edge_types_if_unavailable {\n                        return Err(e);\n                    }\n                }\n            }\n        }\n        Ok(self)"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column_number of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * sources_column_number: Option<usize> - The sources column number to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_sources_column_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "sources_column_number",
                        "Option<usize>"
                    ]
                ],
                "return_type": "Result<EdgeFileReader, String>",
                "body": "if let Some(column) = sources_column_number {\n            let expected_elements = self.reader.get_elements_per_line()?;\n            if column >= expected_elements {\n                return Err(format!(\n                    concat!(\n                        \"The source column number passed was {} but \",\n                        \"the first parsable line has {} values.\"\n                    ),\n                    column, expected_elements\n                ));\n            }\n            self.sources_column_number = column;\n        }\n        Ok(self)"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * destination_column: Option<String> - The node types column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_destinations_column",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "destinations_column",
                        "Option<S>"
                    ]
                ],
                "return_type": "Result<EdgeFileReader, String>",
                "body": "if let Some(column) = destinations_column {\n            let column = column.into();\n            if column.is_empty() {\n                return Err(\"The given node types column is empty.\".to_owned());\n            }\n            match self.reader.get_column_number(column) {\n                Ok(ecn) => {\n                    self = self.set_destinations_column_number(Some(ecn))?;\n                }\n                Err(e) => {\n                    if !self.skip_edge_types_if_unavailable {\n                        return Err(e);\n                    }\n                }\n            }\n        }\n        Ok(self)"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column_number of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * destinations_column_number: Option<usize> - The destinations column number to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_destinations_column_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "destinations_column_number",
                        "Option<usize>"
                    ]
                ],
                "return_type": "Result<EdgeFileReader, String>",
                "body": "if let Some(column) = destinations_column_number {\n            let expected_elements = self.reader.get_elements_per_line()?;\n            if column >= expected_elements {\n                return Err(format!(\n                    concat!(\n                        \"The destinations column number passed was {} but \",\n                        \"the first parsable line has {} values.\"\n                    ),\n                    column, expected_elements\n                ));\n            }\n            self.destinations_column_number = column;\n        }\n        Ok(self)"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * destination_column: Option<String> - The node types column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_edge_types_column",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "edge_type_column",
                        "Option<S>"
                    ]
                ],
                "return_type": "Result<EdgeFileReader, String>",
                "body": "if let Some(column) = edge_type_column {\n            let column = column.into();\n            if column.is_empty() {\n                return Err(\"The given node types column is empty.\".to_owned());\n            }\n            match self.reader.get_column_number(column) {\n                Ok(ecn) => {\n                    self = self.set_edge_types_column_number(Some(ecn))?;\n                }\n                Err(e) => {\n                    if !self.skip_edge_types_if_unavailable {\n                        return Err(e);\n                    }\n                }\n            }\n        }\n        Ok(self)"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column_number of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * edge_types_column_number: Option<usize> - The edge_types column number to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_edge_types_column_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "edge_types_column_number",
                        "Option<usize>"
                    ]
                ],
                "return_type": "Result<EdgeFileReader, String>",
                "body": "if let Some(etcn) = &edge_types_column_number {\n            let expected_elements = self.reader.get_elements_per_line()?;\n            if *etcn >= expected_elements {\n                if !self.skip_edge_types_if_unavailable {\n                    return Err(format!(\n                        concat!(\n                            \"The edge types column number passed was {} but \",\n                            \"the first parsable line has {} values.\"\n                        ),\n                        etcn, expected_elements\n                    ));\n                }\n            } else {\n                self.edge_types_column_number = edge_types_column_number;\n            }\n        }\n        Ok(self)"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column of the edge weights.",
                    "",
                    " # Arguments",
                    "",
                    " * weights_column: Option<String> - The edge weights column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_weights_column",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "weights_column",
                        "Option<S>"
                    ]
                ],
                "return_type": "Result<EdgeFileReader, String>",
                "body": "if let Some(column) = weights_column {\n            let column = column.into();\n            if column.is_empty() {\n                return Err(\"The given edge weights column is empty.\".to_owned());\n            }\n            match self.reader.get_column_number(column) {\n                Ok(wcn) => {\n                    self = self.set_weights_column_number(Some(wcn))?;\n                }\n                Err(e) => {\n                    if !self.skip_weights_if_unavailable {\n                        return Err(e);\n                    }\n                }\n            }\n        }\n        Ok(self)"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column_number of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * weights_column_number: Option<usize> - The weights column number to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_weights_column_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "weights_column_number",
                        "Option<usize>"
                    ]
                ],
                "return_type": "Result<EdgeFileReader, String>",
                "body": "if let Some(wcn) = &weights_column_number {\n            let expected_elements = self.reader.get_elements_per_line()?;\n            if *wcn >= expected_elements {\n                if !self.skip_edge_types_if_unavailable {\n                    return Err(format!(\n                        concat!(\n                            \"The weights column number passed was {} but \",\n                            \"the first parsable line has {} values.\"\n                        ),\n                        wcn, expected_elements\n                    ));\n                }\n            } else {\n                self.weights_column_number = weights_column_number;\n            }\n        }\n        Ok(self)"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set whether to automatically skip weights if they are not avaitable instead of raising an exception.",
                    "",
                    " # Arguments",
                    "",
                    " * skip_weights_if_unavailable: Option<bool> - Whether to skip weights if they are not available.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_skip_weights_if_unavailable",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "skip_weights_if_unavailable",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "if let Some(skip) = skip_weights_if_unavailable {\n            self.skip_weights_if_unavailable = skip;\n        }\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set whether to automatically skip edge types if they are not avaitable instead of raising an exception.",
                    "",
                    " # Arguments",
                    "",
                    " * skip_edge_types_if_unavailable: Option<bool> - Whether to skip edge types if they are not available.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_skip_edge_types_if_unavailable",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "skip_edge_types_if_unavailable",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "if let Some(skip) = skip_edge_types_if_unavailable {\n            self.skip_edge_types_if_unavailable = skip;\n        }\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the default default_weight.",
                    "",
                    " # Arguments",
                    "",
                    " * default_weight: Option<WeightT> - The default_weight to use when default_weight is missing.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_default_weight",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "default_weight",
                        "Option<WeightT>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "self.default_weight = default_weight;\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the name of the graph to be loaded.",
                    "",
                    " # Arguments",
                    "",
                    " * graph_name: String - The name of the graph to be loaded.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "set_graph_name",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "graph_name",
                        "String"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "self.reader.graph_name = graph_name;\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the default edge type.",
                    "",
                    " # Arguments",
                    "",
                    " * default_edge_type: Option<String> - The edge type to use when edge type is missing.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_default_edge_type",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "default_edge_type",
                        "Option<S>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "self.default_edge_type = default_edge_type.map(|val| val.into());\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set whether should ignore or not selfloops.",
                    "",
                    " # Arguments",
                    "",
                    " * `skip_selfloops`: Option<bool> - Whether should ignore or not selfloops.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_skip_selfloops",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "skip_selfloops",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "if let Some(ssl) = skip_selfloops {\n            self.skip_selfloops = ssl;\n            self.might_have_singletons_with_selfloops = !ssl;\n        }\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set whether the CSV is expected to be well written.",
                    "",
                    " # Arguments",
                    "",
                    " * csv_is_correct: Option<bool> - Whether you pinky swear the edge list is correct.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_csv_is_correct",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "csv_is_correct",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "if let Some(cic) = csv_is_correct {\n            self.reader.csv_is_correct = cic;\n        }\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the comment symbol to use to skip the lines.",
                    "",
                    " # Arguments",
                    "",
                    " * comment_symbol: Option<String> - if the reader should ignore or not duplicated edges.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_comment_symbol",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "comment_symbol",
                        "Option<String>"
                    ]
                ],
                "return_type": "Result<EdgeFileReader, String>",
                "body": "if let Some(cs) = comment_symbol {\n            if cs.is_empty() {\n                return Err(\"The given comment symbol is empty.\".to_string());\n            }\n            self.reader.comment_symbol = Some(cs);\n        }\n        Ok(self)"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the verbose.",
                    "",
                    " # Arguments",
                    "",
                    " * `verbose`: Option<bool> - Whether to show the loading bar or not.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_verbose",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "if let Some(v) = verbose {\n            self.reader.verbose = v;\n        }\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set whether you pinky promise that this graph has singletons with self-loops or not.",
                    "",
                    " # Arguments",
                    "",
                    " * `might_have_singletons_with_selfloops`: Option<bool> - Whether this graph has singletons with self-loops.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_might_have_singletons_with_selfloops",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "might_have_singletons_with_selfloops",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "if let Some(skip) = might_have_singletons_with_selfloops {\n            self.might_have_singletons_with_selfloops = !self.skip_selfloops && skip;\n        }\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set whether you pinky promise that this graph has trap nodes or not.",
                    "",
                    " # Arguments",
                    "",
                    " * `might_have_trap_nodes`: Option<bool> - Whether this graph has trap nodes with self-loops.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_might_have_trap_nodes",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "might_have_trap_nodes",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "if let Some(skip) = might_have_trap_nodes {\n            self.might_have_trap_nodes = skip;\n        }\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    "",
                    " * numeric_id: Option<bool> - Whether to convert numeric Ids to Node Id.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_numeric_edge_type_ids",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "numeric_edge_type_ids",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "if let Some(neti) = numeric_edge_type_ids {\n            self.numeric_edge_type_ids = neti;\n        }\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the numeric_id.",
                    "",
                    " # Arguments",
                    "",
                    " * numeric_id: Option<bool> - Whether to convert numeric Ids to Node Id.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_numeric_node_ids",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "numeric_node_ids",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "if let Some(nni) = numeric_node_ids {\n            self.numeric_node_ids = nni;\n        }\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the ignore_duplicates.",
                    "",
                    " # Arguments",
                    "",
                    " * ignore_duplicates: Option<bool> - Whether to ignore detected duplicates or raise exception.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_ignore_duplicates",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "ignore_duplicates",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "if let Some(v) = ignore_duplicates {\n            self.reader.ignore_duplicates = v;\n        }\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the separator.",
                    "",
                    " # Arguments",
                    "",
                    " * separator: Option<String> - The separator to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_separator",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "separator",
                        "Option<S>"
                    ]
                ],
                "return_type": "Result<EdgeFileReader, String>",
                "body": "if let Some(sep) = separator {\n            let sep = sep.into();\n            if sep.is_empty() {\n                return Err(\"The separator cannot be empty.\".to_owned());\n            }\n            self.reader.separator = sep;\n        }\n        Ok(self)"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the header.",
                    "",
                    " # Arguments",
                    "",
                    " * header: Option<bool> - Whether to expect an header or not.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_header",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "header",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "if let Some(v) = header {\n            self.reader.header = v;\n        }\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set number of rows to be skipped when starting to read file.",
                    "",
                    " # Arguments",
                    "",
                    " * rows_to_skip: Option<bool> - Whether to show the loading bar or not.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_rows_to_skip",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "rows_to_skip",
                        "Option<usize>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "if let Some(v) = rows_to_skip {\n            self.reader.rows_to_skip = v;\n        }\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the maximum number of rows to load from the file",
                    "",
                    " # Arguments",
                    "",
                    " * max_rows_number: Option<u64> - The edge type to use when edge type is missing.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_max_rows_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "max_rows_number",
                        "Option<u64>"
                    ]
                ],
                "return_type": "EdgeFileReader",
                "body": "self.reader.max_rows_number = max_rows_number;\n        self"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Return boolean representing if the edge types exist."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_edge_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.default_edge_type.is_some() || self.edge_types_column_number.is_some()"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Return boolean representing if the weight types exist."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_edge_weights",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.default_weight.is_some() || self.weights_column_number.is_some()"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Parse a single line (vecotr of strings already splitted)",
                    " # Arguments",
                    "",
                    " * vals: Vec<String> - Vector of the values of the line to be parsed"
                ],
                "attrs": [],
                "modifiers": "",
                "name": "parse_edge_line",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "vals",
                        "Vec<Option<String>>"
                    ]
                ],
                "return_type": "Result<StringQuadruple, String>",
                "body": "// extract the values\n        let maybe_source_node_name = vals[self.sources_column_number].clone();\n        let maybe_destination_node_name = vals[self.destinations_column_number].clone();\n        if maybe_source_node_name.is_none() || maybe_destination_node_name.is_none() {\n            return Err(\"Either the source or destination node ID are undefined.\".to_string());\n        }\n\n        let source_node_name = maybe_source_node_name.unwrap();\n        let destination_node_name = maybe_destination_node_name.unwrap();\n\n        // Handle the extraction of the edge types.\n        let maybe_edge_types_string = match self.edge_types_column_number {\n            Some(column) => match vals[column].to_owned() {\n                Some(edge_type) => Some(edge_type),\n                None => self.default_edge_type.clone(),\n            },\n            None => self.default_edge_type.clone(),\n        };\n\n        // Handle the extraction of the weights.\n        let maybe_weight_string = match self.weights_column_number {\n            Some(column) => match vals[column].to_owned() {\n                Some(w) => Some(parse_weight(w)?),\n                None => self.default_weight,\n            },\n            None => self.default_weight,\n        };\n\n        Ok((\n            source_node_name,\n            destination_node_name,\n            maybe_edge_types_string,\n            maybe_weight_string,\n        ))"
            },
            {
                "file": "edge_file_reader.rs",
                "struct": "EdgeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Return iterator of rows of the edge file."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "read_lines",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = Result<StringQuadruple, String>> + '_, String>",
                "body": "if self.destinations_column_number == self.sources_column_number {\n            return Err(\"The destinations column is the same as the sources one.\".to_string());\n        }\n        if Some(self.destinations_column_number) == self.weights_column_number {\n            return Err(\"The destinations column is the same as the weights one.\".to_string());\n        }\n        if Some(self.sources_column_number) == self.weights_column_number {\n            return Err(\"The sources column is the same as the weights one.\".to_string());\n        }\n        if Some(self.sources_column_number) == self.edge_types_column_number {\n            return Err(\"The sources column is the same as the edge types one.\".to_string());\n        }\n        if Some(self.destinations_column_number) == self.edge_types_column_number {\n            return Err(\"The destinations column is the same as the edge types one.\".to_string());\n        }\n        if self.weights_column_number.is_some()\n            && self.weights_column_number == self.edge_types_column_number\n        {\n            return Err(\"The weights column is the same as the edge types one.\".to_string());\n        }\n\n        let expected_elements = self.reader.get_elements_per_line()?;\n        if self.sources_column_number >= expected_elements {\n            return Err(format!(\n                concat!(\n                    \"The sources column number passed was {} but \",\n                    \"the first parsable line has {} values.\"\n                ),\n                self.sources_column_number, expected_elements\n            ));\n        }\n        if self.destinations_column_number >= expected_elements {\n            return Err(format!(\n                concat!(\n                    \"The destinations column number passed was {} but \",\n                    \"the first parsable line has {} values.\"\n                ),\n                self.destinations_column_number, expected_elements\n            ));\n        }\n        Ok(self\n            .reader\n            .read_lines()?\n            .map(move |values| match values {\n                Ok(vals) => self.parse_edge_line(vals),\n                Err(e) => Err(e),\n            })\n            .filter_ok(move |(source_node_name, destination_node_name, _, _)| {\n                !self.skip_selfloops || source_node_name != destination_node_name\n            }))"
            }
        ]
    },
    "queries_boolean.rs": {
        "imports": [
            "use super::*;"
        ],
        "functions": [
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns boolean representing if given node is a singleton.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_id`: NodeT - The node to be checked for."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_unchecked_singleton_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "bool",
                "body": "self.connected_nodes\n            .as_ref()\n            .map_or(false, |nsns| !nsns[node_id as usize])"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns boolean representing if given node is a singleton or a singleton with selfloop.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_id`: NodeT - The node to be checked for."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_unchecked_disconnected_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "bool",
                "body": "self.is_unchecked_singleton_from_node_id(node_id) || self.is_singleton_with_selfloops_from_node_id(node_id)"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns boolean representing if given node is a singleton.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_id`: NodeT - The node to be checked for."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_singleton_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "self.validate_node_id(node_id)\n            .map(|node_id| self.is_unchecked_singleton_from_node_id(node_id))"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns boolean representing if given node is a singleton with self-loops.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_id`: NodeT - The node to be checked for."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_singleton_with_selfloops_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "bool",
                "body": "self.singleton_nodes_with_selfloops\n            .as_ref()\n            .map_or(false, |snsls| snsls.contains(node_id))"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns boolean representing if given node is a singleton.",
                    "",
                    " Nota that this method will raise a panic if caled with unproper",
                    " parametrization.",
                    "",
                    " # Arguments",
                    " * `node_name`: &str - The node name to be checked for."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_unchecked_singleton_from_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "bool",
                "body": "self.is_unchecked_singleton_from_node_id(\n            self.get_unchecked_node_id_from_node_name(node_name),\n        )"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns boolean representing if given node is a singleton.",
                    "",
                    " # Arguments",
                    " * `node_name`: &str - The node name to be checked for."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_singleton_from_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "Ok(self.is_unchecked_singleton_from_node_id(self.get_node_id_from_node_name(node_name)?))"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns whether the graph has the given node name.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_name`: &str - Name of the node.",
                    "",
                    " # Example",
                    " To check if a node appears in the graph you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let node_name = \"ENSP00000000233\";",
                    " let unexistent_node_name = \"I_do_not_exist!\";",
                    " assert!(graph.has_node_name(node_name));",
                    " assert!(!graph.has_node_name(unexistent_node_name));",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_node_id_from_node_name(node_name).is_ok()"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns whether the graph has the given node type id.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_type_id`: NodeTypeT - id of the node.",
                    "",
                    " # Example",
                    " To check if a node appears in the graph you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let node_type_id = 0;",
                    " let unexistent_node_type_id = 34567;",
                    " assert!(graph.has_node_type_id(node_type_id));",
                    " assert!(!graph.has_node_type_id(unexistent_node_type_id));",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_node_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_id",
                        "NodeTypeT"
                    ]
                ],
                "return_type": "bool",
                "body": "self.validate_node_type_id(Some(node_type_id)).is_ok()"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns whether the graph has the given node type name.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_type_name`: &str - Name of the node.",
                    "",
                    " # Example",
                    " To check if a node appears in the graph you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let node_type_name = \"biolink:Gene\";",
                    " let unexistent_node_type_name = \"I_do_not_exist!\";",
                    " assert!(graph.has_node_type_name(node_type_name));",
                    " assert!(!graph.has_node_type_name(unexistent_node_type_name));",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_node_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_name",
                        "&str"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_node_type_id_from_node_type_name(node_type_name)\n            .is_ok()"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns whether the graph has the given edge type id.",
                    "",
                    " # Arguments",
                    "",
                    " * `edge_type_id`: EdgeTypeT - id of the edge.",
                    "",
                    " # Example",
                    " To check if a edge appears in the graph you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let edge_type_id = 0;",
                    " let unexistent_edge_type_id = 567;",
                    " assert!(graph.has_edge_type_id(edge_type_id));",
                    " assert!(!graph.has_edge_type_id(unexistent_edge_type_id));",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_id",
                        "EdgeTypeT"
                    ]
                ],
                "return_type": "bool",
                "body": "self.validate_edge_type_id(Some(edge_type_id)).is_ok()"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns whether the graph has the given edge type name.",
                    "",
                    " # Arguments",
                    "",
                    " * `edge_type_name`: &str - Name of the edge.",
                    "",
                    " # Example",
                    " To check if a edge appears in the graph you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let edge_type_name = \"red\";",
                    " let unexistent_edge_type_name = \"I_do_not_exist!\";",
                    " assert!(graph.has_edge_type_name(edge_type_name));",
                    " assert!(!graph.has_edge_type_name(unexistent_edge_type_name));",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_edge_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_name",
                        "&str"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_edge_type_id_from_edge_type_name(Some(edge_type_name))\n            .is_ok()"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns whether edge passing between given node ids exists.",
                    "",
                    " # Arguments",
                    "",
                    " * `src`: NodeT - Source node id.",
                    " * `dst`: NodeT - Destination node id.",
                    "",
                    " # Example",
                    " To check if an edge appears in the graph you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " assert!(graph.has_edge_from_node_ids(0, 1));",
                    " assert!(!graph.has_edge_from_node_ids(0, 4565));",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_edge_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_edge_id_from_node_ids(src, dst).is_ok()"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns whether edge with the given type passing between given nodes exists.",
                    "",
                    " # Arguments",
                    "",
                    " * `src`: NodeT - The source node of the edge.",
                    " * `dst`: NodeT - The destination node of the edge.",
                    " * `edge_type`: Option<EdgeTypeT> - The (optional) edge type.",
                    "",
                    " # Example",
                    " To check if an edge with given type appears in the graph you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " assert!(graph.has_edge_from_node_ids_and_edge_type_id(0, 1, Some(0)));",
                    " assert!(!graph.has_edge_from_node_ids_and_edge_type_id(0, 1, Some(1)));",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_edge_from_node_ids_and_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ],
                    [
                        "edge_type",
                        "Option<EdgeTypeT>"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_edge_id_from_node_ids_and_edge_type_id(src, dst, edge_type)\n            .is_ok()"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns boolean representing if given node is a trap.",
                    "",
                    " If the provided node_id is higher than the number of nodes in the graph,",
                    " the method will panic.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_id`: NodeT - Integer ID of the node, if this is bigger that the number of nodes it will panic.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_unchecked_trap_node_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_unchecked_unweighted_node_degree_from_node_id(node_id) == 0\n            && self\n                .connected_nodes\n                .as_ref()\n                .map_or(true, |nsns| nsns[node_id as usize])"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns boolean representing if given node is a trap.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_id`: NodeT - Integer ID of the node, if this is bigger that the number of nodes it will panic.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_trap_node_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "self.validate_node_id(node_id)\n            .map(|node_id| self.is_unchecked_trap_node_from_node_id(node_id))"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns whether the given node name and node type name exist in current graph.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_name`: &str - The node name.",
                    " * `node_type_name`: Option<Vec<String>> - The node types name.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_node_name_and_node_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ],
                    [
                        "node_type_name",
                        "Option<Vec<String>>"
                    ]
                ],
                "return_type": "bool",
                "body": "match self.get_node_id_from_node_name(node_name) {\n            Err(_) => false,\n            Ok(node_id) => {\n                let our_node_types = self.get_node_type_names_from_node_id(node_id);\n                match (our_node_types, node_type_name) {\n                    (Err(_), None) => true,\n                    (Ok(None), None) => true,\n                    (Ok(Some(mut our_nts)), Some(mut other_nts)) => {\n                        our_nts.sort();\n                        other_nts.sort();\n                        our_nts == other_nts\n                    }\n                    _ => false,\n                }\n            }\n        }"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns whether if edge passing between given nodes exists.",
                    "",
                    " # Arguments",
                    "",
                    " * `src_name`: &str - The source node name of the edge.",
                    " * `dst_name`: &str - The destination node name of the edge.",
                    "",
                    " # Example",
                    " To check if an edge in the graph you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " assert!(graph.has_edge_from_node_names(\"ENSP00000000233\", \"ENSP00000432568\"));",
                    " assert!(!graph.has_edge_from_node_names(\"ENSP00000000233\", \"NonExistent\"));",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_edge_from_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src_name",
                        "&str"
                    ],
                    [
                        "dst_name",
                        "&str"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_edge_id_from_node_names(src_name, dst_name).is_ok()"
            },
            {
                "file": "queries_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Queries",
                    " The naming convention for unchecked methods follows:",
                    " * `/is_(.+?)_from_(.+)/`",
                    " * `/has_(.+?)_from_(.+)/`",
                    " * `/is_unchecked_(.+?)_from_(.+)/`",
                    " * `/has_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns whether if edge with type passing between given nodes exists.",
                    "",
                    " # Arguments",
                    "",
                    " * `src_name`: &str - The source node name of the edge.",
                    " * `dst_name`: &str - The destination node name of the edge.",
                    " * `edge_type_name`: Option<&str> - The (optional) edge type name.",
                    "",
                    " # Example",
                    " To check if an edge with type in the graph you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " let edge_type = Some(\"red\");",
                    " let unexistent_edge_type = Some(\"NonExistent\");",
                    " assert!(graph.has_edge_from_node_names_and_edge_type_name(\"ENSP00000000233\", \"ENSP00000432568\", edge_type));",
                    " assert!(!graph.has_edge_from_node_names_and_edge_type_name(\"ENSP00000000233\", \"ENSP00000432568\", unexistent_edge_type));",
                    " assert!(!graph.has_edge_from_node_names_and_edge_type_name(\"ENSP00000000233\", \"NonExistent\", edge_type));",
                    " assert!(!graph.has_edge_from_node_names_and_edge_type_name(\"ENSP00000000233\", \"NonExistent\", unexistent_edge_type));",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_edge_from_node_names_and_edge_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src_name",
                        "&str"
                    ],
                    [
                        "dst_name",
                        "&str"
                    ],
                    [
                        "edge_type_name",
                        "Option<&str>"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_edge_id_from_node_names_and_edge_type_name(src_name, dst_name, edge_type_name)\n            .is_ok()"
            }
        ]
    },
    "edge_metrics.rs": {
        "imports": [
            "use super::types::*;",
            "use super::*;",
            "use num_traits::Pow;"
        ],
        "functions": [
            {
                "file": "edge_metrics.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Properties and measurements of the graph"
                ],
                "doc": [
                    " Returns the minumum preferential attachment score.",
                    "",
                    " # Safety",
                    " If the graph does not contain nodes, the return value will be undefined.",
                    " Returns the maximum preferential attachment score.",
                    "",
                    " # Safety",
                    " If the graph does not contain nodes, the return value will be undefined.",
                    " Returns the preferential attachment.",
                    "",
                    " # Arguments",
                    "",
                    " * `one`: NodeT - Integer ID of the first node.",
                    " * `two`: NodeT - Integer ID of the second node.",
                    " * `normalize`: bool - Whether to normalize within 0 to 1.",
                    "",
                    " # Safety",
                    " If either of the provided one and two node IDs are higher than the",
                    " number of nodes in the graph.",
                    " Returns the preferential attachment.",
                    "",
                    " # Arguments",
                    "",
                    " * `one`: NodeT - Integer ID of the first node.",
                    " * `two`: NodeT - Integer ID of the second node.",
                    " * `normalize`: bool - Whether to normalize by the square of maximum degree.",
                    "",
                    " # Raises",
                    " * If eithert of the node IDs are higher than the number of nodes in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_preferential_attachment",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "one",
                        "NodeT"
                    ],
                    [
                        "two",
                        "NodeT"
                    ],
                    [
                        "normalize",
                        "bool"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "Ok(unsafe {\n            self.get_unchecked_preferential_attachment(\n                self.validate_node_id(one)?,\n                self.validate_node_id(two)?,\n                normalize,\n            )\n        })"
            },
            {
                "file": "edge_metrics.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Properties and measurements of the graph"
                ],
                "doc": [
                    " Returns the Jaccard index for the two given nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * `one`: NodeT - Integer ID of the first node.",
                    " * `two`: NodeT - Integer ID of the second node.",
                    "",
                    " # References",
                    " [D. Liben-Nowell, J. Kleinberg.",
                    " The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The Jaccard Index between node 1 and node 2 is {}\", unsafe{ graph.get_unchecked_jaccard_coefficient(1, 2) });",
                    " ```",
                    "",
                    " # Safety",
                    " If either of the provided one and two node IDs are higher than the",
                    " number of nodes in the graph.",
                    " Returns the Jaccard index for the two given nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * `one`: NodeT - Integer ID of the first node.",
                    " * `two`: NodeT - Integer ID of the second node.",
                    "",
                    " # References",
                    " [D. Liben-Nowell, J. Kleinberg.",
                    " The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The Jaccard Index between node 1 and node 2 is {}\", graph.get_jaccard_coefficient(1, 2).unwrap());",
                    " ```",
                    "",
                    " # Raises",
                    " * If eithert of the node IDs are higher than the number of nodes in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_jaccard_coefficient",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "one",
                        "NodeT"
                    ],
                    [
                        "two",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "Ok(unsafe {\n            self.get_unchecked_jaccard_coefficient(\n                self.validate_node_id(one)?,\n                self.validate_node_id(two)?,\n            )\n        })"
            },
            {
                "file": "edge_metrics.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Properties and measurements of the graph"
                ],
                "doc": [
                    " Returns the Adamic/Adar Index for the given pair of nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * `one`: NodeT - Integer ID of the first node.",
                    " * `two`: NodeT - Integer ID of the second node.",
                    "",
                    " # Implementation details",
                    " Since the Adamic/Adar Index is only defined for graph not containing",
                    " node traps (nodes without any outbound edge) and must support all kind",
                    " of graphs, the sinks node are excluded from",
                    " the computation because they would result in an infinity.",
                    "",
                    " # References",
                    " [D. Liben-Nowell, J. Kleinberg.",
                    " The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)",
                    "",
                    " # Safety",
                    " If either of the provided one and two node IDs are higher than the",
                    " number of nodes in the graph.",
                    " Returns the Adamic/Adar Index for the given pair of nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * `one`: NodeT - Integer ID of the first node.",
                    " * `two`: NodeT - Integer ID of the second node.",
                    "",
                    " # Implementation details",
                    " Since the Adamic/Adar Index is only defined for graph not containing",
                    " node traps (nodes without any outbound edge) and must support all kind",
                    " of graphs, the sinks node are excluded from",
                    " the computation because they would result in an infinity.",
                    "",
                    " # References",
                    " [D. Liben-Nowell, J. Kleinberg.",
                    " The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)",
                    "",
                    " # Raises",
                    " * If eithert of the node IDs are higher than the number of nodes in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_adamic_adar_index",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "one",
                        "NodeT"
                    ],
                    [
                        "two",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "Ok(unsafe {\n            self.get_unchecked_adamic_adar_index(\n                self.validate_node_id(one)?,\n                self.validate_node_id(two)?,\n            )\n        })"
            },
            {
                "file": "edge_metrics.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Properties and measurements of the graph"
                ],
                "doc": [
                    " Returns the Resource Allocation Index for the given pair of nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * `one`: NodeT - Integer ID of the first node.",
                    " * `two`: NodeT - Integer ID of the second node.",
                    "",
                    " # References",
                    " [T. Zhou, L. Lu, Y.-C. Zhang.",
                    " Predicting missing links via local information.",
                    " Eur. Phys. J. B 71 (2009) 623.](http://arxiv.org/pdf/0901.0553.pdf)",
                    "",
                    " # Implementation details",
                    " Since the Resource Allocation Index is only defined for graph not",
                    " containing node traps (nodes without any outbound edge) and",
                    " must support all kind of graphs, the sinks node are excluded from",
                    " the computation because they would result in an infinity.",
                    "",
                    " # Safety",
                    " If either of the provided one and two node IDs are higher than the",
                    " number of nodes in the graph.",
                    " Returns the Resource Allocation Index for the given pair of nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * `one`: NodeT - Integer ID of the first node.",
                    " * `two`: NodeT - Integer ID of the second node.",
                    "",
                    " # References",
                    " [T. Zhou, L. Lu, Y.-C. Zhang.",
                    " Predicting missing links via local information.",
                    " Eur. Phys. J. B 71 (2009) 623.](http://arxiv.org/pdf/0901.0553.pdf)",
                    "",
                    " # Implementation details",
                    " Since the Resource Allocation Index is only defined for graph not",
                    " containing node traps (nodes without any outbound edge) and",
                    " must support all kind of graphs, the sinks node are excluded from",
                    " the computation because they would result in an infinity.",
                    "",
                    " # Raises",
                    " * If eithert of the node IDs are higher than the number of nodes in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_resource_allocation_index",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "one",
                        "NodeT"
                    ],
                    [
                        "two",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "Ok(unsafe {\n            self.get_unchecked_resource_allocation_index(\n                self.validate_node_id(one)?,\n                self.validate_node_id(two)?,\n            )\n        })"
            }
        ]
    },
    "bitmaps.rs": {
        "imports": [
            "use super::*;",
            "use roaring::RoaringBitmap;"
        ],
        "functions": [
            {
                "file": "bitmaps.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Drop.",
                    " The naming convention we follow is:",
                    " * `.*bitmap.*`"
                ],
                "doc": [
                    " Return a roaringbitmap with the node ids to keep.",
                    "",
                    " If both node\\_names and node\\_types are specified the result will be the",
                    " union of both queries.",
                    "",
                    " # Arguments",
                    " * `node_names` - The nodes to keep as strings",
                    " * `node_types` - The nodes types to keep as strings",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "get_filter_bitmap",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_names",
                        "Option<Vec<String>>"
                    ],
                    [
                        "node_types",
                        "Option<Vec<Option<String>>>"
                    ]
                ],
                "return_type": "Result<Option<RoaringBitmap>, String>",
                "body": "let mut node_ids = RoaringBitmap::new();\n\n        if let Some(ns) = node_names {\n            node_ids.extend(\n                ns.iter()\n                    .map(|node_name| self.get_node_id_from_node_name(node_name))\n                    .collect::<Result<Vec<NodeT>, String>>()?,\n            );\n        }\n\n        if let Some(ndt) = node_types {\n            let node_type_ids = self.get_node_type_ids_from_node_type_names(ndt)?;\n            node_ids.extend(\n                self.iter_node_ids_and_node_type_ids()\n                    .filter_map(|(node_id, nts)| {\n                        if nts.map_or_else(\n                            //DEFAULT\n                            || node_type_ids.contains(&None),\n                            // If some\n                            |ns| {\n                                ns.into_iter().any(|node_type_name| {\n                                    node_type_ids.contains(&Some(node_type_name))\n                                })\n                            },\n                        ) {\n                            Some(node_id)\n                        } else {\n                            None\n                        }\n                    }),\n            );\n        }\n\n        Ok(optionify!(node_ids))"
            }
        ]
    },
    "test_utilities.rs": {
        "imports": [
            "use super::*;",
            "use itertools::Itertools;",
            "use log::warn;",
            "use rand::Rng;",
            "use rayon::iter::ParallelIterator;",
            "use std::collections::HashSet;",
            "use std::fs;",
            "use std::path::Path;"
        ],
        "functions": [
            {
                "file": "test_utilities.rs",
                "doc": [
                    " Computes a random string of the chosen length"
                ],
                "attrs": [
                    "#[cfg(target_os = \"macos\")]",
                    "#[cfg(target_os = \"linux\")]",
                    "#[cfg(target_os = \"windows\")]"
                ],
                "modifiers": "pub",
                "name": "random_string",
                "args": [
                    [
                        "len",
                        "usize"
                    ]
                ],
                "return_type": "String",
                "body": "let mut rng = rand::thread_rng();\n\n    (0..len)\n        .map(|_| {\n            let idx = rng.gen_range(0, CHARSET.len());\n            CHARSET[idx] as char\n        })\n        .collect()"
            },
            {
                "file": "test_utilities.rs",
                "doc": [
                    " Computes a random path."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "random_path",
                "args": [
                    [
                        "path",
                        "Option<&str>"
                    ]
                ],
                "return_type": "String",
                "body": "Path::new(path.unwrap_or(DEFAULT_PATH))\n        .join(random_string(64))\n        .to_str()\n        .unwrap()\n        .to_string()"
            },
            {
                "file": "test_utilities.rs",
                "doc": [
                    " Load the Strings Protein Protein Interaction graph with given parametrization.",
                    " This is our default graph we use on tests."
                ],
                "attrs": [
                    "#[allow(clippy::redundant_clone)]"
                ],
                "modifiers": "pub",
                "name": "load_ppi",
                "args": [
                    [
                        "load_nodes",
                        "bool"
                    ],
                    [
                        "load_edge_types",
                        "bool"
                    ],
                    [
                        "load_weights",
                        "bool"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "verbose",
                        "bool"
                    ],
                    [
                        "skip_selfloops",
                        "bool"
                    ]
                ],
                "return_type": "Graph",
                "body": "let graph_name = \"STRING PPI\".to_owned();\n    let nodes_reader = if load_nodes {\n        Some(\n            NodeFileReader::new(\"tests/data/ppi/nodes.tsv\".to_string())\n                .unwrap()\n                .set_verbose(Some(false))\n                .set_node_types_column_number(Some(1))\n                .set_nodes_column_number(Some(0))\n                .set_node_types_column(Some(\"category\".to_string()))\n                .unwrap()\n                .set_default_node_type(Some(\"default\".to_string()))\n                .set_nodes_column(Some(\"id\".to_string()))\n                .unwrap()\n                .set_ignore_duplicates(Some(true))\n                .set_separator(Some(\"\\t\"))\n                .unwrap()\n                .set_header(Some(true))\n                .set_max_rows_number(Some(100000))\n                .set_rows_to_skip(Some(0))\n                .clone(),\n        )\n    } else {\n        None\n    };\n    let edges_reader = EdgeFileReader::new(\"tests/data/ppi/edges.tsv\".to_string())\n        .unwrap()\n        .set_verbose(Some(verbose))\n        .set_ignore_duplicates(Some(true))\n        .set_separator(Some(\"\\t\"))\n        .unwrap()\n        .set_header(Some(true))\n        .set_rows_to_skip(Some(0))\n        .set_sources_column(Some(\"subject\".to_string()))\n        .unwrap()\n        .set_destinations_column(Some(\"object\".to_string()))\n        .unwrap()\n        .set_weights_column(if load_weights {\n            Some(\"weight\".to_string())\n        } else {\n            None\n        })\n        .unwrap()\n        .set_edge_types_column(if load_edge_types {\n            Some(\"edge_label\".to_string())\n        } else {\n            None\n        })\n        .unwrap()\n        .set_default_edge_type(if load_edge_types {\n            Some(\"Kebab\".to_string())\n        } else {\n            None\n        })\n        .set_max_rows_number(Some(100000))\n        .set_default_weight(if load_weights { Some(5.0) } else { None })\n        .set_skip_selfloops(Some(skip_selfloops))\n        .clone();\n\n    let ppi = Graph::from_unsorted_csv(\n        edges_reader,\n        nodes_reader,\n        directed,\n        false,\n        graph_name.clone(),\n    )\n    .unwrap();\n    assert_eq!(ppi.has_node_types(), load_nodes);\n    assert_eq!(ppi.has_edge_types(), load_edge_types,);\n    assert_eq!(ppi.has_edge_weights(), load_weights);\n    assert_eq!(\n        ppi.has_selfloops(),\n        !skip_selfloops,\n        concat!(\n            \"I was expecting the graph self-loops status to be {} \",\n            \"since we have given parameter skip_selfloops equal to {}, \",\n            \"but actually is {}.\\n\",\n            \"The graph report is: \\n {:?}\"\n        ),\n        !skip_selfloops,\n        skip_selfloops,\n        ppi.has_selfloops(),\n        ppi.textual_report(false)\n    );\n    ppi"
            },
            {
                "file": "test_utilities.rs",
                "doc": [
                    " Load an empty graph instance"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "load_empty_graph",
                "args": [
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "Graph",
                "body": "Graph::build_graph(\n        std::iter::empty(),\n        0,\n        Vocabulary::default(),\n        None,\n        None,\n        directed,\n        false,\n        \"Empty graph\",\n        false,\n        false,\n        false,\n        false,\n        false,\n        false,\n    )\n    .unwrap()"
            },
            {
                "file": "test_utilities.rs",
                "doc": [
                    " This is our default graph we use on tests with node types."
                ],
                "attrs": [
                    "#[allow(clippy::redundant_clone)]"
                ],
                "modifiers": "pub",
                "name": "load_cora",
                "args": [],
                "return_type": "Graph",
                "body": "let graph_name = \"Cora\".to_owned();\n    let edges_reader = EdgeFileReader::new(\"tests/data/cora/edges.tsv\")\n        .unwrap()\n        .set_separator(Some(\"\\t\"))\n        .unwrap()\n        .set_verbose(Some(false))\n        .set_sources_column(Some(\"subject\"))\n        .unwrap()\n        .set_destinations_column(Some(\"object\"))\n        .unwrap()\n        .set_edge_types_column(Some(\"edge_type\"))\n        .unwrap();\n    let nodes_reader = Some(\n        NodeFileReader::new(\"tests/data/cora/nodes.tsv\")\n            .unwrap()\n            .set_separator(Some(\"\\t\"))\n            .unwrap()\n            .set_nodes_column(Some(\"id\"))\n            .unwrap()\n            .set_verbose(Some(false))\n            .set_node_types_column(Some(\"node_type\"))\n            .unwrap(),\n    );\n    Graph::from_unsorted_csv(edges_reader, nodes_reader, false, false, graph_name.clone()).unwrap()"
            },
            {
                "file": "test_utilities.rs",
                "doc": [
                    " Return WalksParameters to execute a first order walk."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "first_order_walker",
                "args": [
                    [
                        "graph",
                        "&Graph"
                    ]
                ],
                "return_type": "Result<WalksParameters, String>",
                "body": "Ok(WalksParameters::new(8)?\n        .set_iterations(Some(1))?\n        .set_random_state(Some(43))\n        .set_dense_node_mapping(Some(graph.get_dense_nodes_mapping())))"
            },
            {
                "file": "test_utilities.rs",
                "doc": [
                    " Return WalksParameters to execute a second order walk."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "second_order_walker",
                "args": [
                    [
                        "graph",
                        "&Graph"
                    ],
                    [
                        "return_weight",
                        "WeightT"
                    ],
                    [
                        "explore_weight",
                        "WeightT"
                    ]
                ],
                "return_type": "Result<WalksParameters, String>",
                "body": "Ok(WalksParameters::new(8)?\n        .set_iterations(Some(1))?\n        .set_return_weight(Some(return_weight))?\n        .set_explore_weight(Some(explore_weight))?\n        .set_max_neighbours(Some(3))?\n        .set_change_edge_type_weight(Some(2.0))?\n        .set_change_node_type_weight(Some(2.0))?\n        .set_dense_node_mapping(Some(graph.get_dense_nodes_mapping()))\n        .set_random_state(Some(43)))"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "validate_vocabularies",
                "args": [
                    [
                        "graph",
                        "&Graph"
                    ]
                ],
                "body": "if let Some(ets) = &graph.edge_types {\n        assert_eq!(!ets.ids.is_empty(), graph.has_edge_types(),\n            \"We expected that if the graph has edge types then it cannot be empty. The report of the graph is:\\n{:?}\",\n            graph.textual_report(false)\n        );\n    }\n\n    if let Some(nts) = &graph.node_types {\n        assert_eq!(!nts.ids.is_empty(), graph.has_node_types());\n    }\n\n    if let Some(ws) = &graph.weights {\n        assert_eq!(\n            !ws.is_empty(), graph.has_edge_weights(),\n            concat!(\n                \"We expect the edge weights vector to NOT be empty if the graph says it has weights.\\n\",\n                \"The graph report is:\\n{:?}\"\n            ),\n            graph.textual_report(false)\n        );\n    }"
            },
            {
                "file": "test_utilities.rs",
                "doc": [
                    " Executes the default test suite for holdouts."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "default_holdout_test_suite",
                "args": [
                    [
                        "graph",
                        "&Graph"
                    ],
                    [
                        "train",
                        "&Graph"
                    ],
                    [
                        "test",
                        "&Graph"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "for g in &[graph, train, test] {\n        validate_vocabularies(g);\n    }\n    assert!(\n        !train.overlaps(&test)?,\n        \"Training graph overlaps with test graph!\"\n    );\n    assert!(\n        !test.overlaps(&train)?,\n        \"Test graph overlaps with training graph!\"\n    );\n    assert!(graph.contains(&train)?, \"Graph does not training graph.\");\n    assert!(graph.contains(&test)?, \"Graph does not contain test graph.\");\n    let summed = (train | test)?;\n    validate_vocabularies(&summed);\n    assert!(\n        summed.contains(&graph)?,\n        \"Composed train and test graph do not contained original graph.\"\n    );\n    let subtracted = (graph - test)?;\n    validate_vocabularies(&subtracted);\n    assert!(\n        subtracted.contains(&train)?,\n        \"Main graph subtracted test does not contain training graph.\"\n    );\n    assert!(\n        !subtracted.overlaps(&test)?,\n        \"Main graph subtracted train does not contain test graph.\"\n    );\n    let xorred = (graph ^ test)?;\n    validate_vocabularies(&xorred);\n    assert!(\n        xorred.contains(&train)?,\n        \"Main graph xorred test does not contain training graph.\"\n    );\n    assert!(\n        !xorred.overlaps(&test)?,\n        \"Main graph xorred train does not contain testing graph.\"\n    );\n    let anded = (graph & test)?;\n    validate_vocabularies(&anded);\n    assert!(\n        anded.contains(&test)?,\n        \"Main graph anded test does not contain training graph.\"\n    );\n\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [
                    " Test that the spanning arborescence algorithm from bader is working correctly."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_spanning_arborescence_bader",
                "args": [
                    [
                        "graph",
                        "&Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "body": "let kruskal_tree = graph.spanning_arborescence_kruskal(verbose).0;\n    let random_kruskal_tree = graph\n        .random_spanning_arborescence_kruskal(42, &None, verbose)\n        .0;\n    if !graph.directed {\n        let spanning_arborescence_bader: Vec<(NodeT, NodeT)> =\n            graph.spanning_arborescence(verbose).unwrap().1.collect();\n        assert_eq!(\n            spanning_arborescence_bader.len(), kruskal_tree.len(),\n            \"The number of extracted edges forming the spanning arborescence computed by the bader's algorithm does not match the one computed by kruskal. The graph report is:\\n{:?}\\nThe bader's tree is:\\n{:?}\\nThe kruskal's tree is:\\n{:?}\",\n            graph.textual_report(false), spanning_arborescence_bader, kruskal_tree,\n        );\n    } else {\n        assert!(graph.spanning_arborescence(verbose).is_err());\n    }\n    assert_eq!(random_kruskal_tree.len() as usize, kruskal_tree.len());"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_graph_properties",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "// Testing that vocabularies are properly loaded\n    validate_vocabularies(graph);\n\n    // Testing that the degrees computation is correct\n    assert_eq!(\n        graph.get_max_node_degree()?,\n        graph.iter_unweighted_node_degrees().max().unwrap(),\n        \"The cached maximum degree does not match the one computed from the node degrees.\"\n    );\n    assert_eq!(\n        graph.get_min_node_degree()?,\n        graph.iter_unweighted_node_degrees().min().unwrap(),\n        \"The cached minimum degree does not match the one computed from the node degrees.\"\n    );\n\n    if !graph.is_directed() && graph.get_min_node_degree()? == 0 {\n        assert!(graph.has_singleton_nodes());\n    }\n\n    if graph.has_singleton_nodes() {\n        assert!(graph.unique_sources.is_some());\n    }\n\n    assert_eq!(\n        graph.singleton_nodes_with_selfloops.is_some(),\n        graph.has_singleton_nodes_with_selfloops(),\n    );\n\n    assert_eq!(\n        graph\n            .singleton_nodes_with_selfloops\n            .as_ref()\n            .map_or(0, |x| x.len() as NodeT),\n        graph.get_singleton_nodes_with_selfloops_number(),\n    );\n\n    for singleton_node_id in graph.iter_singleton_node_ids() {\n        assert!(graph.get_unchecked_unweighted_node_degree_from_node_id(singleton_node_id) == 0);\n        assert!(graph.is_unchecked_singleton_from_node_id(singleton_node_id));\n    }\n\n    if !graph.is_directed() {\n        for node_id in graph.iter_node_ids() {\n            assert_eq!(\n                graph.is_unchecked_singleton_from_node_id(node_id),\n                graph.get_unchecked_unweighted_node_degree_from_node_id(node_id) == 0\n            );\n        }\n    }\n\n    // Test get_edge_id_from_node_names_and_edge_type_name()\n    assert!(\n        graph\n            .get_edge_id_from_node_names_and_edge_type_name(NONEXISTENT, NONEXISTENT, None)\n            .is_err(),\n        \"Graph contains non-existing edge.\"\n    );\n\n    // Test has_node_from_name\n    assert!(\n        !(graph.has_node_name_and_node_type_name(NONEXISTENT, None)),\n        \"The graph seems to have a non-existing node.\"\n    );\n    assert!(\n        !(graph.has_node_name(NONEXISTENT)),\n        \"The graph seems to have a non-existing node.\"\n    );\n\n    // Singletons with selfloops can only exist if the graph has nodes AND selfloops\n    if graph.has_singleton_nodes() {\n        assert!(graph.has_nodes());\n    }\n    if graph.has_singleton_nodes_with_selfloops() {\n        assert!(graph.has_nodes());\n        assert!(graph.has_selfloops());\n    }\n\n    // Test translate_edge|node_types()\n    assert!(\n        graph\n            .get_edge_type_ids_from_edge_type_names(vec![Some(NONEXISTENT.to_string())])\n            .is_err(),\n        \"The graph seems to have a non-existing edge type.\"\n    );\n\n    assert!(\n        graph\n            .get_node_type_ids_from_node_type_names(vec![Some(NONEXISTENT.to_string())])\n            .is_err(),\n        \"The graph seems to have a non-existing node type.\"\n    );\n\n    assert_eq!(\n        graph.get_connected_nodes_number()\n            + graph.get_singleton_nodes_number()\n            + graph.get_singleton_nodes_with_selfloops_number(),\n        graph.get_nodes_number(),\n        \"Sum of singleton and non singleton nodes number does not match.\"\n    );\n\n    assert_eq!(\n        graph.get_disconnected_nodes_number(), graph.get_singleton_nodes_number() + graph.get_singleton_nodes_with_selfloops_number(),\n        \"Sum of singleton and singleton with selfloops does not match the number of disconnected nodes.\"\n    );\n\n    warn!(\"Running connected components tests.\");\n    let (_components_number, smallest, biggest) = graph.get_connected_components_number(false);\n    assert!(\n        biggest >= smallest,\n        \"smallest: {} biggest: {}\",\n        smallest,\n        biggest\n    );\n\n    if smallest == 1 {\n        assert!(\n            graph.has_singleton_nodes() || graph.has_singleton_nodes_with_selfloops(),\n            \"When the smallest component is one the graph must have singletons! Graph report: \\n{:?}\",\n            graph.textual_report(false)\n        );\n    }\n\n    assert_eq!(\n        !graph.has_nodes(),\n        smallest == 0,\n        \"When the smallest component is zero the graph must be empty! Graph report: \\n{:?}\",\n        graph.textual_report(false)\n    );\n\n    // Get one edge from the graph if there are any presents\n    if let Some(edge) = graph.iter_unique_edge_node_ids(true).next() {\n        let src_string = graph.get_unchecked_node_name_from_node_id(edge.0);\n        let dst_string = graph.get_unchecked_node_name_from_node_id(edge.1);\n        let edge_id = graph.get_edge_id_from_node_names(&src_string, &dst_string)?;\n        if graph.has_edge_types() {\n            let edge_type = graph.get_edge_type_name_from_edge_id(edge_id)?;\n            let clone_edge_type = edge_type.clone();\n            assert!(\n                graph.has_edge_from_node_names_and_edge_type_name(&src_string, &dst_string, clone_edge_type.as_deref()),\n                \"I was expecting for the edge ({}, {}, {:?}) to exist, but it seems to not exist in graph {:?}\",\n                src_string,\n                dst_string,\n                edge_type,\n                graph.textual_report(false)\n            );\n        } else {\n            assert!(\n                graph.has_edge_from_node_names(&src_string, &dst_string),\n                \"I was expecting for the edge ({}, {}) without type to exist, but it seems to not exist in graph {:?}\",\n                src_string,\n                dst_string,\n                graph.textual_report(false)\n            );\n        }\n        assert!(graph.has_node_name(&src_string) && graph.has_node_name(&dst_string));\n        if graph.has_node_types() {\n            assert!(\n                graph.has_node_name_and_node_type_name(\n                    &src_string,\n                    graph.get_node_type_name_from_node_name(&src_string)?\n                ) && graph.has_node_name_and_node_type_name(\n                    &dst_string,\n                    graph.get_node_type_name_from_node_name(&dst_string)?\n                ),\n                concat!(\n                    \"The nodes {:?} and {:?} with node types are not present in the graph.\\n\",\n                    \"The node types are {:?} and {:?}.\\n\",\n                    \"The first node existance is {}\\n\",\n                    \"The second node existance is {}\\n\",\n                    \"The graph report is {:?}\"\n                ),\n                src_string,\n                dst_string,\n                graph.get_node_type_name_from_node_name(&src_string),\n                graph.get_node_type_name_from_node_name(&dst_string),\n                graph.has_node_name_and_node_type_name(\n                    &src_string,\n                    graph.get_node_type_name_from_node_name(&src_string)?\n                ),\n                graph.has_node_name_and_node_type_name(\n                    &dst_string,\n                    graph.get_node_type_name_from_node_name(&dst_string)?\n                ),\n                graph.textual_report(false)\n            );\n        }\n        assert_eq!(\n            graph.get_edge_id_from_node_names(&src_string, &dst_string)?,\n            graph.get_edge_id_from_node_ids(edge.0, edge.1).unwrap(),\n            \"Check of given edge ID does not match.\"\n        );\n    }\n\n    // Test the generation of the textual report, this includes the connected components algorithm.\n    graph.report();\n    graph.textual_report(verbose)?;\n    graph.overlap_textual_report(&graph, verbose)?;\n    graph.get_peculiarities_report_markdown();\n\n    // Compute degrees metrics\n    for src in 0..5 {\n        for dst in 0..5 {\n            let _ = graph.get_preferential_attachment(src, dst, true);\n            let _ = graph.get_preferential_attachment(src, dst, false);\n            let _ = graph.get_jaccard_coefficient(src, dst);\n            let _ = graph.get_adamic_adar_index(src, dst);\n            let _ = graph.get_resource_allocation_index(src, dst);\n        }\n    }\n\n    assert_eq!(\n        graph.has_node_types(),\n        graph.get_node_type_id_from_node_id(0).is_ok()\n    );\n\n    assert!(\n        graph.get_node_type_id_from_node_id(graph.get_nodes_number() + 1).is_err(),\n        \"Given graph does not raise an exception when a node's node type greater than the number of available nodes is requested.\"\n    );\n\n    assert_eq!(\n        graph.has_edge_types(),\n        graph.get_edge_type_id_from_edge_id(0).is_ok()\n    );\n\n    assert!(\n        graph.get_edge_type_id_from_edge_id(graph.get_directed_edges_number() + 1).is_err(),\n        \"Given graph does not raise an exception when a edge's edge type greater than the number of available edges is requested.\"\n    );\n\n    // Evaluate get_node_type\n    assert_eq!(\n        graph.get_node_type_id_from_node_id(0).is_ok(),\n        graph.has_node_types()\n    );\n\n    // Evaluate get_edge_type\n    assert_eq!(\n        graph.get_edge_type_id_from_edge_id(0).is_ok(),\n        graph.has_edge_types()\n    );\n\n    // Evaluate get_edge_type_counts\n    assert_eq!(\n        graph.get_edge_type_id_counts_hashmap().is_ok(),\n        graph.has_edge_types()\n    );\n\n    // Evaluate get_edge_type_id_counts_hashmap\n    assert_eq!(\n        graph.get_edge_type_id_counts_hashmap().is_ok(),\n        graph.has_edge_types()\n    );\n\n    graph.set_name(graph.get_name());\n    graph.strongly_connected_components();\n\n    // Checking that the connected components are a dense range.\n    let (_, connected_components, total_connected_components, _, _) =\n        graph.random_spanning_arborescence_kruskal(42, &None, verbose);\n    let actual_components_number = connected_components.iter().unique().count() as NodeT;\n    assert_eq!(\n        actual_components_number,\n        total_connected_components,\n        \"The measured number of connected components ({}) does not match the computed number of connected components ({}).\",\n        actual_components_number,\n        total_connected_components\n    );\n    let max_component_id = connected_components.iter().max();\n    if let Some(mci) = max_component_id {\n        assert_eq!(\n            *mci as usize,\n            total_connected_components as usize - 1,\n            \"We expected the connected components to be a dense set.\\n The obtained components are: \\n{:?}\\n The graph report is:\\n{:?}\",\n            connected_components,\n            graph.textual_report(false)\n        );\n    }\n    if !graph.is_directed() {\n        // Checking that the connected components are a dense range.\n        let (connected_components, total_connected_components, _, _) =\n            graph.connected_components(verbose)?;\n        let actual_components_number = connected_components.iter().unique().count() as NodeT;\n        assert_eq!(\n            actual_components_number,\n            total_connected_components,\n            \"The measured number of connected components ({}) does not match the computed number of connected components ({}).\",\n            actual_components_number,\n            total_connected_components\n        );\n        let max_component_id = connected_components.iter().max();\n        if let Some(mci) = max_component_id {\n            assert_eq!(\n                *mci as usize,\n                total_connected_components as usize - 1,\n                \"We expected the connected components to be a dense set.\\n The obtained components are: \\n{:?}\\n The graph report is:\\n{:?}\",\n                connected_components,\n                graph.textual_report(false)\n            );\n        }\n    }\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_node_centralities",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "let node_degree_centralities = graph.get_degree_centrality()?;\n    assert_eq!(\n        node_degree_centralities.len(),\n        graph.get_nodes_number() as usize\n    );\n\n    assert!(\n        node_degree_centralities\n            .into_iter()\n            .all(|value| value <= 1.0),\n        \"All node degrees centralities are expected to be within 0 and 1.\"\n    );\n    let node_betweenness_centralities = graph.get_betweenness_centrality(None, Some(verbose));\n    assert_eq!(\n        node_betweenness_centralities.len(),\n        graph.get_nodes_number() as usize\n    );\n    node_betweenness_centralities\n        .into_iter()\n        .enumerate()\n        .for_each(|(node_id, value)| {\n            if graph.is_unchecked_singleton_from_node_id(node_id as NodeT) {\n                assert!(value.abs() < f64::EPSILON);\n            }\n        });\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_vertex_cover",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "_verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "let vertex_cover = graph.approximated_vertex_cover_set();\n    graph\n        .par_iter_edge_ids(true)\n        .for_each(|(_, src_node_id, dst_node_id)| {\n            assert!(\n                vertex_cover.contains(&src_node_id) || vertex_cover.contains(&dst_node_id),\n                concat!(\n                    \"We expected for either the node {} or {} to be in the vertex cover.\\n\",\n                    \"The vertex cover is {:?}\"\n                ),\n                src_node_id,\n                dst_node_id,\n                vertex_cover\n            );\n        });\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_polygons",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "_verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "assert_eq!(\n        graph\n            .get_number_of_triangles_per_node(Some(false))\n            .into_iter()\n            .map(|triangles_number| triangles_number as EdgeT)\n            .sum::<EdgeT>(),\n        graph.get_number_of_triangles(Some(false))\n    );\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_random_walks",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "_verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "// Testing principal random walk algorithms\n    let walker = first_order_walker(&graph)?;\n    assert_eq!(walker.clone(), walker);\n    let walker2 = second_order_walker(&graph, 2.0, 2.0)?;\n    assert_eq!(walker2.clone(), walker2);\n\n    if !graph.directed {\n        warn!(\"Executing random walks tests.\");\n        for mode in 0..3 {\n            if mode == 1 {\n                graph.enable(false, true, true, None)?;\n                if let Some(cumulative_node_degrees) = &graph.cumulative_node_degrees {\n                    assert_eq!(\n                        cumulative_node_degrees.len(),\n                        graph.get_nodes_number() as usize,\n                        \"Length of cumulative_node_degrees does not match number of nodes in the graph.\"\n                    );\n                }\n                if let Some(destinations) = &graph.destinations {\n                    assert_eq!(\n                        destinations.len(),\n                        graph.get_directed_edges_number() as usize,\n                        \"Length of destinations does not match number of edges in the graph.\"\n                    );\n                }\n            }\n            if mode == 2 {\n                graph.enable(false, false, false, Some(0.05))?;\n                assert!(\n                    graph.cached_destinations.is_some(),\n                    \"Cached destinations are not None when cache is enabled.\"\n                );\n            }\n            assert_eq!(\n                graph\n                    .iter_random_walks(1, &walker)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                graph\n                    .iter_random_walks(1, &walker)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                \"Walks of first order are not reproducible!\"\n            );\n\n            assert_eq!(\n                graph\n                    .iter_random_walks(1, &second_order_walker(&graph, 2.0, 2.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                graph\n                    .iter_random_walks(1, &second_order_walker(&graph, 2.0, 2.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                \"Walks of second order are not reproducible!\"\n            );\n\n            assert_eq!(\n                graph\n                    .iter_complete_walks(&walker)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                graph\n                    .iter_complete_walks(&walker)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                \"Complete first order walks are not reproducible!\"\n            );\n\n            assert_eq!(\n                graph\n                    .iter_complete_walks(&second_order_walker(&graph, 2.0, 2.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                graph\n                    .iter_complete_walks(&second_order_walker(&graph, 2.0, 2.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                \"Complete second order walks are not reproducible!\"\n            );\n\n            assert_eq!(\n                graph\n                    .iter_complete_walks(&second_order_walker(&graph, 2.0, 1.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                graph\n                    .iter_complete_walks(&second_order_walker(&graph, 2.0, 1.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                \"Complete second order walks are not reproducible!\"\n            );\n\n            assert_eq!(\n                graph\n                    .iter_complete_walks(&second_order_walker(&graph, 1.0, 2.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                graph\n                    .iter_complete_walks(&second_order_walker(&graph, 1.0, 2.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                \"Complete second order walks are not reproducible!\"\n            );\n        }\n    } else {\n        assert!(graph.iter_complete_walks(&walker).is_err());\n    }\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_edge_holdouts",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "if !graph.has_edge_types() {\n        assert!(graph\n            .connected_holdout(4, 0.8, Some(vec![None]), false, verbose)\n            .is_err());\n    }\n    for include_all_edge_types in &[false, true] {\n        let (train, test) =\n            graph.random_holdout(4, 0.6, *include_all_edge_types, None, None, verbose)?;\n        default_holdout_test_suite(graph, &train, &test)?;\n        let (train, test) =\n            graph.connected_holdout(4, 0.8, None, *include_all_edge_types, verbose)?;\n        let (total, min_comp, max_comp) = graph.get_connected_components_number(verbose);\n        assert_eq!(\n            graph.get_connected_components_number(verbose),\n            train.get_connected_components_number(verbose),\n            \"The number of components of the original graph and the connected training set does not match. Particularly, the number of nodes in the graph is {nodes_number}.\",\n            nodes_number=graph.get_nodes_number().to_string()\n        );\n        if total == 1 {\n            assert_eq!(\n                min_comp,\n                graph.get_nodes_number(),\n                concat!(\n                    \"We expect for the minimum size of connected components \",\n                    \"in a graph with a single connected component to \",\n                    \"match the number of nodes of the graph, but we got \",\n                    \"the minimum component with size {} and the number \",\n                    \"of nodes in the graph equal to {}.\\n\",\n                    \"The graph report is: \\n {:?}\",\n                ),\n                min_comp,\n                graph.get_nodes_number(),\n                graph.textual_report(false)\n            );\n            assert_eq!(max_comp, graph.get_nodes_number());\n            assert_eq!(min_comp, test.get_nodes_number());\n            assert_eq!(max_comp, test.get_nodes_number());\n        }\n        if total == 2 {\n            assert_eq!(\n                max_comp + min_comp, graph.get_nodes_number(),\n                \"We expected that the number of the minimum component ({}) plus the maximum component ({}), when the components are two, made up the graph nodes ({}).\\nThe graph report is:\\n {:?}\",\n                min_comp, max_comp, graph.get_nodes_number(),\n                graph.textual_report(false)\n            );\n            assert_eq!(max_comp + min_comp, test.get_nodes_number());\n        }\n        default_holdout_test_suite(graph, &train, &test)?;\n    }\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_remove_components",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "if graph.get_connected_components_number(verbose).0 > 1 {\n        let without_selfloops = graph.drop_selfloops(Some(verbose));\n\n        assert_eq!(\n            graph.get_connected_components_number(verbose),\n            without_selfloops.get_connected_components_number(verbose),\n            concat!(\n                \"We expected the graph to have the same components once we remove the selfloops.\\n\",\n                \"The report of the original graph is {:?}\\n\",\n                \"The report of the filtered graph is {:?}\\n\",\n                \"The edge node ids of the original graph are {:?}\\n\",\n                \"The edge node ids of the filtered graph are {:?}\\n\"\n            ),\n            graph.textual_report(false),\n            without_selfloops.textual_report(false),\n            graph.get_edge_node_ids(true),\n            without_selfloops.get_edge_node_ids(true),\n        );\n\n        let single_component = graph.remove_components(None, None, None, None, Some(1), verbose);\n        assert!(\n            single_component.is_ok(),\n            concat!(\n                \"Removing all the components except the first one returned an error.\\n\",\n                \"The error is:\\n{:?}\\nand the graph report is:\\n{:?}\"\n            ),\n            single_component,\n            graph.textual_report(false)\n        );\n        let single_component_number = single_component\n            .unwrap()\n            .get_connected_components_number(verbose)\n            .0;\n        assert_eq!(\n            single_component_number,\n            1,\n            concat!(\n                \"Removing all the components except the first one returned a graph \",\n                \"with {} components, which is not one.\\nThe report of the graph is:{:?}\\n\"\n            ),\n            single_component_number,\n            graph.textual_report(false)\n        );\n\n        let test = graph.remove_components(\n            Some(vec![graph.nodes.unchecked_translate(0)]),\n            None,\n            None,\n            None,\n            None,\n            verbose,\n        )?;\n        let without_selfloops = test.drop_selfloops(Some(verbose));\n        assert_eq!(\n            without_selfloops.get_connected_components_number(verbose).0,\n            1,\n            concat!(\n                \"Expected number of components (1) is not matched!\\n\",\n                \"The report of the original graph is {:?}\\n\",\n                \"The report of the graph with only one component is {:?}\\n\",\n                \"The report of the graph without selfloops is {:?}\\n\",\n            ),\n            graph.textual_report(false),\n            test.textual_report(false),\n            without_selfloops.textual_report(false)\n        );\n        if let Ok(node_type_name) = graph.get_node_type_name_from_node_type_id(0) {\n            assert!(graph\n                .remove_components(\n                    None,\n                    Some(vec![Some(node_type_name)]),\n                    None,\n                    None,\n                    None,\n                    verbose\n                )\n                .is_ok());\n        }\n        if graph.has_unknown_node_types()? {\n            let without_unknowns =\n                graph.remove_components(None, Some(vec![None]), None, None, None, verbose);\n            assert!(\n                without_unknowns.is_ok(),\n                \"Could not remove components without node type None.\\nThe error is {:?}\\nThe graph report is {:?}\",\n                without_unknowns, graph.textual_report(false)\n            );\n        }\n        if let Ok(edge_type_name) = graph.get_edge_type_name_from_edge_type_id(0) {\n            assert!(graph\n                .remove_components(\n                    None,\n                    None,\n                    Some(vec![Some(edge_type_name)]),\n                    None,\n                    None,\n                    verbose\n                )\n                .is_ok());\n        }\n        if graph.has_unknown_edge_types()? {\n            assert!(graph\n                .remove_components(None, None, Some(vec![None]), None, None, verbose)\n                .is_ok());\n        }\n    } else {\n        assert!(\n            graph\n                .remove_components(None, None, None, None, None, verbose)\n                .is_ok(),\n            \"We expect it to be possible, now, to create empty graphs.\"\n        );\n    }\n\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_kfold",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "_verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "let k = 3;\n    for i in 0..k {\n        let (train, test) = graph.kfold(k, i, None, 42, false)?;\n        assert!(\n            test.get_edges_number() <= (graph.get_edges_number() / k) + 1,\n            concat!(\n                \"Check that test kfolds respect size bound has failed!\\n\",\n                \"The value of k is {}.\\n\",\n                \"The report of the original graph is:\\n{:?}\\n\",\n                \"The report of the train graph is:\\n{:?}\\n\",\n                \"The report of the test graph is:\\n{:?}\\n\",\n                \"We expect that the test graph has at most {} edges but it has {}.\\n\",\n                \"The holdout index is {}.\\n\",\n            ),\n            k,\n            graph.textual_report(false),\n            train.textual_report(false),\n            test.textual_report(false),\n            (graph.get_edges_number() / k) + 1,\n            test.get_edges_number(),\n            i\n        );\n        default_holdout_test_suite(graph, &train, &test)?;\n    }\n\n    if let Ok(edge_t) = graph.get_edge_type_name_from_edge_type_id(0) {\n        for i in 0..k {\n            let (train, test) = graph.kfold(k, i, Some(vec![Some(edge_t.clone())]), 1337, false)?;\n            default_holdout_test_suite(graph, &train, &test)?;\n        }\n    }\n\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_negative_edges_generation",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "for only_from_same_component in &[true, false] {\n        let negatives = graph.sample_negatives(\n            4,\n            graph.get_edges_number(),\n            None,\n            *only_from_same_component,\n            verbose,\n        )?;\n        assert_eq!(\n            graph.get_edges_number(),\n            negatives.get_edges_number(),\n            \"We expect the graph and its negative graph to have the same number of edges but we got {} and {}.\",\n            graph.get_edges_number(),\n            negatives.get_edges_number()\n        );\n        validate_vocabularies(&negatives);\n        if !graph.has_edge_types() {\n            assert!(!graph.overlaps(&negatives)?);\n            assert!(!negatives.overlaps(&graph)?);\n        }\n        // Testing holdouts executed on negative edges.\n        let (neg_train, neg_test) =\n            negatives.random_holdout(32, 0.8, false, None, None, verbose)?;\n\n        neg_test.get_trap_nodes_number();\n\n        default_holdout_test_suite(&negatives, &neg_train, &neg_test)?;\n    }\n\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_subgraph_generation",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "let expected_nodes = graph.get_connected_nodes_number() / 10;\n    let subgraph = graph.random_subgraph(6, expected_nodes, verbose)?;\n    assert!(subgraph.overlaps(&graph)?);\n    assert!(subgraph.get_connected_nodes_number() <= expected_nodes + 1);\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_dump_graph",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "let node_file = random_path(None);\n    let nodes_writer = NodeFileWriter::new(node_file.clone())\n        .set_verbose(Some(verbose))\n        .set_separator(Some(\"\\t\"))\n        .set_header(Some(true))\n        .set_node_types_column_number(Some(4))\n        .set_nodes_column_number(Some(6))\n        .set_node_types_column(Some(\"node_types\"))\n        .set_nodes_column(Some(\"node_column\".to_string()));\n    nodes_writer.dump(&graph)?;\n    fs::remove_file(node_file).unwrap();\n\n    let edges_file = random_path(None);\n    let edges_writer = EdgeFileWriter::new(edges_file.clone())\n        .set_verbose(Some(verbose))\n        .set_separator(Some(\"\\t\"))\n        .set_header(Some(true))\n        .set_edge_types_column(Some(\"edge_types\"))\n        .set_destinations_column_number(Some(3))\n        .set_weights_column(Some(\"weight\".to_string()))\n        .set_weights_column_number(Some(2))\n        .set_sources_column(Some(\"The land of sushi\".to_string()))\n        .set_sources_column_number(Some(0))\n        .set_destinations_column(Some(\"The land of pizza\".to_string()))\n        .set_destinations_column_number(Some(1));\n\n    edges_writer.dump(&graph)?;\n    fs::remove_file(edges_file).unwrap();\n\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_embiggen_preprocessing",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "let walker = first_order_walker(&graph)?;\n    if !graph.directed {\n        let (terms_number, iterator) = graph.cooccurence_matrix(&walker, 3, verbose)?;\n        assert_eq!(terms_number, iterator.count());\n\n        let window_size = 3;\n        let batch_size = 256;\n        let data = graph\n            .node2vec(&walker, batch_size, window_size)?\n            .collect::<Vec<_>>();\n        assert_eq!(\n            data.len(),\n            batch_size as usize\n                * walker.iterations as usize\n                * (walker.single_walk_parameters.walk_length as usize - window_size * 2)\n        );\n        for (context, _) in data.iter() {\n            assert_eq!(context.len(), window_size * 2);\n        }\n    }\n    if graph.has_edges() {\n        graph\n            .link_prediction_degrees(0, 256, true, 10.0, false, 10, &None)\n            .unwrap()\n            .collect::<Vec<_>>();\n        graph\n            .link_prediction_ids(0, 256, 10.0, false, 10, &None)\n            .unwrap()\n            .collect::<Vec<_>>();\n    }\n\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_edgelist_generation",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "_verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "let _clique = graph.get_clique_edge_names(\n        None,\n        None,\n        Some(false),\n        None,\n        // limit to compute the clique for at most the first 3 nodes\n        // because it's really expensive computationally.\n        Some(\n            graph\n                .get_node_names()\n                .iter()\n                .take(3)\n                .cloned()\n                .collect::<HashSet<String>>(),\n        ),\n    );\n    warn!(\"Running edge lists generator tests.\");\n    if graph.get_nodes_number() > 1 {\n        let _bipartite = graph.get_bipartite_edge_names(\n            None,\n            Some(\n                [graph.get_unchecked_node_name_from_node_id(0)]\n                    .iter()\n                    .cloned()\n                    .collect::<HashSet<String>>(),\n            ),\n            Some(\n                [graph.get_unchecked_node_name_from_node_id(1)]\n                    .iter()\n                    .cloned()\n                    .collect::<HashSet<String>>(),\n            ),\n            None,\n            None,\n        )?;\n        let _star = graph.get_star_edges(\n            graph.get_unchecked_node_name_from_node_id(0),\n            Some(false),\n            Some(\n                [graph.get_unchecked_node_name_from_node_id(1)]\n                    .iter()\n                    .cloned()\n                    .collect::<HashSet<String>>(),\n            ),\n            None,\n        )?;\n        let _star = graph.get_star_edge_names(\n            graph.get_unchecked_node_name_from_node_id(0),\n            Some(false),\n            Some(\n                [graph.get_unchecked_node_name_from_node_id(1)]\n                    .iter()\n                    .cloned()\n                    .collect::<HashSet<String>>(),\n            ),\n            None,\n        )?;\n    }\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_nodelabel_holdouts",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "for use_stratification in [true, false] {\n        if graph.get_known_node_types_number()? < 2\n            || (use_stratification\n                && (graph.has_multilabel_node_types()? || graph.has_singleton_node_types()?))\n        {\n            assert!(graph\n                .node_label_holdout(0.8, use_stratification, 42)\n                .is_err());\n            continue;\n        }\n\n        let (train, test) = graph.node_label_holdout(0.8, use_stratification, 42)?;\n        assert!(train.has_unknown_node_types()?);\n        assert!(test.has_unknown_node_types()?);\n        assert!(!test\n            .replace_unknown_node_types_with_node_type_name(vec![\"HALLO!\".to_string()], verbose)?\n            .has_unknown_node_types()?);\n        let remerged = &mut (&train | &test)?;\n        assert_eq!(remerged.node_types, graph.node_types);\n        assert!(\n            remerged.contains(graph)?,\n            \"The re-merged holdouts does not contain the original graph.\"\n        );\n        assert!(\n            graph.contains(remerged)?,\n            \"The re-merged holdouts does not contain the original graph.\"\n        );\n        assert!(\n            train.node_types.as_ref().map_or(false, |train_nts| {\n                test.node_types.as_ref().map_or(false, |test_nts| {\n                    train_nts.ids.iter().zip(test_nts.ids.iter()).all(\n                        |(train_node_type, test_node_type)| {\n                            !(train_node_type.is_some() && test_node_type.is_some())\n                        },\n                    )\n                })\n            }),\n            \"The train and test node-label graphs are overlapping!\"\n        );\n    }\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_edgelabel_holdouts",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "for use_stratification in [true, false].iter() {\n        if *use_stratification && graph.has_singleton_edge_types()?\n            || graph.get_directed_edges_number() - graph.get_unknown_edge_types_number()? < 2\n            || !graph.has_edge_types()\n        {\n            assert!(graph\n                .edge_label_holdout(0.8, *use_stratification, 42)\n                .is_err());\n            continue;\n        }\n        let (train, test) = graph.edge_label_holdout(0.8, *use_stratification, 42)?;\n        assert!(train.has_unknown_edge_types()?);\n        assert!(test.has_unknown_edge_types()?);\n        assert!(!test\n            .replace_unknown_edge_types_with_edge_type_name(\"HALLO!\".to_string(), verbose)?\n            .has_unknown_edge_types()?);\n        assert!(\n            train.edge_types.as_ref().map_or(false, |train_nts| {\n                test.edge_types.as_ref().map_or(false, |test_nts| {\n                    train_nts.ids.iter().zip(test_nts.ids.iter()).all(\n                        |(train_edge_type, test_edge_type)| {\n                            !(train_edge_type.is_some() && test_edge_type.is_some())\n                        },\n                    )\n                })\n            }),\n            \"The train and test edge-label graphs are overlapping!\"\n        );\n    }\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_graph_filter",
                "args": [
                    [
                        "graph",
                        "&Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "let unfiltered = graph.filter_from_ids(\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        None,\n        false,\n        false,\n        false,\n        false,\n        Some(verbose),\n    );\n    assert_eq!(&unfiltered, graph);\n    assert!(graph\n        .filter_from_names(\n            None,\n            Some(vec![NONEXISTENT]),\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            false,\n            false,\n            false,\n            false,\n            Some(verbose),\n        )\n        .is_err());\n    for node_name in graph.iter_node_names().take(10) {\n        // The following test should remove ONLY the given node name\n        let graph_without_given_name_result = graph.filter_from_names(\n            None,\n            Some(vec![node_name.as_str()]),\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            false,\n            false,\n            false,\n            false,\n            Some(verbose),\n        );\n        assert!(graph_without_given_name_result.is_ok());\n        let graph_without_given_id = graph_without_given_name_result.unwrap();\n        assert_eq!(\n            graph_without_given_id.has_nodes(),\n            graph.get_nodes_number() > 1\n        );\n        assert!(!graph_without_given_id.has_node_name(node_name.as_str()));\n\n        // The following test should keep ONLY the given node name\n        let graph_with_given_name_result = graph.filter_from_names(\n            Some(vec![node_name.as_str()]),\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            false,\n            false,\n            false,\n            false,\n            Some(verbose),\n        );\n        assert!(graph_with_given_name_result.is_ok());\n        let graph_with_given_node_name = graph_with_given_name_result.unwrap();\n        assert_eq!(\n            graph_with_given_node_name.has_selfloops(),\n            graph.has_edge_from_node_names(node_name.as_ref(), node_name.as_ref())\n        );\n        assert_eq!(\n            graph_with_given_node_name.has_edges(),\n            graph_with_given_node_name.has_selfloops()\n        );\n        assert_eq!(graph_with_given_node_name.get_nodes_number(), 1);\n        assert!(graph_with_given_node_name.has_node_name(node_name.as_str()));\n    }\n\n    for node_type_name in graph.iter_unique_node_type_names()?.take(10) {\n        // The following test should remove ONLY the given node name\n        let graph_without_given_node_type_name_result = graph.filter_from_names(\n            None,\n            None,\n            None,\n            None,\n            None,\n            Some(vec![Some(node_type_name.clone())]),\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            false,\n            false,\n            false,\n            false,\n            Some(verbose),\n        );\n        assert!(graph_without_given_node_type_name_result.is_ok());\n        let graph_without_given_node_type_name = graph_without_given_node_type_name_result.unwrap();\n        if graph.get_node_types_number()? > 1 && !graph.has_multilabel_node_types()? {\n            assert!(graph_without_given_node_type_name.has_node_types());\n            assert!(graph_without_given_node_type_name.has_nodes());\n        }\n        assert!(!graph_without_given_node_type_name.has_node_type_name(node_type_name.as_str()));\n    }\n\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_graph_removes",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "let without_edge_types = graph.remove_edge_types(Some(verbose))?;\n    validate_vocabularies(&without_edge_types);\n    assert!(!without_edge_types.has_edge_types());\n    assert_eq!(\n        without_edge_types.has_edge_weights(),\n        graph.has_edge_weights()\n    );\n    assert_eq!(without_edge_types.node_types, graph.node_types);\n    if !graph.is_multigraph() {\n        assert_eq!(\n            without_edge_types.get_unique_edges_number(),\n            graph.get_unique_edges_number(),\n            concat!(\n                \"Number of unique edges does not match in graph without edge types.\\n\",\n                \"The report of the original graph is \\n{:?}\\n\",\n                \"The report of the graph without edge types is \\n{:?}\",\n            ),\n            graph.textual_report(false),\n            without_edge_types.textual_report(false)\n        );\n        assert_eq!(\n            without_edge_types.get_unique_selfloop_number(),\n            graph.get_unique_selfloop_number(),\n            \"Number of unique self loops does not match in graph without edge types.\"\n        );\n    }\n    assert_eq!(without_edge_types.nodes, graph.nodes);\n    let without_node_types = graph.remove_node_types()?;\n    validate_vocabularies(&without_node_types);\n    assert!(!without_node_types.has_node_types());\n    assert_eq!(\n        graph.is_multigraph(),\n        without_node_types.is_multigraph(),\n        \"If the original graph is a multigraph, the removal of node types should not change that.\"\n    );\n    assert_eq!(\n        without_node_types.weights,\n        graph.weights,\n        concat!(\n            \"We expected the weights not to change when removig node types.\",\n            \"\\nThe report of the original graph is {:?}.\",\n            \"\\nThe report of the filtered graph is {:?}.\"\n        ),\n        graph.textual_report(false),\n        without_node_types.textual_report(false)\n    );\n    assert_eq!(without_node_types.has_selfloops(), graph.has_selfloops());\n    assert_eq!(without_node_types.nodes, graph.nodes);\n    let without_weights = graph.remove_edge_weights()?;\n    validate_vocabularies(&without_weights);\n    assert!(!without_weights.has_edge_weights());\n    assert_eq!(without_weights.node_types, graph.node_types);\n    assert_eq!(without_weights.has_selfloops(), graph.has_selfloops());\n    assert_eq!(without_weights.nodes, graph.nodes);\n\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_clone_and_setters",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "let mut clone = graph.clone();\n    clone = clone.set_all_edge_types(\"TEST_SET_ALL_EDGE_TYPES\", Some(verbose))?;\n    assert!(!clone.is_multigraph());\n    clone = clone.set_all_node_types(\"TEST_SET_ALL_NODE_TYPES\")?;\n\n    assert_eq!(\n        clone.get_edge_types_number().unwrap(),\n        1,\n        \"Number of edge types of the graph is not 1.\"\n    );\n    if !graph.is_multigraph() {\n        assert_eq!(\n            clone.get_unchecked_edge_count_from_edge_type_id(Some(0)),\n            graph.get_directed_edges_number(),\n            \"Number of edges with the unique edge type does not match number of edges in the graph.\"\n        );\n    }\n\n    assert_eq!(\n        clone.get_node_types_number().unwrap(),\n        1,\n        \"Number of node types of the graph is not 1.\"\n    );\n    assert_eq!(\n        clone.get_unchecked_node_count_from_node_type_id(Some(0)),\n        graph.get_nodes_number(),\n        \"Number of nodes with the unique node type does not match number of nodes in the graph.\"\n    );\n\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_graph_remapping",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "assert!(\n        graph.are_nodes_remappable(&graph),\n        \"Graph always should be remappable to itself.\"\n    );\n    assert!(\n        graph.remap(&graph, verbose).is_ok(),\n        \"Graph always should be remappable to itself.\"\n    );\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "test_graph_diameter",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "// TODO! update this when we will support the graph diameter on directed graphs\n    if graph.is_directed() {\n        return Ok(());\n    }\n    let (n_of_components, _, biggest) = graph.get_connected_components_number(verbose);\n\n    let verbose = Some(verbose);\n    match n_of_components {\n        0 => {\n            // on an empty graph this should always fail\n            assert!(graph.get_unweighted_diameter(Some(false), verbose).is_err());\n            assert!(graph.get_unweighted_diameter(Some(true), verbose).is_err());\n        }\n\n        1 => {\n            // by definition the diameter of a graph with a single component\n            // cannot be infinite unless it's just a singleton.\n            if graph.get_nodes_number() == 1 {\n                assert_eq!(\n                    graph.get_unweighted_diameter(Some(false), verbose).unwrap(),\n                    f64::INFINITY\n                );\n                assert_eq!(\n                    graph.get_unweighted_diameter(Some(true), verbose).unwrap(),\n                    f64::INFINITY\n                );\n            } else {\n                assert_ne!(\n                    graph.get_unweighted_diameter(Some(false), verbose).unwrap(),\n                    f64::INFINITY\n                );\n                assert_ne!(\n                    graph.get_unweighted_diameter(Some(true), verbose).unwrap(),\n                    f64::INFINITY\n                );\n            }\n        }\n\n        _ => {\n            assert_eq!(\n                graph.get_unweighted_diameter(Some(false), verbose).unwrap(),\n                f64::INFINITY\n            );\n\n            // if all the nodes are singletons then the diameter should be infinite\n            if biggest == 1 {\n                assert_eq!(\n                    graph.get_unweighted_diameter(Some(true), verbose).unwrap(),\n                    f64::INFINITY\n                );\n            }\n        }\n    }\n\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [
                    " Executes near-complete test of all functions for the given graph."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "_default_test_suite",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "warn!(\"Starting default test suite.\");\n    let _ = test_graph_properties(graph, verbose);\n\n    warn!(\"Testing SkipGram / CBOW / GloVe preprocessing.\");\n    let _ = test_embiggen_preprocessing(graph, verbose);\n\n    warn!(\"Testing subgraph generation.\");\n    let _ = test_subgraph_generation(graph, verbose);\n\n    warn!(\"Testing clone and setters.\");\n    let _ = test_clone_and_setters(graph, verbose);\n\n    warn!(\"Testing edge-label holdouts tests.\");\n    let _ = test_edgelabel_holdouts(graph, verbose);\n\n    warn!(\"Testing writing out graph to file.\");\n    let _ = test_dump_graph(graph, verbose);\n\n    warn!(\"Testing generic filtering mechanism.\");\n    let _ = test_graph_filter(graph, verbose);\n\n    warn!(\"Testing the spanning arborescences.\");\n    let _ = test_spanning_arborescence_bader(graph, verbose);\n\n    warn!(\"Testing the graph diameter.\");\n    let _ = test_graph_diameter(graph, verbose);\n\n    warn!(\"Running node-label holdouts tests.\");\n    let _ = test_nodelabel_holdouts(graph, verbose);\n\n    warn!(\"Running remove components tests.\");\n    let _ = test_remove_components(graph, verbose);\n\n    warn!(\"Testing removes.\");\n    let _ = test_graph_removes(graph, verbose);\n\n    warn!(\"Testing negative edges generation.\");\n    let _ = test_negative_edges_generation(graph, verbose);\n\n    warn!(\"Executing edge holdouts tests.\");\n    let _ = test_edge_holdouts(graph, verbose);\n\n    warn!(\"Testing k-fold holdouts.\");\n    let _ = test_kfold(graph, verbose);\n\n    warn!(\"Testing edge lists generation.\");\n    let _ = test_edgelist_generation(graph, verbose);\n\n    warn!(\"Testing graph remapping.\");\n    let _ = test_graph_remapping(graph, verbose);\n\n    warn!(\"Testing random walks.\");\n    let _ = test_random_walks(graph, verbose);\n\n    //warn!(\"Testing dijkstra.\");\n    //let _ = test_dijkstra(graph, verbose);\n\n    warn!(\"Testing approximated vertex cover\");\n    let _ = test_vertex_cover(graph, verbose);\n\n    warn!(\"Testing node centralities.\");\n    let _ = test_node_centralities(graph, verbose);\n\n    warn!(\"Testing polygons.\");\n    let _ = test_polygons(graph, verbose);\n\n    Ok(())"
            },
            {
                "file": "test_utilities.rs",
                "doc": [
                    " Executes near-complete test of all functions for the given graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "default_test_suite",
                "args": [
                    [
                        "graph",
                        "&mut Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "warn!(\"Starting default test suite.\");\n    let _ = _default_test_suite(graph, verbose);\n    warn!(\"Starting default test suite with speedups enabled.\");\n    graph.enable(true, true, true, None)?;\n    let _ = _default_test_suite(graph, verbose);\n    warn!(\"Starting default test suite on transformed graphs.\");\n    for mut transformed_graph in [\n        graph.get_unweighted_laplacian_transformed_graph(Some(verbose)),\n        graph.get_unweighted_symmetric_normalized_transformed_graph(Some(verbose))?,\n        graph.get_unweighted_symmetric_normalized_laplacian_transformed_graph(Some(verbose))?,\n        graph.get_unweighted_random_walk_normalized_laplacian_transformed_graph(Some(verbose)),\n        graph.get_weighted_laplacian_transformed_graph(Some(verbose))?,\n        graph.get_weighted_symmetric_normalized_transformed_graph(Some(verbose))?,\n        graph.get_weighted_symmetric_normalized_laplacian_transformed_graph(Some(verbose))?,\n        graph.get_weighted_random_walk_normalized_laplacian_transformed_graph(Some(verbose))?,\n    ] {\n        println!(\"{:?}\\n========\", transformed_graph.textual_report(false));\n        let _ = _default_test_suite(&mut transformed_graph, verbose);\n    }\n    Ok(())"
            }
        ]
    },
    "modifiers.rs": {
        "imports": [
            "use super::*;",
            "use rayon::iter::IntoParallelRefIterator;",
            "use rayon::iter::ParallelIterator;",
            "use std::collections::HashMap;"
        ],
        "functions": [
            {
                "file": "modifiers.rs",
                "struct": "Graph",
                "doc": [
                    " Enable extra perks that buys you time as you accept to spend more memory.",
                    "",
                    " # Arguments",
                    " * `vector_sources`: bool - Whether to cache sources into a vector for faster walks.",
                    " * `vector_destinations`: bool - Whether to cache destinations into a vector for faster walks.",
                    " * `vector_cumulative_node_degrees`: bool - Whether to cache cumulative_node_degrees into a vector for faster walks.",
                    " * `cache_size`: Option<f64> - percentage of nodes destinations to cache. This cannot be used with the vector destinations."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "enable",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "vector_sources",
                        "bool"
                    ],
                    [
                        "vector_destinations",
                        "bool"
                    ],
                    [
                        "vector_cumulative_node_degrees",
                        "bool"
                    ],
                    [
                        "cache_size",
                        "Option<f64>"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "if (vector_destinations || self.destinations.is_some())\n            && (cache_size.is_some() || self.cached_destinations.is_some())\n        {\n            return Err(concat!(\n                \"It is not possible (nor would it make sense) to have both \",\n                \"partially cached destinations and completely cached vector \",\n                \"destinations at once.\\n\",\n                \"If you want to switch from one to the \",\n                \"other form of destinations cache remember to run the method \",\n                \"disable_all to disable all forms of time-memory tradeoffs.\\n\",\n                \"Once you have disabled again all trade-offs, you can \",\n                \"re-enable the any one you would like.\"\n            )\n            .to_string());\n        }\n\n        if vector_destinations {\n            if self.destinations.is_none() {\n                self.destinations = Some(self.get_destination_node_ids(true));\n            }\n        } else {\n            self.destinations = None;\n        }\n        if vector_sources {\n            if self.sources.is_none() {\n                self.sources = Some(self.get_source_node_ids(true));\n            }\n        } else {\n            self.sources = None;\n        }\n        if vector_cumulative_node_degrees {\n            if self.cumulative_node_degrees.is_none() {\n                self.cumulative_node_degrees = Some(self.get_cumulative_node_degrees());\n            }\n        } else {\n            self.cumulative_node_degrees = None;\n        }\n        if let Some(cs) = cache_size {\n            if cs <= 0.0 || cs >= 1.0 {\n                return Err(\"Cache size must be between strictly 0 and 1, otherwise just enable the destinations vector.\".to_owned());\n            }\n            let cached_nodes_number: NodeT = (self.get_nodes_number() as f64 * cs) as NodeT;\n            if cached_nodes_number == 0 || cached_nodes_number == self.get_nodes_number() {\n                return Err(\"Required cached nodes number cannot be 0 or all the nodes.\".to_owned());\n            }\n            self.cached_destinations = Some(\n                self.get_top_k_central_node_ids(cached_nodes_number)\n                    .par_iter()\n                    .map(|node_id| {\n                        (\n                            *node_id,\n                            self.iter_unchecked_neighbour_node_ids_from_source_node_id(*node_id)\n                                .collect::<Vec<NodeT>>(),\n                        )\n                    })\n                    .collect::<HashMap<NodeT, Vec<NodeT>>>(),\n            );\n        } else {\n            self.cached_destinations = None;\n        }\n        Ok(())"
            },
            {
                "file": "modifiers.rs",
                "struct": "Graph",
                "doc": [
                    " Disable all extra perks, reducing memory impact but incresing time requirements."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "disable_all",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "body": "self.destinations = None;\n        self.sources = None;\n        self.cumulative_node_degrees = None;\n        self.cached_destinations = None;"
            }
        ]
    },
    "polygons.rs": {
        "imports": [
            "use super::*;",
            "use rayon::iter::IndexedParallelIterator;",
            "use rayon::iter::IntoParallelIterator;",
            "use rayon::iter::IntoParallelRefIterator;",
            "use rayon::iter::IntoParallelRefMutIterator;",
            "use rayon::iter::ParallelIterator;",
            "use std::sync::atomic::{AtomicU32, Ordering};"
        ],
        "functions": [
            {
                "file": "polygons.rs",
                "struct": "Graph",
                "doc": [
                    " Returns number of triangles in the graph.",
                    "",
                    " # Arguments",
                    " * `normalize`: Option<bool> - Whether to normalize the number of triangles.",
                    "",
                    " # References",
                    " This implementation is described in [\"Faster Clustering Coefficient Using Vertex Covers\"](https://ieeexplore.ieee.org/document/6693348)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_number_of_triangles",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "normalize",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "let normalize = normalize.unwrap_or(true);\n        // First, we compute the set of nodes composing a vertex cover set.\n        // This vertex cover is NOT minimal, but is a 2-approximation.\n        let vertex_cover_set = self.approximated_vertex_cover_set();\n        // We start iterating over the nodes in the cover using rayon to parallelize the procedure.\n        let mut number_of_triangles = vertex_cover_set\n            .par_iter()\n            // For each node in the cover\n            .map(|&node_id| {\n                // We obtain the neighbours and collect them into a vector\n                // We store them instead of using them in a stream because we will need\n                // them multiple times below.\n                let neighbours = self\n                    .iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)\n                    .filter(|&neighbour_node_id| node_id != neighbour_node_id)\n                    .collect::<Vec<NodeT>>();\n                // We iterate over the neighbours\n                neighbours\n                    .iter()\n                    // If the neighbour either is a selfloop\n                    // or is not present in the vertex cover\n                    // we return 0 new triangles.\n                    .filter(|&neighbour_node_id| vertex_cover_set.contains(&neighbour_node_id))\n                    .map(|&neighbour_node_id| {\n                        // We compute the intersection of the neighbours.\n                        iter_set::intersection(\n                            neighbours.iter().cloned(),\n                            self.iter_unchecked_neighbour_node_ids_from_source_node_id(\n                                neighbour_node_id,\n                            ),\n                        )\n                        .filter(|&inner_neighbour_id| inner_neighbour_id != neighbour_node_id)\n                        .into_iter()\n                        .map(|inner_node_id| {\n                            // If the inner node is as well in the vertex cover\n                            // we only count this as one, as we will encounter\n                            // combinations of these nodes multiple times\n                            // while iterating the vertex cover nodes\n                            if vertex_cover_set.contains(&inner_node_id) {\n                                1\n                            } else {\n                                // Otherwise we won't encounter again this\n                                // node and we need to count the triangles\n                                // three times.\n                                3\n                            }\n                        })\n                        .sum::<EdgeT>()\n                    })\n                    .sum::<EdgeT>()\n            })\n            .sum::<EdgeT>();\n        if normalize {\n            number_of_triangles /= 3 * if self.is_directed() { 1 } else { 2 }\n        }\n        number_of_triangles"
            },
            {
                "file": "polygons.rs",
                "struct": "Graph",
                "doc": [
                    " Returns total number of triads in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_triads_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "self.par_iter_unweighted_node_degrees()\n            .map(|degree| (degree * degree.saturating_sub(1)) as EdgeT)\n            .sum()"
            },
            {
                "file": "polygons.rs",
                "struct": "Graph",
                "doc": [
                    " Returns transitivity of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_transitivity",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "f64",
                "body": "self.get_number_of_triangles(Some(false)) as f64 / self.get_triads_number() as f64"
            },
            {
                "file": "polygons.rs",
                "struct": "Graph",
                "doc": [
                    " Returns number of triangles for all nodes in the graph.",
                    "",
                    " # Arguments",
                    " * `normalize`: Option<bool> - Whether to normalize the number of triangles.",
                    "",
                    " # References",
                    " This implementation is described in [\"Faster Clustering Coefficient Using Vertex Covers\"](https://ieeexplore.ieee.org/document/6693348)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_number_of_triangles_per_node",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "normalize",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "let normalize = normalize.unwrap_or(true);\n        // First, we compute the set of nodes composing a vertex cover set.\n        // This vertex cover is NOT minimal, but is a 2-approximation.\n        let vertex_cover_set = self.approximated_vertex_cover_set();\n        let node_triangles_number = self\n            .iter_node_ids()\n            .map(|_| AtomicU32::new(0))\n            .collect::<Vec<_>>();\n        // We start iterating over the nodes in the cover using rayon to parallelize the procedure.\n        vertex_cover_set\n            .par_iter()\n            // For each node in the cover\n            .for_each(|&node_id| {\n                // We obtain the neighbours and collect them into a vector\n                // We store them instead of using them in a stream because we will need\n                // them multiple times below.\n                let neighbours = self\n                    .iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)\n                    .filter(|&neighbour_node_id| node_id != neighbour_node_id)\n                    .collect::<Vec<NodeT>>();\n                // We iterate over the neighbours\n                neighbours.iter().for_each(|&neighbour_node_id| {\n                    // If the neighbour either is a selfloop\n                    // or is not present in the vertex cover\n                    // we return 0 new triangles.\n                    if vertex_cover_set.contains(&neighbour_node_id) {\n                        // We compute the intersection of the neighbours.\n                        iter_set::intersection(\n                            neighbours.iter().cloned(),\n                            self.iter_unchecked_neighbour_node_ids_from_source_node_id(\n                                neighbour_node_id,\n                            ),\n                        )\n                        .filter(|&inner_node_id| inner_node_id != neighbour_node_id)\n                        .into_iter()\n                        .for_each(|inner_node_id| {\n                            // If the inner node is as well in the vertex cover\n                            // we only count this as one, as we will encounter\n                            // combinations of these nodes multiple times\n                            // while iterating the vertex cover nodes\n                            node_triangles_number[node_id as usize].fetch_add(1, Ordering::Relaxed);\n                            if !vertex_cover_set.contains(&inner_node_id) {\n                                // Otherwise we won't encounter again this\n                                // node and we need to count the triangles\n                                // three times.\n                                node_triangles_number[neighbour_node_id as usize]\n                                    .fetch_add(1, Ordering::Relaxed);\n                                node_triangles_number[inner_node_id as usize]\n                                    .fetch_add(1, Ordering::Relaxed);\n                            }\n                        });\n                    }\n                });\n            });\n        let mut node_triangles_number =\n            unsafe { std::mem::transmute::<Vec<AtomicU32>, Vec<NodeT>>(node_triangles_number) };\n        if normalize {\n            node_triangles_number\n                .par_iter_mut()\n                .for_each(|triangles_number| {\n                    *triangles_number /= 2;\n                });\n        }\n        node_triangles_number"
            },
            {
                "file": "polygons.rs",
                "struct": "Graph",
                "doc": [
                    " Returns iterator over the clustering coefficients for all nodes in the graph.",
                    "",
                    " # References",
                    " This implementation is described in [\"Faster Clustering Coefficient Using Vertex Covers\"](https://ieeexplore.ieee.org/document/6693348)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_clustering_coefficient_per_node",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "impl IndexedParallelIterator<Item = f64> + '_",
                "body": "self.get_number_of_triangles_per_node(Some(false))\n            .into_par_iter()\n            .zip(self.par_iter_unweighted_node_degrees())\n            .map(|(triangles_number, degree)| {\n                if degree < 2 {\n                    0.0\n                } else {\n                    triangles_number as f64 / (degree * (degree - 1)) as f64\n                }\n            })"
            },
            {
                "file": "polygons.rs",
                "struct": "Graph",
                "doc": [
                    " Returns clustering coefficients for all nodes in the graph.",
                    "",
                    " # References",
                    " This implementation is described in [\"Faster Clustering Coefficient Using Vertex Covers\"](https://ieeexplore.ieee.org/document/6693348)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_clustering_coefficient_per_node",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<f64>",
                "body": "self.iter_clustering_coefficient_per_node().collect()"
            },
            {
                "file": "polygons.rs",
                "struct": "Graph",
                "doc": [
                    " Returns the graph clustering coefficient.",
                    "",
                    " # References",
                    " This implementation is described in [\"Faster Clustering Coefficient Using Vertex Covers\"](https://ieeexplore.ieee.org/document/6693348)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_clustering_coefficient",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "f64",
                "body": "self.iter_clustering_coefficient_per_node().sum()"
            },
            {
                "file": "polygons.rs",
                "struct": "Graph",
                "doc": [
                    " Returns the graph average clustering coefficient.",
                    "",
                    " # References",
                    " This implementation is described in [\"Faster Clustering Coefficient Using Vertex Covers\"](https://ieeexplore.ieee.org/document/6693348)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_average_clustering_coefficient",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "f64",
                "body": "self.get_clustering_coefficient() / self.get_nodes_number() as f64"
            }
        ]
    },
    "node_file_writer.rs": {
        "imports": [
            "use super::*;"
        ],
        "functions": [
            {
                "file": "node_file_writer.rs",
                "struct": "NodeFileWriter",
                "impl_doc": [
                    " Structure that saves the writer specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * writer: CSVFileWriter - The common writer for readin and writing a csv.",
                    " * nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
                    " * nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
                    " * node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * node_types_separator: String - Separator to split the node types."
                ],
                "doc": [
                    " Return new NodeFileWriter object.",
                    "",
                    " # Arguments",
                    "",
                    " * path: String - Path where to store/load the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "new",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "path",
                        "S"
                    ]
                ],
                "return_type": "NodeFileWriter",
                "body": "NodeFileWriter {\n            writer: CSVFileWriter::new(path),\n            nodes_column: \"id\".to_string(),\n            nodes_column_number: 0,\n            node_types_column: \"category\".to_string(),\n            node_types_column_number: 1,\n            node_types_separator: \"\".to_string(),\n        }"
            },
            {
                "file": "node_file_writer.rs",
                "struct": "NodeFileWriter",
                "impl_doc": [
                    " Structure that saves the writer specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * writer: CSVFileWriter - The common writer for readin and writing a csv.",
                    " * nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
                    " * nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
                    " * node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * node_types_separator: String - Separator to split the node types."
                ],
                "doc": [
                    " Set the column of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * nodes_column: Option<String> - The nodes column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_nodes_column",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "nodes_column",
                        "Option<S>"
                    ]
                ],
                "return_type": "NodeFileWriter",
                "body": "if let Some(column) = nodes_column {\n            self.nodes_column = column.into();\n        }\n        self"
            },
            {
                "file": "node_file_writer.rs",
                "struct": "NodeFileWriter",
                "impl_doc": [
                    " Structure that saves the writer specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * writer: CSVFileWriter - The common writer for readin and writing a csv.",
                    " * nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
                    " * nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
                    " * node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * node_types_separator: String - Separator to split the node types."
                ],
                "doc": [
                    " Set the column of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * node_types_column: Option<String> - The node types column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_node_types_column",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "nodes_type_column",
                        "Option<S>"
                    ]
                ],
                "return_type": "NodeFileWriter",
                "body": "if let Some(column) = nodes_type_column {\n            self.node_types_column = column.into();\n        }\n        self"
            },
            {
                "file": "node_file_writer.rs",
                "struct": "NodeFileWriter",
                "impl_doc": [
                    " Structure that saves the writer specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * writer: CSVFileWriter - The common writer for readin and writing a csv.",
                    " * nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
                    " * nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
                    " * node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * node_types_separator: String - Separator to split the node types."
                ],
                "doc": [
                    " Set the column_number of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * nodes_column_number: Option<usize> - The nodes column_number to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_nodes_column_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "nodes_column_number",
                        "Option<usize>"
                    ]
                ],
                "return_type": "NodeFileWriter",
                "body": "if let Some(column) = nodes_column_number {\n            self.nodes_column_number = column;\n        }\n        self"
            },
            {
                "file": "node_file_writer.rs",
                "struct": "NodeFileWriter",
                "impl_doc": [
                    " Structure that saves the writer specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * writer: CSVFileWriter - The common writer for readin and writing a csv.",
                    " * nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
                    " * nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
                    " * node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * node_types_separator: String - Separator to split the node types."
                ],
                "doc": [
                    " Set the column_number of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * node_types_column_number: Option<usize> - The node types column_number to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_node_types_column_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "node_types_column_number",
                        "Option<usize>"
                    ]
                ],
                "return_type": "NodeFileWriter",
                "body": "if let Some(v) = node_types_column_number {\n            self.node_types_column_number = v;\n        }\n        self"
            },
            {
                "file": "node_file_writer.rs",
                "struct": "NodeFileWriter",
                "impl_doc": [
                    " Structure that saves the writer specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * writer: CSVFileWriter - The common writer for readin and writing a csv.",
                    " * nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
                    " * nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
                    " * node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * node_types_separator: String - Separator to split the node types."
                ],
                "doc": [
                    " Set the verbose.",
                    "",
                    " # Arguments",
                    "",
                    " * `verbose`: Option<bool> - Whether to show the loading bar or not.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_verbose",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "NodeFileWriter",
                "body": "if let Some(v) = verbose {\n            self.writer.verbose = v;\n        }\n        self"
            },
            {
                "file": "node_file_writer.rs",
                "struct": "NodeFileWriter",
                "impl_doc": [
                    " Structure that saves the writer specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * writer: CSVFileWriter - The common writer for readin and writing a csv.",
                    " * nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
                    " * nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
                    " * node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * node_types_separator: String - Separator to split the node types."
                ],
                "doc": [
                    " Set the separator.",
                    "",
                    " # Arguments",
                    "",
                    " * separator: Option<String> - The separator to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_separator",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "separator",
                        "Option<S>"
                    ]
                ],
                "return_type": "NodeFileWriter",
                "body": "if let Some(v) = separator {\n            self.writer.separator = v.into();\n        }\n        self"
            },
            {
                "file": "node_file_writer.rs",
                "struct": "NodeFileWriter",
                "impl_doc": [
                    " Structure that saves the writer specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * writer: CSVFileWriter - The common writer for readin and writing a csv.",
                    " * nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
                    " * nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
                    " * node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * node_types_separator: String - Separator to split the node types."
                ],
                "doc": [
                    " Set the header.",
                    "",
                    " # Arguments",
                    "",
                    " * header: Option<bool> - Whether to write out an header or not.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_header",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "header",
                        "Option<bool>"
                    ]
                ],
                "return_type": "NodeFileWriter",
                "body": "if let Some(v) = header {\n            self.writer.header = v;\n        }\n        self"
            },
            {
                "file": "node_file_writer.rs",
                "struct": "NodeFileWriter",
                "impl_doc": [
                    " Structure that saves the writer specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * writer: CSVFileWriter - The common writer for readin and writing a csv.",
                    " * nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
                    " * nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
                    " * node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * node_types_separator: String - Separator to split the node types."
                ],
                "doc": [
                    " Write nodes to file.",
                    "",
                    " # Arguments",
                    "",
                    " * `graph`: &Graph, reference to graph to use."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "dump",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "graph",
                        "&Graph"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "// build the header\n        let mut header = vec![(self.nodes_column.clone(), self.nodes_column_number)];\n\n        if graph.has_node_types() {\n            header.push((\n                self.node_types_column.clone(),\n                self.node_types_column_number,\n            ));\n        }\n\n        let number_of_columns = 1 + header.iter().map(|(_, i)| i).max().unwrap();\n\n        self.writer.write_lines(\n            graph.get_nodes_number() as usize,\n            compose_lines(number_of_columns, header),\n            (0..graph.get_nodes_number()).map(|node_id| {\n                let mut line = vec![(\n                    graph.nodes.unchecked_translate(node_id),\n                    self.nodes_column_number,\n                )];\n\n                if graph.has_node_types() {\n                    line.push((\n                        match graph.get_node_type_names_from_node_id(node_id).unwrap() {\n                            Some(values) => values.join(&self.node_types_separator),\n                            None => \"\".to_string(),\n                        },\n                        self.node_types_column_number,\n                    ));\n                }\n                compose_lines(number_of_columns, line)\n            }),\n        )"
            }
        ]
    },
    "dijkstra.rs": {
        "imports": [
            "use super::*;",
            "use bitvec::prelude::*;",
            "use indicatif::ParallelProgressIterator;",
            "use rayon::iter::IndexedParallelIterator;",
            "use rayon::iter::IntoParallelRefIterator;",
            "use rayon::iter::ParallelIterator;",
            "use roaring::RoaringBitmap;",
            "use std::cmp::Ord;",
            "use std::collections::VecDeque;"
        ],
        "functions": [
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns vector of minimum paths distances and vector of nodes predecessors, if requested.",
                    "",
                    " # Arguments",
                    " * `src_node_id`: NodeT - Root of the tree of minimum paths.",
                    " * `maybe_dst_node_id`: Option<NodeT> - Optional target destination. If provided, Dijkstra will stop upon reaching this node.",
                    " * `maybe_dst_node_ids`: Option<RoaringBitmap> - Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.",
                    " * `compute_distances`: Option<bool> - Whether to compute the vector of distances.",
                    " * `compute_predecessors`: Option<bool> - Whether to compute the vector of predecessors."
                ],
                "attrs": [
                    "#[no_binding]"
                ],
                "modifiers": "pub",
                "name": "get_unchecked_breath_first_search",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src_node_id",
                        "NodeT"
                    ],
                    [
                        "maybe_dst_node_id",
                        "Option<NodeT>"
                    ],
                    [
                        "maybe_dst_node_ids",
                        "Option<RoaringBitmap>"
                    ],
                    [
                        "compute_distances",
                        "Option<bool>"
                    ],
                    [
                        "compute_predecessors",
                        "Option<bool>"
                    ]
                ],
                "return_type": "ShortestPathsResultBFS",
                "body": "let compute_distances = compute_distances.unwrap_or(true);\n        let compute_predecessors = compute_predecessors.unwrap_or(true);\n        let nodes_number = self.get_nodes_number() as usize;\n\n        let mut parents: Option<Vec<Option<NodeT>>> = if compute_predecessors {\n            let mut parents = vec![None; nodes_number];\n            parents[src_node_id as usize] = Some(src_node_id);\n            Some(parents)\n        } else {\n            None\n        };\n\n        let mut distances: Option<Vec<NodeT>> = if compute_distances {\n            let mut distances: Vec<NodeT> = vec![NodeT::MAX; nodes_number];\n            distances[src_node_id as usize] = 0;\n            Some(distances)\n        } else {\n            None\n        };\n\n        let mut visited: Option<_> = if parents.is_some() || distances.is_some() {\n            None\n        } else {\n            let mut visited = bitvec![Lsb0, u8; 0; nodes_number];\n            unsafe { *visited.get_unchecked_mut(src_node_id as usize) = true };\n            Some(visited)\n        };\n\n        if self.is_unchecked_disconnected_from_node_id(src_node_id) {\n            return (distances, parents, NodeT::MAX, NodeT::MAX, 0.0);\n        }\n\n        let mut to_be_added = |neighbour_node_id, new_neighbour_distance, node_id| match (\n            &mut distances,\n            &mut parents,\n            &mut visited,\n        ) {\n            (None, None, Some(visited)) if !visited[neighbour_node_id as usize] => {\n                unsafe { *visited.get_unchecked_mut(neighbour_node_id as usize) = true };\n                true\n            }\n            (Some(distances), None, None)\n                if distances[neighbour_node_id as usize] == NodeT::MAX =>\n            {\n                distances[neighbour_node_id as usize] = new_neighbour_distance;\n                true\n            }\n            (None, Some(parents), None) if parents[neighbour_node_id as usize].is_none() => {\n                parents[neighbour_node_id as usize] = Some(node_id);\n                true\n            }\n            (Some(distances), Some(parents), None)\n                if distances[neighbour_node_id as usize] == NodeT::MAX =>\n            {\n                distances[neighbour_node_id as usize] = new_neighbour_distance;\n                parents[neighbour_node_id as usize] = Some(node_id);\n                true\n            }\n            _ => false,\n        };\n\n        let mut nodes_to_explore = VecDeque::with_capacity(nodes_number);\n        nodes_to_explore.push_back((src_node_id, 0));\n        let mut maximal_distance = 0;\n        let mut total_distance = 0;\n        let mut total_harmonic_distance: f64 = 0.0;\n\n        while let Some((node_id, depth)) = nodes_to_explore.pop_front() {\n            // Update the metrics\n            maximal_distance = maximal_distance.max(depth);\n            total_distance += depth;\n            if depth != 0 {\n                total_harmonic_distance += 1.0 / depth as f64;\n            }\n            // If the closest node is the optional destination node, we have\n            // completed what the user has required.\n            if maybe_dst_node_id.map_or(false, |dst| dst == node_id) {\n                break;\n            }\n\n            // If the closest node is in the set of the destination nodes\n            if let Some(dst_node_ids) = &mut maybe_dst_node_ids {\n                // We remove it\n                dst_node_ids.remove(node_id);\n                // And if now the roaringbitmap is empty\n                if dst_node_ids.is_empty() {\n                    // We have completed the requested task.\n                    break;\n                }\n            }\n\n            let new_neighbour_distance = depth + 1;\n\n            self.iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)\n                .for_each(|neighbour_node_id| {\n                    if to_be_added(neighbour_node_id, new_neighbour_distance, node_id) {\n                        nodes_to_explore.push_back((neighbour_node_id, new_neighbour_distance));\n                    }\n                });\n        }\n        (\n            distances,\n            parents,\n            maximal_distance,\n            total_distance,\n            total_harmonic_distance,\n        )"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns vector of k minimum paths distances and vector of nodes predecessors.",
                    "",
                    " # Arguments",
                    " * `src_node_id`: NodeT - Source node ID.",
                    " * `dst_node_id`: NodeT - Destination node ID.",
                    " * `k`: usize - Number of paths to find."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_unweighted_k_shortest_path",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src_node_id",
                        "NodeT"
                    ],
                    [
                        "dst_node_id",
                        "NodeT"
                    ],
                    [
                        "k",
                        "usize"
                    ]
                ],
                "return_type": "Vec<Vec<NodeT>>",
                "body": "let nodes_number = self.get_nodes_number() as usize;\n        let mut counts = vec![0; nodes_number];\n        let mut paths = Vec::new();\n\n        let mut nodes_to_explore = VecDeque::with_capacity(nodes_number);\n        nodes_to_explore.push_back(vec![src_node_id]);\n\n        while let Some(path) = nodes_to_explore.pop_front() {\n            // If we have found all the required paths we can exit\n            if counts[dst_node_id as usize] >= k {\n                break;\n            }\n            let node_id = *path.last().unwrap();\n            counts[node_id as usize] += 1;\n\n            if node_id == dst_node_id {\n                paths.push(path);\n                continue;\n            }\n\n            // If the number of identified paths to\n            // node ID is greater than k, we can continue.\n            if counts[node_id as usize] > k {\n                continue;\n            }\n\n            self.iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)\n                .for_each(|neighbour_node_id| {\n                    let mut new_path = path.clone();\n                    new_path.push(neighbour_node_id);\n                    nodes_to_explore.push_back(new_path);\n                });\n        }\n        paths"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns unweighted eccentricity of the given node.",
                    "",
                    " This method will panic if the given node ID does not exists in the graph.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - Node for which to compute the eccentricity.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_unweighted_eccentricity_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "NodeT",
                "body": "self.get_unchecked_breath_first_search(node_id, None, None, None, None)\n            .2"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns weighted eccentricity of the given node.",
                    "",
                    " This method will panic if the given node ID does not exists in the graph.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - Node for which to compute the eccentricity.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_weighted_eccentricity_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "f64",
                "body": "self.get_unchecked_dijkstra_from_node_ids(node_id, None, None, None)\n            .2"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns unweighted eccentricity of the given node ID.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - Node for which to compute the eccentricity.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unweighted_eccentricity_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "self.validate_node_id(node_id)\n            .map(|node_id| self.get_unchecked_unweighted_eccentricity_from_node_id(node_id))"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns weighted eccentricity of the given node ID.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - Node for which to compute the eccentricity.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_weighted_eccentricity_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "self.must_have_positive_edge_weights()?;\n        self.validate_node_id(node_id)\n            .map(|node_id| self.get_unchecked_weighted_eccentricity_from_node_id(node_id))"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns unweighted eccentricity of the given node name.",
                    "",
                    " # Arguments",
                    " * `node_name`: &str - Node for which to compute the eccentricity.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unweighted_eccentricity_from_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "self.get_node_id_from_node_name(node_name)\n            .map(|node_id| self.get_unchecked_unweighted_eccentricity_from_node_id(node_id))"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns weighted eccentricity of the given node name.",
                    "",
                    " # Arguments",
                    " * `node_name`: &str - Node for which to compute the eccentricity.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_weighted_eccentricity_from_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "self.get_node_id_from_node_name(node_name)\n            .map(|node_id| self.get_unchecked_weighted_eccentricity_from_node_id(node_id))"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns vector of minimum paths distances and vector of nodes predecessors, if requested.",
                    "",
                    " # Arguments",
                    " * `src_node_id`: NodeT - Root of the tree of minimum paths.",
                    " * `maybe_dst_node_id`: Option<NodeT> - Optional target destination. If provided, Dijkstra will stop upon reaching this node.",
                    " * `maybe_dst_node_ids`: Option<RoaringBitmap> - Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.",
                    " * `compute_predecessors`: bool - Whether to compute the vector of predecessors."
                ],
                "attrs": [
                    "#[no_binding]"
                ],
                "modifiers": "pub",
                "name": "get_unchecked_dijkstra_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src_node_id",
                        "NodeT"
                    ],
                    [
                        "maybe_dst_node_id",
                        "Option<NodeT>"
                    ],
                    [
                        "maybe_dst_node_ids",
                        "Option<RoaringBitmap>"
                    ],
                    [
                        "compute_predecessors",
                        "Option<bool>"
                    ]
                ],
                "return_type": "ShortestPathsDjkstra",
                "body": "let compute_predecessors = compute_predecessors.unwrap_or(true);\n        let nodes_number = self.get_nodes_number() as usize;\n        let mut parents: Option<Vec<Option<NodeT>>> = if compute_predecessors {\n            Some(vec![None; nodes_number])\n        } else {\n            None\n        };\n\n        if self.is_unchecked_disconnected_from_node_id(src_node_id) {\n            let mut distances = vec![f64::INFINITY; nodes_number];\n            distances[src_node_id as usize] = 0.0;\n            return (distances, parents, f64::INFINITY, f64::INFINITY, 0.0);\n        }\n\n        let mut nodes_to_explore: DijkstraQueue =\n            DijkstraQueue::with_capacity_from_root(nodes_number, src_node_id as usize);\n        let mut maximal_distance: f64 = 0.0;\n        let mut total_distance: f64 = 0.0;\n        let mut total_harmonic_distance: f64 = 0.0;\n\n        while let Some(closest_node_id) = nodes_to_explore.pop() {\n            // Update the distances metrics\n            maximal_distance = maximal_distance.max(nodes_to_explore[closest_node_id]);\n            total_distance += nodes_to_explore[closest_node_id];\n            if nodes_to_explore[closest_node_id] > 0.0 {\n                total_harmonic_distance += 1.0 / nodes_to_explore[closest_node_id];\n            }\n            // If the closest node is the optional destination node, we have\n            // completed what the user has required.\n            if maybe_dst_node_id.map_or(false, |dst| dst == closest_node_id as NodeT) {\n                break;\n            }\n            // If the closest node is in the set of the destination nodes\n            if let Some(dst_node_ids) = &mut maybe_dst_node_ids {\n                // We remove it\n                dst_node_ids.remove(closest_node_id as NodeT);\n                // And if now the roaringbitmap is empty\n                if dst_node_ids.is_empty() {\n                    // We have completed the requested task.\n                    break;\n                }\n            }\n            self.iter_unchecked_neighbour_node_ids_from_source_node_id(closest_node_id as NodeT)\n                .zip(self.iter_unchecked_edge_weights_from_source_node_id(closest_node_id as NodeT))\n                .for_each(|(neighbour_node_id, weight)| {\n                    let new_neighbour_distance = nodes_to_explore[closest_node_id] + weight as f64;\n                    if new_neighbour_distance < nodes_to_explore[neighbour_node_id as usize] {\n                        if let Some(parents) = &mut parents {\n                            parents[neighbour_node_id as usize] = Some(closest_node_id as NodeT);\n                        }\n                        nodes_to_explore.push(neighbour_node_id as usize, new_neighbour_distance);\n                    }\n                });\n        }\n\n        (\n            nodes_to_explore.unwrap(),\n            parents,\n            maximal_distance,\n            total_distance,\n            total_harmonic_distance,\n        )"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.",
                    "",
                    " # Arguments",
                    " * `src_node_id`: NodeT - Node ID root of the tree of minimum paths.",
                    " * `maybe_dst_node_id`: Option<NodeT> - Optional target destination. If provided, Dijkstra will stop upon reaching this node.",
                    " * `maybe_dst_node_ids`: Option<RoaringBitmap> - Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.",
                    " * `compute_distances`: Option<bool> - Whether to compute the vector of distances.",
                    " * `compute_predecessors`: Option<bool> - Whether to compute the vector of predecessors.",
                    "",
                    " # Raises",
                    " * If the given source node ID does not exist in the current graph.",
                    " * If the given optional destination node ID does not exist in the current graph."
                ],
                "attrs": [
                    "#[no_binding]"
                ],
                "modifiers": "pub",
                "name": "get_breath_first_search_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src_node_id",
                        "NodeT"
                    ],
                    [
                        "maybe_dst_node_id",
                        "Option<NodeT>"
                    ],
                    [
                        "maybe_dst_node_ids",
                        "Option<RoaringBitmap>"
                    ],
                    [
                        "compute_distances",
                        "Option<bool>"
                    ],
                    [
                        "compute_predecessors",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<ShortestPathsResultBFS, String>",
                "body": "// Check if the given root exists in the graph\n        self.validate_node_id(src_node_id)?;\n        // If given, check if the given destination node ID exists in the graph\n        if let Some(dst) = &maybe_dst_node_id {\n            self.validate_node_id(*dst)?;\n        }\n        // If given, check if the given destination node IDs exist in the graph\n        if let Some(dst_node_ids) = &maybe_dst_node_ids {\n            for dst_node_id in dst_node_ids.iter() {\n                self.validate_node_id(dst_node_id)?;\n            }\n        }\n        Ok(self.get_unchecked_breath_first_search(\n            src_node_id,\n            maybe_dst_node_id,\n            maybe_dst_node_ids,\n            compute_distances,\n            compute_predecessors,\n        ))"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.",
                    "",
                    " # Arguments",
                    " * `src_node_id`: NodeT - Node ID root of the tree of minimum paths.",
                    " * `maybe_dst_node_id`: Option<NodeT> - Optional target destination. If provided, Dijkstra will stop upon reaching this node.",
                    " * `maybe_dst_node_ids`: Option<RoaringBitmap> - Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.",
                    " * `compute_predecessors`: Option<bool> - Whether to compute the vector of predecessors.",
                    "",
                    " # Raises",
                    " * If the weights are to be used and the graph does not have weights.",
                    " * If the given source node ID does not exist in the current graph.",
                    " * If the given optional destination node ID does not exist in the current graph."
                ],
                "attrs": [
                    "#[no_binding]"
                ],
                "modifiers": "pub",
                "name": "get_dijkstra_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src_node_id",
                        "NodeT"
                    ],
                    [
                        "maybe_dst_node_id",
                        "Option<NodeT>"
                    ],
                    [
                        "maybe_dst_node_ids",
                        "Option<RoaringBitmap>"
                    ],
                    [
                        "compute_predecessors",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<ShortestPathsDjkstra, String>",
                "body": "// Check if the given root exists in the graph\n        self.validate_node_id(src_node_id)?;\n        self.must_have_positive_edge_weights()?;\n        // If given, check if the given destination node ID exists in the graph\n        if let Some(dst) = &maybe_dst_node_id {\n            self.validate_node_id(*dst)?;\n        }\n        // If given, check if the given destination node IDs exist in the graph\n        if let Some(dst_node_ids) = &maybe_dst_node_ids {\n            for dst_node_id in dst_node_ids.iter() {\n                self.validate_node_id(dst_node_id)?;\n            }\n        }\n        Ok(self.get_unchecked_dijkstra_from_node_ids(\n            src_node_id,\n            maybe_dst_node_id,\n            maybe_dst_node_ids,\n            compute_predecessors,\n        ))"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns diameter of an UNDIRECTED and UNWEIGHTED graph.",
                    "",
                    " # Referencences",
                    " This method is based on the algorithm described in [\"On computing the diameter of real-world undirected graphs\" by Crescenzi et al](https://who.rocq.inria.fr/Laurent.Viennot/road/papers/ifub.pdf)."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "get_unweighted_ifub",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "f64",
                "body": "let most_central_node_id = unsafe { self.get_unchecked_argmax_node_degree() };\n        if self.is_singleton_with_selfloops_from_node_id(most_central_node_id) {\n            return f64::INFINITY;\n        }\n        let (distances, _, mut root_eccentricity, _, _) = self.get_unchecked_breath_first_search(\n            most_central_node_id,\n            None,\n            None,\n            Some(true),\n            Some(false),\n        );\n        assert!(\n            root_eccentricity != NodeT::MAX,\n            \"The central node eccentricity cannot be infinite!\"\n        );\n        assert!(\n            root_eccentricity != 0,\n            \"The central node eccentricity cannot be zero!\"\n        );\n        let mut lower_bound_diameter = root_eccentricity;\n        let distances = unsafe { distances.unwrap_unchecked() };\n        let mut upper_bound_diameter = 2 * root_eccentricity;\n        while lower_bound_diameter < upper_bound_diameter {\n            if let Some(maximal_eccentricity) = distances\n                .par_iter()\n                .enumerate()\n                .filter(|(_, &distance)| distance == root_eccentricity)\n                .map(|(node_id, _)| {\n                    self.get_unchecked_unweighted_eccentricity_from_node_id(node_id as NodeT)\n                })\n                .max()\n            {\n                assert!(\n                    maximal_eccentricity != NodeT::MAX,\n                    \"The maximal eccentricity here cannot be infinite!\"\n                );\n                assert!(\n                    maximal_eccentricity != 0,\n                    \"The maximal eccentricity here cannot be zero!\"\n                );\n                assert!(\n                    root_eccentricity != 0,\n                    \"The root eccentricity cannot be zero!\"\n                );\n                lower_bound_diameter = lower_bound_diameter.max(maximal_eccentricity);\n            }\n            root_eccentricity -= 1;\n            upper_bound_diameter = 2 * root_eccentricity;\n        }\n        lower_bound_diameter as f64"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns diameter of an UNDIRECTED and WEIGHTED graph.",
                    "",
                    " # Referencences",
                    " This method is based on the algorithm described in [\"On Computing the Diameter of Real-World Directed (Weighted) Graphs\" by Crescenzi et al](https://link.springer.com/chapter/10.1007/978-3-642-30850-5_10)."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "get_weighted_ifub",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "f64",
                "body": "let most_central_node_id = unsafe { self.get_unchecked_argmax_node_degree() };\n        if self.is_singleton_with_selfloops_from_node_id(most_central_node_id) {\n            return f64::INFINITY;\n        }\n        let (distances, _, mut root_eccentricity, _, _) = self\n            .get_unchecked_dijkstra_from_node_ids(most_central_node_id, None, None, Some(false));\n\n        assert!(\n            root_eccentricity != f64::INFINITY,\n            \"The central node eccentricity cannot be infinite!\"\n        );\n        assert!(\n            root_eccentricity != 0.0,\n            \"The central node eccentricity cannot be zero!\"\n        );\n        let mut lower_bound_diameter = root_eccentricity;\n        let mut upper_bound_diameter = 2.0 * root_eccentricity;\n        while upper_bound_diameter < lower_bound_diameter {\n            if let Some(maximal_eccentricity) = distances\n                .par_iter()\n                .enumerate()\n                .filter(|(_, &distance)| (distance - root_eccentricity).abs() < f64::EPSILON)\n                .map(|(node_id, _)| {\n                    Some(self.get_unchecked_weighted_eccentricity_from_node_id(node_id as NodeT))\n                })\n                .reduce(\n                    || None,\n                    |old, new| {\n                        if let (Some(old), Some(new)) = (old, new) {\n                            Some(f64::max(old, new))\n                        } else {\n                            new\n                        }\n                    },\n                )\n            {\n                assert!(\n                    maximal_eccentricity != f64::INFINITY,\n                    \"The maximal eccentricity here cannot be infinite!\"\n                );\n                assert!(\n                    maximal_eccentricity != 0.0,\n                    \"The maximal eccentricity here cannot be zero!\"\n                );\n                assert!(\n                    root_eccentricity != 0.0,\n                    \"The root eccentricity cannot be zero!\"\n                );\n                lower_bound_diameter = lower_bound_diameter.max(maximal_eccentricity);\n            }\n            root_eccentricity -= 1.0;\n            upper_bound_diameter = 2.0 * root_eccentricity;\n        }\n        lower_bound_diameter"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns diameter of the graph.",
                    "",
                    " # Arguments",
                    " * `ignore_infinity`: Option<bool> - Whether to ignore infinite distances, which are present when in the graph exist multiple components.",
                    " * `verbose`: Option<bool> - Whether to show a loading bar.",
                    "",
                    " # Raises",
                    " * If the graph does not contain nodes.",
                    " * If the graph does not have weights and weights have been requested."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unweighted_diameter",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "ignore_infinity",
                        "Option<bool>"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "self.must_have_nodes()?;\n\n        if !self.has_edges() {\n            return Ok(f64::INFINITY);\n        }\n\n        let ignore_infinity = ignore_infinity.unwrap_or(false);\n        let verbose = verbose.unwrap_or(true);\n\n        if !ignore_infinity && !self.is_connected(verbose) {\n            return Ok(f64::INFINITY);\n        }\n\n        if self.is_directed() {\n            let pb = get_loading_bar(\n                verbose,\n                \"Computing unweighted diameter\",\n                self.get_nodes_number() as usize,\n            );\n            // TODO: Add a better implementation for the directed case\n            Ok(self\n                .par_iter_node_ids()\n                .progress_with(pb)\n                .map(|node_id| {\n                    self.get_unchecked_breath_first_search(\n                        node_id,\n                        None,\n                        None,\n                        Some(false),\n                        Some(false),\n                    )\n                    .2\n                })\n                .filter(|&distance| !ignore_infinity || distance != NodeT::MAX)\n                .max()\n                .unwrap_or(0) as f64)\n        } else {\n            Ok(self.get_unweighted_ifub())\n        }"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns diameter of the graph.",
                    "",
                    " # Arguments",
                    " * `ignore_infinity`: Option<bool> - Whether to ignore infinite distances, which are present when in the graph exist multiple components.",
                    " * `verbose`: Option<bool> - Whether to show a loading bar.",
                    "",
                    " # Raises",
                    " * If the graph does not contain nodes.",
                    " * If the graph does not have weights and weights have been requested."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_weighted_diameter",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "ignore_infinity",
                        "Option<bool>"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "self.must_have_nodes()?;\n        self.must_have_positive_edge_weights()?;\n\n        if !self.has_edges() {\n            return Ok(f64::INFINITY);\n        }\n        let ignore_infinity = ignore_infinity.unwrap_or(true);\n        let verbose = verbose.unwrap_or(true);\n\n        if !ignore_infinity && !self.is_connected(verbose) {\n            return Ok(f64::INFINITY);\n        }\n\n        if self.is_directed() {\n            let pb = get_loading_bar(\n                verbose,\n                \"Computing weighted diameter\",\n                self.get_nodes_number() as usize,\n            );\n            Ok(self\n                .par_iter_node_ids()\n                .progress_with(pb)\n                .map(|node_id| {\n                    self.get_unchecked_dijkstra_from_node_ids(node_id, None, None, Some(false))\n                        .2\n                })\n                .filter(|&distance| !ignore_infinity || distance != f64::INFINITY)\n                .reduce(|| f64::NEG_INFINITY, f64::max))\n        } else {\n            Ok(self.get_weighted_ifub() as f64)\n        }"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.",
                    "",
                    " # Arguments",
                    " * `src_node_name`: &str - Node name root of the tree of minimum paths.",
                    " * `maybe_dst_node_name`: Option<&str> - Optional target destination node name. If provided, Dijkstra will stop upon reaching this node.",
                    " * `maybe_dst_node_names`: Option<Vec<&str>> - Optional target destination node names. If provided, Dijkstra will stop upon reaching all of these nodes.",
                    " * `compute_distances`: Option<bool> - Whether to compute the vector of distances.",
                    " * `compute_predecessors`: Option<bool> - Whether to compute the vector of predecessors.",
                    "",
                    " # Raises",
                    " * If the weights are to be used and the graph does not have weights.",
                    " * If the given source node name does not exist in the current graph.",
                    " * If the given optional destination node name does not exist in the current graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_breath_first_search_from_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src_node_name",
                        "&str"
                    ],
                    [
                        "maybe_dst_node_name",
                        "Option<&str>"
                    ],
                    [
                        "maybe_dst_node_names",
                        "Option<Vec<&str>>"
                    ],
                    [
                        "compute_distances",
                        "Option<bool>"
                    ],
                    [
                        "compute_predecessors",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<ShortestPathsResultBFS, String>",
                "body": "Ok(self.get_unchecked_breath_first_search(\n            self.get_node_id_from_node_name(src_node_name)?,\n            maybe_dst_node_name.map_or(Ok::<_, String>(None), |dst_node_name| {\n                Ok(Some(self.get_node_id_from_node_name(dst_node_name)?))\n            })?,\n            maybe_dst_node_names.map_or(Ok::<_, String>(None), |dst_node_names| {\n                let mut bitmap = RoaringBitmap::new();\n                for node_name in dst_node_names.iter() {\n                    bitmap.push(self.get_node_id_from_node_name(node_name)?);\n                }\n                Ok(Some(bitmap))\n            })?,\n            compute_distances,\n            compute_predecessors,\n        ))"
            },
            {
                "file": "dijkstra.rs",
                "struct": "Graph",
                "doc": [
                    " Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.",
                    "",
                    " # Arguments",
                    " * `src_node_name`: &str - Node name root of the tree of minimum paths.",
                    " * `maybe_dst_node_name`: Option<&str> - Optional target destination node name. If provided, Dijkstra will stop upon reaching this node.",
                    " * `maybe_dst_node_names`: Option<Vec<&str>> - Optional target destination node names. If provided, Dijkstra will stop upon reaching all of these nodes.",
                    " * `compute_predecessors`: Option<bool> - Whether to compute the vector of predecessors.",
                    "",
                    " # Raises",
                    " * If the weights are to be used and the graph does not have weights.",
                    " * If the given source node name does not exist in the current graph.",
                    " * If the given optional destination node name does not exist in the current graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_dijkstra_from_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src_node_name",
                        "&str"
                    ],
                    [
                        "maybe_dst_node_name",
                        "Option<&str>"
                    ],
                    [
                        "maybe_dst_node_names",
                        "Option<Vec<&str>>"
                    ],
                    [
                        "compute_predecessors",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<ShortestPathsDjkstra, String>",
                "body": "self.get_dijkstra_from_node_ids(\n            self.get_node_id_from_node_name(src_node_name)?,\n            maybe_dst_node_name.map_or(Ok::<_, String>(None), |dst_node_name| {\n                Ok(Some(self.get_node_id_from_node_name(dst_node_name)?))\n            })?,\n            maybe_dst_node_names.map_or(Ok::<_, String>(None), |dst_node_names| {\n                let mut bitmap = RoaringBitmap::new();\n                for node_name in dst_node_names.iter() {\n                    bitmap.push(self.get_node_id_from_node_name(node_name)?);\n                }\n                Ok(Some(bitmap))\n            })?,\n            compute_predecessors,\n        )"
            }
        ]
    },
    "iter_queries.rs": {
        "imports": [
            "use super::*;",
            "use rayon::prelude::*;"
        ],
        "functions": [
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns range of the edge ids of edges starting from the given source node.",
                    "",
                    " # Arguments",
                    "",
                    " * `src`: NodeT - Source node of the edge.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unchecked_edge_ids_from_source_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ]
                ],
                "return_type": "std::ops::Range<usize>",
                "body": "let (min_edge_id, max_edge_id) =\n            self.get_unchecked_minmax_edge_ids_from_source_node_id(src);\n        min_edge_id as usize..max_edge_id as usize"
            },
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns iterator over the edge weights that have given node ID as source.",
                    "",
                    " This method assumes that the given source node ID exists in the graph.",
                    " Additionally it assumes that the graph has weights.",
                    " If either one of the above assumptions are not true, it will panic.",
                    "",
                    " # Arguments",
                    " * `source_node_id`: NodeT - The source node whose weights are to be returned.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unchecked_edge_weights_from_source_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "source_node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "impl Iterator<Item = WeightT> + '_",
                "body": "self.weights\n            .as_ref()\n            .map(|weights| {\n                weights[self.iter_unchecked_edge_ids_from_source_node_id(source_node_id)]\n                    .iter()\n                    .cloned()\n            })\n            .unwrap()"
            },
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns range of the edge ids of edges starting from the given source node.",
                    "",
                    " # Arguments",
                    "",
                    " * `src`: NodeT - Source node of the edge.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_unchecked_edge_ids_from_source_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ]
                ],
                "return_type": "impl ParallelIterator<Item = NodeT> + '_",
                "body": "self.iter_unchecked_edge_ids_from_source_node_id(src)\n            .into_par_iter()\n            .map(|node_id| node_id as NodeT)"
            },
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns range of multigraph minimum and maximum edge ids with same source and destination nodes and different edge type.",
                    "",
                    " # Arguments",
                    "",
                    " * `src`: NodeT - Source node of the edge.",
                    " * `dst`: NodeT -  Destination node of the edge.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unchecked_edge_ids_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "impl Iterator<Item = EdgeT>",
                "body": "let (min_edge_id, max_edge_id) = self.get_unchecked_minmax_edge_ids_from_node_ids(src, dst);\n        min_edge_id..max_edge_id"
            },
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return iterator over NodeT of destinations of the given node src.",
                    "",
                    " # Arguments",
                    " * `src`: NodeT - The node whose neighbours are to be retrieved.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unchecked_neighbour_node_ids_from_source_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ]
                ],
                "return_type": "Box<dyn Iterator<Item = NodeT> + Send + '_>",
                "body": "match &self.destinations {\n            Some(dsts) => Box::new(\n                dsts[self.iter_unchecked_edge_ids_from_source_node_id(src)]\n                    .iter()\n                    .cloned(),\n            ),\n            None => Box::new(\n                self.edges\n                    .iter_in_range(self.encode_edge(src, 0)..self.encode_edge(src + 1, 0))\n                    .map(move |edge| self.decode_edge(edge).1),\n            ),\n        }"
            },
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return iterator over neighbours intersection.",
                    "",
                    " # Arguments",
                    " * `first_src_node_id`: NodeT - The first node whose neighbours are to be retrieved.",
                    " * `second_src_node_id`: NodeT - The second node whose neighbours are to be retrieved.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unchecked_neighbour_node_ids_intersection_from_source_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "first_src_node_id",
                        "NodeT"
                    ],
                    [
                        "second_src_node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "impl Iterator<Item = NodeT> + Send + '_",
                "body": "iter_set::intersection(\n            self.iter_unchecked_neighbour_node_ids_from_source_node_id(first_src_node_id),\n            self.iter_unchecked_neighbour_node_ids_from_source_node_id(second_src_node_id),\n        )"
            },
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return iterator over neighbours union.",
                    "",
                    " # Arguments",
                    " * `first_src_node_id`: NodeT - The first node whose neighbours are to be retrieved.",
                    " * `second_src_node_id`: NodeT - The second node whose neighbours are to be retrieved.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unchecked_neighbour_node_ids_union_from_source_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "first_src_node_id",
                        "NodeT"
                    ],
                    [
                        "second_src_node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "impl Iterator<Item = NodeT> + Send + '_",
                "body": "iter_set::union(\n            self.iter_unchecked_neighbour_node_ids_from_source_node_id(first_src_node_id),\n            self.iter_unchecked_neighbour_node_ids_from_source_node_id(second_src_node_id),\n        )"
            },
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return iterator over neighbours difference.",
                    "",
                    " # Arguments",
                    " * `first_src_node_id`: NodeT - The first node whose neighbours are to be retrieved.",
                    " * `second_src_node_id`: NodeT - The second node whose neighbours are to be retrieved.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unchecked_neighbour_node_ids_difference_from_source_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "first_src_node_id",
                        "NodeT"
                    ],
                    [
                        "second_src_node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "impl Iterator<Item = NodeT> + Send + '_",
                "body": "iter_set::difference(\n            self.iter_unchecked_neighbour_node_ids_from_source_node_id(first_src_node_id),\n            self.iter_unchecked_neighbour_node_ids_from_source_node_id(second_src_node_id),\n        )"
            },
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return iterator over NodeT of destinations of the given node src.",
                    "",
                    " # Arguments",
                    " * `src`: NodeT - The node whose neighbour names are to be retrieved.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unchecked_neighbour_node_names_from_source_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ]
                ],
                "return_type": "impl Iterator<Item = String> + '_",
                "body": "self.iter_unchecked_neighbour_node_ids_from_source_node_id(src)\n            .map(move |dst| self.get_unchecked_node_name_from_node_id(dst))"
            },
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns option of range of multigraph minimum and maximum edge ids with same source and destination nodes and different edge type.",
                    "",
                    " # Arguments",
                    "",
                    " * `src`: NodeT - Source node id of the edge.",
                    " * `dst`: NodeT -  Destination node id of the edge.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_edge_ids_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = EdgeT>, String>",
                "body": "let (min_edge_id, max_edge_id) = self.get_minmax_edge_ids_from_node_ids(src, dst)?;\n        Ok(min_edge_id..max_edge_id)"
            },
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns iterator over edge IDs and their properties with given edge type.",
                    "",
                    " # Arguments",
                    " * `edge_type_id`: Option<EdgeTypeT> - Edge type ID to extract.",
                    " * `directed`: bool - Whether to iterate the edge list as directed or undirected.",
                    "",
                    " # Raises",
                    " * If there are no edge types in the graph.",
                    " * If the given edge type ID does not exist in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_edge_node_ids_and_edge_type_id_from_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_id",
                        "Option<EdgeTypeT>"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>)> + '_, String>",
                "body": "self.validate_edge_type_id(edge_type_id)\n            .map(|edge_type_id| {\n                self.iter_edge_node_ids_and_edge_type_id(directed)\n                    .filter(move |(_, _, _, this_edge_type_id)| *this_edge_type_id == edge_type_id)\n            })"
            },
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns iterator over node IDs and their properties with given node type.",
                    "",
                    " # Arguments",
                    " * `node_type_id`: Option<NodeTypeT> - node type ID to extract.",
                    "",
                    " # Raises",
                    " * If there are no node types in the graph.",
                    " * If the given node type ID does not exist in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_node_ids_and_node_type_ids_from_node_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_id",
                        "Option<NodeTypeT>"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = (NodeT, Option<Vec<NodeTypeT>>)> + '_, String>",
                "body": "self.validate_node_type_id(node_type_id)\n            .map(|node_type_id| {\n                self.iter_node_ids_and_node_type_ids().filter(\n                    move |(_, this_node_type_ids)| match (this_node_type_ids, &node_type_id) {\n                        (Some(tntis), Some(nti)) => tntis.contains(nti),\n                        (None, None) => true,\n                        _ => false,\n                    },\n                )\n            })"
            },
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns iterator over node names and their properties with given node type.",
                    "",
                    " # Arguments",
                    " * `node_type_id`: Option<NodeTypeT> - node type ID to extract.",
                    "",
                    " # Raises",
                    " * If there are no node types in the graph.",
                    " * If the given node type ID does not exist in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_node_names_and_node_type_names_from_node_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_id",
                        "Option<NodeTypeT>"
                    ]
                ],
                "return_type": "Result<\n        impl Iterator<Item = (NodeT, String, Option<Vec<NodeTypeT>>, Option<Vec<String>>)> + '_,\n        String,\n    >",
                "body": "self.validate_node_type_id(node_type_id)\n            .map(|node_type_id| {\n                self.iter_node_names_and_node_type_names().filter(\n                    move |(_, _, this_node_type_ids, _)| match (this_node_type_ids, &node_type_id) {\n                        (Some(tntis), Some(nti)) => tntis.contains(nti),\n                        (None, None) => true,\n                        _ => false,\n                    },\n                )\n            })"
            },
            {
                "file": "iter_queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The methods must follow the following naming convenction",
                    " * `/iter_(.+?)_from_(.+)/`",
                    " * `/iter_unchecked_(.+?)_from_(.+)/`",
                    " * `/par_iter_(.+?)_from_(.+)/`",
                    " * `/par_iter_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns iterator over edge node names and their properties with given edge type.",
                    "",
                    " # Arguments",
                    " * `edge_type_id`: Option<EdgeTypeT> - Edge type ID to extract.",
                    " * `directed`: bool - Whether to iterate the edge list as directed or undirected.",
                    "",
                    " # Raises",
                    " * If there are no edge types in the graph.",
                    " * If the given edge type ID does not exist in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_edge_node_names_and_edge_type_name_from_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_id",
                        "Option<EdgeTypeT>"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "Result<\n        impl Iterator<\n                Item = (\n                    EdgeT,\n                    NodeT,\n                    String,\n                    NodeT,\n                    String,\n                    Option<EdgeTypeT>,\n                    Option<String>,\n                ),\n            > + '_,\n        String,\n    >",
                "body": "self.validate_edge_type_id(edge_type_id)\n            .map(|edge_type_id| {\n                self.iter_edge_node_names_and_edge_type_name(directed)\n                    .filter(move |(_, _, _, _, _, this_edge_type_id, _)| {\n                        *this_edge_type_id == edge_type_id\n                    })\n            })"
            }
        ]
    },
    "tarjan.rs": {
        "imports": [
            "use super::types::*;",
            "use super::Graph;",
            "use std::cmp::min;",
            "use std::collections::HashSet;"
        ],
        "functions": [
            {
                "file": "tarjan.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Tarjan algorithm"
                ],
                "doc": [
                    " Returns list of nodes of the various strongly connected components.",
                    "",
                    " This is an implementation of Tarjan algorithm.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "strongly_connected_components",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<HashSet<NodeT>>",
                "body": "let mut indexed_mask: Vec<bool> = vec![false; self.get_nodes_number() as usize];\n        let mut stacked_mask: Vec<bool> = vec![false; self.get_nodes_number() as usize];\n        let mut low_indices: Vec<NodeT> = vec![0; self.get_nodes_number() as usize];\n        let mut indices: Vec<NodeT> = vec![0; self.get_nodes_number() as usize];\n        let mut components_stack: Vec<NodeT> = Vec::new();\n        let mut components: Vec<HashSet<NodeT>> = Vec::new();\n        let mut common_index = 0;\n        let mut recurse: bool;\n        for node in self.iter_node_ids() {\n            if !indexed_mask[node as usize] {\n                let mut to_visit: Vec<(NodeT, usize)> = vec![(node, 0)];\n                while !to_visit.is_empty() {\n                    let (src, i) = to_visit.pop().unwrap();\n                    if !indexed_mask[src as usize] {\n                        low_indices[src as usize] = common_index;\n                        indices[src as usize] = common_index;\n                        indexed_mask[src as usize] = true;\n                        stacked_mask[src as usize] = true;\n                        common_index += 1;\n                        components_stack.push(src);\n                    }\n                    recurse = false;\n                    let (_min, _max) = self.get_unchecked_minmax_edge_ids_from_source_node_id(src);\n                    // Consider successors of source node\n                    for (j, dst) in ((_min + i as EdgeT).._max)\n                        .map(|edge_id| self.get_unchecked_destination_node_id_from_edge_id(edge_id))\n                        .enumerate()\n                    {\n                        if !indexed_mask[dst as usize] {\n                            // Successor w has not yet been visited; recurse on it\n                            to_visit.push((src, i + j + 1));\n                            to_visit.push((dst, 0));\n                            recurse = true;\n                            break;\n                        } else if stacked_mask[dst as usize] {\n                            // Successor w is in stack S and hence in the current SCC\n                            // If w is not on stack, then (v, w) is an edge pointing to an SCC already found and must be ignored\n                            // Note: The next line may look odd - but is correct.\n                            // It says w.index not w.lowlink; that is deliberate and from the original paper\n                            low_indices[src as usize] =\n                                min(low_indices[src as usize], indices[dst as usize]);\n                        }\n                    }\n\n                    if recurse {\n                        continue;\n                    }\n\n                    // If source is a root node, pop the stack and generate an SCC\n                    if low_indices[src as usize] == indices[src as usize] {\n                        // start a new strongly connected component\n                        let mut new_component: HashSet<NodeT> = HashSet::new();\n                        loop {\n                            let dst = components_stack.pop().unwrap();\n                            stacked_mask[dst as usize] = false;\n                            new_component.insert(dst);\n                            if dst == src {\n                                break;\n                            }\n                        }\n                        components.push(new_component);\n                    }\n\n                    if !to_visit.is_empty() {\n                        let (root, _) = to_visit.last().unwrap();\n                        low_indices[*root as usize] =\n                            min(low_indices[*root as usize], low_indices[src as usize]);\n                    }\n                }\n            }\n        }\n        components"
            }
        ]
    },
    "queries.rs": {
        "imports": [
            "use super::*;",
            "use rayon::prelude::*;"
        ],
        "functions": [
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns option with the weight of the given edge id.",
                    "",
                    " This method will raise a panic if the given edge ID is higher than",
                    " the number of edges in the graph. Additionally, it will simply",
                    " return None if there are no graph weights.",
                    "",
                    " # Arguments",
                    " * `edge_id`: EdgeT - The edge whose edge weight is to be returned."
                ],
                "attrs": [
                    "#[no_inverse_method]"
                ],
                "modifiers": "pub",
                "name": "get_unchecked_edge_weight_from_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "Option<WeightT>",
                "body": "self.weights.as_ref().map(|ws| ws[edge_id as usize])"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns option with the weight of the given node ids.",
                    "",
                    " This method will raise a panic if the given node IDs are higher than",
                    " the number of nodes in the graph.",
                    "",
                    " # Arguments",
                    " * `src`: NodeT - The source node ID.",
                    " * `dst`: NodeT - The destination node ID."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_edge_weight_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "WeightT",
                "body": "unsafe {\n            self.get_unchecked_edge_weight_from_edge_id(\n                self.get_unchecked_edge_id_from_node_ids(src, dst),\n            )\n            .unwrap_unchecked()\n        }"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns node id from given node name raising a panic if used unproperly.",
                    "",
                    " # Arguments",
                    " * `node_name`: &str - The node name whose node ID is to be returned."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_node_id_from_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "NodeT",
                "body": "*self.nodes.get(node_name).unwrap()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return edge type ID corresponding to the given edge type name.",
                    "",
                    " # Arguments",
                    " * `edge_type_name`: &str - The edge type name whose edge type ID is to be returned."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_edge_type_id_from_edge_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_name",
                        "&str"
                    ]
                ],
                "return_type": "Option<EdgeTypeT>",
                "body": "self.edge_types\n            .as_ref()\n            .and_then(|ets| ets.get(edge_type_name).copied())"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return edge type ID corresponding to the given edge type name",
                    " raising panic if edge type ID does not exists in current graph.",
                    "",
                    " # Arguments",
                    " * `edge_type_id`: Option<EdgeTypeT> - The edge type naIDme whose edge type name is to be returned."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_edge_type_name_from_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_id",
                        "Option<EdgeTypeT>"
                    ]
                ],
                "return_type": "Option<String>",
                "body": "match (&self.edge_types, edge_type_id) {\n            (Some(ets), Some(et)) => Some(ets.unchecked_translate(et)),\n            _ => None,\n        }"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return number of edges of the given edge type without checks.",
                    "",
                    " # Arguments",
                    " * `edge_type`: Option<EdgeTypeT> - The edge type to retrieve count of."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_edge_count_from_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type",
                        "Option<EdgeTypeT>"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "match (&self.edge_types, edge_type) {\n            (Some(ets), None) => ets.get_unknown_count(),\n            (Some(ets), Some(et)) => ets.counts[et as usize],\n            _ => unreachable!(\"The current graph instance does not have edge types!\"),\n        }"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return number of nodes of the given node type without checks.",
                    "",
                    " # Arguments",
                    " * node_type: Option<NodeTypeT> - The node type to retrieve count of."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "get_unchecked_node_count_from_node_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type",
                        "Option<NodeTypeT>"
                    ]
                ],
                "return_type": "NodeT",
                "body": "match (&self.node_types, node_type) {\n            (Some(nts), None) => nts.get_unknown_count(),\n            (Some(nts), Some(nt)) => nts.counts[nt as usize],\n            _ => unreachable!(\"The current graph instance does not have node types!\"),\n        }"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return (subsampled) vector of destinations of given node.",
                    "",
                    " If the max neighbours parameter is given, and is smaller than the",
                    " number of the neighbours of the given node, the subsampling",
                    " mechanism is given.",
                    "",
                    " # Arguments",
                    " `node`: NodeT - Node whose neighbours are to return.",
                    " `random_state`: u64 - Random state to subsample neighbours.",
                    " `max_neighbours`: Option<NodeT> - Optionally number of neighbours to consider."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "get_unchecked_destination_node_ids_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node",
                        "NodeT"
                    ],
                    [
                        "random_state",
                        "u64"
                    ],
                    [
                        "max_neighbours",
                        "Option<NodeT>"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "let (min_edge_id, max_edge_id, destinations, _) =\n            self.get_edges_and_destinations_from_source_node_id(max_neighbours, random_state, node);\n        self.get_destinations_slice(min_edge_id, max_edge_id, node, &destinations)\n            .to_owned()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return edge ID without any checks for given tuple of nodes and edge type.",
                    "",
                    " This method will cause a panic if used improperly when it is not certain",
                    " that the edge exists.",
                    "",
                    " # Arguments",
                    " * `src`: NodeT - Source node of the edge.",
                    " * `dst`: NodeT - Destination node of the edge.",
                    " * `edge_type`: Option<EdgeTypeT> - Edge Type of the edge."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_edge_id_from_node_ids_and_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ],
                    [
                        "edge_type",
                        "Option<EdgeTypeT>"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "self.edge_types.as_ref().map_or_else(\n            || self.get_unchecked_edge_id_from_node_ids(src, dst),\n            |ets| {\n                self.iter_unchecked_edge_ids_from_node_ids(src, dst)\n                    // The vectors of the edge types can only have one element.\n                    .find(|edge_id| ets.ids[*edge_id as usize] == edge_type)\n                    .unwrap()\n            },\n        )"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return range of outbound edges IDs for all the edges bewteen the given",
                    " source and destination nodes.",
                    " This operation is meaningfull only in a multigraph.",
                    "",
                    " # Arguments",
                    "",
                    " * `src`: NodeT - Source node.",
                    " * `dst`: NodeT - Destination node.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_minmax_edge_ids_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "(EdgeT, EdgeT)",
                "body": "(\n            self.get_unchecked_edge_id_from_node_ids(src, dst),\n            self.get_unchecked_edge_id_from_node_ids(src, dst + 1),\n        )"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return the number of edges between the given source and destination nodes.",
                    "",
                    " This might be thought as the degree of an edge in a multigraph.",
                    " On non-multigraph this trivially return 1 on existing edges and 0 on",
                    " the non-existing ones.",
                    "",
                    " # Arguments",
                    "",
                    " * `src`: NodeT - Source node.",
                    " * `dst`: NodeT - Destination node.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "get_unchecked_edge_degree_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "let (min_edge_id, max_edge_id) = self.get_unchecked_minmax_edge_ids_from_node_ids(src, dst);\n        max_edge_id - min_edge_id"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns node IDs corresponding to given edge ID.",
                    "",
                    " The method will panic if the given edge ID does not exists in the",
                    " current graph instance.",
                    "",
                    " # Arguments",
                    " * `edge_id`: EdgeT - The edge ID whose source and destination node IDs are to e retrieved.",
                    "",
                    " # Example",
                    " To retrieve the source and destination node IDs of a given edge ID you can use the following:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let edge_id = 0;",
                    " let (src, dst) = graph.get_unchecked_node_ids_from_edge_id(edge_id);",
                    " println!(\"The edge with ID {} has source node ID {} and destination node ID {}.\", edge_id, src, dst);",
                    " ```"
                ],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "pub",
                "name": "get_unchecked_node_ids_from_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "(NodeT, NodeT)",
                "body": "if let (Some(sources), Some(destinations)) = (&self.sources, &self.destinations) {\n            return (sources[edge_id as usize], destinations[edge_id as usize]);\n        }\n        self.decode_edge(self.edges.unchecked_select(edge_id))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns node IDs corresponding to given edge ID.",
                    "",
                    " # Arguments",
                    " * `edge_id`: EdgeT - The edge ID whose source and destination node IDs are to e retrieved.",
                    "",
                    " # Example",
                    " To retrieve the source and destination node IDs of a given edge ID you can use the following:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(graph.get_node_ids_from_edge_id(0).is_ok());",
                    " assert!(graph.get_node_ids_from_edge_id(10000000000).is_err());",
                    " ```"
                ],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "pub",
                "name": "get_node_ids_from_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "Result<(NodeT, NodeT), String>",
                "body": "self.validate_edge_id(edge_id)\n            .map(|edge_id| self.get_unchecked_node_ids_from_edge_id(edge_id))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns edge ID corresponding to given source and destination node IDs.",
                    "",
                    " The method will panic if the given source and destination node IDs do",
                    " not correspond to an edge in this graph instance.",
                    "",
                    " # Arguments",
                    " * `src`: NodeT - The source node ID.",
                    " * `dst`: NodeT - The destination node ID.",
                    "",
                    " # Example",
                    " To retrieve the edge ID curresponding to the given source and destination node IDs you can use the following:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " let src = 0;",
                    " let dst = 1;",
                    " let edge_id = graph.get_unchecked_edge_id_from_node_ids(src, dst);",
                    " println!(\"The source node ID {} and destination node ID {} corrrespond to the edge with ID {}.\", src, dst, edge_id);",
                    " ```"
                ],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "pub",
                "name": "get_unchecked_edge_id_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "self.edges.unchecked_rank(self.encode_edge(src, dst)) as EdgeT"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns edge ID corresponding to given source and destination node IDs.",
                    "",
                    " # Arguments",
                    " * `src`: NodeT - The source node ID.",
                    " * `dst`: NodeT - The destination node ID.",
                    "",
                    " # Example",
                    " To retrieve the edge ID curresponding to the given source and destination node IDs you can use the following:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " assert!(graph.get_edge_id_from_node_ids(0, 1).is_ok());",
                    " assert!(graph.get_edge_id_from_node_ids(0, 100000000).is_err());",
                    " ```"
                ],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "pub",
                "name": "get_edge_id_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<EdgeT, String>",
                "body": "match self\n            .edges\n            .rank(self.encode_edge(src, dst))\n            .map(|value| value as EdgeT) {\n                Some(edge_id) => Ok(edge_id),\n                None => Err(format!(\"The edge composed by the source node {} and destination node {} does not exist in this graph.\", src, dst))\n            }"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns edge ID corresponding to given source and destination node IDs.",
                    "",
                    " # Arguments",
                    " * `source_id`: NodeT - The source node ID.",
                    "",
                    " # Example",
                    " To retrieve the edge ID curresponding to the given source and destination node IDs you can use the following:",
                    "",
                    " ```rust",
                    " # let graph_without_singletons = graph::test_utilities::load_ppi(false, true, true, false, false, false);",
                    " for node_id in graph_without_singletons.iter_node_ids(){",
                    "     assert_eq!(",
                    "         graph_without_singletons.get_unchecked_unique_source_node_id(node_id),",
                    "         node_id,",
                    "         \"The expected node ID does not match the obtained node ID.\"",
                    "     );",
                    " }",
                    " ```"
                ],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "pub",
                "name": "get_unchecked_unique_source_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "source_id",
                        "NodeT"
                    ]
                ],
                "return_type": "NodeT",
                "body": "// If there are no singletons or trap nodes in the graph\n        self.unique_sources.as_ref().map_or(\n            // We can directly return the provided source id.\n            source_id,\n            |x|\n                // Otherwise we need to retrieve the nodes corresponding to the given source ID\n                x.unchecked_select(source_id as u64) as NodeT,\n        )"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return the src, dst, edge type of a given edge ID.",
                    "",
                    " This method will raise a panic when an improper configuration is used.",
                    "",
                    " # Arguments",
                    " * `edge_id`: EdgeT - The edge ID whose source, destination and edge type are to be retrieved.",
                    "",
                    " # Example",
                    " In order to retrieve a given edge ID informations, you can use the following:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let edge_id = 0;",
                    " let (src, dst, edge_type) = graph.get_unchecked_node_ids_and_edge_type_id_from_edge_id(edge_id);",
                    " println!(\"The edge with ID {} has source node ID {}, destination node ID {} and edge type ID {:?}\", edge_id, src, dst, edge_type);",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_node_ids_and_edge_type_id_from_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "(NodeT, NodeT, Option<EdgeTypeT>)",
                "body": "let (src, dst) = self.get_unchecked_node_ids_from_edge_id(edge_id);\n        (\n            src,\n            dst,\n            self.get_unchecked_edge_type_id_from_edge_id(edge_id),\n        )"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return the src, dst, edge type of a given edge ID.",
                    "",
                    " # Arguments",
                    " * `edge_id`: EdgeT - The edge ID whose source, destination and edge type are to be retrieved.",
                    "",
                    " # Example",
                    " In order to retrieve a given edge ID informations, you can use the following:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(graph.get_node_ids_and_edge_type_id_from_edge_id(0).is_ok());",
                    " assert!(graph.get_node_ids_and_edge_type_id_from_edge_id(10000000000).is_err());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_ids_and_edge_type_id_from_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "Result<(NodeT, NodeT, Option<EdgeTypeT>), String>",
                "body": "self.validate_edge_id(edge_id)\n            .map(|edge_id| self.get_unchecked_node_ids_and_edge_type_id_from_edge_id(edge_id))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return the src, dst, edge type and weight of a given edge ID.",
                    "",
                    " This method will raise a panic when an improper configuration is used.",
                    "",
                    " # Arguments",
                    " * `edge_id`: EdgeT - The edge ID whose source, destination, edge type and weight are to be retrieved.",
                    "",
                    " # Example",
                    " In order to retrieve a given edge ID informations, you can use the following:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let edge_id = 0;",
                    " let (src, dst, edge_type, weight) = graph.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(edge_id);",
                    " println!(\"The edge with ID {} has source node ID {}, destination node ID {}, edge type ID {:?} and weight {:?}.\", edge_id, src, dst, edge_type, weight);",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "(NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>)",
                "body": "let (src, dst, edge_type) =\n            self.get_unchecked_node_ids_and_edge_type_id_from_edge_id(edge_id);\n        (\n            src,\n            dst,\n            edge_type,\n            self.get_unchecked_edge_weight_from_edge_id(edge_id),\n        )"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return the src, dst, edge type and weight of a given edge ID.",
                    "",
                    " # Arguments",
                    " * `edge_id`: EdgeT - The edge ID whose source, destination, edge type and weight are to be retrieved.",
                    "",
                    " # Example",
                    " In order to retrieve a given edge ID informations, you can use the following:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(0).is_ok());",
                    " assert!(graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(10000000000).is_err());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "Result<(NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>), String>",
                "body": "self.validate_edge_id(edge_id).map(|edge_id| {\n            self.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(edge_id)\n        })"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return vector with top k central node Ids.",
                    "",
                    " If the k passed is bigger than the number of nodes this method will return",
                    " all the nodes in the graph.",
                    "",
                    " # Arguments",
                    "",
                    " * `k`: NodeT - Number of central nodes to extract.",
                    " TODO: This can be refactored to run faster!"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_top_k_central_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "k",
                        "NodeT"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "let k = k.min(self.get_nodes_number());\n        let mut nodes_degrees: Vec<(NodeT, NodeT)> = self\n            .iter_node_ids()\n            .map(|node_id| {\n                (\n                    self.get_unchecked_unweighted_node_degree_from_node_id(node_id),\n                    node_id,\n                )\n            })\n            .collect();\n        nodes_degrees.par_sort_unstable();\n        nodes_degrees.reverse();\n        nodes_degrees[0..k as usize]\n            .iter()\n            .map(|(_, node_id)| *node_id)\n            .collect()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns the number of outbound neighbours of given node.",
                    "",
                    " The method will panic if the given node id is higher than the number of",
                    " nodes in the graph.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_id`: NodeT - Integer ID of the node.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_unweighted_node_degree_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "NodeT",
                "body": "let (min_edge_id, max_edge_id) =\n            self.get_unchecked_minmax_edge_ids_from_source_node_id(node_id);\n        (max_edge_id - min_edge_id) as NodeT"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns the weighted sum of outbound neighbours of given node.",
                    "",
                    " The method will panic if the given node id is higher than the number of",
                    " nodes in the graph.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_id`: NodeT - Integer ID of the node.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_weighted_node_degree_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "WeightT",
                "body": "self.iter_unchecked_edge_weights_from_source_node_id(node_id)\n            .sum::<WeightT>()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns the number of outbound neighbours of given node ID.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - Integer ID of the node.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unweighted_node_degree_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "self.validate_node_id(node_id)\n            .map(|node_id| self.get_unchecked_unweighted_node_degree_from_node_id(node_id))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns the weighted sum of outbound neighbours of given node ID.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - Integer ID of the node.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_weighted_node_degree_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<WeightT, String>",
                "body": "self.validate_node_id(node_id)\n            .map(|node_id| self.get_unchecked_weighted_node_degree_from_node_id(node_id))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns the number of outbound neighbours of given node name.",
                    "",
                    " # Arguments",
                    " * `node_name`: &str - Integer ID of the node.",
                    "",
                    " # Raises",
                    " * If the given node name does not exist in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_degree_from_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "Ok(self.get_unchecked_unweighted_node_degree_from_node_id(\n            self.get_node_id_from_node_name(node_name)?,\n        ))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return vector with top k central node names.",
                    "",
                    " # Arguments",
                    "",
                    " * `k`: NodeT - Number of central nodes to extract."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_top_k_central_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "k",
                        "NodeT"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "self.get_top_k_central_node_ids(k)\n            .into_iter()\n            .map(|node_id| self.get_unchecked_node_name_from_node_id(node_id))\n            .collect()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns option with vector of node types of given node.",
                    "",
                    " This method will panic if the given node ID is greater than",
                    " the number of nodes in the graph.",
                    " Furthermore, if the graph does NOT have node types, it will NOT",
                    " return neither an error or a panic.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_id`: NodeT - node whose node type is to be returned.",
                    "",
                    " # Example",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The node type id of node {} is {:?}\", 0, unsafe{ graph.get_unchecked_node_type_id_from_node_id(0) });",
                    " ```",
                    "",
                    " # Safety",
                    " Even though the method will return an option when the node types are",
                    " not available for the current graph, the behaviour is undefined.",
                    " Returns node type of given node.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_id`: NodeT - node whose node type is to be returned.",
                    "",
                    " # Example",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The node type id of node {} is {:?}\", 0, graph.get_node_type_id_from_node_id(0));",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_type_id_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<Option<Vec<NodeTypeT>>, String>",
                "body": "self.must_have_node_types()?;\n        self.validate_node_id(node_id)\n            .map(|node_id| unsafe { self.get_unchecked_node_type_id_from_node_id(node_id) })"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns edge type of given edge.",
                    "",
                    " This method will panic if the given edge ID is greater than",
                    " the number of edges in the graph.",
                    " Furthermore, if the graph does NOT have edge types, it will NOT",
                    " return neither an error or a panic.",
                    "",
                    " # Arguments",
                    "",
                    " * `edge_id`: EdgeT - edge whose edge type is to be returned.",
                    "",
                    " # Example",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert_eq!(graph.get_unchecked_edge_type_id_from_edge_id(0), Some(0));",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_edge_type_id_from_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "Option<EdgeTypeT>",
                "body": "self.edge_types\n            .as_ref()\n            .and_then(|ets| ets.ids[edge_id as usize])"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns edge type of given edge.",
                    "",
                    " # Arguments",
                    "",
                    " * `edge_id`: EdgeT - edge whose edge type is to be returned.",
                    "",
                    " # Example",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " # let graph_without_edge_types = graph::test_utilities::load_ppi(true, false, true, true, false, false);",
                    " assert_eq!(graph.get_edge_type_id_from_edge_id(0).unwrap(), Some(0));",
                    " assert!(graph_without_edge_types.get_edge_type_id_from_edge_id(0).is_err());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_type_id_from_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "Result<Option<EdgeTypeT>, String>",
                "body": "self.must_have_edge_types()?;\n        self.validate_edge_id(edge_id)\n            .map(|edge_id| self.get_unchecked_edge_type_id_from_edge_id(edge_id))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns result of option with the node type of the given node id.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - The node ID whose node types are to be returned.",
                    "",
                    " # Safety",
                    " This method will return an iterator of None values when the graph",
                    " does not contain node types.",
                    " Returns result of option with the node type of the given node id.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - The node ID whose node types are to be returned.",
                    "",
                    " # Raises",
                    " * If the node types are not available for the current graph instance."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_type_names_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<Option<Vec<String>>, String>",
                "body": "self.must_have_node_types()?;\n        Ok(self\n            .get_node_type_id_from_node_id(node_id)?\n            .map(|node_type_ids| unsafe {\n                self.get_unchecked_node_type_names_from_node_type_ids(node_type_ids)\n            }))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns result of option with the node type of the given node name.",
                    "",
                    " # Arguments",
                    " * `node_name`: &str - The node name whose node types are to be returned."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_type_names_from_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<Option<Vec<String>>, String>",
                "body": "self.get_node_type_names_from_node_id(self.get_node_id_from_node_name(node_name)?)"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns option with the edge type of the given edge id.",
                    "",
                    " # Arguments",
                    " * `edge_id`: EdgeT - The edge ID whose edge type is to be returned."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_type_name_from_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "Result<Option<String>, String>",
                "body": "self.get_edge_type_id_from_edge_id(edge_id)?\n            .map_or(Ok(None), |x| {\n                Ok(Some(self.get_edge_type_name_from_edge_type_id(x)?))\n            })"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return edge type name of given edge type.",
                    "",
                    " # Arguments",
                    " * `edge_type_id`: EdgeTypeT - Id of the edge type."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_type_name_from_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_id",
                        "EdgeTypeT"
                    ]
                ],
                "return_type": "Result<String, String>",
                "body": "self.must_have_edge_types()?;\n        self.edge_types\n            .as_ref()\n            .map(|ets| ets.translate(edge_type_id))\n            .unwrap()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns weight of the given edge id.",
                    "",
                    " # Arguments",
                    " * `edge_id`: EdgeT - The edge ID whose weight is to be returned.",
                    "",
                    " # Example",
                    " To get the weight of a given `edge_id` you can run:",
                    " ```rust",
                    " # let weighted_graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " # let unweighted_graph = graph::test_utilities::load_ppi(true, true, false, true, false, false);",
                    " let edge_id = 0;",
                    " let unexistent_edge_id = 123456789;",
                    " assert!(weighted_graph.get_edge_weight_from_edge_id(edge_id).is_ok());",
                    " assert!(weighted_graph.get_edge_weight_from_edge_id(unexistent_edge_id).is_err());",
                    " assert!(unweighted_graph.get_edge_weight_from_edge_id(edge_id).is_err());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_weight_from_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "Result<WeightT, String>",
                "body": "self.must_have_edge_weights()?;\n        self.weights.as_ref().map(\n            |weights| weights.get(edge_id as usize).map_or(\n                Err(format!(\n                    \"The given edge_id {} is higher than the number of available directed edges {}.\",\n                    edge_id,\n                    self.get_directed_edges_number()\n                )),\n                |value| Ok(*value)\n            )\n        ).unwrap()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns weight of the given node ids.",
                    "",
                    " # Arguments",
                    " * `src`: NodeT - The node ID of the source node.",
                    " * `dst`: NodeT - The node ID of the destination node.",
                    "",
                    " # Example",
                    " To get the weight of a given `src` and `dst` you can run:",
                    " ```rust",
                    " # let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " let src = 0;",
                    " let dst = 1;",
                    " assert!(weighted_graph.get_edge_weight_from_node_ids(src, dst).is_ok());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_weight_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<WeightT, String>",
                "body": "self.get_edge_weight_from_edge_id(self.get_edge_id_from_node_ids(src, dst)?)"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns weight of the given node ids and edge type.",
                    "",
                    " # Arguments",
                    " * `src`: NodeT - The node ID of the source node.",
                    " * `dst`: NodeT - The node ID of the destination node.",
                    " * `edge_type`: Option<EdgeTypeT> - The edge type ID of the edge.",
                    "",
                    " # Example",
                    " To get the weight of a given `src` and `dst` and `edge_type` you can run:",
                    " ```rust",
                    " # let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " let src = 0;",
                    " let dst = 1;",
                    " let edge_type = Some(0);",
                    " assert!(weighted_graph.get_edge_weight_from_node_ids_and_edge_type_id(src, dst, edge_type).is_ok());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_weight_from_node_ids_and_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ],
                    [
                        "edge_type",
                        "Option<EdgeTypeT>"
                    ]
                ],
                "return_type": "Result<WeightT, String>",
                "body": "self.get_edge_weight_from_edge_id(\n            self.get_edge_id_from_node_ids_and_edge_type_id(src, dst, edge_type)?,\n        )"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns weight of the given node names and edge type.",
                    "",
                    " # Arguments",
                    " * `src`: &str - The node name of the source node.",
                    " * `dst`: &str - The node name of the destination node.",
                    " * `edge_type`: Option<&str> - The edge type name of the edge.",
                    "",
                    " # Example",
                    " To get the weight of a given `src` and `dst` and `edge_type` you can run:",
                    " ```rust",
                    " # let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " let src = \"ENSP00000000233\";",
                    " let dst = \"ENSP00000432568\";",
                    " let edge_type = Some(\"red\");",
                    " assert!(weighted_graph.get_edge_weight_from_node_names_and_edge_type_name(src, dst, edge_type).is_ok());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_weight_from_node_names_and_edge_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "&str"
                    ],
                    [
                        "dst",
                        "&str"
                    ],
                    [
                        "edge_type",
                        "Option<&str>"
                    ]
                ],
                "return_type": "Result<WeightT, String>",
                "body": "self.get_edge_weight_from_edge_id(\n            self.get_edge_id_from_node_names_and_edge_type_name(src, dst, edge_type)?,\n        )"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns weight of the given node names.",
                    "",
                    " # Arguments",
                    " * `src_name`: &str - The node name of the source node.",
                    " * `dst_name`: &str - The node name of the destination node.",
                    "",
                    " # Example",
                    " To get the weight of a given `src_name` and `dst_name` you can run:",
                    " ```rust",
                    " # let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " let src_name = \"ENSP00000000233\";",
                    " let dst_name = \"ENSP00000432568\";",
                    " assert!(weighted_graph.get_edge_weight_from_node_names(src_name, dst_name).is_ok());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_weight_from_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src_name",
                        "&str"
                    ],
                    [
                        "dst_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<WeightT, String>",
                "body": "self.get_edge_weight_from_edge_id(self.get_edge_id_from_node_names(src_name, dst_name)?)"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns result with the node name.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - The node ID whose name is to be returned.",
                    "",
                    " # Example",
                    " To get the name of a node you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert_eq!(graph.get_unchecked_node_name_from_node_id(0), \"ENSG00000004059\".to_string());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_node_name_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "String",
                "body": "self.nodes.unchecked_translate(node_id)"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns result with the node name.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - The node ID whose name is to be returned.",
                    "",
                    " # Example",
                    " To get the name of a node you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(graph.get_node_name_from_node_id(0).is_ok());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_name_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<String, String>",
                "body": "self.validate_node_id(node_id)\n            .map(|node_id| self.get_unchecked_node_name_from_node_id(node_id))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns result with the node ID.",
                    "",
                    " # Arguments",
                    " * `node_name`: &str - The node name whose node ID is to be returned.",
                    "",
                    " # Raises",
                    " * When the given node name does not exists in the current graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_id_from_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "match self.nodes.get(node_name) {\n            Some(node_id) => Ok(*node_id),\n            None => Err(format!(\n                \"Given node name {} is not available in current graph.\",\n                node_name\n            )),\n        }"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns result with the node IDs.",
                    "",
                    " # Arguments",
                    " * `node_names`: Vec<&str> - The node names whose node IDs is to be returned.",
                    "",
                    " # Raises",
                    " * When any of the given node name does not exists in the current graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_ids_from_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_names",
                        "Vec<&str>"
                    ]
                ],
                "return_type": "Result<Vec<NodeT>, String>",
                "body": "node_names\n            .into_iter()\n            .map(|node_name| self.get_node_id_from_node_name(node_name))\n            .collect::<Result<Vec<NodeT>, String>>()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns result with the edge node IDs.",
                    "",
                    " # Arguments",
                    " * `edge_node_names`: Vec<(&str, &str)> - The node names whose node IDs is to be returned.",
                    "",
                    " # Raises",
                    " * When any of the given node name does not exists in the current graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_node_ids_from_edge_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_node_names",
                        "Vec<(&str, &str)>"
                    ]
                ],
                "return_type": "Result<Vec<(NodeT, NodeT)>, String>",
                "body": "edge_node_names\n            .into_iter()\n            .map(|(src_name, dst_name)| {\n                Ok((\n                    self.get_node_id_from_node_name(src_name)?,\n                    self.get_node_id_from_node_name(dst_name)?,\n                ))\n            })\n            .collect::<Result<Vec<(NodeT, NodeT)>, String>>()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns result with the edge node names.",
                    "",
                    " # Arguments",
                    " * `edge_node_ids`: Vec<(NodeT, NodeT)> - The node names whose node names is to be returned.",
                    "",
                    " # Raises",
                    " * When any of the given node IDs does not exists in the current graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_node_names_from_edge_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_node_ids",
                        "Vec<(NodeT, NodeT)>"
                    ]
                ],
                "return_type": "Result<Vec<(String, String)>, String>",
                "body": "edge_node_ids\n            .into_iter()\n            .map(|(src_name, dst_name)| {\n                Ok((\n                    self.get_node_name_from_node_id(src_name)?,\n                    self.get_node_name_from_node_id(dst_name)?,\n                ))\n            })\n            .collect::<Result<Vec<(String, String)>, String>>()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return node type ID for the given node name if available.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_name`: &str - Name of the node.",
                    "",
                    " # Example",
                    " To get the node type ID for a given node name you can run:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let node_name = \"ENSP00000000233\";",
                    " println!(\"The node type ID of node {} is {:?}.\", node_name, graph.get_node_type_id_from_node_name(node_name).unwrap());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_type_id_from_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<Option<Vec<NodeTypeT>>, String>",
                "body": "self.get_node_type_id_from_node_id(self.get_node_id_from_node_name(node_name)?)"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return node type name for the given node name if available.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_name`: &str - Name of the node.",
                    "",
                    " # Example",
                    " To get the node type name for a given node name you can run:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let node_name = \"ENSP00000000233\";",
                    " println!(\"The node type of node {} is {:?}\", node_name, graph.get_node_type_name_from_node_name(node_name).unwrap());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_type_name_from_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<Option<Vec<String>>, String>",
                "body": "self.get_node_type_names_from_node_id(self.get_node_id_from_node_name(node_name)?)"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return number of edges with given edge type ID.",
                    "",
                    " If None is given as an edge type ID, the unknown edge type IDs",
                    " will be returned.",
                    "",
                    " # Arguments",
                    " * `edge_type_id`: Option<EdgeTypeT> - The edge type ID to count the edges of.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_count_from_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_id",
                        "Option<EdgeTypeT>"
                    ]
                ],
                "return_type": "Result<EdgeT, String>",
                "body": "self.validate_edge_type_id(edge_type_id)\n            .map(|edge_type_id| self.get_unchecked_edge_count_from_edge_type_id(edge_type_id))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return edge type ID curresponding to given edge type name.",
                    "",
                    " If None is given as an edge type ID, None is returned.",
                    "",
                    " # Arguments",
                    " * `edge_type_name`: Option<&str> - The edge type name whose ID is to be returned.",
                    "",
                    " TODO: refactor this method using new validation methods."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_type_id_from_edge_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_name",
                        "Option<&str>"
                    ]
                ],
                "return_type": "Result<Option<EdgeTypeT>, String>",
                "body": "match (&self.edge_types, edge_type_name) {\n            (None, _) => Err(\"Current graph does not have edge types.\".to_owned()),\n            (Some(_), None) => Ok(None),\n            (Some(ets), Some(etn)) => match ets.get(etn) {\n                Some(edge_type_id) => Ok(Some(*edge_type_id)),\n                None => Err(format!(\n                    \"Given edge type name {} is not available in current graph.\",\n                    etn\n                )),\n            },\n        }"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return number of edges with given edge type name.",
                    "",
                    " If None is given as an edge type name, the unknown edge types",
                    " will be returned.",
                    "",
                    " # Arguments",
                    " * `edge_type_name`: Option<&str> - The edge type name to count the edges of.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_count_from_edge_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_name",
                        "Option<&str>"
                    ]
                ],
                "return_type": "Result<EdgeT, String>",
                "body": "self.get_edge_count_from_edge_type_id(\n            self.get_edge_type_id_from_edge_type_name(edge_type_name)?,\n        )"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return node type ID curresponding to given node type name.",
                    "",
                    " If None is given as an node type ID, None is returned.",
                    "",
                    " # Arguments",
                    " * `node_type_name`: &str - The node type name whose ID is to be returned.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_type_id_from_node_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<NodeTypeT, String>",
                "body": "self.must_have_node_types()?;\n        self.node_types\n            .as_ref()\n            .map(|nts| {\n                nts.get(node_type_name).map_or_else(\n                    || {\n                        Err(\n                            format!(\n                            concat!(\n                                \"The given node type name {} does not exists in the current graph instance.\\n\",\n                                \"The supported node types are {:?}.\"\n                            ),\n                            node_type_name,\n                            self.get_unique_node_type_names()\n                        )\n                    )\n                    },\n                    |node_type_id| Ok(*node_type_id),\n                )\n            })\n            .unwrap()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return number of nodes with given node type ID.",
                    "",
                    " If None is given as an node type ID, the unknown node types",
                    " will be returned.",
                    "",
                    " # Arguments",
                    " * `node_type_id`: Option<NodeTypeT> - The node type ID to count the nodes of.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_count_from_node_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_id",
                        "Option<NodeTypeT>"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "self.validate_node_type_id(node_type_id)\n            .map(|node_type_id| self.get_unchecked_node_count_from_node_type_id(node_type_id))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return number of nodes with given node type name.",
                    "",
                    " If None is given as an node type name, the unknown node types",
                    " will be returned.",
                    "",
                    " # Arguments",
                    " * `node_type_name`: Option<&str> - The node type name to count the nodes of.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_count_from_node_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_name",
                        "Option<&str>"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "self.get_node_count_from_node_type_id(\n            node_type_name.map_or(Ok::<_, String>(None), |ntn| {\n                Ok(Some(self.get_node_type_id_from_node_type_name(ntn)?))\n            })?,\n        )"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns the destination of given edge id without making any boundary check.",
                    "",
                    " # Arguments",
                    "",
                    " * `edge_id`: EdgeT - The edge ID whose destination is to be retrieved."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "get_unchecked_destination_node_id_from_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "NodeT",
                "body": "self.destinations.as_ref().map_or_else(\n            || self.get_unchecked_node_ids_from_edge_id(edge_id).1,\n            |dsts| dsts[edge_id as usize],\n        )"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Returns the destination of given edge id.",
                    "",
                    " # Arguments",
                    "",
                    " * `edge_id`: EdgeT - The edge ID whose destination is to be retrieved."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_destination_node_id_from_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "self.validate_edge_id(edge_id)\n            .map(|edge_id| self.get_unchecked_destination_node_id_from_edge_id(edge_id))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return vector of destinations for the given source node ID.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_id`: NodeT - Node ID whose neighbours are to be retrieved.",
                    "",
                    " # Example",
                    " To retrieve the neighbours of a given node `src` you can use:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " # let node_id = 0;",
                    " println!(\"The neighbours of the node {} are {:?}.\", node_id, graph.get_neighbour_node_ids_from_node_id(node_id).unwrap());",
                    " let unavailable_node = 2349765432;",
                    " assert!(graph.get_neighbour_node_ids_from_node_id(unavailable_node).is_err());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_neighbour_node_ids_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<Vec<NodeT>, String>",
                "body": "self.validate_node_id(node_id).map(|node_id| {\n            self.iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)\n                .collect()\n        })"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return vector of destinations for the given source node name.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_name`: &str - Node ID whose neighbours are to be retrieved.",
                    "",
                    " # Example",
                    " To retrieve the neighbours of a given node `src` you can use:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let node_name = \"ENSP00000000233\";",
                    " println!(\"The neighbours of the node {} are {:?}.\", node_name, graph.get_neighbour_node_ids_from_node_name(node_name).unwrap());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_neighbour_node_ids_from_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<Vec<NodeT>, String>",
                "body": "self.get_neighbour_node_ids_from_node_id(self.get_node_id_from_node_name(node_name)?)"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return vector of destination names for the given source node name.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_name`: &str - Node name whose neighbours are to be retrieved.",
                    "",
                    " # Example",
                    " To retrieve the neighbours of a given node `src` you can use:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " let node_name = \"ENSP00000000233\";",
                    " println!(\"The neighbours of the node {} are {:?}.\", node_name, graph.get_neighbour_node_names_from_node_name(node_name).unwrap());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_neighbour_node_names_from_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<Vec<String>, String>",
                "body": "Ok(self\n            .iter_unchecked_neighbour_node_names_from_source_node_id(\n                self.get_node_id_from_node_name(node_name)?,\n            )\n            .collect())"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return range of outbound edges IDs for all the edges bewteen the given",
                    " source and destination nodes.",
                    " This operation is meaningfull only in a multigraph.",
                    "",
                    " # Arguments",
                    "",
                    " * `src`: NodeT - Source node.",
                    " * `dst`: NodeT - Destination node.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_minmax_edge_ids_from_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<(EdgeT, EdgeT), String>",
                "body": "Ok((\n            self.get_edge_id_from_node_ids(src, dst)?,\n            self.get_unchecked_edge_id_from_node_ids(src, dst + 1),\n        ))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return edge ID for given tuple of nodes and edge type.",
                    "",
                    " This method will return an error if the graph does not contain the",
                    " requested edge with edge type.",
                    "",
                    " # Arguments",
                    " * `src`: NodeT - Source node of the edge.",
                    " * `dst`: NodeT - Destination node of the edge.",
                    " * `edge_type`: Option<EdgeTypeT> - Edge Type of the edge.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_id_from_node_ids_and_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ],
                    [
                        "edge_type",
                        "Option<EdgeTypeT>"
                    ]
                ],
                "return_type": "Result<EdgeT, String>",
                "body": "self.edge_types\n            .as_ref()\n            .map_or_else(\n                || self.get_edge_id_from_node_ids(src, dst).ok(),\n                |ets| {\n                    self.iter_edge_ids_from_node_ids(src, dst)\n                        .ok()\n                        .and_then(|mut edge_ids| {\n                            edge_ids.find(|edge_id| ets.ids[*edge_id as usize] == edge_type)\n                        })\n                },\n            )\n            .ok_or_else(|| {\n                format!(\n                    concat!(\n                    \"The current graph instance does not contain the required edge composed of \",\n                    \"source node ID {}, destination node ID {} and edge ID {:?}.\"\n                ),\n                    src, dst, edge_type\n                )\n            })"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return edge ID for given tuple of node names.",
                    "",
                    " This method will return an error if the graph does not contain the",
                    " requested edge with edge type.",
                    "",
                    " # Arguments",
                    " * `src_name`: &str - Source node name of the edge.",
                    " * `dst_name`: &str - Destination node name of the edge.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_id_from_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src_name",
                        "&str"
                    ],
                    [
                        "dst_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<EdgeT, String>",
                "body": "match (self.nodes.get(src_name), self.nodes.get(dst_name)) {\n            (Some(src), Some(dst)) => self.get_edge_id_from_node_ids(*src, *dst).ok(),\n            _ => None,\n        }\n        .ok_or_else(|| {\n            format!(\n                concat!(\n                    \"The current graph instance does not contain the required edge composed of \",\n                    \"source node name {} and destination node name {}.\"\n                ),\n                src_name, dst_name\n            )\n        })"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return edge ID for given tuple of node names and edge type name.",
                    "",
                    " This method will return an error if the graph does not contain the",
                    " requested edge with edge type.",
                    "",
                    " # Arguments",
                    " * `src_name`: &str - Source node name of the edge.",
                    " * `dst_name`: &str - Destination node name of the edge.",
                    " * `edge_type_name`: Option<&str> - Edge type name.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_id_from_node_names_and_edge_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src_name",
                        "&str"
                    ],
                    [
                        "dst_name",
                        "&str"
                    ],
                    [
                        "edge_type_name",
                        "Option<&str>"
                    ]
                ],
                "return_type": "Result<EdgeT, String>",
                "body": "match (self.nodes.get(src_name), self.nodes.get(dst_name)) {\n            (Some(src), Some(dst)) => self\n                .get_edge_id_from_node_ids_and_edge_type_id(\n                    *src,\n                    *dst,\n                    self.get_edge_type_id_from_edge_type_name(edge_type_name)?,\n                )\n                .ok(),\n            _ => None,\n        }\n        .ok_or_else(|| {\n            format!(\n                concat!(\n                    \"The current graph instance does not contain the required edge composed of \",\n                    \"source node name {}, destination node name {} and edge name {:?}.\"\n                ),\n                src_name, dst_name, edge_type_name\n            )\n        })"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return translated edge types from string to internal edge ID.",
                    "",
                    " # Arguments",
                    " * `edge_type_names`: Vec<Option<String>> - Vector of edge types to be converted."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_type_ids_from_edge_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_names",
                        "Vec<Option<String>>"
                    ]
                ],
                "return_type": "Result<Vec<Option<EdgeTypeT>>, String>",
                "body": "edge_type_names\n            .iter()\n            .map(|edge_type_name| match edge_type_name {\n                None => Ok(None),\n                Some(edge_type_name) => {\n                    self.get_edge_type_id_from_edge_type_name(Some(edge_type_name))\n                }\n            })\n            .collect::<Result<Vec<Option<EdgeTypeT>>, String>>()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return translated node types from string to internal node ID.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_type_names`: Vec<Option<String>> - Vector of node types to be converted."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_type_ids_from_node_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_names",
                        "Vec<Option<String>>"
                    ]
                ],
                "return_type": "Result<Vec<Option<NodeTypeT>>, String>",
                "body": "self.must_have_node_types()?;\n        node_type_names\n            .iter()\n            .map(|node_type_name| match node_type_name {\n                None => Ok(None),\n                Some(node_type_name) => self\n                    .get_node_type_id_from_node_type_name(node_type_name)\n                    .map(Some),\n            })\n            .collect::<Result<Vec<Option<NodeTypeT>>, String>>()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return translated node types from string to internal node ID.",
                    "",
                    " # Arguments",
                    "",
                    " * `node_type_names`: Vec<Option<Vec<&str>>> - Vector of node types to be converted.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types.",
                    " * If any of the given node type names do not exists in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_multiple_node_type_ids_from_node_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_names",
                        "Vec<Option<Vec<&str>>>"
                    ]
                ],
                "return_type": "Result<Vec<Option<Vec<NodeTypeT>>>, String>",
                "body": "self.must_have_node_types()?;\n        node_type_names\n            .iter()\n            .map(|maybe_node_type_names| {\n                maybe_node_type_names\n                    .as_ref()\n                    .map_or(Ok::<_, String>(None), |node_type_names| {\n                        Ok(Some(\n                            node_type_names\n                                .iter()\n                                .map(|node_type_name| {\n                                    self.get_node_type_id_from_node_type_name(node_type_name)\n                                })\n                                .collect::<Result<Vec<NodeTypeT>, String>>()?,\n                        ))\n                    })\n            })\n            .collect::<Result<Vec<Option<Vec<NodeTypeT>>>, String>>()"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return range of outbound edges IDs which have as source the given Node.",
                    "",
                    " The method will panic if the given source node ID is higher than",
                    " the number of nodes in the graph.",
                    "",
                    " # Arguments",
                    "",
                    " * `src`: NodeT - Node for which we need to compute the cumulative_node_degrees range.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_minmax_edge_ids_from_source_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ]
                ],
                "return_type": "(EdgeT, EdgeT)",
                "body": "match &self.cumulative_node_degrees {\n            Some(cumulative_node_degrees) => {\n                let min_edge_id = if src == 0 {\n                    0\n                } else {\n                    cumulative_node_degrees[src as usize - 1]\n                };\n                (min_edge_id, cumulative_node_degrees[src as usize])\n            }\n            None => {\n                let min_edge_id: EdgeT = self.get_unchecked_edge_id_from_node_ids(src, 0);\n                (\n                    min_edge_id,\n                    match &self.cached_destinations {\n                        Some(cds) => match cds.get(&src) {\n                            Some(destinations) => destinations.len() as EdgeT + min_edge_id,\n                            None => self.get_unchecked_edge_id_from_node_ids(src + 1, 0),\n                        },\n                        None => self.get_unchecked_edge_id_from_node_ids(src + 1, 0),\n                    },\n                )\n            }\n        }"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return range of outbound edges IDs which have as source the given Node.",
                    "",
                    " # Arguments",
                    "",
                    " * `src`: NodeT - Node for which we need to compute the cumulative_node_degrees range.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_minmax_edge_ids_from_source_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<(EdgeT, EdgeT), String>",
                "body": "self.validate_node_id(src)\n            .map(|src| self.get_unchecked_minmax_edge_ids_from_source_node_id(src))"
            },
            {
                "file": "queries.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Queries",
                    " The naming convention we follow is:",
                    " * `/get_(.+?)_from_(.+)/`",
                    " * `/get_unchecked_(.+?)_from_(.+)/`"
                ],
                "doc": [
                    " Return node type name of given node type.",
                    "",
                    " There is no need for a unchecked version since we will have to map",
                    " on the note_types anyway.",
                    "",
                    " # Arguments",
                    " * `node_type_id`: NodeTypeT - Id of the node type."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_type_name_from_node_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_id",
                        "NodeTypeT"
                    ]
                ],
                "return_type": "Result<String, String>",
                "body": "self.must_have_node_types()?;\n        self.node_types\n            .as_ref()\n            .map(|nts| nts.translate(node_type_id))\n            .unwrap()"
            }
        ]
    },
    "filters.rs": {
        "imports": [
            "use super::*;",
            "use indicatif::ProgressIterator;"
        ],
        "functions": [
            {
                "file": "filters.rs",
                "struct": "Graph",
                "doc": [
                    " Returns a **NEW** Graph that does not have the required attributes.",
                    "",
                    " # Arguments",
                    " * `node_ids_to_keep`: Option<Vec<NodeT>> - List of node IDs to keep during filtering.",
                    " * `node_ids_to_filter`: Option<Vec<NodeT>> - List of node IDs to remove during filtering.",
                    " * `node_type_ids_to_keep`: Option<Vec<Option<Vec<NodeTypeT>>>> - List of node type IDs to keep during filtering. The node types must match entirely the given node types vector provided.",
                    " * `node_type_ids_to_filter`: Option<Vec<Option<Vec<NodeTypeT>>>> - List of node type IDs to remove during filtering. The node types must match entirely the given node types vector provided.",
                    " * `node_type_id_to_keep`: Option<Vec<Option<NodeTypeT>>> - List of node type IDs to keep during filtering. Any of node types must match with one of the node types given.",
                    " * `node_type_id_to_filter`: Option<Vec<Option<NodeTypeT>>> - List of node type IDs to remove during filtering. Any of node types must match with one of the node types given.",
                    " * `edge_ids_to_keep`: Option<Vec<EdgeT>> - List of edge IDs to keep during filtering.",
                    " * `edge_ids_to_filter`: Option<Vec<EdgeT>> - List of edge IDs to remove during filtering.",
                    " * `edge_node_ids_to_keep`: Option<Vec<(NodeT, NodeT)>> - List of tuple of node IDs to keep during filtering.",
                    " * `edge_node_ids_to_filter`: Option<Vec<(NodeT, NodeT)>> - List of tuple of node IDs to remove during filtering.",
                    " * `edge_type_ids_to_keep`: Option<Vec<Option<EdgeTypeT>>> - List of edge type IDs to keep during filtering.",
                    " * `edge_type_ids_to_filter`: Option<Vec<Option<EdgeTypeT>>> - List of edge type IDs to remove during filtering.",
                    " * `min_edge_weight`: Option<WeightT> - Minimum edge weight. Values lower than this are removed.",
                    " * `max_edge_weight`: Option<WeightT> - Maximum edge weight. Values higher than this are removed.",
                    " * `filter_singleton_nodes`: bool - Whether to filter out singleton nodes.",
                    " * `filter_singleton_nodes_with_selfloop`: bool - Whether to filter out singleton nodes with selfloops.",
                    " * `filter_selfloops`: bool - Whether to filter out selfloops.",
                    " * `filter_parallel_edges`: bool - Whether to filter out parallel edges.",
                    " * `verbose`: bool - Whether to show loading bar while building the graphs.",
                    "",
                    " ## Implementation details",
                    "",
                    " ### How the collapse of multigraphs is handled",
                    " We keep only the first edge when a multigraph is collapsed while removing",
                    " the edge types, in the order provided when first reading from the CSV file.",
                    "",
                    " ### Generation of new singleton nodes when removing edges",
                    " Some of the remove operations allowed in this method might lead to the",
                    " generation of new singleton nodes that will not be handled within this",
                    " function call even if you provide the flag singletons to true, but you",
                    " will need to call the method again if you want to get reed of also those",
                    " newly created singleton nodes.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "filter_from_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_ids_to_keep",
                        "Option<Vec<NodeT>>"
                    ],
                    [
                        "node_ids_to_filter",
                        "Option<Vec<NodeT>>"
                    ],
                    [
                        "node_type_ids_to_keep",
                        "Option<Vec<Option<Vec<NodeTypeT>>>>"
                    ],
                    [
                        "node_type_ids_to_filter",
                        "Option<Vec<Option<Vec<NodeTypeT>>>>"
                    ],
                    [
                        "node_type_id_to_keep",
                        "Option<Vec<Option<NodeTypeT>>>"
                    ],
                    [
                        "node_type_id_to_filter",
                        "Option<Vec<Option<NodeTypeT>>>"
                    ],
                    [
                        "edge_ids_to_keep",
                        "Option<Vec<EdgeT>>"
                    ],
                    [
                        "edge_ids_to_filter",
                        "Option<Vec<EdgeT>>"
                    ],
                    [
                        "edge_node_ids_to_keep",
                        "Option<Vec<(NodeT, NodeT)>>"
                    ],
                    [
                        "edge_node_ids_to_filter",
                        "Option<Vec<(NodeT, NodeT)>>"
                    ],
                    [
                        "edge_type_ids_to_keep",
                        "Option<Vec<Option<EdgeTypeT>>>"
                    ],
                    [
                        "edge_type_ids_to_filter",
                        "Option<Vec<Option<EdgeTypeT>>>"
                    ],
                    [
                        "min_edge_weight",
                        "Option<WeightT>"
                    ],
                    [
                        "max_edge_weight",
                        "Option<WeightT>"
                    ],
                    [
                        "filter_singleton_nodes",
                        "bool"
                    ],
                    [
                        "filter_singleton_nodes_with_selfloop",
                        "bool"
                    ],
                    [
                        "filter_selfloops",
                        "bool"
                    ],
                    [
                        "filter_parallel_edges",
                        "bool"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Graph",
                "body": "let verbose = verbose.unwrap_or(true);\n        let pb_edges = get_loading_bar(\n            verbose,\n            format!(\n                \"Building edges of graph {} without required attributes\",\n                self.name\n            )\n            .as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n\n        let pb_nodes = get_loading_bar(\n            verbose,\n            format!(\n                \"Building nodes of graph {} without required attributes\",\n                self.name\n            )\n            .as_ref(),\n            self.get_nodes_number() as usize,\n        );\n\n        let has_node_filters = self.has_nodes()\n            && [\n                node_ids_to_keep.is_some(),\n                node_ids_to_filter.is_some(),\n                node_type_ids_to_keep.is_some(),\n                node_type_ids_to_filter.is_some(),\n                node_type_id_to_keep.is_some(),\n                node_type_id_to_filter.is_some(),\n                filter_singleton_nodes && self.has_singleton_nodes(),\n                filter_singleton_nodes_with_selfloop && self.has_singleton_nodes_with_selfloops(),\n            ]\n            .iter()\n            .any(|value| *value);\n\n        let has_edge_filters = self.has_edges()\n            && [\n                edge_ids_to_keep.is_some(),\n                edge_ids_to_filter.is_some(),\n                edge_node_ids_to_keep.is_some(),\n                edge_node_ids_to_filter.is_some(),\n                edge_type_ids_to_keep.is_some(),\n                edge_type_ids_to_filter.is_some(),\n                min_edge_weight.is_some() && max_edge_weight.is_some() && self.has_edge_weights(),\n                filter_selfloops && self.has_selfloops(),\n                filter_parallel_edges && self.is_multigraph(),\n                filter_singleton_nodes_with_selfloop && self.has_singleton_nodes_with_selfloops(),\n            ]\n            .iter()\n            .any(|value| *value);\n\n        let min_edge_weight = min_edge_weight.unwrap_or(WeightT::NEG_INFINITY);\n        let max_edge_weight = max_edge_weight.unwrap_or(WeightT::INFINITY);\n\n        let mut last_dst: Option<NodeT> = None;\n\n        let mut edge_filter = |(edge_id, src, dst, edge_type_id, weight): &(\n            EdgeT,\n            NodeT,\n            NodeT,\n            Option<EdgeTypeT>,\n            Option<WeightT>,\n        )| {\n            let result = edge_ids_to_keep.as_ref().map_or(true, |edge_ids| edge_ids.contains(edge_id)) &&\n            edge_ids_to_filter.as_ref().map_or(true, |edge_ids| !edge_ids.contains(edge_id)) &&\n            // If parallel edges need to be filtered out.\n            (!filter_parallel_edges || last_dst.as_ref().map_or(true, |last_dst| *last_dst!=*dst)) &&\n            // If selfloops need to be filtered out.\n            (!filter_selfloops || src != dst) &&\n            // If singleton nodes with selfloops need to be filtered out\n            (!filter_singleton_nodes_with_selfloop || src != dst || !self.is_singleton_with_selfloops_from_node_id(*src)) &&\n            // If the allow edge types set was provided\n            edge_node_ids_to_keep.as_ref().map_or(true, |edge_node_ids| edge_node_ids.contains(&(*src, *dst))) &&\n            // If the deny edge types set was provided\n            edge_node_ids_to_filter.as_ref().map_or(true, |edge_node_ids| !edge_node_ids.contains(&(*src, *dst))) &&\n            edge_type_ids_to_keep.as_ref().map_or(true, |ntitk| ntitk.contains(edge_type_id)) &&\n            edge_type_ids_to_filter.as_ref().map_or(true, |ntitf| !ntitf.contains(edge_type_id)) &&\n            weight.map_or(true, |weight| weight >= min_edge_weight && weight <= max_edge_weight);\n            last_dst.replace(*dst);\n            result\n        };\n\n        let node_filter = |(node_id, _, node_type_ids, _): &(\n            NodeT,\n            String,\n            Option<Vec<NodeTypeT>>,\n            Option<Vec<String>>,\n        )| {\n            node_ids_to_keep\n                .as_ref()\n                .map_or(true, |nitk| nitk.contains(node_id))\n                && node_ids_to_filter\n                    .as_ref()\n                    .map_or(true, |nitf| !nitf.contains(node_id))\n                && node_type_ids_to_keep\n                    .as_ref()\n                    .map_or(true, |ntitk| ntitk.contains(node_type_ids))\n                && node_type_ids_to_filter\n                    .as_ref()\n                    .map_or(true, |ntitf| !ntitf.contains(node_type_ids))\n                && node_type_id_to_keep\n                    .as_ref()\n                    .map_or(true, |ntitk| match node_type_ids {\n                        Some(node_type_ids) => node_type_ids\n                            .iter()\n                            .any(|node_type_id| ntitk.contains(&Some(*node_type_id))),\n                        None => ntitk.contains(&None),\n                    })\n                && !node_type_id_to_filter\n                    .as_ref()\n                    .map_or(false, |ntitf| match node_type_ids {\n                        Some(node_type_ids) => node_type_ids\n                            .iter()\n                            .any(|node_type_id| ntitf.contains(&Some(*node_type_id))),\n                        None => ntitf.contains(&None),\n                    })\n                && !(filter_singleton_nodes && self.is_unchecked_singleton_from_node_id(*node_id))\n                && !(filter_singleton_nodes\n                    && filter_selfloops\n                    && self.is_singleton_with_selfloops_from_node_id(*node_id)) &&\n                // If singleton nodes with selfloops need to be filtered out\n                (!filter_singleton_nodes_with_selfloop || !self.is_singleton_with_selfloops_from_node_id(*node_id))\n        };\n\n        match (has_node_filters, has_edge_filters) {\n            (false, false) => Ok(self.clone()),\n            (false, true) => Graph::build_graph(\n                self.iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)\n                    .progress_with(pb_edges)\n                    .filter(edge_filter)\n                    .map(|(_, src, dst, edge_type, weight)| Ok((src, dst, edge_type, weight))),\n                self.get_directed_edges_number() as usize,\n                self.nodes.clone(),\n                self.node_types.clone(),\n                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n                self.directed,\n                true,\n                self.get_name(),\n                false,\n                self.has_edge_types(),\n                self.has_edge_weights(),\n                true,\n                self.has_singleton_nodes_with_selfloops() && !filter_selfloops,\n                true,\n            ),\n            (true, _) => {\n                Graph::from_string_sorted(\n                    self.iter_edge_node_names_and_edge_type_name_and_edge_weight(true)\n                        .progress_with(pb_edges)\n                        .filter(\n                            |(edge_id, src, src_name, dst, dst_name, edge_type, _, weight)| unsafe {\n                                edge_filter(&(*edge_id, *src, *dst, *edge_type, *weight))\n                                    && node_filter(&(\n                                        *src,\n                                        src_name.clone(),\n                                        self.get_unchecked_node_type_id_from_node_id(*src),\n                                        None,\n                                    ))\n                                    && node_filter(&(\n                                        *dst,\n                                        dst_name.clone(),\n                                        self.get_unchecked_node_type_id_from_node_id(*dst),\n                                        None,\n                                    ))\n                            },\n                        )\n                        .map(|(_, _, src_name, _, dst_name, _, edge_type_name, weight)| {\n                            Ok((src_name, dst_name, edge_type_name, weight))\n                        }),\n                    Some(\n                        self.iter_node_names_and_node_type_names()\n                            .progress_with(pb_nodes)\n                            .filter(node_filter)\n                            .map(|(_, node_name, _, node_types)| Ok((node_name, node_types))),\n                    ),\n                    self.is_directed(),\n                    true,\n                    self.get_name(),\n                    false,\n                    true,\n                    false,\n                    true,\n                    self.get_directed_edges_number() as usize,\n                    self.get_nodes_number(),\n                    // TODO: UPDATE THE FOLLOWING FOUR BOOLEANS\n                    false,\n                    false,\n                    false,\n                    false,\n                    self.has_node_types(),\n                    self.has_edge_types(),\n                    self.has_edge_weights(),\n                    // TODO: Almost any edge filtering procedure may produce singletons.\n                    // Consider refining the following for the subset that do not\n                    // which should basically be only those that remove singletons.\n                    true,\n                    self.has_selfloops() && !filter_selfloops,\n                    true,\n                )\n            }\n        }\n        .unwrap()"
            },
            {
                "file": "filters.rs",
                "struct": "Graph",
                "doc": [
                    " Returns a **NEW** Graph that does not have the required attributes.",
                    "",
                    " # Arguments",
                    " * `node_names_to_keep`: Option<Vec<&str>> - List of node names to keep during filtering.",
                    " * `node_names_to_filter`: Option<Vec<&str>> - List of node names to remove during filtering.",
                    " * `node_type_names_to_keep`: Option<Vec<Option<Vec<&str>>>> - List of node type names to keep during filtering. The node types must match entirely the given node types vector provided.",
                    " * `node_type_names_to_filter`: Option<Vec<Option<Vec<&str>>>> - List of node type names to remove during filtering. The node types must match entirely the given node types vector provided.",
                    " * `node_type_name_to_keep`: Option<Vec<Option<String>>> - List of node type name to keep during filtering. Any of node types must match with one of the node types given.",
                    " * `node_type_name_to_filter`: Option<Vec<Option<String>>> - List of node type name to remove during filtering. Any of node types must match with one of the node types given.",
                    " * `edge_node_names_to_keep`: Option<Vec<(&str, &str)>> - List of tuple of node names to keep during filtering.",
                    " * `edge_node_names_to_filter`: Option<Vec<(&str, &str)>> - List of tuple of node names to remove during filtering.",
                    " * `edge_type_names_to_keep`: Option<Vec<Option<String>>> - List of edge type names to keep during filtering.",
                    " * `edge_type_names_to_filter`: Option<Vec<Option<String>>> - List of edge type names to remove during filtering.",
                    " * `min_edge_weight`: Option<WeightT> - Minimum edge weight. Values lower than this are removed.",
                    " * `max_edge_weight`: Option<WeightT> - Maximum edge weight. Values higher than this are removed.",
                    " * `filter_singleton_nodes`: bool - Whether to filter out singletons.",
                    " * `filter_singleton_nodes_with_selfloop`: bool - Whether to filter out singleton nodes with selfloops.",
                    " * `filter_selfloops`: bool - Whether to filter out selfloops.",
                    " * `filter_parallel_edges`: bool - Whether to filter out parallel edges.",
                    " * `verbose`: bool - Whether to show loading bar while building the graphs.",
                    "",
                    " ## Implementation details",
                    "",
                    " ### How the collapse of multigraphs is handled",
                    " We keep only the first edge when a multigraph is collapsed while removing",
                    " the edge types, in the order provided when first reading from the CSV file.",
                    "",
                    " ### Generation of new singleton nodes when removing edges",
                    " Some of the remove operations allowed in this method might lead to the",
                    " generation of new singleton nodes that will not be handled within this",
                    " function call even if you provide the flag singletons to true, but you",
                    " will need to call the method again if you want to get reed of also those",
                    " newly created singleton nodes.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "filter_from_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_names_to_keep",
                        "Option<Vec<&str>>"
                    ],
                    [
                        "node_names_to_filter",
                        "Option<Vec<&str>>"
                    ],
                    [
                        "node_type_names_to_keep",
                        "Option<Vec<Option<Vec<&str>>>>"
                    ],
                    [
                        "node_type_names_to_filter",
                        "Option<Vec<Option<Vec<&str>>>>"
                    ],
                    [
                        "node_type_name_to_keep",
                        "Option<Vec<Option<String>>>"
                    ],
                    [
                        "node_type_name_to_filter",
                        "Option<Vec<Option<String>>>"
                    ],
                    [
                        "edge_node_names_to_keep",
                        "Option<Vec<(&str, &str)>>"
                    ],
                    [
                        "edge_node_names_to_filter",
                        "Option<Vec<(&str, &str)>>"
                    ],
                    [
                        "edge_type_names_to_keep",
                        "Option<Vec<Option<String>>>"
                    ],
                    [
                        "edge_type_names_to_filter",
                        "Option<Vec<Option<String>>>"
                    ],
                    [
                        "min_edge_weight",
                        "Option<WeightT>"
                    ],
                    [
                        "max_edge_weight",
                        "Option<WeightT>"
                    ],
                    [
                        "filter_singleton_nodes",
                        "bool"
                    ],
                    [
                        "filter_singleton_nodes_with_selfloop",
                        "bool"
                    ],
                    [
                        "filter_selfloops",
                        "bool"
                    ],
                    [
                        "filter_parallel_edges",
                        "bool"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "Ok(self.filter_from_ids(\n            node_names_to_keep.map_or(Ok::<_, String>(None), |nntk| {\n                Ok(Some(self.get_node_ids_from_node_names(nntk)?))\n            })?,\n            node_names_to_filter.map_or(Ok::<_, String>(None), |nntf| {\n                Ok(Some(self.get_node_ids_from_node_names(nntf)?))\n            })?,\n            node_type_names_to_keep.map_or(Ok::<_, String>(None), |ntntk| {\n                Ok(Some(\n                    self.get_multiple_node_type_ids_from_node_type_names(ntntk)?,\n                ))\n            })?,\n            node_type_names_to_filter.map_or(Ok::<_, String>(None), |ntntf| {\n                Ok(Some(\n                    self.get_multiple_node_type_ids_from_node_type_names(ntntf)?,\n                ))\n            })?,\n            node_type_name_to_keep.map_or(Ok::<_, String>(None), |ntntf| {\n                Ok(Some(self.get_node_type_ids_from_node_type_names(ntntf)?))\n            })?,\n            node_type_name_to_filter.map_or(Ok::<_, String>(None), |ntntf| {\n                Ok(Some(self.get_node_type_ids_from_node_type_names(ntntf)?))\n            })?,\n            None,\n            None,\n            edge_node_names_to_keep.map_or(Ok::<_, String>(None), |enntk| {\n                Ok(Some(self.get_edge_node_ids_from_edge_node_names(enntk)?))\n            })?,\n            edge_node_names_to_filter.map_or(Ok::<_, String>(None), |enntf| {\n                Ok(Some(self.get_edge_node_ids_from_edge_node_names(enntf)?))\n            })?,\n            edge_type_names_to_keep.map_or(Ok::<_, String>(None), |etnk| {\n                Ok(Some(self.get_edge_type_ids_from_edge_type_names(etnk)?))\n            })?,\n            edge_type_names_to_filter.map_or(Ok::<_, String>(None), |etnf| {\n                Ok(Some(self.get_edge_type_ids_from_edge_type_names(etnf)?))\n            })?,\n            min_edge_weight,\n            max_edge_weight,\n            filter_singleton_nodes,\n            filter_singleton_nodes_with_selfloop,\n            filter_selfloops,\n            filter_parallel_edges,\n            verbose,\n        ))"
            },
            {
                "file": "filters.rs",
                "struct": "Graph",
                "doc": [
                    " Returns new graph without unknown node types and relative nodes.",
                    "",
                    " Note that this method will remove ALL nodes labeled with unknown node",
                    " type!",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show a loading bar while building the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "drop_unknown_node_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Graph",
                "body": "self.filter_from_ids(\n            None,\n            None,\n            None,\n            None,\n            None,\n            Some(vec![None]),\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            false,\n            false,\n            false,\n            false,\n            verbose,\n        )"
            },
            {
                "file": "filters.rs",
                "struct": "Graph",
                "doc": [
                    " Returns new graph without unknown edge types and relative edges.",
                    "",
                    " Note that this method will remove ALL edges labeled with unknown edge",
                    " type!",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show a loading bar while building the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "drop_unknown_edge_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Graph",
                "body": "self.filter_from_ids(\n            None,\n            None,\n            None,\n            None,\n            None,\n            Some(vec![None]),\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            None,\n            false,\n            false,\n            false,\n            false,\n            verbose,\n        )"
            },
            {
                "file": "filters.rs",
                "struct": "Graph",
                "doc": [
                    " Returns new graph without singleton nodes.",
                    "",
                    " A node is singleton when does not have neither incoming or outgoing edges.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show a loading bar while building the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "drop_singleton_nodes",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Graph",
                "body": "self.filter_from_ids(\n            None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n            true, false, false, false, verbose,\n        )"
            },
            {
                "file": "filters.rs",
                "struct": "Graph",
                "doc": [
                    " Returns new graph without singleton nodes with selfloops.",
                    "",
                    " A node is singleton with selfloop when does not have neither incoming or outgoing edges.",
                    "",
                    " # Arguments",
                    " * `verbose`: bool - Whether to show a loading bar while building the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "drop_singleton_nodes_with_selfloops",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Graph",
                "body": "self.filter_from_ids(\n            None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n            false, true, false, false, verbose,\n        )"
            },
            {
                "file": "filters.rs",
                "struct": "Graph",
                "doc": [
                    " Returns new graph without selfloops.",
                    "",
                    " # Arguments",
                    " * `verbose`: bool - Whether to show a loading bar while building the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "drop_selfloops",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Graph",
                "body": "self.filter_from_ids(\n            None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n            false, false, true, false, verbose,\n        )"
            },
            {
                "file": "filters.rs",
                "struct": "Graph",
                "doc": [
                    " Returns new graph without parallel edges.",
                    "",
                    " # Arguments",
                    " * `verbose`: bool - Whether to show a loading bar while building the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "drop_parallel_edges",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Graph",
                "body": "self.filter_from_ids(\n            None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n            false, false, false, true, verbose,\n        )"
            }
        ]
    },
    "types.rs": {
        "imports": [
            "use std::fmt::Display;",
            "use std::hash::Hash;",
            "use std::ops::AddAssign;",
            "use std::sync::{RwLock, RwLockReadGuard, RwLockWriteGuard};",
            "use std::cell::UnsafeCell;"
        ],
        "functions": [
            {
                "file": "types.rs",
                "doc": [
                    " Type used to index the Nodes.",
                    " Type used to index the Node Types.",
                    " Type used to index the Edges.",
                    " Type used to index the Edge Types.",
                    " Type used for the weights of the edges.",
                    " Type used for the parameters of the walk such as the return weight (p),",
                    " and the explore weight (q).",
                    " Type used to save contexts used for Skipgram and CBOW.",
                    " Type used to save a group of words indices.",
                    " Type used to save the frequencies of words",
                    " Triple of edge data",
                    " Quadruple of edge data",
                    " Quadrule of string edge data",
                    " Return type for shortest paths algorithms",
                    " Trait used for the Vocabulary class.",
                    " It represent an unsigned integer that can be converted to and from usize.",
                    " This allows us to save memory using indicies of smaller size than u64",
                    " and it has no effects on performance because it's optimized away during",
                    " compilaton.",
                    " create the type from a usize"
                ],
                "attrs": [],
                "modifiers": "",
                "name": "from_usize",
                "args": [
                    [
                        "v",
                        "usize"
                    ]
                ],
                "return_type": "Self;\n    /// create an usize from the type\n    fn to_usize(v: Self) -> usize;\n}\n\n/// Automatically implement the methods needed to convert from and to usize\n/// for the given numerical type.\nmacro_rules! impl_to_from_usize",
                "body": "($($ty:ty)*) => {\n        $(\n            impl ToFromUsize for $ty {\n                #[inline(always)]\n                fn from_usize(v: usize) -> $ty {\n                    v as $ty\n                }\n                #[inline(always)]\n                fn to_usize(v: $ty) -> usize {\n                    v as usize\n                }\n            }\n        )*\n    }"
            },
            {
                "file": "types.rs",
                "doc": [],
                "attrs": [
                    "#[derive(Debug)]"
                ],
                "modifiers": "pub",
                "name": "new",
                "args": [
                    [
                        "val",
                        "T"
                    ]
                ],
                "return_type": "ClonableRwLock<T>",
                "body": "ClonableRwLock {\n            value: RwLock::new(val),\n        }"
            },
            {
                "file": "types.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "read",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "RwLockReadGuard<T>",
                "body": "self.value.read().unwrap()"
            },
            {
                "file": "types.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "write",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "RwLockWriteGuard<T>",
                "body": "self.value.write().unwrap()"
            },
            {
                "file": "types.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "clone",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "ClonableRwLock<T>",
                "body": "ClonableRwLock {\n            value: RwLock::new(self.read().clone()),\n        }"
            }
        ]
    },
    "validators.rs": {
        "imports": [
            "use super::*;"
        ],
        "functions": [
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Validates provided node ID.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - node ID to validate.",
                    "",
                    " # Example",
                    " In order to validate a given node ID, you can use the following:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(graph.validate_node_id(0).is_ok());",
                    " assert!(graph.validate_node_id(100000000).is_err());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the given node ID does not exists in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "validate_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "if node_id >= self.get_nodes_number() {\n            return Err(format!(\n                \"The given node id ({}) is higher than the number of nodes within the graph ({}).\",\n                node_id,\n                self.get_nodes_number()\n            ));\n        }\n        Ok(node_id)"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Validates provided edge ID.",
                    "",
                    " # Arguments",
                    " * `edge_id`: EdgeT - Edge ID to validate.",
                    "",
                    " # Example",
                    " In order to validate a given edge ID, you can use the following:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(graph.validate_edge_id(0).is_ok());",
                    " assert!(graph.validate_edge_id(10000000000).is_err());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the given edge ID does not exists in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "validate_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "Result<EdgeT, String>",
                "body": "if edge_id >= self.get_directed_edges_number() {\n            return Err(format!(\n                \"The given edge id ({}) is higher than the number of edges within the graph ({}).\",\n                edge_id,\n                self.get_directed_edges_number()\n            ));\n        }\n        Ok(edge_id)"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Validates provided node type ID.",
                    "",
                    " # Arguments",
                    " * `node_type_id`: Option<NodeTypeT> - Node type ID to validate.",
                    "",
                    " # Example",
                    " In order to validate a given node type ID, you can use the following:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(graph.validate_node_type_id(Some(0)).is_ok());",
                    " assert!(graph.validate_node_type_id(Some(1000)).is_err());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the given node type ID does not exists in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "validate_node_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_id",
                        "Option<NodeTypeT>"
                    ]
                ],
                "return_type": "Result<Option<NodeTypeT>, String>",
                "body": "self.get_node_types_number().and_then(|node_types_number| {\n            node_type_id.map_or_else( || if !self.has_unknown_node_types()?{\n                Err(\n                    \"An unknown node type was given but the graph does not contain unknown node types.\".to_string()\n                )\n            } else {\n                Ok(None)\n            }, |nti| {\n                if node_types_number <= nti {\n                    Err(format!(\n                        \"Given node type ID {} is bigger than number of node types in the graph {}.\",\n                        nti,\n                        node_types_number\n                    ))\n                } else {\n                    Ok(Some(nti))\n                }\n            })\n        })"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Validates provided node type IDs.",
                    "",
                    " # Arguments",
                    " * `node_type_ids`: Vec<Option<NodeTypeT>> - Vector of node type IDs to validate.",
                    "",
                    " # Raises",
                    " * If there are no node types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "validate_node_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_ids",
                        "Vec<Option<NodeTypeT>>"
                    ]
                ],
                "return_type": "Result<Vec<Option<NodeTypeT>>, String>",
                "body": "self.must_have_node_types()?;\n        node_type_ids\n            .into_iter()\n            .map(|node_type| self.validate_node_type_id(node_type))\n            .collect()"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Validates provided edge type ID.",
                    "",
                    " # Arguments",
                    " * `edge_type_id`: Option<EdgeTypeT> - edge type ID to validate.",
                    "",
                    " # Example",
                    " In order to validate a given edge type ID, you can use the following:",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(graph.validate_edge_type_id(Some(0)).is_ok());",
                    " assert!(graph.validate_edge_type_id(Some(1000)).is_err());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the given edge type ID does not exists in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "validate_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_id",
                        "Option<EdgeTypeT>"
                    ]
                ],
                "return_type": "Result<Option<EdgeTypeT>, String>",
                "body": "self.get_edge_types_number().and_then(|edge_types_number| {\n            edge_type_id.map_or_else( || if !self.has_unknown_edge_types()?{\n                Err(\n                    \"An unknown edge type was given but the graph does not contain unknown edge types.\".to_string()\n                )\n            } else {\n                Ok(None)\n            }, |eti| {\n                if edge_types_number <= eti {\n                    Err(format!(\n                        \"Given edge type ID {} is bigger than number of edge types in the graph {}.\",\n                        eti,\n                        edge_types_number\n                    ))\n                } else {\n                    Ok(Some(eti))\n                }\n            })\n        })"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Validates provided edge type IDs.",
                    "",
                    " # Arguments",
                    " * `edge_type_ids`: Vec<Option<EdgeTypeT>> - Vector of edge type IDs to validate.",
                    "",
                    " # Raises",
                    " * If there are no edge types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "validate_edge_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_ids",
                        "Vec<Option<EdgeTypeT>>"
                    ]
                ],
                "return_type": "Result<Vec<Option<EdgeTypeT>>, String>",
                "body": "self.must_have_edge_types()?;\n        edge_type_ids\n            .into_iter()\n            .map(|edge_type| self.validate_edge_type_id(edge_type))\n            .collect()"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Raises an error if the graph does not have node types.",
                    "",
                    " # Example",
                    " In order to validate a graph instance, you can use:",
                    "",
                    " ```rust",
                    " # let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " # let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " assert!(graph_with_node_types.must_have_node_types().is_ok());",
                    " assert!(graph_without_node_types.must_have_node_types().is_err());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph does not contain node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "must_have_node_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<&NodeTypeVocabulary, String>",
                "body": "if !self.has_node_types() {\n            return Err(\"The current graph instance does not have node types.\".to_string());\n        }\n        Ok(self.node_types.as_ref().unwrap())"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Raises an error if the graph does not have edge types.",
                    "",
                    " # Example",
                    " In order to validate a graph instance, you can use:",
                    "",
                    " ```rust",
                    " # let graph_with_edge_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " # let graph_without_edge_types = graph::test_utilities::load_ppi(false, false, true, true, false, false);",
                    " assert!(graph_with_edge_types.must_have_edge_types().is_ok());",
                    " assert!(graph_without_edge_types.must_have_edge_types().is_err());",
                    " ```",
                    "",
                    " # Raises",
                    " * If there are no edge types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "must_have_edge_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<&EdgeTypeVocabulary, String>",
                "body": "if !self.has_edge_types() {\n            return Err(\"The current graph instance does not have edge types.\".to_string());\n        }\n        Ok(self.edge_types.as_ref().unwrap())"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Raises an error if the graph does not have edge types.",
                    "",
                    " # Example",
                    " In order to validate a graph instance, you can use:",
                    "",
                    " ```rust",
                    " # let undirecte_graph = graph::test_utilities::load_ppi(false, false, false, false, false, false);",
                    " # let directed_graph = graph::test_utilities::load_ppi(false, false, true, true, false, false);",
                    " assert!(undirecte_graph.must_be_undirected().is_ok());",
                    " assert!(directed_graph.must_be_undirected().is_err());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph is directed."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "must_be_undirected",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "if self.is_directed() {\n            return Err(\"The current graph instance is not undirected.\".to_string());\n        }\n        Ok(())"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Raises an error if the graph does not have edge types.",
                    "",
                    " # Example",
                    " In order to validate a graph instance, you can use:",
                    "",
                    " ```rust",
                    " # let multigraph = graph::test_utilities::load_ppi(false, true, false, false, false, false);",
                    " # let homogeneous = graph::test_utilities::load_ppi(false, false, false, false, false, false);",
                    " assert!(multigraph.must_be_multigraph().is_ok());",
                    " assert!(homogeneous.must_be_multigraph().is_err());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph is not a multigraph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "must_be_multigraph",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "if !self.is_multigraph() {\n            return Err(\n                \"The current graph instance must be a multigraph to run this method.\".to_string(),\n            );\n        }\n        Ok(())"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Raises an error if the graph does not have edge types.",
                    "",
                    " # Example",
                    " In order to validate a graph instance, you can use:",
                    "",
                    " ```rust",
                    " # let multigraph = graph::test_utilities::load_ppi(false, true, false, false, false, false);",
                    " # let homogeneous = graph::test_utilities::load_ppi(false, false, false, false, false, false);",
                    " assert!(multigraph.must_not_be_multigraph().is_err());",
                    " assert!(homogeneous.must_not_be_multigraph().is_ok());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph is a multigraph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "must_not_be_multigraph",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "if self.is_multigraph() {\n            return Err(\n                \"The current graph instance must not be a multigraph to run this method.\"\n                    .to_string(),\n            );\n        }\n        Ok(())"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Raises an error if the graph does not have weights.",
                    "",
                    " # Example",
                    " In order to validate a graph instance, you can use:",
                    "",
                    " ```rust",
                    " # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);",
                    " # let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);",
                    " assert!(graph_with_weights.must_have_edge_weights().is_ok());",
                    " assert!(graph_without_weights.must_have_edge_weights().is_err());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph does not have edge weights."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "must_have_edge_weights",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<&Vec<WeightT>, String>",
                "body": "if !self.has_edge_weights() {\n            return Err(\"The current graph instance does not have weights.\".to_string());\n        }\n        Ok(self.weights.as_ref().unwrap())"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Raises an error if the graph has negative edge weights.",
                    "",
                    " # Example",
                    " In order to validate a graph instance, you can use:",
                    "",
                    " ```rust",
                    " # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);",
                    " # let graph_with_negative_weights = graph_with_weights.get_unweighted_laplacian_transformed_graph(Some(false));",
                    " assert!(graph_with_weights.must_have_positive_edge_weights().is_ok());",
                    " assert!(graph_with_negative_weights.must_have_positive_edge_weights().is_err());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph does not contain edge weights.",
                    " * If the graph contains negative edge weights."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "must_have_positive_edge_weights",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<&Vec<WeightT>, String>",
                "body": "if self.has_negative_edge_weights()? {\n            return Err(\"The current graph instance contains negative edge weights.\".to_string());\n        }\n        Ok(self.weights.as_ref().unwrap())"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Raises an error if the graph does not have any edge.",
                    "",
                    " # Example",
                    " In order to validate a graph instance, you can use:",
                    "",
                    " ```rust",
                    " # let graph_with_edges = graph::test_utilities::load_ppi(false, false, true, true, false, false);",
                    " # let graph_without_edges = graph::test_utilities::load_empty_graph(false);",
                    " assert!(graph_with_edges.must_have_edges().is_ok());",
                    " assert!(graph_without_edges.must_have_edges().is_err());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph does not have edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "must_have_edges",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "if !self.has_edges() {\n            return Err(\"The current graph instance does not have any edge.\".to_string());\n        }\n        Ok(())"
            },
            {
                "file": "validators.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Validators",
                    " The naming convention we follow is:",
                    " * `/validate_(.+)/`",
                    " * `/must_have_(.+)/`",
                    " * `/must_be_(.+)/`",
                    " * `/must_not_be_(.+)/`"
                ],
                "doc": [
                    " Raises an error if the graph does not have any node.",
                    "",
                    " # Example",
                    " In order to validate a graph instance, you can use:",
                    "",
                    " ```rust",
                    " # let graph_with_nodes = graph::test_utilities::load_ppi(false, false, true, true, false, false);",
                    " # let graph_without_nodes = graph::test_utilities::load_empty_graph(false);",
                    " assert!(graph_with_nodes.must_have_nodes().is_ok());",
                    " assert!(graph_without_nodes.must_have_nodes().is_err());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph does not have nodes."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "must_have_nodes",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "if !self.has_nodes() {\n            return Err(\"The current graph instance does not have any node.\".to_string());\n        }\n        Ok(())"
            }
        ]
    },
    "remove.rs": {
        "imports": [
            "use super::*;",
            "use counter::Counter;",
            "use indicatif::ProgressIterator;",
            "use roaring::RoaringBitmap;",
            "use std::collections::HashSet;"
        ],
        "functions": [
            {
                "file": "remove.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # remove."
                ],
                "doc": [
                    " remove all the components that are not connected to interesting",
                    " nodes and edges.",
                    "",
                    " # Arguments",
                    " * `node_names`: Option<Vec<String>> - The name of the nodes of which components to keep.",
                    " * `node_types`: Option<Vec<Option<String>>> - The types of the nodes of which components to keep.",
                    " * `edge_types`: Option<Vec<Option<String>>> - The types of the edges of which components to keep.",
                    " * `minimum_component_size`: Option<NodeT> - Optional, Minimum size of the components to keep.",
                    " * `top_k_components`: Option<NodeT> - Optional, number of components to keep sorted by number of nodes.",
                    " * `verbose`: bool - Whether to show the loading bar."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_components",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_names",
                        "Option<Vec<String>>"
                    ],
                    [
                        "node_types",
                        "Option<Vec<Option<String>>>"
                    ],
                    [
                        "edge_types",
                        "Option<Vec<Option<String>>>"
                    ],
                    [
                        "minimum_component_size",
                        "Option<NodeT>"
                    ],
                    [
                        "top_k_components",
                        "Option<NodeT>"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let mut keep_components = RoaringBitmap::new();\n        let components_vector = self.get_node_connected_component_ids(verbose);\n\n        // Extend the components so the include the given node Ids and node types.\n        if let Some(node_ids) = self.get_filter_bitmap(node_names, node_types)? {\n            keep_components.extend(\n                node_ids\n                    .iter()\n                    .map(|node_id| components_vector[node_id as usize]),\n            );\n        }\n\n        // Extend the components to keep those that include the given edge types.\n        if let Some(ets) = edge_types {\n            let edge_types_ids: HashSet<Option<EdgeTypeT>> = self\n                .get_edge_type_ids_from_edge_type_names(ets)?\n                .into_iter()\n                .collect();\n\n            let pb = get_loading_bar(\n                verbose,\n                &format!(\n                    \"Computing which components are to keep for the graph {}\",\n                    &self.name\n                ),\n                self.get_directed_edges_number() as usize,\n            );\n\n            self.iter_edge_node_ids_and_edge_type_id(self.directed)\n                .progress_with(pb)\n                .for_each(|(_, src, dst, edge_type)| {\n                    if edge_types_ids.contains(&edge_type) {\n                        keep_components.insert(components_vector[src as usize]);\n                        keep_components.insert(components_vector[dst as usize]);\n                    }\n                });\n        }\n\n        // Create the components counter\n        let component_counts: Vec<(NodeT, NodeT)> =\n            Counter::init(components_vector.clone()).most_common_ordered();\n\n        // Insert the top k biggest components components\n        if let Some(tkc) = top_k_components {\n            for (i, (component_id, _)) in component_counts.iter().enumerate() {\n                if i < tkc as usize {\n                    keep_components.insert(*component_id);\n                }\n            }\n        }\n\n        // Remove components smaller than the given amount\n        if let Some(mcs) = &minimum_component_size {\n            component_counts\n                .iter()\n                .for_each(|(component, component_size)| {\n                    if *component_size < *mcs {\n                        keep_components.remove(*component);\n                    }\n                });\n        }\n\n        let pb = get_loading_bar(\n            verbose,\n            &format!(\n                \"Building edge list with only required components {}\",\n                &self.name\n            ),\n            self.get_directed_edges_number() as usize,\n        );\n        let pb_nodes = get_loading_bar(\n            verbose,\n            &format!(\n                \"Building node list with only required components {}\",\n                &self.name\n            ),\n            self.get_nodes_number() as usize,\n        );\n\n        let min_component_size = keep_components\n            .iter()\n            .map(|component_id| component_counts[component_id as usize].1)\n            .min();\n\n        Graph::from_string_sorted(\n            self.iter_edge_node_names_and_edge_type_name_and_edge_weight(true)\n                .progress_with(pb)\n                .filter_map(\n                    |(_, src, src_name, _, dst_name, _, edge_type_name, weight)| {\n                        // we just check src because dst is trivially in the same component as src\n                        match keep_components.contains(components_vector[src as usize]) {\n                            true => Some(Ok((src_name, dst_name, edge_type_name, weight))),\n                            false => None,\n                        }\n                    },\n                ),\n            Some(self.iter_node_names_and_node_type_names().progress_with(pb_nodes).filter_map(\n                |(node_id, node_name, _, node_type_names)| {\n                    match keep_components.contains(components_vector[node_id as usize]) {\n                        true => Some(Ok((node_name, node_type_names))),\n                        false => None,\n                    }\n                },\n            )),\n            self.directed,\n            true,\n            self.get_name(),\n            false,\n            true,\n            true,\n            true,\n            self.get_directed_edges_number() as usize, // Approximation of expected edges number.\n            self.get_nodes_number(),                   // Approximation of expected nodes number.\n            false,\n            false,\n            false,\n            false,\n            self.has_node_types(),\n            self.has_edge_types(),\n            self.has_edge_weights(),\n            min_component_size.as_ref().map_or(true, |mcs| *mcs <= 1),\n            self.has_singleton_nodes_with_selfloops()\n                && min_component_size.as_ref().map_or(true, |mcs| *mcs <= 1),\n            self.has_trap_nodes(),\n        )"
            }
        ]
    },
    "centrality.rs": {
        "imports": [
            "use super::*;",
            "use atomic_float::AtomicF64;",
            "use indicatif::ParallelProgressIterator;",
            "use itertools::Itertools;",
            "use num_traits::pow::Pow;",
            "use rayon::iter::IndexedParallelIterator;",
            "use rayon::iter::IntoParallelRefIterator;",
            "use rayon::iter::{IntoParallelRefMutIterator, ParallelIterator};",
            "use std::collections::VecDeque;",
            "use std::sync::atomic::Ordering;"
        ],
        "functions": [
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Returns iterator over degree centrality for all nodes."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_degree_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = f64> + '_, String>",
                "body": "self.must_have_edges()?;\n\n        let max_degree = unsafe { self.get_unchecked_max_node_degree() as f64 };\n        Ok(\n            self.iter_unweighted_node_degrees()\n                .map(move |degree| degree as f64 / max_degree),\n        )"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Returns vector of degree centrality for all nodes."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_degree_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<f64>, String>",
                "body": "Ok(self.iter_degree_centrality()?.collect())"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Return closeness centrality of the requested node.",
                    "",
                    " If the given node ID does not exist in the current graph the method",
                    " will panic.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - The node ID whose closeness centrality is to be computed.",
                    " * `verbose`: Option<bool> - Whether to show an indicative progress bar.",
                    "",
                    " # References",
                    " The metric is described in [Centrality in Social Networks by Freeman](https://www.bebr.ufl.edu/sites/default/files/Centrality%20in%20Social%20Networks.pdf)",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_unweighted_closeness_centrality_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "f64",
                "body": "1.0 / self\n            .get_unchecked_breath_first_search(node_id, None, None, Some(false), Some(false))\n            .3 as f64"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Return closeness centrality of the requested node.",
                    "",
                    " If the given node ID does not exist in the current graph the method",
                    " will panic.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - The node ID whose closeness centrality is to be computed.",
                    "",
                    " # References",
                    " The metric is described in [Centrality in Social Networks by Freeman](https://www.bebr.ufl.edu/sites/default/files/Centrality%20in%20Social%20Networks.pdf)",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_weighted_closeness_centrality_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "f64",
                "body": "1.0 / self\n            .get_unchecked_dijkstra_from_node_ids(node_id, None, None, Some(false))\n            .2"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Return parallel iterator over closeness centrality for all nodes.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show an indicative progress bar.",
                    "",
                    " # References",
                    " The metric is described in [Centrality in Social Networks by Freeman](https://www.bebr.ufl.edu/sites/default/files/Centrality%20in%20Social%20Networks.pdf)"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_unweighted_closeness_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "impl ParallelIterator<Item = f64> + '_",
                "body": "let verbose = verbose.unwrap_or(true);\n        let pb = get_loading_bar(\n            verbose,\n            \"Computing closeness centrality\",\n            self.get_nodes_number() as usize,\n        );\n        self.par_iter_node_ids()\n            .progress_with(pb)\n            .map(move |node_id| {\n                self.get_unchecked_unweighted_closeness_centrality_from_node_id(node_id)\n            })"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Return parallel iterator over closeness centrality for all nodes.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show an indicative progress bar.",
                    "",
                    " # References",
                    " The metric is described in [Centrality in Social Networks by Freeman](https://www.bebr.ufl.edu/sites/default/files/Centrality%20in%20Social%20Networks.pdf)"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_weighted_closeness_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<impl ParallelIterator<Item = f64> + '_, String>",
                "body": "self.must_have_edge_weights()?;\n        let verbose = verbose.unwrap_or(true);\n        let pb = get_loading_bar(\n            verbose,\n            \"Computing closeness centrality\",\n            self.get_nodes_number() as usize,\n        );\n        Ok(self.par_iter_node_ids()\n            .progress_with(pb)\n            .map(move |node_id| {\n                self.get_unchecked_weighted_closeness_centrality_from_node_id(node_id)\n            }))"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Return closeness centrality for all nodes.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show an indicative progress bar.",
                    "",
                    " # References",
                    " The metric is described in [Centrality in Social Networks by Freeman](https://www.bebr.ufl.edu/sites/default/files/Centrality%20in%20Social%20Networks.pdf)"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unweighted_closeness_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Vec<f64>",
                "body": "self.par_iter_unweighted_closeness_centrality(verbose)\n            .collect()"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Return closeness centrality for all nodes.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show an indicative progress bar.",
                    "",
                    " # References",
                    " The metric is described in [Centrality in Social Networks by Freeman](https://www.bebr.ufl.edu/sites/default/files/Centrality%20in%20Social%20Networks.pdf)"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_weighted_closeness_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Vec<f64>, String>",
                "body": "self.par_iter_weighted_closeness_centrality(verbose).map(|x| x.collect())"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Return harmonic centrality of the requested node.",
                    "",
                    " If the given node ID does not exist in the current graph the method",
                    " will panic.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - The node ID whose harmonic centrality is to be computed.",
                    "",
                    " # References",
                    " The metric is described in [Axioms for centrality by Boldi and Vigna](https://www.tandfonline.com/doi/abs/10.1080/15427951.2013.865686).",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_unweighted_harmonic_centrality_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "f64",
                "body": "self.get_unchecked_breath_first_search(node_id, None, None, Some(false), Some(false))\n            .4"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Return harmonic centrality of the requested node.",
                    "",
                    " If the given node ID does not exist in the current graph the method",
                    " will panic.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - The node ID whose harmonic centrality is to be computed.",
                    "",
                    " # References",
                    " The metric is described in [Axioms for centrality by Boldi and Vigna](https://www.tandfonline.com/doi/abs/10.1080/15427951.2013.865686).",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unchecked_weighted_harmonic_centrality_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "f64",
                "body": "self.get_unchecked_dijkstra_from_node_ids(node_id, None, None, Some(false))\n            .3"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Return parallel iterator over harmonic centrality for all nodes.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show an indicative progress bar.",
                    "",
                    " # References",
                    " The metric is described in [Axioms for centrality by Boldi and Vigna](https://www.tandfonline.com/doi/abs/10.1080/15427951.2013.865686)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_unweighted_harmonic_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "impl ParallelIterator<Item = f64> + '_",
                "body": "let verbose = verbose.unwrap_or(true);\n        let pb = get_loading_bar(\n            verbose,\n            \"Computing harmonic centrality\",\n            self.get_nodes_number() as usize,\n        );\n        self.par_iter_node_ids()\n            .progress_with(pb)\n            .map(move |node_id| {\n                self.get_unchecked_unweighted_harmonic_centrality_from_node_id(node_id)\n            })"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Return parallel iterator over harmonic centrality for all nodes.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show an indicative progress bar.",
                    "",
                    " # References",
                    " The metric is described in [Axioms for centrality by Boldi and Vigna](https://www.tandfonline.com/doi/abs/10.1080/15427951.2013.865686)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_weighted_harmonic_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<impl ParallelIterator<Item = f64> + '_, String>",
                "body": "self.must_have_edge_weights()?;\n        let verbose = verbose.unwrap_or(true);\n        let pb = get_loading_bar(\n            verbose,\n            \"Computing harmonic centrality\",\n            self.get_nodes_number() as usize,\n        );\n        Ok(self.par_iter_node_ids()\n            .progress_with(pb)\n            .map(move |node_id| {\n                self.get_unchecked_weighted_harmonic_centrality_from_node_id(node_id)\n            }))"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Return harmonic centrality for all nodes.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show an indicative progress bar.",
                    "",
                    " # References",
                    " The metric is described in [Axioms for centrality by Boldi and Vigna](https://www.tandfonline.com/doi/abs/10.1080/15427951.2013.865686)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unweighted_harmonic_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Vec<f64>",
                "body": "self.par_iter_unweighted_harmonic_centrality(verbose)\n            .collect()"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Return harmonic centrality for all nodes.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show an indicative progress bar.",
                    "",
                    " # References",
                    " The metric is described in [Axioms for centrality by Boldi and Vigna](https://www.tandfonline.com/doi/abs/10.1080/15427951.2013.865686)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_weighted_harmonic_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Vec<f64>, String>",
                "body": "self.par_iter_weighted_harmonic_centrality(verbose)\n            .map(|x| x.collect())"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Returns vector of stress centrality for all nodes.",
                    "",
                    " # Arguments",
                    " * `normalize`: Option<bool> - Whether to normalize the values. By default, it is false.",
                    " * `verbose`: Option<bool> - Whether to show a loading bar. By default, it is true.",
                    "",
                    " # References",
                    " The algorithm is implemented as described in [Parallel Algorithms for Evaluating Centrality Indices in Real-World Networks](https://ieeexplore.ieee.org/abstract/document/1690659), by Bader et al.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_stress_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "normalize",
                        "Option<bool>"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Vec<f64>",
                "body": "if !self.has_nodes() {\n            return Vec::new();\n        }\n        let normalize = normalize.unwrap_or(false);\n        let verbose = verbose.unwrap_or(true);\n        let nodes_number = self.get_nodes_number() as usize;\n        let centralities: Vec<AtomicF64> =\n            self.iter_node_ids().map(|_| AtomicF64::new(0.0)).collect();\n        let factor = if self.is_directed() { 1.0 } else { 2.0 };\n        let pb = get_loading_bar(verbose, \"Computing stress centralities\", nodes_number);\n        self.par_iter_node_ids()\n            .progress_with(pb)\n            .for_each(|src_node_id| {\n                let mut stack: Vec<NodeT> = Vec::new();\n                let mut node_lists: Vec<Vec<NodeT>> =\n                    self.iter_node_ids().map(|_| Vec::new()).collect();\n                let mut shortest_path_counts = vec![0; nodes_number];\n                shortest_path_counts[src_node_id as usize] = 1;\n                let mut distance_from_root = vec![u64::MAX; nodes_number];\n                distance_from_root[src_node_id as usize] = 0;\n                let mut nodes_to_visit: VecDeque<NodeT> = VecDeque::new();\n                nodes_to_visit.push_back(src_node_id);\n                while !nodes_to_visit.is_empty() {\n                    let current_node_id = nodes_to_visit.pop_front().unwrap();\n                    stack.push(current_node_id);\n                    // Bader says to do the following step in parallel\n                    // Currently it is not parallel because the EliasFano implementation\n                    // does not supporting a range of values in parallel, and currently\n                    // it is not possible to Box a parallel iterator from Rayon.\n                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(current_node_id)\n                        .for_each(|neighbour_node_id| {\n                            if distance_from_root[neighbour_node_id as usize] == u64::MAX {\n                                nodes_to_visit.push_back(neighbour_node_id);\n                                distance_from_root[neighbour_node_id as usize] =\n                                    distance_from_root[current_node_id as usize] + 1;\n                            }\n                            if distance_from_root[neighbour_node_id as usize]\n                                == distance_from_root[current_node_id as usize] + 1\n                            {\n                                shortest_path_counts[neighbour_node_id as usize] +=\n                                    shortest_path_counts[current_node_id as usize];\n                                node_lists[neighbour_node_id as usize].push(current_node_id);\n                            }\n                        });\n                }\n                let mut dependencies = vec![0.0; nodes_number];\n                stack.into_iter().rev().for_each(|current_node_id| {\n                    node_lists[current_node_id as usize]\n                        .iter()\n                        .for_each(|&neighbour_node_id| {\n                            dependencies[neighbour_node_id as usize] +=\n                                shortest_path_counts[neighbour_node_id as usize] as f64\n                                    * (1.0 + dependencies[current_node_id as usize]);\n                        });\n                    if current_node_id != src_node_id {\n                        centralities[current_node_id as usize].fetch_add(\n                            dependencies[current_node_id as usize] / factor,\n                            Ordering::SeqCst,\n                        );\n                    }\n                });\n            });\n        let mut centralities =\n            unsafe { std::mem::transmute::<Vec<AtomicF64>, Vec<f64>>(centralities) };\n        if normalize {\n            let (min_centrality, max_centrality) =\n                centralities.iter().cloned().minmax().into_option().unwrap();\n            let delta = max_centrality - min_centrality;\n            centralities.par_iter_mut().for_each(|value| {\n                *value = (*value - min_centrality) / delta;\n            });\n        }\n        centralities"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Returns vector of betweenness centrality for all nodes.",
                    "",
                    " # Arguments",
                    " * `normalize`: Option<bool> - Whether to normalize the values. By default, it is false.",
                    " * `verbose`: Option<bool> - Whether to show a loading bar. By default, it is true.",
                    "",
                    " # References",
                    " The algorithm is implemented as described in [Parallel Algorithms for Evaluating Centrality Indices in Real-World Networks](https://ieeexplore.ieee.org/abstract/document/1690659), by Bader et al.",
                    "",
                    " TODO: I think this method can be bettered for the undirected case."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_betweenness_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "normalize",
                        "Option<bool>"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Vec<f64>",
                "body": "if !self.has_nodes() {\n            return Vec::new();\n        }\n        let normalize = normalize.unwrap_or(false);\n        let verbose = verbose.unwrap_or(true);\n        let nodes_number = self.get_nodes_number() as usize;\n        let centralities: Vec<AtomicF64> =\n            self.iter_node_ids().map(|_| AtomicF64::new(0.0)).collect();\n        let factor = if self.is_directed() { 1.0 } else { 2.0 };\n        let pb = get_loading_bar(verbose, \"Computing betweennes centralities\", nodes_number);\n        self.par_iter_node_ids()\n            .progress_with(pb)\n            .for_each(|src_node_id| {\n                let mut stack: Vec<NodeT> = Vec::new();\n                let mut node_lists: Vec<Vec<NodeT>> =\n                    self.iter_node_ids().map(|_| Vec::new()).collect();\n                let mut shortest_path_counts = vec![0; nodes_number];\n                shortest_path_counts[src_node_id as usize] = 1;\n                let mut distance_from_root = vec![u64::MAX; nodes_number];\n                distance_from_root[src_node_id as usize] = 0;\n                let mut nodes_to_visit: VecDeque<NodeT> = VecDeque::new();\n                nodes_to_visit.push_back(src_node_id);\n                while !nodes_to_visit.is_empty() {\n                    let current_node_id = nodes_to_visit.pop_front().unwrap();\n                    stack.push(current_node_id);\n                    // Bader says to do the following step in parallel\n                    // Currently it is not parallel because the EliasFano implementation\n                    // does not supporting a range of values in parallel, and currently\n                    // it is not possible to Box a parallel iterator from Rayon.\n                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(current_node_id)\n                        .for_each(|neighbour_node_id| {\n                            if distance_from_root[neighbour_node_id as usize] == u64::MAX {\n                                nodes_to_visit.push_back(neighbour_node_id);\n                                distance_from_root[neighbour_node_id as usize] =\n                                    distance_from_root[current_node_id as usize] + 1;\n                            }\n                            if distance_from_root[neighbour_node_id as usize]\n                                == distance_from_root[current_node_id as usize] + 1\n                            {\n                                shortest_path_counts[neighbour_node_id as usize] +=\n                                    shortest_path_counts[current_node_id as usize];\n                                node_lists[neighbour_node_id as usize].push(current_node_id);\n                            }\n                        });\n                }\n                let mut dependencies = vec![0.0; nodes_number];\n                stack.into_iter().rev().for_each(|current_node_id| {\n                    node_lists[current_node_id as usize]\n                        .iter()\n                        .for_each(|&neighbour_node_id| {\n                            dependencies[neighbour_node_id as usize] +=\n                                shortest_path_counts[neighbour_node_id as usize] as f64\n                                    / shortest_path_counts[current_node_id as usize] as f64\n                                    * (1.0 + dependencies[current_node_id as usize]);\n                        });\n                    if current_node_id != src_node_id {\n                        centralities[current_node_id as usize].fetch_add(\n                            dependencies[current_node_id as usize] / factor,\n                            Ordering::SeqCst,\n                        );\n                    }\n                });\n            });\n        let mut centralities =\n            unsafe { std::mem::transmute::<Vec<AtomicF64>, Vec<f64>>(centralities) };\n        if normalize {\n            let (min_centrality, max_centrality) =\n                centralities.iter().cloned().minmax().into_option().unwrap();\n            let delta = max_centrality - min_centrality;\n            centralities.par_iter_mut().for_each(|value| {\n                *value = (*value - min_centrality) / delta;\n            });\n        }\n        centralities"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Returns vector with unweighted eigenvector centrality.",
                    "",
                    " # Arguments",
                    " * `maximum_iterations_number`: Option<usize> - The maximum number of iterations to consider.",
                    " * `tollerance`: Option<f64> - The maximum error tollerance for convergence."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unweighted_eigenvector_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "maximum_iterations_number",
                        "Option<usize>"
                    ],
                    [
                        "tollerance",
                        "Option<f64>"
                    ]
                ],
                "return_type": "Result<Vec<f64>, String>",
                "body": "let maximum_iterations_number = maximum_iterations_number.unwrap_or(1000);\n        let tollerance = tollerance.unwrap_or(1e-6) * self.get_nodes_number() as f64;\n        if tollerance < f64::EPSILON {\n            return Err(\"The tollerance must be a non-zero positive value bigger than epislon (1e-16).\".to_string());\n        }\n        let mut centralities: Vec<AtomicF64> = self\n            .iter_node_ids()\n            .map(|_| AtomicF64::new(1.0 / self.get_nodes_number() as f64))\n            .collect();\n        let mut last_centralities =\n            vec![1.0 / self.get_nodes_number() as f64; self.get_nodes_number() as usize];\n        for _ in 0..maximum_iterations_number {\n            self.par_iter_node_ids().for_each(|src| {\n                self.iter_unchecked_neighbour_node_ids_from_source_node_id(src)\n                    .for_each(|dst| {\n                        centralities[dst as usize]\n                            .fetch_add(last_centralities[src as usize], Ordering::Relaxed);\n                    });\n            });\n            let norm: f64 = centralities\n                .par_iter()\n                .map(|centrality| centrality.load(Ordering::Relaxed).pow(2))\n                .sum::<f64>()\n                .sqrt();\n            centralities.par_iter_mut().for_each(|centrality| {\n                centrality\n                    .fetch_update(Ordering::Relaxed, Ordering::Relaxed, |x| Some(x / norm))\n                    .unwrap();\n            });\n            let updated_centrality = centralities\n                .iter()\n                .map(|centrality| centrality.load(Ordering::Relaxed))\n                .collect::<Vec<f64>>();\n            let differences = updated_centrality\n                .par_iter()\n                .zip(last_centralities.par_iter())\n                .map(|(centrality, old_centrality)| (centrality - old_centrality).abs())\n                .sum::<f64>();\n            if differences < tollerance {\n                return Ok(updated_centrality);\n            }\n            last_centralities = updated_centrality;\n        }\n        Err(format!(\n            \"Unable to reach convergence in {} iterations.\",\n            maximum_iterations_number\n        ))"
            },
            {
                "file": "centrality.rs",
                "struct": "Graph",
                "doc": [
                    " Returns vector with unweighted eigenvector centrality.",
                    "",
                    " # Arguments",
                    " * `maximum_iterations_number`: Option<usize> - The maximum number of iterations to consider.",
                    " * `tollerance`: Option<f64> - The maximum error tollerance for convergence."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_weighted_eigenvector_centrality",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "maximum_iterations_number",
                        "Option<usize>"
                    ],
                    [
                        "tollerance",
                        "Option<f64>"
                    ]
                ],
                "return_type": "Result<Vec<f64>, String>",
                "body": "self.must_have_edge_weights()?;\n        let maximum_iterations_number = maximum_iterations_number.unwrap_or(1000);\n        let tollerance = tollerance.unwrap_or(1e-6) * self.get_nodes_number() as f64;\n        if tollerance < f64::EPSILON {\n            return Err(\"The tollerance must be a non-zero positive value bigger than epislon (1e-16).\".to_string());\n        }\n        let mut centralities: Vec<AtomicF64> = self\n            .iter_node_ids()\n            .map(|_| AtomicF64::new(1.0 / self.get_nodes_number() as f64))\n            .collect();\n        let mut last_centralities =\n            vec![1.0 / self.get_nodes_number() as f64; self.get_nodes_number() as usize];\n        for _ in 0..maximum_iterations_number {\n            self.par_iter_node_ids().for_each(|src| {\n                self.iter_unchecked_neighbour_node_ids_from_source_node_id(src)\n                    .for_each(|dst| {\n                        centralities[dst as usize].fetch_add(\n                            last_centralities[src as usize]\n                                * self.get_unchecked_edge_weight_from_node_ids(src, dst) as f64,\n                            Ordering::Relaxed,\n                        );\n                    });\n            });\n            let norm: f64 = centralities\n                .par_iter()\n                .map(|centrality| centrality.load(Ordering::Relaxed).pow(2))\n                .sum::<f64>()\n                .sqrt();\n            centralities.par_iter_mut().for_each(|centrality| {\n                centrality\n                    .fetch_update(Ordering::Relaxed, Ordering::Relaxed, |x| Some(x / norm))\n                    .unwrap();\n            });\n            let updated_centrality = centralities\n                .iter()\n                .map(|centrality| centrality.load(Ordering::Relaxed))\n                .collect::<Vec<f64>>();\n            let differences = updated_centrality\n                .par_iter()\n                .zip(last_centralities.par_iter())\n                .map(|(centrality, old_centrality)| (centrality - old_centrality).abs())\n                .sum::<f64>();\n            if differences < tollerance {\n                return Ok(updated_centrality);\n            }\n            last_centralities = updated_centrality;\n        }\n        Err(format!(\n            \"Unable to reach convergence in {} iterations.\",\n            maximum_iterations_number\n        ))"
            }
        ]
    },
    "edge_file_writer.rs": {
        "imports": [
            "use super::*;"
        ],
        "functions": [
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Return new EdgeFileWriter object.",
                    "",
                    " # Arguments",
                    "",
                    " * path: String - Path where to store/load the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "new",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "path",
                        "S"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "EdgeFileWriter {\n            writer: CSVFileWriter::new(path),\n            sources_column: \"subject\".to_string(),\n            sources_column_number: 0,\n            destinations_column: \"object\".to_string(),\n            destinations_column_number: 1,\n            edge_types_column: \"label\".to_string(),\n            edge_types_column_number: 2,\n            weights_column: \"weight\".to_string(),\n            weights_column_number: 3,\n            numeric_node_ids: false,\n            directed: None,\n        }"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column of the source nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * sources_column: Option<String> - The source nodes column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_sources_column",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "sources_column",
                        "Option<S>"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "if let Some(column) = sources_column {\n            self.sources_column = column.into();\n        }\n        self"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column of the source nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * sources_column_number: Option<String> - The source nodes column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_sources_column_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "sources_column_number",
                        "Option<usize>"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "if let Some(column_number) = sources_column_number {\n            self.sources_column_number = column_number;\n        }\n        self"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * destinations_column: Option<String> - The node types column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_destinations_column",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "destinations_column",
                        "Option<S>"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "if let Some(column) = destinations_column {\n            self.destinations_column = column.into();\n        }\n        self"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * destinations_column_number: Option<String> - The node types column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_destinations_column_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "destinations_column_number",
                        "Option<usize>"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "if let Some(column_number) = destinations_column_number {\n            self.destinations_column_number = column_number;\n        }\n        self"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * edge_types_column: Option<String> - The node types column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_edge_types_column",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "edge_type_column",
                        "Option<S>"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "if let Some(column) = edge_type_column {\n            self.edge_types_column = column.into();\n        }\n        self"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * edge_types_column_number: Option<usize> - The node types column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_edge_types_column_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "edge_type_column_number",
                        "Option<usize>"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "if let Some(column_number) = edge_type_column_number {\n            self.edge_types_column_number = column_number;\n        }\n        self"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * weights_column: Option<String> - The node types column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_weights_column",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "weights_column",
                        "Option<S>"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "if let Some(column) = weights_column {\n            self.weights_column = column.into();\n        }\n        self"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the column of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * weights_column_number: Option<usize> - The node types column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_weights_column_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "weights_column_number",
                        "Option<usize>"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "if let Some(column_number) = weights_column_number {\n            self.weights_column_number = column_number;\n        }\n        self"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the verbose.",
                    "",
                    " # Arguments",
                    "",
                    " * `verbose`: Option<bool> - Whether to show the loading bar or not.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_verbose",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "if let Some(v) = verbose {\n            self.writer.verbose = v;\n        }\n        self"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the numeric_id.",
                    "",
                    " # Arguments",
                    "",
                    " * numeric_id: Option<bool> - Whether to convert numeric Ids to Node Id.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_numeric_node_ids",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "numeric_node_ids",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "if let Some(nni) = numeric_node_ids {\n            self.numeric_node_ids = nni;\n        }\n        self"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the separator.",
                    "",
                    " # Arguments",
                    "",
                    " * separator: Option<String> - The separator to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_separator",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "separator",
                        "Option<S>"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "if let Some(v) = separator {\n            self.writer.separator = v.into();\n        }\n        self"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the header.",
                    "",
                    " # Arguments",
                    "",
                    " * header: Option<bool> - Whether to write out an header or not.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_header",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "header",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "if let Some(v) = header {\n            self.writer.header = v;\n        }\n        self"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Set the directed.",
                    "",
                    " # Arguments",
                    "",
                    " * `directed`: Option<bool> - Whether to write out the graph as directed or not.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_directed",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "directed",
                        "Option<bool>"
                    ]
                ],
                "return_type": "EdgeFileWriter",
                "body": "self.directed = directed;\n        self"
            },
            {
                "file": "edge_file_writer.rs",
                "struct": "EdgeFileWriter",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes"
                ],
                "doc": [
                    " Write edge file.",
                    "",
                    " # Arguments",
                    "",
                    " * `graph`: &Graph - the graph to write out."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "dump",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "graph",
                        "&Graph"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "let directed: bool = self.directed.unwrap_or_else(|| graph.is_directed());\n        // build the header\n        let mut header = vec![\n            (self.sources_column.clone(), self.sources_column_number),\n            (\n                self.destinations_column.clone(),\n                self.destinations_column_number,\n            ),\n        ];\n\n        if graph.has_edge_types() {\n            header.push((\n                self.edge_types_column.clone(),\n                self.edge_types_column_number,\n            ));\n        }\n\n        if graph.has_edge_weights() {\n            header.push((self.weights_column.clone(), self.weights_column_number));\n        }\n\n        let number_of_columns = 1 + header.iter().map(|(_, i)| i).max().unwrap();\n\n        self.writer.write_lines(\n            graph.get_directed_edges_number() as usize,\n            compose_lines(number_of_columns, header),\n            graph\n                .iter_edge_node_ids_and_edge_type_id_and_edge_weight(directed)\n                .map(|(_, src, dst, edge_type, weight)| {\n                    let mut line = vec![\n                        (\n                            match self.numeric_node_ids {\n                                true => src.to_string(),\n                                false => graph.nodes.unchecked_translate(src),\n                            },\n                            self.sources_column_number,\n                        ),\n                        (\n                            match self.numeric_node_ids {\n                                true => dst.to_string(),\n                                false => graph.nodes.unchecked_translate(dst),\n                            },\n                            self.destinations_column_number,\n                        ),\n                    ];\n\n                    if let Some(ets) = &graph.edge_types {\n                        line.push((\n                            edge_type.map_or(\"\".to_string(), |et| ets.unchecked_translate(et)),\n                            self.edge_types_column_number,\n                        ));\n                    }\n\n                    if let Some(w) = weight {\n                        line.push((w.to_string(), self.weights_column_number));\n                    }\n\n                    compose_lines(number_of_columns, line)\n                }),\n        )"
            }
        ]
    },
    "setters.rs": {
        "imports": [
            "use super::*;",
            "use itertools::Itertools;",
            "use rayon::iter::IntoParallelRefMutIterator;",
            "use rayon::iter::ParallelIterator;",
            "use std::sync::atomic::{AtomicU32, AtomicU64, Ordering};"
        ],
        "functions": [
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Set the name of the graph.",
                    "",
                    " # Arguments",
                    "",
                    " * `name`: String - Name of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_name",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "name",
                        "String"
                    ]
                ],
                "body": "self.invalidate_report();\n        self.name = name;"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Invalidate the cache for the textual report.",
                    " This should be called as the first line of every methods that either get",
                    " a mutable reference to self or get ownership of self."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "invalidate_report",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "body": "*self.cached_report.write() = None;"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Replace all edge types (if present) and set all the edge to edge_type.",
                    "",
                    " This happens INPLACE, that is edits the current graph instance.",
                    "",
                    " # Arguments",
                    " * `edge_type`: S - The edge type to assing to all the edges.",
                    "",
                    " # Raises",
                    " * If the graph does not have edges.",
                    " * If the graph is a multigraph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_inplace_all_edge_types",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "edge_type",
                        "S"
                    ]
                ],
                "return_type": "Result<&Graph, String>",
                "body": "// If the graph does not have edges, it does not make sense to\n        // try and set the edge types.\n        self.must_have_edges()?;\n        // Similarly, setting the edge types of a multigraph would make it\n        // collapse to a homogeneous graph, and this operation is not supported\n        // with the function set all edge types.\n        self.must_not_be_multigraph().map_err(|_| {\n            concat!(\n                \"The method set_all_edge_types does not support multigraphs because \",\n                \"setting the edge types of all edges to a single one in this type\",\n                \"of graphs will cause a multigraph to collapse to an homogeneous \",\n                \"graph, leading to multiple undefined behaviours, such as loosing \",\n                \"the parallel edges that would collapse to one: which one should we keep?\\n\",\n                \"You can drop the parallell edges by calling the not INPLACE version \",\n                \"of this method.\\n\",\n                \"Consider that when using the remove method, you will still collapse \",\n                \"the multigraph to an homogeneous graph, and it will keep the FIRST edge \",\n                \"of any group of multigraph edges between two given nodes.\"\n            )\n            .to_string()\n        })?;\n        self.invalidate_report();\n        let mut vocabulary = Vocabulary::default();\n        vocabulary.insert(edge_type.into())?;\n        vocabulary.build_reverse_mapping()?;\n        let edge_types = EdgeTypeVocabulary::from_structs(\n            vec![Some(0); self.get_directed_edges_number() as usize],\n            vocabulary,\n        );\n        self.edge_types = Some(edge_types);\n        Ok(self)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Replace all edge types (if present) and set all the edge to edge_type.",
                    "",
                    " This DOES NOT happen inplace, but created a new instance of the graph.",
                    "",
                    " # Arguments",
                    " * `edge_type`: S - The edge type to assing to all the edges.",
                    " * `verbose`: Option<bool> - Whether to show a loading bar in the case of a multigraph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_all_edge_types",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type",
                        "S"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let mut graph = self.drop_parallel_edges(verbose);\n        graph.set_inplace_all_edge_types(edge_type)?;\n        Ok(graph)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Replace all node types (if present) and set all the node to node_type.",
                    "",
                    " # Arguments",
                    " * `node_type`: S - The node type to assing to all the nodes."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_inplace_all_node_types",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "node_type",
                        "S"
                    ]
                ],
                "return_type": "Result<&Graph, String>",
                "body": "self.must_have_nodes()?;\n        self.invalidate_report();\n        let mut vocabulary = Vocabulary::default();\n        vocabulary.insert(node_type.into())?;\n        vocabulary.build_reverse_mapping()?;\n        let node_types = NodeTypeVocabulary::from_structs(\n            vec![Some(vec![0]); self.get_nodes_number() as usize],\n            Some(vocabulary),\n        );\n        self.node_types = node_types;\n        Ok(self)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Replace all node types (if present) and set all the node to node_type.",
                    "",
                    " This DOES NOT happen inplace, but created a new instance of the graph.",
                    "",
                    " # Arguments",
                    " * `node_type`: S - The node type to assing to all the nodes."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_all_node_types",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type",
                        "S"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let mut graph = self.clone();\n        graph.set_inplace_all_node_types(node_type)?;\n        Ok(graph)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove given node type ID from all nodes.",
                    "",
                    " If any given node remains with no node type, that node is labeled",
                    " with node type None. Note that the modification happens inplace.",
                    "",
                    " # Arguments",
                    " * `node_type_id_to_remove`: NodeTypeT - The node type ID to remove.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types.",
                    " * If the given node type ID does not exists in the graph.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_inplace_node_type_ids",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "node_type_ids_to_remove",
                        "Vec<NodeTypeT>"
                    ]
                ],
                "return_type": "Result<&Graph, String>",
                "body": "self.must_have_node_types()?;\n\n        // if the user passed no values, we won't modify the graph so we can \n        // return ealry\n        if node_type_ids_to_remove.is_empty() {\n            return Ok(self);\n        }\n        // check that the values are in the range of node type ids\n        self.validate_node_type_id(node_type_ids_to_remove.iter().max().cloned())?;\n\n        // if there are duplicated nodes it's probably an error \n        if node_type_ids_to_remove.len() != node_type_ids_to_remove.iter().unique().count() {\n            return Err(\"In the given vector of node type ids to remove there are duplicated values.\".to_string());\n        }\n\n        // we modify the graph so we must invalidate the report\n        self.invalidate_report();\n\n\n        if let Some(node_types) = self.node_types.as_mut() {\n            // compute the new node ids once the given ones are removed\n            // we need this to keep a dense mapping.\n            let new_node_type_ids = \n            unsafe{\n                node_types.unchecked_remove_values(node_type_ids_to_remove.clone())\n            };\n\n            // Counter of how many new nodes have unknown type (aka how many nodes we removed)\n            let new_unknown_nodes = AtomicU32::new(0);\n\n            // Iter over each node and update its node\n            node_types\n                .ids\n                .par_iter_mut()\n                .for_each(|node_type_ids| {\n                    if let Some(ntis) = node_type_ids.as_mut() {\n                        // We remove the given node type if one was given.\n                        for node_type_id_to_remove in &node_type_ids_to_remove {\n                            if let Some(pos) = ntis.iter().position(|x| *x == *node_type_id_to_remove) {\n                                ntis.remove(pos);\n                            }\n                        }\n\n                        // node type anymore, we replace its empty vector with a None.\n                        if ntis.is_empty() {\n                            *node_type_ids = None;\n                            new_unknown_nodes.fetch_add(1, Ordering::SeqCst);\n                            return;\n                        }\n\n                        // densify the mapping\n                        ntis.iter_mut()\n                            .for_each(|node_type_id| {\n                                if let Some(idx) = new_node_type_ids[*node_type_id as usize] {\n                                    *node_type_id = idx as NodeTypeT;\n                                } else {\n                                    unreachable!(\"This should not happen\");\n                                }\n                            }); // If after we have removed the node type the node does not have any\n                    }\n                });\n\n            node_types.unknown_count += new_unknown_nodes.load(Ordering::SeqCst);\n        }\n        Ok(self)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove singleton node types from all nodes.",
                    "",
                    " If any given node remains with no node type, that node is labeled",
                    " with node type None. Note that the modification happens inplace.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_inplace_singleton_node_types",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "return_type": "Result<&mut Graph, String>",
                "body": "self.remove_inplace_node_type_ids(self.get_singleton_node_type_ids()?)?;\n        Ok(self)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove given edge type ID from all edges.",
                    "",
                    " # Arguments",
                    " * `edge_type_id`: EdgeTypeT - The edge type ID to remove.",
                    "",
                    " # Raises",
                    " * If the graph is a multigraph.",
                    " * If the graph does not have edge types.",
                    " * If the given edge type ID does not exists in the graph.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_inplace_edge_type_ids",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "edge_type_ids_to_remove",
                        "Vec<EdgeTypeT>"
                    ]
                ],
                "return_type": "Result<&mut Graph, String>",
                "body": "self.must_have_edge_types()?;\n\n        self.must_not_be_multigraph().map_err(|_| {\n            concat!(\n                \"The method remove_edge_type_id does not support multigraphs because \",\n                \"setting the edge types of all edges to a single one in this type\",\n                \"of graphs will cause a multigraph to collapse to an homogeneous \",\n                \"graph, leading to multiple undefined behaviours, such as loosing \",\n                \"the parallel edges that would collapse to one: which one should we keep?\\n\",\n                \"You can drop the parallell edges by calling the not INPLACE version \",\n                \"of this method.\\n\",\n                \"Consider that when using the remove method, you will still collapse \",\n                \"the multigraph to an homogeneous graph, and it will keep the FIRST edge \",\n                \"of any group of multigraph edges between two given nodes.\"\n            )\n            .to_string()\n        })?;\n\n        // if the user passed no values, we won't modify the graph so we can \n        // return ealry\n        if edge_type_ids_to_remove.is_empty() {\n            return Ok(self);\n        }\n\n        // check that the values are in the range of edge type ids\n        self.validate_edge_type_id(edge_type_ids_to_remove.iter().max().cloned())?;\n\n        // if there are duplicated edges it's probably an error \n        if edge_type_ids_to_remove.len() != edge_type_ids_to_remove.iter().unique().count() {\n            return Err(\"In the given vector of edge type ids to remove there are duplicated values.\".to_string());\n        }\n\n        self.invalidate_report();\n\n        if let Some(edge_types) = self.edge_types.as_mut() {\n            // compute the new edge ids once the given ones are removed\n            // we need this to keep a dense mapping.\n            let new_edge_type_ids = \n            unsafe{\n                edge_types.unchecked_remove_values(edge_type_ids_to_remove)\n            };\n\n            let new_unknown_edges = AtomicU64::new(0);\n            edge_types\n                .ids\n                .par_iter_mut()\n                .for_each(|maybe_edge_type_id| {\n                    *maybe_edge_type_id = maybe_edge_type_id.and_then(|x| new_edge_type_ids[x as usize].map(|x| x as EdgeTypeT));\n                });\n            edge_types.unknown_count += new_unknown_edges.load(Ordering::SeqCst);\n        }\n        Ok(self)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove singleton edge types from all edges.",
                    "",
                    " If any given edge remains with no edge type, that edge is labeled",
                    " with edge type None. Note that the modification happens inplace.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_inplace_singleton_edge_types",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "return_type": "Result<&mut Graph, String>",
                "body": "self.remove_inplace_edge_type_ids(self.get_singleton_edge_type_ids()?)?;\n        Ok(self)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove given node type name from all nodes.",
                    "",
                    " If any given node remains with no node type, that node is labeled",
                    " with node type None. Note that the modification happens inplace.",
                    "",
                    " # Arguments",
                    " * `node_type_name`: &str - The node type ID to remove.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types.",
                    " * If the given node type name does not exists in the graph.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_inplace_node_type_name",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "node_type_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<&Graph, String>",
                "body": "let node_type_id = self.get_node_type_id_from_node_type_name(node_type_name)?;\n        self.remove_inplace_node_type_ids(vec![node_type_id])?;\n        Ok(self)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove given node type ID from all nodes.",
                    "",
                    " If any given node remains with no node type, that node is labeled",
                    " with node type None. Note that the modification DOES NOT happen inplace.",
                    "",
                    " # Arguments",
                    " * `node_type_id`: NodeTypeT - The node type ID to remove.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types.",
                    " * If the given node type ID does not exists in the graph.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_node_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_id",
                        "NodeTypeT"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let mut graph = self.clone();\n        graph.remove_inplace_node_type_ids(vec![node_type_id])?;\n        Ok(graph)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove singleton node types from all nodes.",
                    "",
                    " If any given node remains with no node type, that node is labeled",
                    " with node type None. Note that the modification DOES NOT happen inplace.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_singleton_node_types",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let mut graph = self.clone();\n        graph.remove_inplace_singleton_node_types()?;\n        Ok(graph)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove given node type name from all nodes.",
                    "",
                    " If any given node remains with no node type, that node is labeled",
                    " with node type None. Note that the modification DOES NOT happen inplace.",
                    "",
                    " # Arguments",
                    " * `node_type_name`: &str - The node type ID to remove.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types.",
                    " * If the given node type name does not exists in the graph.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_node_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let mut graph = self.clone();\n        graph.remove_inplace_node_type_name(node_type_name)?;\n        Ok(graph)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove given edge type name from all edges.",
                    "",
                    " If any given edge remains with no edge type, that edge is labeled",
                    " with edge type None. Note that the modification happens inplace.",
                    "",
                    " # Arguments",
                    " * `edge_type_name`: &str - The edge type ID to remove.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types.",
                    " * If the given edge type name does not exists in the graph.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_inplace_edge_type_name",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "edge_type_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<&mut Graph, String>",
                "body": "let edge_type_id = self\n            .get_edge_type_id_from_edge_type_name(Some(edge_type_name))?\n            .unwrap();\n        self.remove_inplace_edge_type_ids(vec![edge_type_id])"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove given edge type ID from all edges.",
                    "",
                    " If any given edge remains with no edge type, that edge is labeled",
                    " with edge type None. Note that the modification DOES NOT happen inplace.",
                    "",
                    " # Arguments",
                    " * `edge_type_id`: EdgeTypeT - The edge type ID to remove.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types.",
                    " * If the given edge type ID does not exists in the graph.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_id",
                        "EdgeTypeT"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let mut graph = self.clone();\n        graph.remove_inplace_edge_type_ids(vec![edge_type_id])?;\n        Ok(graph)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove singleton edge types from all edges.",
                    "",
                    " If any given edge remains with no edge type, that edge is labeled",
                    " with edge type None. Note that the modification DOES NOT happen inplace.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_singleton_edge_types",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let mut graph = self.clone();\n        graph.remove_inplace_singleton_edge_types()?;\n        Ok(graph)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove given edge type name from all edges.",
                    "",
                    " If any given edge remains with no edge type, that edge is labeled",
                    " with edge type None. Note that the modification DOES NOT happen inplace.",
                    "",
                    " # Arguments",
                    " * `edge_type_name`: &str - The edge type ID to remove.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types.",
                    " * If the given edge type name does not exists in the graph.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_edge_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let mut graph = self.clone();\n        graph.remove_inplace_edge_type_name(edge_type_name)?;\n        Ok(graph)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove node types from the graph.",
                    "",
                    " Note that the modification happens inplace.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_inplace_node_types",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "return_type": "Result<&Graph, String>",
                "body": "self.must_have_node_types()?;\n        self.invalidate_report();\n        self.node_types = None;\n        Ok(self)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove node types from the graph.",
                    "",
                    " Note that the modification does not happen inplace.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_node_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let mut graph = self.clone();\n        graph.remove_inplace_node_types()?;\n        Ok(graph)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove edge types from the graph.",
                    "",
                    " Note that the modification happens inplace.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types.",
                    " * If the graph is a multigraph.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_inplace_edge_types",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "return_type": "Result<&Graph, String>",
                "body": "self.must_have_edge_types()?;\n        self.must_not_be_multigraph()?;\n        self.invalidate_report();\n        self.edge_types = None;\n        Ok(self)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove edge types from the graph.",
                    "",
                    " Note that the modification does not happen inplace.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show a loading bar in the case of a multigraph.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_edge_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let mut graph = self.drop_parallel_edges(verbose);\n        graph.remove_inplace_edge_types()?;\n        Ok(graph)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove edge weights from the graph.",
                    "",
                    " Note that the modification happens inplace.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge weights.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_inplace_edge_weights",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "return_type": "Result<&Graph, String>",
                "body": "self.must_have_edge_weights()?;\n        self.invalidate_report();\n        self.weights = None;\n        Ok(self)"
            },
            {
                "file": "setters.rs",
                "struct": "Graph",
                "doc": [
                    " Remove edge weights from the graph.",
                    "",
                    " Note that the modification does not happen inplace.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge weights.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "remove_edge_weights",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let mut graph = self.clone();\n        graph.remove_inplace_edge_weights()?;\n        Ok(graph)"
            }
        ]
    },
    "walks.rs": {
        "imports": [
            "use super::*;",
            "use log::info;",
            "use rayon::prelude::*;",
            "use vec_rand::sample_f32 as sample;",
            "use vec_rand::sample_uniform;",
            "use vec_rand::splitmix64;",
            "use super::update_explore_weight_transition;",
            "use super::update_return_explore_weight_transition;",
            "use super::update_return_weight_transition;",
            "use super::WeightT;"
        ],
        "functions": [
            {
                "file": "walks.rs",
                "doc": [],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "",
                "name": "update_return_weight_transition",
                "args": [
                    [
                        "transition",
                        "&mut Vec<WeightT>"
                    ],
                    [
                        "destinations",
                        "&[NodeT]"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ],
                    [
                        "return_weight",
                        "ParamsT"
                    ],
                    [
                        "has_selfloop",
                        "bool"
                    ]
                ],
                "body": "if let Ok(mut i) = destinations.binary_search(&src) {\n        let mut j = i;\n        while j > 0 && destinations[j] == src {\n            transition[j] *= return_weight;\n            j -= 1;\n        }\n        i += 1;\n        while i < destinations.len() && destinations[i] == src {\n            transition[i] *= return_weight;\n            i += 1;\n        }\n    }\n\n    if src != dst && has_selfloop {\n        if let Ok(mut i) = destinations.binary_search(&dst) {\n            let mut j = i;\n            while j > 0 && destinations[j] == dst {\n                transition[j] *= return_weight;\n                j -= 1;\n            }\n            i += 1;\n            while i < destinations.len() && destinations[i] == dst {\n                transition[i] *= return_weight;\n                i += 1;\n            }\n        }\n    }"
            },
            {
                "file": "walks.rs",
                "doc": [],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "",
                "name": "rust_update_explore_weight_transition",
                "args": [
                    [
                        "transition",
                        "&mut Vec<WeightT>"
                    ],
                    [
                        "destinations",
                        "&[NodeT]"
                    ],
                    [
                        "previous_destinations",
                        "&[NodeT]"
                    ],
                    [
                        "explore_weight",
                        "ParamsT"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "body": "let mut i = 0;\n    let mut j = 0;\n    let mut v1: NodeT;\n    let mut v2: NodeT;\n    //############################################################\n    //# Handling of the Q parameter: the explore coefficient     #\n    //############################################################\n    // This coefficient increases the probability of switching\n    // to nodes not locally seen.\n    while i < destinations.len() && j < previous_destinations.len() {\n        v1 = destinations[i];\n        v2 = previous_destinations[j];\n        if v1 <= v2 {\n            let is_less = v1 < v2;\n            if is_less && v1 != src && v1 != dst {\n                transition[i] *= explore_weight;\n            }\n            j += !is_less as usize;\n            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    for k in i..destinations.len() {\n        v1 = destinations[k];\n        transition[k] *= 1.0 + (v1 != src && v1 != dst) as u64 as WeightT * (explore_weight - 1.0);\n    }"
            },
            {
                "file": "walks.rs",
                "doc": [],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "",
                "name": "rust_update_return_explore_weight_transition",
                "args": [
                    [
                        "transition",
                        "&mut Vec<WeightT>"
                    ],
                    [
                        "destinations",
                        "&[NodeT]"
                    ],
                    [
                        "previous_destinations",
                        "&[NodeT]"
                    ],
                    [
                        "return_weight",
                        "ParamsT"
                    ],
                    [
                        "explore_weight",
                        "ParamsT"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "body": "let mut i = 0;\n    let mut j = 0;\n    let mut v1: NodeT;\n    let mut v2: NodeT;\n    //############################################################\n    //# Handling of the Q parameter: the explore coefficient     #\n    //############################################################\n    // This coefficient increases the probability of switching\n    // to nodes not locally seen.\n    while i < destinations.len() && j < previous_destinations.len() {\n        v1 = destinations[i];\n        v2 = previous_destinations[j];\n        if v1 == src || v1 == dst {\n            transition[i] *= return_weight;\n            i += 1;\n            continue;\n        }\n        if v1 <= v2 {\n            let is_less = v1 < v2;\n            if is_less {\n                transition[i] *= explore_weight;\n            }\n            j += !is_less as usize;\n            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    for k in i..destinations.len() {\n        v1 = destinations[k];\n        if v1 == src || v1 == dst {\n            transition[k] *= return_weight;\n        } else {\n            transition[k] *= explore_weight;\n        }\n    }"
            },
            {
                "file": "walks.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "update_explore_weight_transition",
                "args": [
                    [
                        "transition",
                        "&mut Vec<WeightT>"
                    ],
                    [
                        "destinations",
                        "&[NodeT]"
                    ],
                    [
                        "previous_destinations",
                        "&[NodeT]"
                    ],
                    [
                        "explore_weight",
                        "ParamsT"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "body": "#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n    {\n        if is_x86_feature_detected!(\"avx2\") {\n            unsafe {\n                c_update_explore_weight_transition(\n                    transition.as_ptr(),\n                    destinations.as_ptr(),\n                    destinations.len() as u32,\n                    previous_destinations.as_ptr(),\n                    previous_destinations.len() as u32,\n                    explore_weight,\n                    src,\n                    dst,\n                );\n            }\n            return;\n        }\n    }\n    rust_update_explore_weight_transition(\n        transition,\n        destinations,\n        previous_destinations,\n        explore_weight,\n        src,\n        dst,\n    );"
            },
            {
                "file": "walks.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "update_return_explore_weight_transition",
                "args": [
                    [
                        "transition",
                        "&mut Vec<WeightT>"
                    ],
                    [
                        "destinations",
                        "&[NodeT]"
                    ],
                    [
                        "previous_destinations",
                        "&[NodeT]"
                    ],
                    [
                        "return_weight",
                        "ParamsT"
                    ],
                    [
                        "explore_weight",
                        "ParamsT"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "body": "#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n    {\n        if is_x86_feature_detected!(\"avx2\") {\n            unsafe {\n                c_update_return_explore_weight_transition(\n                    transition.as_ptr(),\n                    destinations.as_ptr(),\n                    destinations.len() as u32,\n                    previous_destinations.as_ptr(),\n                    previous_destinations.len() as u32,\n                    explore_weight,\n                    return_weight,\n                    src,\n                    dst,\n                );\n            }\n            return;\n        }\n    }\n    rust_update_return_explore_weight_transition(\n        transition,\n        destinations,\n        previous_destinations,\n        return_weight,\n        explore_weight,\n        src,\n        dst,\n    );"
            },
            {
                "file": "walks.rs",
                "doc": [],
                "attrs": [
                    "#[cfg(test)]",
                    "#[test]"
                ],
                "modifiers": "",
                "name": "test_update_explore_weight_transition",
                "args": [],
                "body": "let destinations = vec![\n            1, 2, 3, 4, 4, 4, 5, 6, 100, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101,\n            101, 101, 101, 101,\n        ];\n        let previous_destinations = vec![2, 4, 4, 4];\n        let mut transitions = (0..destinations.len())\n            .map(|_| 1.0)\n            .collect::<Vec<WeightT>>();\n        update_explore_weight_transition(\n            &mut transitions,\n            &destinations,\n            &previous_destinations,\n            2.0,\n            6,\n            100,\n        );\n        assert_eq!(\n            transitions,\n            vec![\n                2.0, 1.0, 2.0, 1.0, 1.0, 1.0, 2.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n                2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0\n            ]\n        )"
            },
            {
                "file": "walks.rs",
                "doc": [],
                "attrs": [
                    "#[test]"
                ],
                "modifiers": "",
                "name": "test_update_return_explore_weight_transition",
                "args": [],
                "body": "let destinations = vec![1, 2, 3, 4, 4, 4, 5, 6, 100];\n        let previous_destinations = vec![2, 4, 4, 4];\n        let mut transitions = (0..destinations.len())\n            .map(|_| 1.0)\n            .collect::<Vec<WeightT>>();\n        update_return_explore_weight_transition(\n            &mut transitions,\n            &destinations,\n            &previous_destinations,\n            3.0,\n            2.0,\n            6,\n            100,\n        );\n        assert_eq!(\n            transitions,\n            vec![2.0, 1.0, 2.0, 1.0, 1.0, 1.0, 2.0, 3.0, 3.0]\n        )"
            },
            {
                "file": "walks.rs",
                "doc": [],
                "attrs": [
                    "#[test]"
                ],
                "modifiers": "",
                "name": "test_update_return_weight_transition",
                "args": [],
                "body": "let destinations = vec![1, 2, 3, 4, 4, 4, 5, 6, 100];\n        let mut transitions = (0..destinations.len())\n            .map(|_| 1.0)\n            .collect::<Vec<WeightT>>();\n        update_return_weight_transition(&mut transitions, &destinations, 6, 2, 2.0, true);\n        assert_eq!(\n            transitions,\n            vec![1.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, 2.0, 1.0]\n        )"
            },
            {
                "file": "walks.rs",
                "struct": "Graph",
                "doc": [
                    " Return the base weighted transitions.",
                    "",
                    " # Arguments",
                    "",
                    " * `min_edge_id`: EdgeT - The minimum edge id.",
                    " * `max_edge_id`: EdgeT - The maximum edge id.",
                    ""
                ],
                "attrs": [],
                "modifiers": "",
                "name": "get_edge_weighted_transitions",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "min_edge_id",
                        "EdgeT"
                    ],
                    [
                        "max_edge_id",
                        "EdgeT"
                    ],
                    [
                        "probabilistic_indices",
                        "&Option<Vec<u64>>"
                    ]
                ],
                "return_type": "Vec<WeightT>",
                "body": "match &probabilistic_indices {\n            Some(indices) => match &self.weights {\n                Some(ws) => indices\n                    .iter()\n                    .map(|edge_id| ws[*edge_id as usize])\n                    .collect(),\n                // Otherwise we return an uniform vector.\n                None => vec![1.0; indices.len()],\n            },\n            None => match &self.weights {\n                Some(ws) => ws[(min_edge_id as usize)..(max_edge_id as usize)].to_vec(),\n                // Otherwise we return an uniform vector.\n                None => vec![1.0; (max_edge_id - min_edge_id) as usize],\n            },\n        }"
            },
            {
                "file": "walks.rs",
                "struct": "Graph",
                "doc": [
                    " Updates the the transitions probability score for the change of the node type.",
                    "",
                    " Specifically, we multiply the transition score by the given `change_node_type_weight`",
                    " when the node type changes.",
                    "",
                    " # Arguments",
                    "",
                    " * `node`: NodeT - Source node.",
                    " * `transition`: &mut Vec<WeightT> - Vector of transitions to update.",
                    " * `destinations`: impl Iterator<Item = NodeT> - Iterator of the destinations.",
                    " * `change_node_type_weight`: ParamsT - The weight to multiply the transition by if there is a change of node type.",
                    ""
                ],
                "attrs": [],
                "modifiers": "",
                "name": "update_node_transition",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node",
                        "NodeT"
                    ],
                    [
                        "transition",
                        "&mut Vec<WeightT>"
                    ],
                    [
                        "destinations",
                        "impl Iterator<Item = NodeT>"
                    ],
                    [
                        "change_node_type_weight",
                        "ParamsT"
                    ]
                ],
                "body": "//############################################################\n        //# Handling of the change node type parameter               #\n        //############################################################\n\n        if not_one(change_node_type_weight) {\n            // If the node types were given:\n            if let Some(nt) = &self.node_types {\n                // if the destination node type matches the neighbour\n                // destination node type (we are not changing the node type)\n                // we weigth using the provided change_node_type_weight weight.\n\n                transition\n                    .iter_mut()\n                    .zip(destinations)\n                    .for_each(|(transition_value, dst)| {\n                        if nt.ids[node as usize] != nt.ids[dst as usize] {\n                            *transition_value *= change_node_type_weight\n                        }\n                    });\n            }\n        }"
            },
            {
                "file": "walks.rs",
                "struct": "Graph",
                "doc": [
                    " Return the node transition weights and the related node and edges.",
                    "",
                    " # Arguments",
                    "",
                    " * `node`: NodeT, the previous node from which to compute the transitions, if this is bigger that the number of nodes it will panic.",
                    " * `walk_weights`: WalkWeights, the weights for the weighted random walks.",
                    ""
                ],
                "attrs": [],
                "modifiers": "",
                "name": "get_node_transition",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node",
                        "NodeT"
                    ],
                    [
                        "walk_weights",
                        "&WalkWeights"
                    ],
                    [
                        "min_edge_id",
                        "EdgeT"
                    ],
                    [
                        "max_edge_id",
                        "EdgeT"
                    ],
                    [
                        "destinations",
                        "&[NodeT]"
                    ],
                    [
                        "probabilistic_indices",
                        "&Option<Vec<u64>>"
                    ]
                ],
                "return_type": "Vec<WeightT>",
                "body": "// Retrieve the data to compute the update transition\n        let mut transition =\n            self.get_edge_weighted_transitions(min_edge_id, max_edge_id, probabilistic_indices);\n\n        // Compute the transition weights relative to the node weights.\n        self.update_node_transition(\n            node,\n            &mut transition,\n            destinations.iter().cloned(),\n            walk_weights.change_node_type_weight,\n        );\n\n        transition"
            },
            {
                "file": "walks.rs",
                "struct": "Graph",
                "doc": [
                    " Return the edge transition weights and the related node and edges.",
                    "",
                    " # Arguments",
                    "",
                    " * `edge`: EdgeT - the previous edge from which to compute the transitions.",
                    " * `weights`: WalkWeights - Weights to use for the weighted walk."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "get_edge_transition",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ],
                    [
                        "walk_weights",
                        "&WalkWeights"
                    ],
                    [
                        "min_edge_id",
                        "EdgeT"
                    ],
                    [
                        "max_edge_id",
                        "EdgeT"
                    ],
                    [
                        "destinations",
                        "&[NodeT]"
                    ],
                    [
                        "previous_destinations",
                        "&[NodeT]"
                    ],
                    [
                        "probabilistic_indices",
                        "&Option<Vec<u64>>"
                    ],
                    [
                        "has_selfloop",
                        "bool"
                    ]
                ],
                "return_type": "(Vec<WeightT>, EdgeT)",
                "body": "let mut transition =\n            self.get_edge_weighted_transitions(min_edge_id, max_edge_id, probabilistic_indices);\n\n        // Compute the transition weights relative to the node weights.\n        self.update_node_transition(\n            dst,\n            &mut transition,\n            destinations.iter().cloned(),\n            walk_weights.change_node_type_weight,\n        );\n\n        //############################################################\n        //# Handling of the change edge type parameter               #\n        //############################################################\n\n        // If the edge types were given:\n        if not_one(walk_weights.change_edge_type_weight) {\n            if let Some(ets) = &self.edge_types {\n                //# If the neighbour edge type matches the previous\n                //# edge type (we are not changing the edge type)\n                //# we weigth using the provided change_edge_type_weight weight.\n                let this_type: Option<EdgeTypeT> = ets.ids[edge_id as usize];\n                transition\n                    .iter_mut()\n                    .zip(min_edge_id..max_edge_id)\n                    .for_each(|(transition_value, edge_id)| {\n                        if this_type == ets.ids[edge_id as usize] {\n                            *transition_value /= walk_weights.change_edge_type_weight\n                        }\n                    });\n            }\n        }\n\n        //###############################################################\n        //# Handling of the P & Q parameters: the node2vec coefficients #\n        //###############################################################\n        match (\n            not_one(walk_weights.return_weight),\n            not_one(walk_weights.explore_weight),\n        ) {\n            (false, false) => {}\n            (false, true) => {\n                update_explore_weight_transition(\n                    &mut transition,\n                    destinations,\n                    previous_destinations,\n                    walk_weights.explore_weight,\n                    src,\n                    dst,\n                );\n            }\n            (true, false) => {\n                update_return_weight_transition(\n                    &mut transition,\n                    destinations,\n                    src,\n                    dst,\n                    walk_weights.return_weight,\n                    has_selfloop,\n                );\n            }\n            (true, true) => {\n                update_return_explore_weight_transition(\n                    &mut transition,\n                    destinations,\n                    previous_destinations,\n                    walk_weights.return_weight,\n                    walk_weights.explore_weight,\n                    src,\n                    dst,\n                );\n            }\n        }\n\n        (transition, min_edge_id)"
            },
            {
                "file": "walks.rs",
                "struct": "Graph",
                "doc": [
                    " Return new sampled node with the transition edge used.",
                    "",
                    " # Arguments",
                    "",
                    " * `node`: NodeT, the previous node from which to compute the transitions.",
                    " * `random_state`: u64, the random_state to use for extracting the node.",
                    ""
                ],
                "attrs": [],
                "modifiers": "",
                "name": "extract_uniform_node",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node",
                        "NodeT"
                    ],
                    [
                        "random_state",
                        "u64"
                    ]
                ],
                "return_type": "NodeT",
                "body": "let (min_edge, max_edge) = self.get_unchecked_minmax_edge_ids_from_source_node_id(node);\n        let sampled_offset = sample_uniform((max_edge - min_edge) as u64, random_state);\n\n        match self\n            .cached_destinations\n            .as_ref()\n            .and_then(|cds| cds.get(&node))\n        {\n            Some(dsts) => dsts[sampled_offset],\n            None => self\n                .get_unchecked_destination_node_id_from_edge_id(min_edge + sampled_offset as EdgeT),\n        }"
            },
            {
                "file": "walks.rs",
                "struct": "Graph",
                "doc": [
                    " Return new sampled node with the transition edge used.",
                    "",
                    " # Arguments",
                    "",
                    " * `node`: NodeT, the previous node from which to compute the transitions.",
                    " * `random_state`: usize, the random_state to use for extracting the node.",
                    " * `walk_weights`: WalkWeights, the weights for the weighted random walks."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "extract_node",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node",
                        "NodeT"
                    ],
                    [
                        "random_state",
                        "u64"
                    ],
                    [
                        "walk_weights",
                        "&WalkWeights"
                    ],
                    [
                        "min_edge_id",
                        "EdgeT"
                    ],
                    [
                        "max_edge_id",
                        "EdgeT"
                    ],
                    [
                        "destinations",
                        "&[NodeT]"
                    ],
                    [
                        "probabilistic_indices",
                        "&Option<Vec<u64>>"
                    ]
                ],
                "return_type": "(NodeT, EdgeT)",
                "body": "let mut weights = self.get_node_transition(\n            node,\n            walk_weights,\n            min_edge_id,\n            max_edge_id,\n            destinations,\n            probabilistic_indices,\n        );\n        let sampled_offset = sample(&mut weights, random_state);\n        let edge_id = match probabilistic_indices {\n            Some(inds) => inds[sampled_offset],\n            None => min_edge_id + sampled_offset as EdgeT,\n        };\n\n        let destination = match self\n            .cached_destinations\n            .as_ref()\n            .and_then(|cds| cds.get(&node))\n        {\n            Some(dsts) => dsts[sampled_offset],\n            None => self.get_unchecked_destination_node_id_from_edge_id(edge_id),\n        };\n        (destination, edge_id)"
            },
            {
                "file": "walks.rs",
                "struct": "Graph",
                "doc": [
                    " Return new random edge with given weights.",
                    "",
                    " # Arguments",
                    "",
                    " * `src`: NodeT - Current source node id.",
                    " * `dst`: NodeT - Current destination node id.",
                    " * `edge`: EdgeT - Current edge id.",
                    " * `random_state`: NodeT - The random state to use to sample the next edge id.",
                    " * `walk_weights`: &WalkWeights - Struct with the weights to use to update the transitions.",
                    " * `min_edge_id`: EdgeT - Minimum edge id to sample for given destination node id.",
                    " * `max_edge_id`: EdgeT - Maximum edge id to sample for given destination node id.",
                    " * `destinations`: &[NodeT] - Current destinations slice.",
                    " * `previous_destinations`: &[NodeT] - Previous destination slice.",
                    " * `probabilistic_indices`: &Option<Vec<u64>> - Probabilistic indices, used when max neighbours is provided.",
                    ""
                ],
                "attrs": [],
                "modifiers": "",
                "name": "extract_edge",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ],
                    [
                        "edge",
                        "EdgeT"
                    ],
                    [
                        "random_state",
                        "u64"
                    ],
                    [
                        "walk_weights",
                        "&WalkWeights"
                    ],
                    [
                        "min_edge_id",
                        "EdgeT"
                    ],
                    [
                        "max_edge_id",
                        "EdgeT"
                    ],
                    [
                        "destinations",
                        "&[NodeT]"
                    ],
                    [
                        "previous_destinations",
                        "&[NodeT]"
                    ],
                    [
                        "probabilistic_indices",
                        "&Option<Vec<u64>>"
                    ]
                ],
                "return_type": "(NodeT, EdgeT)",
                "body": "let (mut weights, min_edge_id) = self.get_edge_transition(\n            src,\n            dst,\n            edge,\n            walk_weights,\n            min_edge_id,\n            max_edge_id,\n            destinations,\n            previous_destinations,\n            probabilistic_indices,\n            self.has_selfloops(),\n        );\n        let sampled_offset = sample(&mut weights, random_state as u64);\n        let edge_id = match probabilistic_indices {\n            Some(inds) => inds[sampled_offset],\n            None => min_edge_id + sampled_offset as EdgeT,\n        };\n        let destination = match self\n            .cached_destinations\n            .as_ref()\n            .and_then(|cds| cds.get(&dst))\n        {\n            Some(dsts) => dsts[sampled_offset],\n            None => self.get_unchecked_destination_node_id_from_edge_id(edge_id),\n        };\n        (destination, edge_id)"
            },
            {
                "file": "walks.rs",
                "struct": "Graph",
                "doc": [
                    " Return vector of walks run on each non-trap node of the graph.",
                    "",
                    " # Arguments",
                    "",
                    " * `quantity`: NodeT - Number of random walk to compute.",
                    " * `parameters`: &'a WalksParameters - the weighted walks parameters.",
                    "",
                    " # Raises",
                    " * If the graph does not contain edges.",
                    " * If the graph is directed.",
                    " * If the given walks parameters are not compatible with the current graph instance."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_random_walks",
                "generics": "'a",
                "args": [
                    [
                        "self",
                        "&'a self"
                    ],
                    [
                        "quantity",
                        "NodeT"
                    ],
                    [
                        "parameters",
                        "&'a WalksParameters"
                    ]
                ],
                "return_type": "Result<impl IndexedParallelIterator<Item = Vec<NodeT>> + 'a, String>",
                "body": "self.must_have_edges()?;\n        let factor = 0xDEAD;\n        let random_state = splitmix64(parameters.random_state.wrapping_mul(factor) as u64);\n        self.iter_walk(\n            quantity,\n            move |index| {\n                let local_index = index % quantity;\n                let random_source_id =\n                    splitmix64(random_state + local_index.wrapping_mul(factor) as u64) as NodeT;\n                (\n                    splitmix64(random_state + index.wrapping_mul(factor) as u64),\n                    self.get_unchecked_unique_source_node_id(\n                        random_source_id % self.get_unique_source_nodes_number(),\n                    ),\n                )\n            },\n            parameters,\n        )"
            },
            {
                "file": "walks.rs",
                "struct": "Graph",
                "doc": [
                    " Return vector of walks run on a random subset of the not trap nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * `parameters`: &'a WalksParameters - the weighted walks parameters.",
                    "",
                    " # Raises",
                    " * If the graph does not contain edges.",
                    " * If the graph is directed.",
                    " * If the given walks parameters are not compatible with the current graph instance."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_complete_walks",
                "generics": "'a",
                "args": [
                    [
                        "self",
                        "&'a self"
                    ],
                    [
                        "parameters",
                        "&'a WalksParameters"
                    ]
                ],
                "return_type": "Result<impl IndexedParallelIterator<Item = Vec<NodeT>> + 'a, String>",
                "body": "self.must_have_edges()?;\n        let factor = 0xDEAD;\n        let random_state = splitmix64(parameters.random_state.wrapping_mul(factor) as u64);\n        self.iter_walk(\n            self.get_unique_source_nodes_number(),\n            move |index| {\n                (\n                    splitmix64(random_state + index.wrapping_mul(factor) as u64),\n                    self.get_unchecked_unique_source_node_id(\n                        index as NodeT % self.get_unique_source_nodes_number(),\n                    ),\n                )\n            },\n            parameters,\n        )"
            },
            {
                "file": "walks.rs",
                "struct": "Graph",
                "doc": [
                    " Returns vector of walks.",
                    "",
                    " # Arguments",
                    "",
                    " * `parameters`: WalksParameters - the weighted walks parameters.",
                    "",
                    " # Raises",
                    " * If the graph is directed.",
                    " * If the given walks parameters are not compatible with the current graph instance.",
                    " * If the graph contains negative edge weights."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "iter_walk",
                "generics": "'a",
                "args": [
                    [
                        "self",
                        "&'a self"
                    ],
                    [
                        "quantity",
                        "NodeT"
                    ],
                    [
                        "to_node",
                        "impl Fn(NodeT) -> (u64, NodeT) + Sync + Send + 'a"
                    ],
                    [
                        "parameters",
                        "&'a WalksParameters"
                    ]
                ],
                "return_type": "Result<impl IndexedParallelIterator<Item = Vec<NodeT>> + 'a, String>",
                "body": "self.must_be_undirected()?;\n        if self.has_edge_weights() {\n            self.must_have_positive_edge_weights()?;\n        }\n\n        // Validate if given parameters are compatible with current graph.\n        parameters.validate(&self)?;\n\n        let total_iterations = quantity * parameters.iterations;\n        info!(\"Starting random walk.\");\n\n        // If the graph does not have any weights and the parameters\n        // for the walks are all equal to 1, we can use the first-order\n        // random walk algorithm.\n        let use_uniform = !self.has_edge_weights() && parameters.is_first_order_walk();\n\n        let walks = (0..total_iterations).into_par_iter().map(move |index| {\n            let (random_state, node) = to_node(index);\n            let mut walk = match use_uniform {\n                true => self.uniform_walk(\n                    node,\n                    random_state,\n                    parameters.single_walk_parameters.walk_length,\n                ),\n                false => self.single_walk(node, random_state, &parameters.single_walk_parameters),\n            };\n\n            if let Some(dense_node_mapping) = &parameters.dense_node_mapping {\n                walk.iter_mut()\n                    .for_each(|node| *node = *dense_node_mapping.get(node).unwrap());\n            }\n            walk\n        });\n\n        Ok(walks)"
            },
            {
                "file": "walks.rs",
                "struct": "Graph",
                "doc": [
                    " Returns single walk from given node.",
                    "",
                    " This method assumes that there are no traps in the graph.",
                    "",
                    " # Arguments",
                    " * `node`: NodeT - Node from where to start the random walks.",
                    " * `random_state`: usize, the random_state to use for extracting the nodes and edges.",
                    " * `parameters`: SingleWalkParameters - Parameters for the single walk.",
                    ""
                ],
                "attrs": [],
                "modifiers": "",
                "name": "single_walk",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node",
                        "NodeT"
                    ],
                    [
                        "random_state",
                        "u64"
                    ],
                    [
                        "parameters",
                        "&SingleWalkParameters"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "let (min_edge_id, max_edge_id, destinations, indices) = self\n            .get_edges_and_destinations_from_source_node_id(\n                parameters.max_neighbours,\n                random_state,\n                node,\n            );\n        let (dst, edge) = self.extract_node(\n            node,\n            random_state,\n            &parameters.weights,\n            min_edge_id,\n            max_edge_id,\n            self.get_destinations_slice(min_edge_id, max_edge_id, node, &destinations),\n            &indices,\n        );\n\n        let mut result = Vec::with_capacity(parameters.walk_length as usize);\n        result.push(node);\n        result.push(dst);\n        // We iterate two times before because we need to parse the two initial nodes\n\n        let mut previous_min_edge_id = min_edge_id;\n        let mut previous_max_edge_id = max_edge_id;\n        let mut previous_destinations = destinations;\n        let mut previous_src = node;\n        let mut previous_dst = dst;\n        let mut previous_edge = edge;\n\n        for i in 2..parameters.walk_length {\n            let (min_edge_id, max_edge_id, destinations, indices) = self\n                .get_edges_and_destinations_from_source_node_id(\n                    parameters.max_neighbours,\n                    random_state + i,\n                    previous_dst,\n                );\n            let (dst, edge) = self.extract_edge(\n                previous_src,\n                previous_dst,\n                previous_edge,\n                random_state + i,\n                &parameters.weights,\n                min_edge_id,\n                max_edge_id,\n                self.get_destinations_slice(min_edge_id, max_edge_id, previous_dst, &destinations),\n                self.get_destinations_slice(\n                    previous_min_edge_id,\n                    previous_max_edge_id,\n                    previous_src,\n                    &previous_destinations,\n                ),\n                &indices,\n            );\n\n            previous_min_edge_id = min_edge_id;\n            previous_max_edge_id = max_edge_id;\n            previous_destinations = destinations;\n            previous_src = previous_dst;\n            previous_dst = dst;\n            previous_edge = edge;\n            result.push(dst);\n        }\n\n        result"
            },
            {
                "file": "walks.rs",
                "struct": "Graph",
                "doc": [
                    " Returns single walk from given node.",
                    "",
                    " This method assumes that there are no traps in the graph.",
                    "",
                    " # Arguments",
                    " * `node`: NodeT - Node from where to start the random walks.",
                    " * `random_state`: usize - the random_state to use for extracting the nodes and edges.",
                    " * `walk_length`: u64 - Length of the random walk.",
                    ""
                ],
                "attrs": [],
                "modifiers": "",
                "name": "uniform_walk",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node",
                        "NodeT"
                    ],
                    [
                        "random_state",
                        "u64"
                    ],
                    [
                        "walk_length",
                        "u64"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "// We iterate one time before because we need to parse the initial node.\n        (0..1)\n            .map(move |_| node)\n            .chain((1..walk_length).scan(node, move |node, iteration| {\n                *node = self.extract_uniform_node(*node, random_state + iteration);\n                Some(*node)\n            }))\n            .collect()"
            }
        ]
    },
    "compression.rs": {
        "imports": [
            "use super::*;"
        ],
        "functions": [
            {
                "file": "compression.rs",
                "doc": [],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "pub(crate)",
                "name": "encode_edge",
                "args": [
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ],
                    [
                        "node_bits",
                        "u8"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "((src as EdgeT) << node_bits) | dst as EdgeT"
            },
            {
                "file": "compression.rs",
                "doc": [],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "pub(crate)",
                "name": "encode_max_edge",
                "args": [
                    [
                        "node",
                        "NodeT"
                    ],
                    [
                        "node_bits",
                        "u8"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "((node as EdgeT) << node_bits) | node as EdgeT"
            },
            {
                "file": "compression.rs",
                "doc": [],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "pub(crate)",
                "name": "decode_edge",
                "args": [
                    [
                        "edge",
                        "u64"
                    ],
                    [
                        "node_bits",
                        "u8"
                    ],
                    [
                        "node_bit_mask",
                        "u64"
                    ]
                ],
                "return_type": "(NodeT, NodeT)",
                "body": "(\n        (edge >> node_bits) as NodeT,\n        (edge & node_bit_mask) as NodeT,\n    )"
            },
            {
                "file": "compression.rs",
                "doc": [],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "pub(crate)",
                "name": "get_node_bits",
                "args": [
                    [
                        "top_node",
                        "NodeT"
                    ]
                ],
                "return_type": "u8",
                "body": "(1.0 + top_node as f64).log2().ceil() as u8"
            },
            {
                "file": "compression.rs",
                "struct": "Graph",
                "doc": [
                    " Return edge value corresponding to given node IDs.",
                    "",
                    " # Arguments",
                    " * `src`: NodeT - The source node ID.",
                    " * `dst`: NodeT - The destination node ID."
                ],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "pub",
                "name": "encode_edge",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "u64",
                "body": "encode_edge(src, dst, self.node_bits)"
            },
            {
                "file": "compression.rs",
                "struct": "Graph",
                "doc": [
                    " Returns source and destination nodes corresponding to given edge ID.",
                    "",
                    " # Arguments",
                    " * `edge`: u64 - The edge value to decode."
                ],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "pub",
                "name": "decode_edge",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge",
                        "u64"
                    ]
                ],
                "return_type": "(NodeT, NodeT)",
                "body": "decode_edge(edge, self.node_bits, self.node_bit_mask)"
            },
            {
                "file": "compression.rs",
                "struct": "Graph",
                "doc": [
                    " Return maximum encodable edge number."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_max_encodable_edge_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "encode_max_edge(\n            self.get_nodes_number(),\n            get_node_bits(self.get_nodes_number()),\n        )"
            }
        ]
    },
    "dijkstra_queue.rs": {
        "imports": [
            "use std::ops::{Index, IndexMut};"
        ],
        "functions": [
            {
                "file": "dijkstra_queue.rs",
                "struct": "DijkstraQueue",
                "doc": [
                    " Initialize the queue with the given root, in this case the capacity",
                    " should always be equal to the number of nodes in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "with_capacity_from_root",
                "args": [
                    [
                        "capacity",
                        "usize"
                    ],
                    [
                        "root_node_id",
                        "usize"
                    ]
                ],
                "return_type": "Self",
                "body": "let mut res = DijkstraQueue{\n            heap: Vec::with_capacity(capacity),\n            distances: vec![f64::INFINITY; capacity],\n            map: vec![usize::MAX; capacity],\n        };\n        res.heap.push(root_node_id);\n        res.distances[root_node_id] = 0.0;\n        res"
            },
            {
                "file": "dijkstra_queue.rs",
                "struct": "DijkstraQueue",
                "doc": [
                    " Get the index of the father of the given node"
                ],
                "attrs": [
                    "#[inline]"
                ],
                "modifiers": "",
                "name": "parent",
                "args": [
                    [
                        "node",
                        "usize"
                    ]
                ],
                "return_type": "usize",
                "body": "(node.saturating_sub(1)) >> 1"
            },
            {
                "file": "dijkstra_queue.rs",
                "struct": "DijkstraQueue",
                "doc": [
                    " Get the index of the left child"
                ],
                "attrs": [
                    "#[inline]"
                ],
                "modifiers": "",
                "name": "left",
                "args": [
                    [
                        "node",
                        "usize"
                    ]
                ],
                "return_type": "usize",
                "body": "(node << 1) + 1"
            },
            {
                "file": "dijkstra_queue.rs",
                "struct": "DijkstraQueue",
                "doc": [
                    " Get the index of the right child"
                ],
                "attrs": [
                    "#[inline]"
                ],
                "modifiers": "",
                "name": "right",
                "args": [
                    [
                        "node",
                        "usize"
                    ]
                ],
                "return_type": "usize",
                "body": "(node << 1) + 2"
            },
            {
                "file": "dijkstra_queue.rs",
                "struct": "DijkstraQueue",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_empty",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.heap.is_empty()"
            },
            {
                "file": "dijkstra_queue.rs",
                "struct": "DijkstraQueue",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "len",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "usize",
                "body": "self.heap.len()"
            },
            {
                "file": "dijkstra_queue.rs",
                "struct": "DijkstraQueue",
                "doc": [
                    " add a value to the heap"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "push",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "node_id",
                        "usize"
                    ],
                    [
                        "distance",
                        "f64"
                    ]
                ],
                "body": "debug_assert!(\n            self.distances[node_id as usize] > distance, \n            \"We think that we are ensured that a node is pushed IFF its distance is smaller than the older ones.\"\n        );\n        // If the distance is finite, the node **IS** already present,\n        // we check if the new distance is smaller, in that case we have to\n        // fix the heap.\n        if self.map[node_id as usize] != usize::MAX{\n            self.distances[node_id as usize] = distance;\n            self.bubble_up(self.map[node_id as usize], distance);\n            return;\n        }\n\n        // otherwise its th\n        // add the node as the last value in the tree\n        self.heap.push(node_id);\n        self.distances[node_id as usize] = distance;\n        // fix the heap\n        self.bubble_up(self.len() - 1, distance);"
            },
            {
                "file": "dijkstra_queue.rs",
                "struct": "DijkstraQueue",
                "doc": [
                    " Return the computed distances"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "unwrap",
                "args": [
                    [
                        "self",
                        "self"
                    ]
                ],
                "return_type": "Vec<f64>",
                "body": "self.distances"
            },
            {
                "file": "dijkstra_queue.rs",
                "struct": "DijkstraQueue",
                "doc": [
                    " remove and return the smallest value"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "pop",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "return_type": "Option<usize>",
                "body": "// if the queue is empty we can early-stop.\n        if self.is_empty() {\n            return None;\n        }\n\n        // swap the minimum with the last value\n        // this is done so we can pop from the end of the vector\n        // so we are ensured O(1) complexity.\n        let number_of_elements = self.len() - 1;\n        // Reset its position in the map\n        self.map[self.heap[0] as usize] = usize::MAX;\n        self.map[self.heap[number_of_elements]] = 0;\n        // swap the value with the last\n        self.heap.swap(0, number_of_elements);\n        // remove the minimum from the tree\n        let result = self.heap.pop();\n\n        if !self.is_empty() {\n            self.bubble_down(0, self.distances[self.heap[0] as usize]);\n        }\n\n        result"
            },
            {
                "file": "dijkstra_queue.rs",
                "struct": "DijkstraQueue",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "bubble_down",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "idx",
                        "usize"
                    ],
                    [
                        "distance",
                        "f64"
                    ]
                ],
                "body": "// fix the heap by bubbling down the value\n        loop {\n            // get the indices of the right and left child\n            let left_i = DijkstraQueue::left(idx);\n            let right_i = DijkstraQueue::right(idx);\n            let left_v = self.heap.get(left_i).map(|x| self.distances[*x]).unwrap_or(f64::INFINITY);\n            let right_v = self.heap.get(right_i).map(|x| self.distances[*x]).unwrap_or(f64::INFINITY);\n\n            // find the smallest child\n            let (smallest_i, smallest_v) = if left_v > right_v {\n                (right_i, right_v)\n            } else {\n                (left_i, left_v)\n            };\n\n            // and the heap rule is violated\n            if smallest_v < distance {\n                // fix it and keep bubbling down\n                self.heap.swap(idx, smallest_i);\n                self.map[self.heap[idx]] = smallest_i;\n                self.map[self.heap[smallest_i]] = idx;\n                idx = smallest_i;   \n                continue;\n            }\n            \n            // the min heap rule holds for both childs so we can exit.\n            break;\n        }"
            },
            {
                "file": "dijkstra_queue.rs",
                "struct": "DijkstraQueue",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "bubble_up",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "idx",
                        "usize"
                    ],
                    [
                        "distance",
                        "f64"
                    ]
                ],
                "body": "loop {\n            let parent_idx = DijkstraQueue::parent(idx);\n\n            // The heap condition is respected so we can stop.\n            // This also handles the case of the node at the root since\n            // self.parent(0) == 0 => current_value == parent_value\n            if distance >= self.distances[self.heap[parent_idx] as usize] {\n                break\n            }\n\n            // swap the parent and the child\n            self.heap.swap(idx, parent_idx);\n            self.map[self.heap[idx]] = parent_idx;\n            self.map[self.heap[parent_idx]] = idx;\n\n\n            // Update the mutables\n            idx = parent_idx;\n        }"
            },
            {
                "file": "dijkstra_queue.rs",
                "struct": "DijkstraQueue",
                "trait": "Index<usize>",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "index",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "usize"
                    ]
                ],
                "return_type": "&f64",
                "body": "&self.distances[node_id]"
            },
            {
                "file": "dijkstra_queue.rs",
                "struct": "DijkstraQueue",
                "trait": "IndexMut<usize>",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "index_mut",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "node_id",
                        "usize"
                    ]
                ],
                "return_type": "&mut f64",
                "body": "&mut self.distances[node_id]"
            }
        ]
    },
    "edge_lists.rs": {
        "imports": [
            "use super::*;",
            "use itertools::Itertools;",
            "use rayon::iter::IntoParallelRefIterator;",
            "use rayon::iter::ParallelIterator;",
            "use std::collections::HashSet;"
        ],
        "functions": [
            {
                "file": "edge_lists.rs",
                "struct": "Graph",
                "doc": [
                    " Return vector of tuple of Node IDs that form the edges of the required bipartite graph.",
                    "",
                    " # Arguments",
                    " * `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.",
                    " * `first_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the first set of nodes of the graph.",
                    " * `second_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the second set of nodes of the graph.",
                    " * `first_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the first set of nodes of the graph.",
                    " * `second_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the second set of nodes of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_bipartite_edges",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "removed_existing_edges",
                        "Option<bool>"
                    ],
                    [
                        "first_nodes_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "second_nodes_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "first_node_types_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "second_node_types_set",
                        "Option<HashSet<String>>"
                    ]
                ],
                "return_type": "Result<Vec<Vec<NodeT>>, String>",
                "body": "let removed_existing_edges_unwrapped = removed_existing_edges.unwrap_or(true);\n        let (first_nodes, second_nodes): (Vec<NodeT>, Vec<NodeT>) = [\n            (first_nodes_set, first_node_types_set),\n            (second_nodes_set, second_node_types_set),\n        ]\n        .iter()\n        .map(|(node_set, node_type_set)| {\n            self.iter_node_names_and_node_type_names()\n                .filter_map(|(node_id, node_name, _, node_type)| {\n                    if let Some(ans) = &node_set {\n                        if !ans.contains(&node_name) {\n                            return None;\n                        }\n                    }\n                    if let (Some(ants), Some(nt)) = (&node_type_set, &node_type) {\n                        if nt\n                            .iter()\n                            .any(|node_type_name| !ants.contains(node_type_name))\n                        {\n                            return None;\n                        }\n                    }\n                    Some(node_id)\n                })\n                .collect::<Vec<NodeT>>()\n        })\n        .collect_tuple()\n        .unwrap();\n\n        if first_nodes.is_empty() {\n            return Err(\"The first nodes set of required bipartite graph is empty!\".to_owned());\n        }\n\n        if second_nodes.is_empty() {\n            return Err(\"The second nodes set of required bipartite graph is empty!\".to_owned());\n        }\n\n        if first_nodes\n            .par_iter()\n            .any(|src| second_nodes.binary_search(src).is_ok())\n        {\n            return Err(\n                \"The giving node sets of the required bipartite graph have shared nodes.\"\n                    .to_owned(),\n            );\n        }\n\n        Ok(first_nodes\n            .par_iter()\n            .flat_map(|src| {\n                second_nodes\n                    .iter()\n                    .filter_map(|dst| {\n                        if removed_existing_edges_unwrapped\n                            && self.has_edge_from_node_ids(*src, *dst)\n                        {\n                            return None;\n                        }\n                        Some(vec![*src, *dst])\n                    })\n                    .collect::<Vec<Vec<NodeT>>>()\n            })\n            .collect())"
            },
            {
                "file": "edge_lists.rs",
                "struct": "Graph",
                "doc": [
                    " Return vector of tuple of Node IDs that form the edges of the required bipartite graph.",
                    "",
                    " # Arguments",
                    " * `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.",
                    " * `first_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the first set of nodes of the graph.",
                    " * `second_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the second set of nodes of the graph.",
                    " * `first_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the first set of nodes of the graph.",
                    " * `second_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the second set of nodes of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_bipartite_edge_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "removed_existing_edges",
                        "Option<bool>"
                    ],
                    [
                        "first_nodes_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "second_nodes_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "first_node_types_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "second_node_types_set",
                        "Option<HashSet<String>>"
                    ]
                ],
                "return_type": "Result<Vec<Vec<String>>, String>",
                "body": "Ok(self\n            .get_bipartite_edges(\n                removed_existing_edges,\n                first_nodes_set,\n                second_nodes_set,\n                first_node_types_set,\n                second_node_types_set,\n            )?\n            .iter()\n            .map(|nodes| {\n                nodes\n                    .iter()\n                    .map(|node| self.get_unchecked_node_name_from_node_id(*node))\n                    .collect::<Vec<String>>()\n            })\n            .collect::<Vec<Vec<String>>>())"
            },
            {
                "file": "edge_lists.rs",
                "struct": "Graph",
                "doc": [
                    " Return vector of tuple of Node IDs that form the edges of the required star.",
                    "",
                    " # Arguments",
                    " * `central_node`: String - Name of the node to use as center of the star.",
                    " * `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.",
                    " * `star_points_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the set of star points.",
                    " * `star_points_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the set of star points."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_star_edges",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "central_node",
                        "String"
                    ],
                    [
                        "removed_existing_edges",
                        "Option<bool>"
                    ],
                    [
                        "star_points_nodes_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "star_points_node_types_set",
                        "Option<HashSet<String>>"
                    ]
                ],
                "return_type": "Result<Vec<Vec<NodeT>>, String>",
                "body": "self.get_bipartite_edges(\n            removed_existing_edges,\n            Some(vec![central_node].into_iter().collect::<HashSet<String>>()),\n            star_points_nodes_set,\n            None,\n            star_points_node_types_set,\n        )"
            },
            {
                "file": "edge_lists.rs",
                "struct": "Graph",
                "doc": [
                    " Return vector of tuple of Node names that form the edges of the required star.",
                    "",
                    " # Arguments",
                    " * `central_node`: String - Name of the node to use as center of the star.",
                    " * `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.",
                    " * `star_points_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the set of star points.",
                    " * `star_points_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the set of star points."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_star_edge_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "central_node",
                        "String"
                    ],
                    [
                        "removed_existing_edges",
                        "Option<bool>"
                    ],
                    [
                        "star_points_nodes_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "star_points_node_types_set",
                        "Option<HashSet<String>>"
                    ]
                ],
                "return_type": "Result<Vec<Vec<String>>, String>",
                "body": "self.get_bipartite_edge_names(\n            removed_existing_edges,\n            Some(vec![central_node].into_iter().collect::<HashSet<String>>()),\n            star_points_nodes_set,\n            None,\n            star_points_node_types_set,\n        )"
            },
            {
                "file": "edge_lists.rs",
                "struct": "Graph",
                "doc": [
                    " Return vector of tuple of Node IDs that form the edges of the required clique.",
                    "",
                    " # Arguments",
                    " * `directed`: Option<bool> - Whether to return the edges as directed or undirected. By default, equal to the graph.",
                    " * `allow_selfloops`: Option<bool> - Whether to allow self-loops in the clique. By default, equal to the graph.",
                    " * `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.",
                    " * `allow_node_type_set`: Option<HashSet<String>> - Node types to include in the clique.",
                    " * `allow_node_set`: Option<HashSet<String>> - Nodes to include i the clique."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_clique_edges",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "Option<bool>"
                    ],
                    [
                        "allow_selfloops",
                        "Option<bool>"
                    ],
                    [
                        "removed_existing_edges",
                        "Option<bool>"
                    ],
                    [
                        "allow_node_type_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "allow_node_set",
                        "Option<HashSet<String>>"
                    ]
                ],
                "return_type": "Vec<Vec<NodeT>>",
                "body": "let directed_unwrapped = directed.unwrap_or(self.directed);\n        let allow_selfloops_unwrapped = allow_selfloops.unwrap_or_else(|| self.has_selfloops());\n        let removed_existing_edges_unwrapped = removed_existing_edges.unwrap_or(true);\n        let nodes: Vec<NodeT> = self\n            .iter_node_names_and_node_type_names()\n            .filter_map(|(node_id, node_name, _, node_type)| {\n                if let (Some(ants), Some(nt)) = (&allow_node_type_set, &node_type) {\n                    if nt\n                        .iter()\n                        .any(|node_type_name| !ants.contains(node_type_name))\n                    {\n                        return None;\n                    }\n                }\n                if let Some(ans) = &allow_node_set {\n                    if !ans.contains(&node_name) {\n                        return None;\n                    }\n                }\n                Some(node_id)\n            })\n            .collect();\n\n        nodes\n            .par_iter()\n            .flat_map(|src| {\n                nodes\n                    .iter()\n                    .filter_map(|dst| {\n                        if !allow_selfloops_unwrapped && src == dst {\n                            return None;\n                        }\n                        if !directed_unwrapped && src > dst {\n                            return None;\n                        }\n                        if removed_existing_edges_unwrapped\n                            && self.has_edge_from_node_ids(*src, *dst)\n                        {\n                            return None;\n                        }\n                        Some(vec![*src, *dst])\n                    })\n                    .collect::<Vec<Vec<NodeT>>>()\n            })\n            .collect()"
            },
            {
                "file": "edge_lists.rs",
                "struct": "Graph",
                "doc": [
                    " Return vector of tuple of Node names that form the edges of the required clique.",
                    "",
                    " # Arguments",
                    " * `directed`: Option<bool> - Whether to return the edges as directed or undirected. By default, equal to the graph.",
                    " * `allow_selfloops`: Option<bool> - Whether to allow self-loops in the clique. By default, equal to the graph.",
                    " * `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.",
                    " * `allow_node_type_set`: Option<HashSet<String>> - Node types to include in the clique.",
                    " * `allow_node_set`: Option<HashSet<String>> - Nodes to include i the clique."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_clique_edge_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "Option<bool>"
                    ],
                    [
                        "allow_selfloops",
                        "Option<bool>"
                    ],
                    [
                        "removed_existing_edges",
                        "Option<bool>"
                    ],
                    [
                        "allow_node_type_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "allow_node_set",
                        "Option<HashSet<String>>"
                    ]
                ],
                "return_type": "Vec<Vec<String>>",
                "body": "self.get_clique_edges(\n            directed,\n            allow_selfloops,\n            removed_existing_edges,\n            allow_node_type_set,\n            allow_node_set,\n        )\n        .iter()\n        .map(|nodes| {\n            nodes\n                .iter()\n                .map(|node| self.get_unchecked_node_name_from_node_id(*node))\n                .collect::<Vec<String>>()\n        })\n        .collect::<Vec<Vec<String>>>()"
            }
        ]
    },
    "replace.rs": {
        "imports": [
            "use super::*;",
            "use indicatif::ProgressIterator;",
            "use itertools::Itertools;",
            "use log::warn;",
            "use std::collections::HashMap;"
        ],
        "functions": [
            {
                "file": "replace.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Replace."
                ],
                "doc": [
                    " Replace given node, node type and edge type names.",
                    "",
                    " # Arguments",
                    " * `node_name_mapping`: Option<HashMap<String, String>> - The node names to replace.",
                    " * `node_type_name_mapping`: Option<HashMap<String, String>> - The node type names to replace.",
                    " * `node_type_names_mapping`: Option<HashMap<Option<Vec<String>>, Option<Vec<String>>>> - The node type names (as vectors) to replace.",
                    " * `edge_type_name_mapping`: Option<HashMap<Option<String>, Option<String>>> - The edge type names to replace.",
                    " * `verbose`: bool - Whether to show a loading bar.",
                    "",
                    " # Raises",
                    " * If the given node names mapping would lead to nodes duplication."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "replace",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name_mapping",
                        "Option<HashMap<String, String>>"
                    ],
                    [
                        "node_type_name_mapping",
                        "Option<HashMap<String, String>>"
                    ],
                    [
                        "node_type_names_mapping",
                        "Option<HashMap<Option<Vec<String>>, Option<Vec<String>>>>"
                    ],
                    [
                        "edge_type_name_mapping",
                        "Option<HashMap<Option<String>, Option<String>>>"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "if node_type_names_mapping.is_some() && node_type_name_mapping.is_some() {\n            return Err(\n                \"Using at once node_type_name_mapping and node_type_names_mapping is not supported.\".to_string()\n            );\n        }\n        if let Some(nns) = &node_name_mapping {\n            for (original_node_name, new_node_name) in nns.iter() {\n                if *original_node_name == *new_node_name {\n                    warn!(\n                        concat!(\n                            \"The required remapping operation includes remapping between \",\n                            \"the same node names: {} => {}\"\n                        ),\n                        original_node_name, new_node_name\n                    );\n                    continue;\n                }\n                if self.has_node_name(new_node_name) {\n                    return Err(format!(\n                        concat!(\n                            \"One of the new node names ({new_node_name}) already exists in the graph \",\n                            \"and the required remapping operation ({original_node_name} => {new_node_name}) would lead to \",\n                            \"a duplicated node name.\"\n                        ),\n                        new_node_name=new_node_name,\n                        original_node_name=original_node_name\n                    ));\n                }\n            }\n        }\n\n        let pb_edges = get_loading_bar(\n            verbose,\n            format!(\n                \"Building edges of graph {} replacing required attributes\",\n                self.name\n            )\n            .as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n\n        let pb_nodes = get_loading_bar(\n            verbose,\n            format!(\n                \"Building nodes of graph {} replacing required attributes\",\n                self.name\n            )\n            .as_ref(),\n            self.get_nodes_number() as usize,\n        );\n\n        Graph::from_string_sorted(\n            self.iter_edge_node_names_and_edge_type_name_and_edge_weight(true)\n                .progress_with(pb_edges)\n                .map(|(_, _, src_name, _, dst_name, _, edge_type_name, weight)| {\n                    Ok((\n                        node_name_mapping\n                            .as_ref()\n                            .map_or(&src_name, |nns| nns.get(&src_name).unwrap_or(&src_name))\n                            .clone(),\n                        node_name_mapping\n                            .as_ref()\n                            .map_or(&dst_name, |nns| nns.get(&dst_name).unwrap_or(&dst_name))\n                            .clone(),\n                        edge_type_name_mapping\n                            .as_ref()\n                            .map_or(&edge_type_name, |etns| {\n                                etns.get(&edge_type_name).unwrap_or(&edge_type_name)\n                            })\n                            .clone(),\n                        weight,\n                    ))\n                }),\n            Some(\n                self.iter_node_names_and_node_type_names()\n                    .progress_with(pb_nodes)\n                    .map(|(_, node_name, _, node_types)| {\n                        Ok((\n                            node_name_mapping\n                                .as_ref()\n                                .map_or(&node_name, |nns| nns.get(&node_name).unwrap_or(&node_name))\n                                .clone(),\n                            match (\n                                &node_type_name_mapping,\n                                &node_type_names_mapping,\n                                node_types,\n                            ) {\n                                (Some(ntn_mapping), None, Some(nts)) => Some(\n                                    nts.into_iter()\n                                        .map(|node_type_name| {\n                                            ntn_mapping\n                                                .get(&node_type_name)\n                                                .map_or(node_type_name, |new_value| {\n                                                    new_value.clone()\n                                                })\n                                        })\n                                        .unique()\n                                        .collect(),\n                                ),\n                                (None, Some(ntns_mapping), node_types) => {\n                                    ntns_mapping.get(&node_types).unwrap_or(&node_types).clone()\n                                }\n                                (_, _, node_types) => node_types,\n                            },\n                        ))\n                    }),\n            ),\n            self.is_directed(),\n            true,\n            self.get_name(),\n            false,\n            true,\n            true,\n            true,\n            self.get_directed_edges_number() as usize,\n            self.get_nodes_number(),\n            // TODO: UPDATE THE FOLLOWING FOUR BOOLEANS\n            false,\n            false,\n            false,\n            false,\n            self.has_node_types(),\n            self.has_edge_types(),\n            self.has_edge_weights(),\n            self.has_singleton_nodes(),\n            self.has_singleton_nodes_with_selfloops(),\n            self.has_trap_nodes(),\n        )"
            },
            {
                "file": "replace.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Replace."
                ],
                "doc": [
                    " Replace unknown node types with given node type.",
                    "",
                    " # Arguments",
                    " * `node_type_names`: Vec<String> - The node types to replace the unknown with.",
                    " * `verbose`: bool - Whether to show a loading bar."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "replace_unknown_node_types_with_node_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type_names",
                        "Vec<String>"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "if node_type_names\n            .iter()\n            .any(|node_type_name| node_type_name.is_empty())\n        {\n            return Err(\"One or more of the given node types are empty!\".to_string());\n        }\n        self.replace(\n            None,\n            None,\n            Some([(None, Some(node_type_names))].iter().cloned().collect()),\n            None,\n            verbose,\n        )"
            },
            {
                "file": "replace.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Replace."
                ],
                "doc": [
                    " Replace unknown edge types with given edge type name.",
                    "",
                    " # Arguments",
                    " * `edge_type_name`: String - The edge type name to replace the unknown with.",
                    " * `verbose`: bool - Whether to show a loading bar."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "replace_unknown_edge_types_with_edge_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type_name",
                        "String"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "if edge_type_name.is_empty() {\n            return Err(\"The given edge type is empty!\".to_string());\n        }\n        self.replace(\n            None,\n            None,\n            None,\n            Some([(None, Some(edge_type_name))].iter().cloned().collect()),\n            verbose,\n        )"
            }
        ]
    },
    "vertex_cover.rs": {
        "imports": [
            "use super::*;",
            "use bitvec::prelude::*;",
            "use rayon::iter::ParallelIterator;",
            "use std::{collections::HashSet, sync::atomic::AtomicU8};"
        ],
        "functions": [
            {
                "file": "vertex_cover.rs",
                "struct": "Graph",
                "doc": [
                    " Returns 2-approximated verted cover bitvec using greedy algorithm.",
                    "",
                    " # References",
                    " This implementation is described in [\"A local-ratio theorem for approximating the weighted vertex cover problem\"](http://www.cs.technion.ac.il/~reuven/PDF/vc_lr.pdf)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "approximated_vertex_cover_bitvec",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "BitVec<Lsb0, u8>",
                "body": "let nodes_number = self.get_nodes_number() as usize;\n        let mut vertex_cover = bitvec![Lsb0, AtomicU8; 0; nodes_number];\n        let thread_shared_vertex_cover = ThreadDataRaceAware {\n            value: std::cell::UnsafeCell::new(&mut vertex_cover),\n        };\n        self.par_iter_edge_ids(self.is_directed()).for_each(\n            |(_, src_node_id, dst_node_id)| unsafe {\n                let vertex_cover = thread_shared_vertex_cover.value.get();\n                let is_src_inserted = (*vertex_cover)[src_node_id as usize];\n                let is_dst_inserted = (*vertex_cover)[dst_node_id as usize];\n                if !is_src_inserted && !is_dst_inserted {\n                    *(*vertex_cover).get_unchecked_mut(src_node_id as usize) = true;\n                }\n            },\n        );\n\n        unsafe { std::mem::transmute::<BitVec<Lsb0, AtomicU8>, BitVec<Lsb0, u8>>(vertex_cover) }"
            },
            {
                "file": "vertex_cover.rs",
                "struct": "Graph",
                "doc": [
                    " Returns 2-approximated verted cover set using greedy algorithm.",
                    "",
                    " # References",
                    " This implementation is described in [\"A local-ratio theorem for approximating the weighted vertex cover problem\"](http://www.cs.technion.ac.il/~reuven/PDF/vc_lr.pdf)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "approximated_vertex_cover_set",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "HashSet<NodeT>",
                "body": "self.approximated_vertex_cover_bitvec()\n            .iter_ones()\n            .map(|node_id| node_id as NodeT)\n            .collect()"
            }
        ]
    },
    "report.rs": {
        "imports": [
            "use super::types::*;",
            "use super::*;",
            "use itertools::Itertools;",
            "use rayon::prelude::*;",
            "use std::collections::hash_map::DefaultHasher;",
            "use std::collections::HashMap as DefaultHashMap;",
            "use std::hash::{Hash, Hasher};"
        ],
        "functions": [
            {
                "file": "report.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Human readable report of the properties of the graph"
                ],
                "doc": [
                    " Returns report relative to the graph metrics",
                    "",
                    " The report includes a few useful metrics like:",
                    "",
                    " * degrees_median: the median degree of the nodes.",
                    " * degrees_mean: the mean degree of the nodes.",
                    " * degrees_mode: the mode degree of the nodes.",
                    " * min_degree: the max degree of the nodes.",
                    " * max_degree: the min degree of the nodes.",
                    " * nodes_number: the number of nodes in the graph.",
                    " * edges_number: the number of edges in the graph.",
                    " * unique_node_types_number: the number of different node types in the graph.",
                    " * unique_edge_types_number: the number of different edge types in the graph.",
                    " * traps_rate: probability to end up in a trap when starting into any given node.",
                    " * selfloops_rate: pecentage of edges that are selfloops.",
                    " * bidirectional_rate: rate of edges that are bidirectional.",
                    "",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " graph.report();",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "report",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "DefaultHashMap<&str, String>",
                "body": "let mut report: DefaultHashMap<&str, String> = DefaultHashMap::new();\n\n        if self.has_nodes() {\n            report.insert(\"density\", self.get_density().unwrap().to_string());\n            report.insert(\n                \"min_degree\",\n                self.get_min_node_degree().unwrap().to_string(),\n            );\n            report.insert(\n                \"max_degree\",\n                self.get_max_node_degree().unwrap().to_string(),\n            );\n            report.insert(\n                \"degree_mean\",\n                self.get_node_degrees_mean().unwrap().to_string(),\n            );\n        }\n\n        if self.has_edges() {\n            report.insert(\n                \"selfloops_rate\",\n                self.get_selfloop_nodes_rate().unwrap().to_string(),\n            );\n        }\n\n        report.insert(\"name\", self.name.clone());\n        report.insert(\"nodes_number\", self.get_nodes_number().to_string());\n        report.insert(\"edges_number\", self.get_directed_edges_number().to_string());\n        report.insert(\n            \"undirected_edges_number\",\n            self.get_undirected_edges_number().to_string(),\n        );\n        report.insert(\"directed\", self.is_directed().to_string());\n        report.insert(\"has_edge_weights\", self.has_edge_weights().to_string());\n        report.insert(\"has_edge_types\", self.has_edge_types().to_string());\n        report.insert(\"has_node_types\", self.has_node_types().to_string());\n        report.insert(\n            \"selfloops_number\",\n            self.get_selfloop_nodes_number().to_string(),\n        );\n        report.insert(\n            \"singleton_nodes_number\",\n            self.get_singleton_nodes_number().to_string(),\n        );\n        if let Ok(node_types_number) = self.get_node_types_number() {\n            report.insert(\"unique_node_types_number\", node_types_number.to_string());\n        }\n        if let Ok(edge_types_number) = self.get_edge_types_number() {\n            report.insert(\"unique_edge_types_number\", edge_types_number.to_string());\n        }\n        report"
            },
            {
                "file": "report.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Human readable report of the properties of the graph"
                ],
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "shared_components_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "nodes_components",
                        "&[NodeT]"
                    ],
                    [
                        "other",
                        "&Graph"
                    ]
                ],
                "return_type": "NodeT",
                "body": "other\n            .iter_node_names_and_node_type_names()\n            .filter_map(\n                |(_, node_name, _, _)| match self.get_node_id_from_node_name(&node_name) {\n                    Ok(node_id) => Some(nodes_components[node_id as usize]),\n                    Err(_) => None,\n                },\n            )\n            .unique()\n            .count() as NodeT"
            },
            {
                "file": "report.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Human readable report of the properties of the graph"
                ],
                "doc": [
                    " Return number of distinct components that are merged by the other graph in current graph.bitvec",
                    "",
                    " # Arguments",
                    " * `nodes_components`: &[NodeT] - Slice with the node components.",
                    " * `other`: &Graph - Graph from where to extract the edge list."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "merged_components_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "nodes_components",
                        "&[NodeT]"
                    ],
                    [
                        "other",
                        "&Graph"
                    ]
                ],
                "return_type": "NodeT",
                "body": "other\n            .iter_edges(false)\n            .filter_map(|(_, _, src_name, _, dst_name)| {\n                match (\n                    self.get_node_id_from_node_name(&src_name),\n                    self.get_node_id_from_node_name(&dst_name),\n                ) {\n                    (Ok(src_id), Ok(dst_id)) => {\n                        let src_component_number = nodes_components[src_id as usize];\n                        let dst_component_number = nodes_components[dst_id as usize];\n                        match src_component_number == dst_component_number {\n                            true => None,\n                            false => Some(vec![src_component_number, dst_component_number]),\n                        }\n                    }\n                    _ => None,\n                }\n            })\n            .flatten()\n            .unique()\n            .count() as NodeT"
            },
            {
                "file": "report.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Human readable report of the properties of the graph"
                ],
                "doc": [
                    " Return rendered textual report about the graph overlaps.",
                    "",
                    " # Arguments",
                    "",
                    " * `other`: &Graph - graph to create overlap report with.",
                    " * `verbose`: bool - Whether to shor the loading bars."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "overlap_textual_report",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "other",
                        "&Graph"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<String, String>",
                "body": "// Checking if overlap is allowed\n        self.validate_operator_terms(other)?;\n        // Get overlapping nodes\n        let overlapping_nodes_number = self\n            .iter_node_names_and_node_type_names()\n            .filter(|(_, node_name, _, node_type)| {\n                other.has_node_name_and_node_type_name(node_name, node_type.clone())\n            })\n            .count();\n        // Get overlapping edges\n        let overlapping_edges_number = self\n            .par_iter_edge_node_names_and_edge_type_name(self.directed)\n            .filter(|(_, _, src_name, _, dst_name, _, edge_type_name)| {\n                other.has_edge_from_node_names_and_edge_type_name(\n                    src_name,\n                    dst_name,\n                    edge_type_name.as_deref(),\n                )\n            })\n            .count();\n        // Get number of overlapping components\n        let first_nodes_components = self.get_node_connected_component_ids(verbose);\n        let second_nodes_components = other.get_node_connected_component_ids(verbose);\n        let first_components_number = first_nodes_components.iter().unique().count() as NodeT;\n        let second_components_number = second_nodes_components.iter().unique().count() as NodeT;\n        let first_shared_components_number =\n            self.shared_components_number(&first_nodes_components, other);\n        let second_shared_components_number =\n            other.shared_components_number(&second_nodes_components, self);\n        // Get number of overlapping components\n        let first_merged_components_number =\n            self.merged_components_number(&first_nodes_components, other);\n        let second_merged_components_number =\n            other.merged_components_number(&second_nodes_components, self);\n\n        let first_edges = match self.directed {\n            true => self.get_directed_edges_number(),\n            false => self.get_undirected_edges_number(),\n        };\n        let second_edges = match other.directed {\n            true => other.get_directed_edges_number(),\n            false => other.get_undirected_edges_number(),\n        };\n        // Building up the report\n        Ok(format!(\n            concat!(\n                \"The graph {first_graph} and the graph {second_graph} share {nodes_number} nodes and {edges_number} edges. \",\n                \"By percent, {first_graph} shares {first_node_percentage:.2}% ({nodes_number} out of {first_nodes}) of its nodes and {first_edge_percentage:.2}% ({edges_number} out of {first_edges}) of its edges with {second_graph}. \",\n                \"{second_graph} shares {second_node_percentage:.2}% ({nodes_number} out of {second_nodes}) of its nodes and {second_edge_percentage:.2}% ({edges_number} out of {second_edges}) of its edges with {first_graph}. \",\n                \"Nodes from {first_graph} appear in {first_components_statement} components of {second_graph}{first_merged_components_statement}. \",\n                \"Similarly, nodes from {second_graph} appear in {second_components_statement} components of {first_graph}{second_merged_components_statement}. \",\n            ),\n            first_graph=self.get_name(),\n            second_graph=other.get_name(),\n            nodes_number=overlapping_nodes_number,\n            edges_number=overlapping_edges_number,\n            first_nodes=self.get_nodes_number(),\n            second_nodes=other.get_nodes_number(),\n            first_edges=first_edges,\n            second_edges=second_edges,\n            first_components_statement = match second_shared_components_number== second_components_number{\n                true=> \"all the\".to_owned(),\n                false => format!(\n                    \"{second_shared_components_number} of the {second_components_number}\",\n                    second_shared_components_number=second_shared_components_number,\n                    second_components_number=second_components_number\n                )\n            },\n            second_components_statement = match first_shared_components_number== first_components_number{\n                true=> \"all the\".to_owned(),\n                false => format!(\n                    \"{first_shared_components_number} of the {first_components_number}\",\n                    first_shared_components_number=first_shared_components_number,\n                    first_components_number=first_components_number\n                )\n            },\n            first_merged_components_statement = match second_components_number > 1 {\n                false=>\"\".to_owned(),\n                true=>format!(\n                    \": of these, {edges_number} connected by edges of {first_graph}\",\n                    first_graph=self.name,\n                    edges_number= match second_merged_components_number {\n                        d if d==0=>\"none are\".to_owned(),\n                        d if d==1=>\"one is\".to_owned(),\n                        d if d==second_components_number=>\"all components are\".to_owned(),\n                        _ => format!(\"{} components are\", second_merged_components_number)\n                    })\n                },\n            second_merged_components_statement = match first_components_number > 1 {\n                false=>\"\".to_owned(),\n                true=>format!(\n                    \": of these, {edges_number} connected by edges of {second_graph}\",\n                    second_graph=other.name,\n                    edges_number= match first_merged_components_number {\n                        d if d==0=>\"none are\".to_owned(),\n                        d if d==1=>\"one is\".to_owned(),\n                        d if d==first_components_number=>\"all components are\".to_owned(),\n                        _ => format!(\"{} components are\", first_merged_components_number)\n                    })\n                },\n            first_node_percentage=100.0*(overlapping_nodes_number as f64 / self.get_nodes_number() as f64),\n            second_node_percentage=100.0*(overlapping_nodes_number as f64 / other.get_nodes_number() as f64),\n            first_edge_percentage=100.0*(overlapping_edges_number as f64 / first_edges as f64),\n            second_edge_percentage=100.0*(overlapping_edges_number as f64 / second_edges as f64),\n        ))"
            },
            {
                "file": "report.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Human readable report of the properties of the graph"
                ],
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "format_list",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "list",
                        "&[String]"
                    ]
                ],
                "return_type": "Result<String, String>",
                "body": "if list.is_empty() {\n            return Err(\"Cannot format a list with no elements.\".to_owned());\n        }\n        if list.len() == 1 {\n            return Ok(list.first().unwrap().clone());\n        }\n        let all_minus_last: String = list[0..list.len() - 1].join(\", \");\n        Ok(format!(\n            \"{all_minus_last} and {last}\",\n            all_minus_last = all_minus_last,\n            last = list.last().unwrap()\n        ))"
            },
            {
                "file": "report.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Human readable report of the properties of the graph"
                ],
                "doc": [
                    " Return formatted node list.",
                    "",
                    " # Arguments",
                    " * `node_list`: &[NodeT] - list of nodes to be formatted."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "format_node_list",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_list",
                        "&[NodeT]"
                    ]
                ],
                "return_type": "Result<String, String>",
                "body": "self.format_list(\n            node_list\n                .iter()\n                .map(|node_id| {\n                    format!(\n                        \"{node_name} (degree {node_degree})\",\n                        node_name = self.get_unchecked_node_name_from_node_id(*node_id),\n                        node_degree = self.get_unchecked_unweighted_node_degree_from_node_id(*node_id)\n                    )\n                })\n                .collect::<Vec<String>>()\n                .as_slice(),\n        )"
            },
            {
                "file": "report.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Human readable report of the properties of the graph"
                ],
                "doc": [
                    " Return human-readable markdown report of the given node.",
                    "",
                    " The report, by default, is rendered using Markdown.",
                    "",
                    " # Arguments",
                    " * `node_id`: NodeT - Whether to show a loading bar in graph operations.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_report_from_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "Result<String, String>",
                "body": "self.validate_node_id(node_id)?;\n        let mut partial_reports: Vec<String> = Vec::new();\n        let node_name = self.get_unchecked_node_name_from_node_id(node_id);\n        //partial_reports.push(format!(\"## Report for node {}\\n\", node_name));\n\n        partial_reports.push(if self.is_unchecked_singleton_from_node_id(node_id) {\n            match self.get_singleton_nodes_number() {\n                1 => format!(\n                    concat!(\"The given node {} is the only singleton node of the graph.\"),\n                    node_name\n                ),\n                singleton_nodes_number => {\n                    format!(\n                        concat!(\"The given node {} is one of {} singleton nodes.\"),\n                        node_name, singleton_nodes_number\n                    )\n                }\n            }\n        } else if self.is_singleton_with_selfloops_from_node_id(node_id) {\n            match self.get_singleton_nodes_with_selfloops_number() {\n                1 => format!(\n                    concat!(\n                        \"The given node {} is the only singleton node with selfloops in the graph.\"\n                    ),\n                    node_name\n                ),\n                singleton_nodes_with_selfloops_number => {\n                    format!(\n                        concat!(\"The given node {} is one of {} singleton nodes with selfloops.\"),\n                        node_name, singleton_nodes_with_selfloops_number\n                    )\n                }\n            }\n        } else if self.is_unchecked_trap_node_from_node_id(node_id) {\n            match self.get_trap_nodes_number() {\n                1 => format!(\n                    concat!(\"The given node {} is the only trap node in the graph.\"),\n                    node_name\n                ),\n                trap_nodes_number => {\n                    format!(\n                        concat!(\"The given node {} is one of {} trap nodes in the graph.\"),\n                        node_name, trap_nodes_number\n                    )\n                }\n            }\n        } else {\n            format!(\n                concat!(\"The given node {} has degree {}\"),\n                node_name,\n                self.get_unchecked_unweighted_node_degree_from_node_id(node_id)\n            )\n        });\n\n        Ok(partial_reports.join(\"\"))"
            },
            {
                "file": "report.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Human readable report of the properties of the graph"
                ],
                "doc": [
                    " Return human-readable markdown report of the given node.",
                    "",
                    " The report, by default, is rendered using Markdown.",
                    "",
                    " # Arguments",
                    " * `node_name`: &str - Whether to show a loading bar in graph operations.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_report_from_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "Result<String, String>",
                "body": "self.get_node_id_from_node_name(node_name)\n            .and_then(|node_id| self.get_node_report_from_node_id(node_id))"
            },
            {
                "file": "report.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Human readable report of the properties of the graph"
                ],
                "doc": [
                    " Return human-readable markdown report of the graph peculiarities.",
                    "",
                    " The report, by default, is rendered using Markdown.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_peculiarities_report_markdown",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "String",
                "body": "let mut partial_reports: Vec<String> = Vec::new();\n\n        partial_reports.push(format!(\n            \"## Peculiarities report for graph {}\\n\",\n            self.get_name()\n        ));\n\n        if !self.has_nodes() {\n            partial_reports.push(\"### Absence of nodes\\n\".to_string());\n            partial_reports.push(\n                concat!(\n                    \"The graph does not have any node. This may be caused by \",\n                    \"an improper use of one of the filter methods.\\n\\n\"\n                )\n                .to_string(),\n            );\n        }\n\n        if !self.has_edges() {\n            partial_reports.push(\"### Absence of edges\\n\".to_string());\n            partial_reports.push(\n                concat!(\n                    \"The graph does not have any edge. This may be caused by \",\n                    \"an improper use of one of the filter methods.\\n\\n\"\n                )\n                .to_string(),\n            );\n        }\n\n        // Detect weirdness relative to nodes\n        if self.has_node_oddities() {\n            partial_reports.push(\"### Oddities relative to nodes\\n\".to_string());\n            if self.has_singleton_nodes() {\n                partial_reports.push(\"#### Singleton nodes\\n\".to_string());\n                partial_reports.push(format!(\n                    concat!(\n                        \"{}: nodes that do not have any inbound or outbound edge. \",\n                        \"We consider singleton nodes an oddity because they represent \",\n                        \"a concept that is not connected to anything else \",\n                        \"and is hardly ever useful when actually using the graph.\\n\",\n                        \"For instance, in most node embedding methods, the \",\n                        \"singleton nodes will often maintain a gaussian node \",\n                        \"embedding, that is often visualized as a gaussian hyper-sphere.\\n\",\n                        \"Such embeddings do not encode any information if not the fact \",\n                        \"that the node has extremely low degree.\\n\",\n                        \"\\n\",\n                        \"Often these cases are caused by some error in the \",\n                        \"data wrangling phase. The solutions include, if no bug \",\n                        \"is identified in the data wrangling phase, to drop\",\n                        \"the singleton nodes or to attach the singletons to \",\n                        \"other nodes when additional features are available.\",\n                        \"\\n\",\n                        \"##### Solution dropping singleton nodes\\n\",\n                        \"It is possible to drop **all** of the singleton nodes \",\n                        \"by using the method `graph.drop_singleton_nodes()`, \",\n                        \"which will create a new graph instance before removing \",\n                        \"the singleton nodes.\\n\",\n                        \"If you need a more fine-grained control on what is \",\n                        \"removed, you can use the `filter` method.\\n\",\n                        \"##### Solution chaining nodes using k-meas\\n\",\n                        \"Another possible solution, when extra node features \",\n                        \"are available (i.e. when there are word embedding \",\n                        \"of the nodes description), additional edges may be \",\n                        \"added to the graph by computing the nodes that are \",\n                        \"close according to some metric and add edges for the \",\n                        \"nodes that result to be closer than a given amount \",\n                        \"in the computed distance.\\n\",\n                        \"Add the time of writing this is not supported in \",\n                        \"Ensmallen, but is work in progress. Currently \",\n                        \"you will need to handle this in your preprocessing \",\n                        \"pipeline before providing the edge list.\"\n                    ),\n                    match self.get_singleton_nodes_number() {\n                        0 => unreachable!(\n                            \"There must be at least a singleton node if we got here.\",\n                        ),\n                        1 => \"There is a singleton node in the graph\".to_string(),\n                        singleton_node_types_number => format!(\n                            \"There are {} singleton nodes in the graph\",\n                            singleton_node_types_number\n                        ),\n                    }\n                ));\n                partial_reports.push(\"##### List of the singleton nodes\\n\".to_string());\n                partial_reports.extend(\n                    self.iter_singleton_node_names()\n                        .take(10)\n                        .map(|node_name| format!(\"* {}\\n\", node_name)),\n                );\n                if self.get_singleton_nodes_number() > 10 {\n                    partial_reports.push(format!(\n                        \"* Plus other {} singleton nodes\\n\",\n                        self.get_singleton_nodes_number() - 10\n                    ))\n                }\n                partial_reports.push(\"\\n\".to_string());\n            }\n\n            if self.has_singleton_nodes_with_selfloops() {\n                partial_reports.push(\"#### Singleton nodes with self loops\\n\".to_string());\n                partial_reports.push(format!(\n                    concat!(\n                        \"{}: nodes that do not have any inbound or outbound edge, \",\n                        \"with the exception of one or more selfloops.\\n\",\n                        \"We consider singleton nodes with selfloops an oddity because they represent \",\n                        \"a concept that is not connected to anything else \",\n                        \"but themselves \",\n                        \"and is hardly ever useful when actually using the graph.\\n\",\n                        \"For instance, in most node embedding methods, the \",\n                        \"singleton nodes with selfloops will often maintain a gaussian node \",\n                        \"embedding, that is often visualized as a gaussian hyper-sphere.\\n\",\n                        \"Such embeddings do not encode any information if not the fact \",\n                        \"that the node has extremely low degree, similarly to what \",\n                        \"happens with a *normal* singleton node.\\n\",\n                        \"\\n\",\n                        \"Often these cases are caused by some error in the \",\n                        \"data wrangling phase. The solutions include, if no bug \",\n                        \"is identified in the data wrangling phase, to drop \",\n                        \"the singleton nodes with selfloops or to attach these \",\n                        \"nodes to other nodes when additional features are available.\\n\",\n                        \"\\n\",\n                        \"##### Solution dropping singleton nodes\\n\",\n                        \"It is possible to drop **all** of the singleton nodes with selfloops \",\n                        \"by using the method `graph.drop_singleton_nodes_with_selfloops()`, \",\n                        \"which will create a new graph instance before removing \",\n                        \"the singleton nodes with selfloops.\\n\",\n                        \"If you need a more fine-grained control on what is \",\n                        \"removed, you can use the `filter` method.\\n\",\n                        \"##### Solution chaining nodes using k-meas\\n\",\n                        \"Another possible solution, when extra node features \",\n                        \"are available (i.e. when there are word embedding \",\n                        \"of the nodes description), additional edges may be \",\n                        \"added to the graph by computing the nodes that are \",\n                        \"close according to some metric and add edges for the \",\n                        \"nodes that result to be closer than a given amount \",\n                        \"in the computed distance.\\n\",\n                        \"Add the time of writing this is not supported in \",\n                        \"Ensmallen, but is work in progress. Currently \",\n                        \"you will need to handle this in your preprocessing \",\n                        \"pipeline before providing the edge list.\"\n                    ),\n                    match self.get_singleton_nodes_with_selfloops_number() {\n                        0 => unreachable!(\n                            \"There must be at least a singleton node with selfloops if we got here.\",\n                        ),\n                        1 => \"There is a singleton node with selfloops in the graph\".to_string(),\n                        singleton_node_types_number => format!(\n                            \"There are {} singleton nodes with selfloops in the graph\",\n                            singleton_node_types_number\n                        ),\n                    }\n                ));\n                partial_reports\n                    .push(\"##### List of the singleton nodes with selfloops\\n\".to_string());\n                partial_reports.extend(\n                    self.iter_singleton_with_selfloops_node_names()\n                        .take(10)\n                        .map(|node_name| format!(\"* {}\\n\", node_name)),\n                );\n                if self.get_singleton_nodes_with_selfloops_number() > 10 {\n                    partial_reports.push(format!(\n                        \"* Plus other {} singleton nodes with selfloops\\n\",\n                        self.get_singleton_nodes_with_selfloops_number() - 10\n                    ))\n                }\n                partial_reports.push(\"\\n\".to_string());\n            }\n        }\n\n        // Detect weirdness relative to node types.\n        if self.has_node_types_oddities().map_or(false, |value| value) {\n            partial_reports.push(\"### Oddities relative to node types\\n\".to_string());\n            if self.has_singleton_node_types().unwrap() {\n                partial_reports.push(\"#### Singleton node types\\n\".to_string());\n                partial_reports.push(format!(\n                    concat!(\n                        \"{}: node types that only appear in one graph node. \",\n                        \"We consider singleton node types an oddity because it \",\n                        \"identifies a single node uniquely, and the node name \",\n                        \"already covers that function.\\n\",\n                        \"Often these cases are caused by some error in the \",\n                        \"data wrangling phase when attempting to normalize \",\n                        \"the node types: consider checking the normalization \",\n                        \"step and see if these node types fall in one of the other node types.\\n\",\n                        \"There are two possible solutions to the peculiarity \",\n                        \"mentioned above: either drop the singleton node types \",\n                        \"or replace them with one of the other node types. \",\n                        \"The first solution may lead to nodes with unknown \",\n                        \"node types that can be either dropped or imputed.\\n\",\n                        \"\\n\",\n                        \"##### Solution dropping singleton node types\\n\",\n                        \"It is possible to drop **all** of the singleton node \",\n                        \"types by using the method `graph.remove_inplace_singleton_node_types()`, \",\n                        \"which will remove *inplace* (from the current instance) \",\n                        \"all of the singleton node types or, similarly, \",\n                        \"the method `graph.remove_singleton_node_types()` \",\n                        \"which will create a new graph instance before removing \",\n                        \"the singleton node types.\\n\",\n                        \"To drop only selected singleton node types you can \",\n                        \"use one of the following methods, according if you \",\n                        \"intend to create a new graph instance or not and if \",\n                        \"you want to execute the operation starting from \",\n                        \"either the node type ID or the node type name:\\n\",\n                        \"* `graph.remove_inplace_node_type_id(node_type_id)`\\n\",\n                        \"* `graph.remove_node_type_id(node_type_id)`\\n\",\n                        \"* `graph.remove_inplace_node_type_name(node_type_name)`\\n\",\n                        \"* `graph.remove_node_type_name(node_type_name)`\\n\",\n                        \"\\n\",\n                        \"##### Solution replacing singleton node types\\n\",\n                        \"An alternative solution is provided by the `replace` \",\n                        \"method: by providing the desired `node_type_names` \",\n                        \"parameter you can remap the singleton node types \",\n                        \"to other node types.\\n\"\n                    ),\n                    match self.get_singleton_node_types_number().unwrap() {\n                        0 => unreachable!(\n                            \"There must be at least a singleton node type if we got here.\",\n                        ),\n                        1 => \"There is a singleton node type in the graph\".to_string(),\n                        singleton_node_types_number => format!(\n                            \"There are {} singleton node types in the graph\",\n                            singleton_node_types_number\n                        ),\n                    }\n                ));\n                partial_reports.push(\"##### List of the singleton node types\\n\".to_string());\n                partial_reports.extend(\n                    self.iter_singleton_node_type_names()\n                        .unwrap()\n                        .take(10)\n                        .map(|node_name| format!(\"* {}\\n\", node_name)),\n                );\n                if self.get_singleton_node_types_number().unwrap() > 10 {\n                    partial_reports.push(format!(\n                        \"* Plus other {} singleton node types\\n\",\n                        self.get_singleton_node_types_number().unwrap() - 10\n                    ))\n                }\n                partial_reports.push(\"\\n\".to_string());\n            }\n            if self.has_homogeneous_node_types().unwrap() {\n                partial_reports.push(\"#### Homogeneous node types\\n\".to_string());\n                partial_reports.push(\n                    concat!(\n                        \"The current graph instance has homogenous node types. \",\n                        \"That is, all nodes share the same node type. \",\n                        \"Graphs with a single node type are odd because if all \",\n                        \"nodes have the same node type, they might as well have none. \",\n                        \"A modelling issue often causes this: for instance, \",\n                        \"when working on a graph such as STRING PPI, a \",\n                        \"protein-protein interactions graph, it is well known \",\n                        \"that all nodes represent a protein and hence it would \",\n                        \"not make sense to add such a node type. Using homogeneous \",\n                        \"node types only leads to a (slightly) higher memory \",\n                        \"footprint and slower embedding if your embedding \",\n                        \"algorithms also involves the node type.\\n\\n\",\n                        \"Consider avoiding loading homogenous node types \",\n                        \"altogether or dropping the node types by using either \",\n                        \"the method `remove_inplace_node_types` or `remove_node_types` \",\n                        \"to remove the node types in place or creating a \",\n                        \"new graph instance without the node types.\\n\"\n                    )\n                    .to_string(),\n                );\n            }\n            if self.has_unknown_node_types().unwrap() {\n                partial_reports.push(\"#### Unknown node types\\n\".to_string());\n                partial_reports.push(format!(\n                    concat!(\n                        \"The following is less than an oddity and more \",\n                        \"of a statement: the graph contains {} nodes with \",\n                        \"unknown node types, composing {:.4} of the nodes.\\n\",\n                        \"The presence of unknown node types should be a \",\n                        \"conscious modelling choice for either actual \",\n                        \"unknown node types or node types reserved for a \",\n                        \"validation set of some kind and not related to a \",\n                        \"data bug created while ingested malformed data sources.\\n\",\n                        \"\\n\",\n                        \"If you have a sound reason to have unknown node types \",\n                        \"in your graph then you can absolutely ignore this warning.\\n\",\n                        \"Conversely, if you want to remove the unknown node types \",\n                        \"you can either use the `drop_unknown_node_types` method \",\n                        \"to drop them and the related nodes, otherwise you can \",\n                        \"remap the unknown node types to some other node type \",\n                        \"if you have a generic node type, as is common in most \",\n                        \"knowledge graphs: you can use the method \",\n                        \"`replace_unknown_node_types_with_node_type_name` for\",\n                        \"this second solution.\\n\"\n                    ),\n                    self.get_unknown_node_types_number().unwrap(),\n                    self.get_unknown_node_types_rate().unwrap() * 100.0,\n                ));\n            }\n        }\n\n        // Detect weirdness relative to edge types.\n        if self.has_edge_types_oddities().map_or(false, |value| value) {\n            partial_reports.push(\"### Oddities relative to edge types\\n\".to_string());\n            if self.has_singleton_edge_types().unwrap() {\n                partial_reports.push(\"#### Singleton edge types\\n\".to_string());\n                partial_reports.push(format!(\n                    concat!(\n                        \"{}: edge types that only appear in one graph edge. \",\n                        \"We consider singleton edge types an oddity because it \",\n                        \"identifies a single edge uniquely, and the edge name \",\n                        \"already covers that function.\\n\",\n                        \"Often these cases are caused by some error in the \",\n                        \"data wrangling phase when attempting to normalize \",\n                        \"the edge types: consider checking the normalization \",\n                        \"step and see if these edge types fall in one of the other edge types.\\n\",\n                        \"There are two possible solutions to the peculiarity \",\n                        \"mentioned above: either drop the singleton edge types \",\n                        \"or replace them with one of the other edge types. \",\n                        \"The first solution may lead to edges with unknown \",\n                        \"edge types that can be either dropped or imputed.\\n\",\n                        \"\\n\",\n                        \"##### Solution dropping singleton edge types\\n\",\n                        \"It is possible to drop **all** of the singleton edge \",\n                        \"types by using the method `graph.remove_inplace_singleton_edge_types()`, \",\n                        \"which will remove *inplace* (from the current instance) \",\n                        \"all of the singleton edge types or, similarly, \",\n                        \"the method `graph.remove_singleton_edge_types()` \",\n                        \"which will create a new graph instance before removing \",\n                        \"the singleton edge types.\\n\",\n                        \"To drop only selected singleton edge types you can \",\n                        \"use one of the following methods, according if you \",\n                        \"intend to create a new graph instance or not and if \",\n                        \"you want to execute the operation starting from \",\n                        \"either the edge type ID or the edge type name:\\n\",\n                        \"* `graph.remove_inplace_edge_type_id(edge_type_id)`\\n\",\n                        \"* `graph.remove_edge_type_id(edge_type_id)`\\n\",\n                        \"* `graph.remove_inplace_edge_type_name(edge_type_name)`\\n\",\n                        \"* `graph.remove_edge_type_name(edge_type_name)`\\n\",\n                        \"\\n\",\n                        \"##### Solution replacing singleton edge types\\n\",\n                        \"An alternative solution is provided by the `replace` \",\n                        \"method: by providing the desired `edge_type_names` \",\n                        \"parameter you can remap the singleton edge types \",\n                        \"to other edge types.\\n\"\n                    ),\n                    match self.get_singleton_edge_types_number().unwrap() {\n                        0 => unreachable!(\n                            \"There must be at least a singleton edge type if we got here.\",\n                        ),\n                        1 => \"There is a singleton edge type in the graph\".to_string(),\n                        singleton_edge_types_number => format!(\n                            \"There are {} singleton edge types in the graph\",\n                            singleton_edge_types_number\n                        ),\n                    }\n                ));\n                partial_reports.push(\"##### List of the singleton edge types\\n\".to_string());\n                partial_reports.extend(\n                    self.iter_singleton_edge_type_names()\n                        .unwrap()\n                        .take(10)\n                        .map(|edge_name| format!(\"* {}\\n\", edge_name)),\n                );\n                if self.get_singleton_edge_types_number().unwrap() > 10 {\n                    partial_reports.push(format!(\n                        \"* Plus other {} singleton edge types\\n\",\n                        self.get_singleton_edge_types_number().unwrap() - 10\n                    ))\n                }\n                partial_reports.push(\"\\n\".to_string());\n            }\n            if self.has_homogeneous_edge_types().unwrap() {\n                partial_reports.push(\"#### Homogeneous edge types\\n\".to_string());\n                partial_reports.push(\n                    concat!(\n                        \"The current graph instance has homogenous edge types. \",\n                        \"That is, all edges share the same edge type. \",\n                        \"Graphs with a single edge type are odd because if all \",\n                        \"edges have the same edge type, they might as well have none. \",\n                        \"A modelling issue often causes this: for instance, \",\n                        \"when working on a graph such as STRING PPI, a \",\n                        \"protein-protein interactions graph, it is well known \",\n                        \"that all edges represent a protein and hence it would \",\n                        \"not make sense to add such a edge type. Using homogeneous \",\n                        \"edge types only leads to a (slightly) higher memory \",\n                        \"footprint and slower embedding if your embedding \",\n                        \"algorithms also involves the edge type.\\n\\n\",\n                        \"Consider avoiding loading homogenous edge types \",\n                        \"altogether or dropping the edge types by using either \",\n                        \"the method `remove_inplace_edge_types` or `remove_edge_types` \",\n                        \"to remove the edge types in place or creating a \",\n                        \"new graph instance without the edge types.\\n\"\n                    )\n                    .to_string(),\n                );\n            }\n            if self.has_unknown_edge_types().unwrap() {\n                partial_reports.push(\"#### Unknown edge types\\n\".to_string());\n                partial_reports.push(format!(\n                    concat!(\n                        \"The following is less than an oddity and more \",\n                        \"of a statement: the graph contains {} edges with \",\n                        \"unknown edge types, composing {:.4} of the edges.\\n\",\n                        \"The presence of unknown edge types should be a \",\n                        \"conscious modelling choice for either actual \",\n                        \"unknown edge types or edge types reserved for a \",\n                        \"validation set of some kind and not related to a \",\n                        \"data bug created while ingested malformed data sources.\\n\",\n                        \"\\n\",\n                        \"If you have a sound reason to have unknown edge types \",\n                        \"in your graph then you can absolutely ignore this warning.\\n\",\n                        \"Conversely, if you want to remove the unknown edge types \",\n                        \"you can either use the `drop_unknown_edge_types` method \",\n                        \"to drop them and the related edges, otherwise you can \",\n                        \"remap the unknown edge types to some other edge type \",\n                        \"if you have a generic edge type, as is common in most \",\n                        \"knowledge graphs: you can use the method \",\n                        \"`replace_unknown_edge_types_with_edge_type_name` for\",\n                        \"this second solution.\\n\"\n                    ),\n                    self.get_unknown_edge_types_number().unwrap(),\n                    self.get_unknown_edge_types_rate().unwrap() * 100.0,\n                ));\n            }\n        }\n\n        // If there is only the title, then we have not detected any weirdness.\n        if partial_reports.len() == 1 {\n            partial_reports.push(format!(\n                \"Congratulations, the graph {} does not seem to have any weirdness!\\n\",\n                self.get_name()\n            ));\n        }\n\n        partial_reports.join(\"\")"
            },
            {
                "file": "report.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Human readable report of the properties of the graph"
                ],
                "doc": [
                    " Return rendered textual report of the graph.",
                    "",
                    " # Arguments",
                    " * `verbose`: bool - Whether to show loading bar.",
                    " TODO: UPDATE THIS METHOD!"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "textual_report",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<String, String>",
                "body": "{\n            let ptr = self.cached_report.read();\n            if let Some(report) = &*ptr {\n                return Ok(report.clone());\n            }\n        }\n\n        if !self.has_nodes() {\n            return Ok(format!(\"The graph {} is empty.\", self.get_name()));\n        }\n\n        let mut ptr = self.cached_report.write();\n        // THis is not a duplicate of above because we need to\n        // check if another thread already filled the cache\n        if let Some(report) = &*ptr {\n            return Ok(report.clone());\n        }\n\n        let (connected_components_number, minimum_connected_component, maximum_connected_component) =\n            self.get_connected_components_number(verbose);\n\n        let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        let hash = hasher.finish();\n\n        *ptr = Some(format!(\n            concat!(\n                \"The {direction} {graph_type} {name} has {nodes_number} nodes{singletons} and {edges_number} {weighted} edges, of which {selfloops}{selfloops_multigraph_connector}{multigraph_edges}. \",\n                \"The graph is {quantized_density} as it has a density of {density:.5} and {connected_components}. \",\n                \"The graph median node degree is {median_node_degree}, the mean node degree is {mean_node_degree:.2}, and the node degree mode is {mode_node_degree}. \",\n                \"The top {most_common_nodes_number} most central nodes are {central_nodes}. \",\n                \"The hash of the graph is {hash:08x}.\"\n            ),\n            hash = hash,\n            direction = match self.directed {\n                true=> \"directed\",\n                false => \"undirected\"\n            }.to_owned(),\n            graph_type = match self.is_multigraph() {\n                true=> \"multigraph\",\n                false => \"graph\"\n            }.to_owned(),\n            name = self.name,\n            nodes_number = self.get_nodes_number(),\n            edges_number = self.get_edges_number(),\n            weighted = match self.has_edge_weights(){\n                true=> \"weighted\",\n                false=> \"unweighted\"\n            }.to_owned(),\n            selfloops = match self.has_selfloops() {\n                true => format!(\"{} are self-loops\", self.get_selfloop_nodes_number()),\n                false => \"none are self-loops\".to_owned()\n            },\n            selfloops_multigraph_connector = match self.is_multigraph() {\n                true => \" and \".to_owned(),\n                false => \"\".to_owned()\n            },\n            multigraph_edges = match self.is_multigraph() {\n                true=>match self.get_multigraph_edges_number()>0 {\n                    true => format!(\"{} are parallel\", self.get_multigraph_edges_number()),\n                    false => \"none are parallel\".to_owned()\n                },\n                false=>\"\".to_owned()\n            },\n            singletons = match self.has_singleton_nodes() {\n                true => format!(\n                    \" There are {singleton_number} singleton nodes{selfloop_singleton},\", \n                    singleton_number=self.get_singleton_nodes_number(),\n                    selfloop_singleton=match self.has_singleton_nodes_with_selfloops(){\n                        true=>format!(\" ({} have self-loops)\", match self.get_singleton_nodes_number()==self.get_singleton_nodes_with_selfloops_number(){\n                            true=>\"all\".to_owned(),\n                            false=>format!(\"{} of these\", self.get_singleton_nodes_with_selfloops_number())\n                        }),\n                        false=>\"\".to_owned()\n                    }\n                ),\n                false => \"\".to_owned()\n            },\n            quantized_density = match self.get_density().unwrap() {\n                d if d < 0.0001 => \"extremely sparse\".to_owned(),\n                d if d < 0.001 => \"quite sparse\".to_owned(),\n                d if d < 0.01 => \"sparse\".to_owned(),\n                d if d < 0.1 => \"dense\".to_owned(),\n                d if d < 0.5 => \"quite dense\".to_owned(),\n                d if (d - 1.0).abs() < f64::EPSILON => \"complete\".to_owned(),\n                d if d <= 1.0 => \"extremely dense\".to_owned(),\n                d => unreachable!(format!(\"Unreacheable density case {}\", d))\n            },\n            density=self.get_density().unwrap(),\n            connected_components=match connected_components_number> 1{\n                true=>format!(\n                    \"has {components_number} connected components, where the component with most nodes has {maximum_connected_component} and the component with the least nodes has {minimum_connected_component}\",\n                    components_number=connected_components_number,\n                    maximum_connected_component=match maximum_connected_component==1{\n                        true=>\"a single node\".to_owned(),\n                        false=>format!(\"{} nodes\", maximum_connected_component)\n                    },\n                    minimum_connected_component=match minimum_connected_component==1{\n                        true=>\"a single node\".to_owned(),\n                        false=>format!(\"{} nodes\", minimum_connected_component)\n                    }\n                ),\n                false=>\"is connected, as it has a single component\".to_owned()\n            },\n            median_node_degree=self.get_node_degrees_median().unwrap(),\n            mean_node_degree=self.get_node_degrees_mean().unwrap(),\n            mode_node_degree=self.get_node_degrees_mode().unwrap(),\n            most_common_nodes_number=std::cmp::min(5, self.get_nodes_number()),\n            central_nodes = self.format_node_list(self.get_top_k_central_node_ids(std::cmp::min(5, self.get_nodes_number())).as_slice())?\n        ));\n\n        Ok(ptr.clone().unwrap())"
            }
        ]
    },
    "getters.rs": {
        "imports": [
            "use super::*;",
            "use counter::Counter;",
            "use log::info;",
            "use rayon::prelude::*;",
            "use std::collections::HashMap;"
        ],
        "functions": [
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number a triple with (number of components, number of nodes of the smallest component, number of nodes of the biggest component )",
                    "",
                    " # Arguments",
                    "",
                    " * `verbose`: bool - Whether to show a loading bar or not."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_connected_components_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "(NodeT, NodeT, NodeT)",
                "body": "info!(\"Computing connected components number.\");\n        if self.directed {\n            let (_, _, components_number, min_component_size, max_component_size) =\n                self.spanning_arborescence_kruskal(verbose);\n            (components_number, min_component_size, max_component_size)\n        } else {\n            info!(\"Executing undirected parallel version of connected components.\");\n            let (_, components_number, min_component_size, max_component_size) =\n                self.connected_components(verbose).unwrap();\n            (components_number, min_component_size, max_component_size)\n        }"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of singleton nodes within the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The graph contains {} singleton nodes\", graph.get_singleton_nodes_number());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_singleton_nodes_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "NodeT",
                "body": "self.get_nodes_number()\n            - self.get_connected_nodes_number()\n            - self.get_singleton_nodes_with_selfloops_number()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of disconnected nodes within the graph.",
                    " A Disconnected node is a node which is nor a singleton nor a singleton",
                    " with selfloops.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The graph contains {} disconnected nodes\", graph.get_disconnected_nodes_number());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_disconnected_nodes_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "NodeT",
                "body": "self.get_nodes_number() - self.get_connected_nodes_number()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns vector of singleton node IDs of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The graph singleton node IDs are {:?}.\", graph.get_singleton_node_ids());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_singleton_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "self.iter_singleton_node_ids().collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns vector of singleton node names of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The graph singleton node names are {:?}.\", graph.get_singleton_node_names());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_singleton_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "self.iter_singleton_node_names().collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of singleton nodes with self-loops within the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The graph contains {} singleton nodes with self-loops\", graph.get_singleton_nodes_with_selfloops_number());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_singleton_nodes_with_selfloops_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "NodeT",
                "body": "self.singleton_nodes_with_selfloops_number"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns vector of singleton_with_selfloops node IDs of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The graph singleton_with_selfloops node IDs are {:?}.\", graph.get_singleton_with_selfloops_node_ids());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_singleton_with_selfloops_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "self.iter_singleton_with_selfloops_node_ids().collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns vector of singleton_with_selfloops node names of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The graph singleton_with_selfloops node names are {:?}.\", graph.get_singleton_with_selfloops_node_names());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_singleton_with_selfloops_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "self.iter_singleton_with_selfloops_node_names().collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of not singleton nodes within the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The graph contains {} not singleton nodes\", graph.get_connected_nodes_number());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_connected_nodes_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "NodeT",
                "body": "self.connected_nodes_number"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns density of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The graph density is {}\", graph.get_density().unwrap());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_density",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "if !self.has_nodes() {\n            return Err(\"The density of an empty graph is undefined.\".to_string());\n        }\n        if !self.has_edges() {\n            return Ok(0.0);\n        }\n        let nodes_number = self.get_nodes_number() as EdgeT;\n        let total_nodes_number = nodes_number\n            * match self.has_selfloops() {\n                true => nodes_number,\n                false => nodes_number - 1,\n            };\n        Ok(self.unique_edges_number as f64 / total_nodes_number as f64)"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns the traps rate of the graph.",
                    "",
                    " THIS IS EXPERIMENTAL AND MUST BE PROVEN!",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The Graph rate is {}\", graph.get_trap_nodes_rate());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_trap_nodes_rate",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "f64",
                "body": "self.par_iter_node_ids()\n            .map(|node_id| {\n                if !self.is_unchecked_trap_node_from_node_id(node_id) {\n                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)\n                        .map(|dst| self.is_unchecked_trap_node_from_node_id(dst) as usize as f64)\n                        .sum::<f64>()\n                        / self.get_unchecked_unweighted_node_degree_from_node_id(node_id) as f64\n                } else {\n                    1.0\n                }\n            })\n            .sum::<f64>()\n            / self.get_nodes_number() as f64"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns mean node degree of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The mean node degree of the graph is  {}\", graph.get_node_degrees_mean().unwrap());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_degrees_mean",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "if !self.has_nodes() {\n            return Err(\n                \"The mean of the node degrees is not defined on an empty graph\".to_string(),\n            );\n        }\n        Ok(self.get_directed_edges_number() as f64 / self.get_nodes_number() as f64)"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of undirected edges of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The number of undirected edges of the graph is  {}\", graph.get_undirected_edges_number());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_undirected_edges_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "(self.get_directed_edges_number() - self.get_selfloop_nodes_number()) / 2\n            + self.get_selfloop_nodes_number()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of undirected edges of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The number of unique undirected edges of the graph is  {}\", graph.get_unique_undirected_edges_number());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unique_undirected_edges_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "(self.unique_edges_number - self.get_unique_selfloop_number() as EdgeT) / 2\n            + self.get_unique_selfloop_number() as EdgeT"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of edges of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The number of edges of the graph is  {}\", graph.get_edges_number());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edges_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "match self.directed {\n            true => self.get_directed_edges_number(),\n            false => self.get_undirected_edges_number(),\n        }"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of unique edges of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The number of edges of the graph is  {}\", graph.get_unique_edges_number());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unique_edges_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "match self.directed {\n            true => self.get_unique_directed_edges_number(),\n            false => self.get_unique_undirected_edges_number(),\n        }"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns median node degree of the graph",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The median node degree of the graph is  {}\", graph.get_node_degrees_median().unwrap());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_degrees_median",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "if !self.has_nodes() {\n            return Err(\n                \"The median of the node degrees is not defined on an empty graph\".to_string(),\n            );\n        }\n        let mut degrees = self.get_node_degrees();\n        degrees.par_sort_unstable();\n        Ok(degrees[(self.get_nodes_number() / 2) as usize])"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns maximum node degree of the graph.",
                    "",
                    " # Safety",
                    " The method will return an undefined value (0) when the graph",
                    " does not contain nodes. In those cases the value is not properly",
                    " defined.",
                    " Returns maximum node degree of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The maximum node degree of the graph is  {}\", graph.get_max_node_degree().unwrap());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph does not contain any node (is an empty graph)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_max_node_degree",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "self.must_have_nodes()\n            .map(|_| unsafe { self.get_unchecked_max_node_degree() })"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns maximum node degree of the graph.",
                    "",
                    " # Safety",
                    " This method fails with a panic if the graph does not have any node.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The maximum node degree of the graph is  {}\", unsafe{graph.get_unchecked_argmax_node_degree()});",
                    " ```",
                    " Returns maximum node degree of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The maximum node degree of the graph is  {}\", graph.get_argmax_node_degree().unwrap());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_argmax_node_degree",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "self.must_have_nodes()\n            .map(|_| unsafe { self.get_unchecked_argmax_node_degree() as NodeT })"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns minimum node degree of the graph.",
                    "",
                    " # Safety",
                    " The method will return an undefined value (NodeT::MAX) when the graph",
                    " does not contain nodes. In those cases the value is not properly",
                    " defined.",
                    " Returns minimum node degree of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The minimum node degree of the graph is  {}\", graph.get_min_node_degree().unwrap());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph does not contain any node (is an empty graph)."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_min_node_degree",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "self.must_have_nodes()\n            .map(|_| unsafe { self.get_unchecked_min_node_degree() })"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns mode node degree of the graph.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The mode node degree of the graph is  {}\", graph.get_node_degrees_mode().unwrap());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_degrees_mode",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "if !self.has_nodes() {\n            return Err(\n                \"The mode of the node degrees is not defined on an empty graph\".to_string(),\n            );\n        }\n        let counter: Counter<NodeT, usize> = Counter::init(self.iter_unweighted_node_degrees());\n        Ok(*counter\n            .iter()\n            .max_by_key(|&(_, count)| count)\n            .map(|(degree, _)| degree)\n            .unwrap())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of self-loops, including also those in eventual multi-edges.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The number of self-loops in the graph is  {}\", graph.get_selfloop_nodes_number());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_selfloop_nodes_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "self.selfloop_number"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of unique self-loops, excluding those in eventual multi-edges.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The number of unique self-loops in the graph is  {}\", graph.get_unique_selfloop_number());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unique_selfloop_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "NodeT",
                "body": "self.unique_selfloop_number"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns rate of self-loops.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The rate of self-loops in the graph is  {}\", graph.get_selfloop_nodes_rate().unwrap());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_selfloop_nodes_rate",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "if !self.has_edges() {\n            return Err(\"The self-loops rate is not defined for graphs without edges.\".to_string());\n        }\n        Ok(self.get_selfloop_nodes_number() as f64 / self.get_directed_edges_number() as f64)"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return name of the graph.",
                    "",
                    " # Example",
                    " To the retrieve the name of the current graph instance selfloop_number can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert_eq!(graph.get_name(), \"STRING PPI\".to_string());",
                    " println!(\"The name of the current graph is {}.\", graph.get_name());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "String",
                "body": "self.name.clone()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return the number of traps (nodes without any outgoing edges that are not singletons)",
                    " This also includes nodes with only a self-loops, therefore singletons with",
                    " only a self-loops are not considered traps because you could make a walk on them.",
                    "",
                    " # Example",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"There are {} trap nodes in the current graph.\", graph.get_trap_nodes_number());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_trap_nodes_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "(self.get_connected_nodes_number() + self.get_singleton_nodes_with_selfloops_number()\n            - self.get_unique_source_nodes_number()) as EdgeT"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return vector of the non-unique source nodes.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_source_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "self.par_iter_source_node_ids(directed).collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return vector of the non-unique source nodes names.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_source_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "self.par_iter_source_node_ids(directed)\n            .map(|src| self.get_unchecked_node_name_from_node_id(src))\n            .collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return vector on the (non unique) destination nodes of the graph.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_destination_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "self.par_iter_destination_node_ids(directed).collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return vector of the non-unique destination nodes names.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_destination_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "self.par_iter_destination_node_ids(directed)\n            .map(|dst| self.get_unchecked_node_name_from_node_id(dst))\n            .collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return vector with the sorted nodes names."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "self.nodes.reverse_map.clone()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return vector with the sorted nodes Ids."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "self.iter_node_ids().collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return the edge types of the edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<Option<EdgeTypeT>>, String>",
                "body": "self.must_have_edge_types()\n            .map(|_| self.edge_types.as_ref().map(|ets| ets.ids.clone()).unwrap())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return the unique edge type IDs of the graph edges.",
                    "",
                    " # Example",
                    " To retrieve the unique edge type IDs of the graph edges you can use:",
                    " ```rust",
                    " # let graph_with_edge_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " # let graph_without_edge_types = graph::test_utilities::load_ppi(false, false, true, true, false, false);",
                    " assert!(graph_with_edge_types.get_unique_edge_type_ids().is_ok());",
                    " assert!(graph_without_edge_types.get_unique_edge_type_ids().is_err());",
                    " println!(\"The graph edge types are {:?}\", graph_with_edge_types.get_unique_edge_type_ids());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unique_edge_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<EdgeTypeT>, String>",
                "body": "self.iter_unique_edge_type_ids()\n            .map(|edge_type_ids| edge_type_ids.collect())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return the edge types names."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<Option<String>>, String>",
                "body": "self.must_have_edge_types().map(|_| {\n            self.edge_types\n                .as_ref()\n                .map(|ets| {\n                    ets.ids\n                        .iter()\n                        .map(|edge_type_id| {\n                            self.get_unchecked_edge_type_name_from_edge_type_id(*edge_type_id)\n                        })\n                        .collect()\n                })\n                .unwrap()\n        })"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return the edge types names."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unique_edge_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<String>, String>",
                "body": "self.iter_unique_edge_type_names()\n            .map(|iter_unique_edge_type_names| iter_unique_edge_type_names.collect())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return the weights of the graph edges.",
                    "",
                    " # Example",
                    " To get an the graph weights you can use:",
                    " ```rust",
                    " # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);",
                    " # let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);",
                    " assert!(graph_with_weights.get_edge_weights().is_ok());",
                    " assert!(graph_without_weights.get_edge_weights().is_err());",
                    " println!(\"The graph weights are {:?}.\", graph_with_weights.get_edge_weights());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_weights",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<WeightT>, String>",
                "body": "self.must_have_edge_weights()?;\n        Ok(self.weights.clone().unwrap())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return the minimum weight, if graph has weights.",
                    "",
                    " # Example",
                    " To get the minimum edge weight you can use:",
                    " ```rust",
                    " # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);",
                    " # let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);",
                    " assert!(graph_with_weights.get_min_edge_weight().is_ok());",
                    " assert!(graph_without_weights.get_min_edge_weight().is_err());",
                    " println!(\"The graph minimum weight is {:?}.\", graph_with_weights.get_min_edge_weight());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph does not contain edge weights."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_min_edge_weight",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<WeightT, String>",
                "body": "self.must_have_edge_weights()\n            .map(|_| self.min_edge_weight.unwrap())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return the maximum weight, if graph has weights.",
                    "",
                    " # Example",
                    " To get the maximum edge weight you can use:",
                    " ```rust",
                    " # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);",
                    " # let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);",
                    " assert!(graph_with_weights.get_max_edge_weight().is_ok());",
                    " assert!(graph_without_weights.get_max_edge_weight().is_err());",
                    " println!(\"The graph maximum weight is {:?}.\", graph_with_weights.get_max_edge_weight());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph does not contain edge weights."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_max_edge_weight",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<WeightT, String>",
                "body": "self.must_have_edge_weights()\n            .map(|_| self.max_edge_weight.unwrap())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return the node types of the graph nodes.",
                    "",
                    " # Example",
                    " To retrieve the node type IDs of the graph nodes you can use:",
                    " ```rust",
                    " # let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " # let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " assert!(graph_with_node_types.get_node_type_ids().is_ok());",
                    " assert!(graph_without_node_types.get_node_type_ids().is_err());",
                    " println!(\"The graph node types are {:?}\", graph_with_node_types.get_node_type_ids());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<Option<Vec<NodeTypeT>>>, String>",
                "body": "self.must_have_node_types()\n            .map(|_| self.node_types.as_ref().map(|nts| nts.ids.clone()).unwrap())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns one-hot encoded node types.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_one_hot_encoded_node_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<Vec<bool>>, String>",
                "body": "Ok(self.iter_one_hot_encoded_node_type_ids()?.collect())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns one-hot encoded edge types.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_one_hot_encoded_edge_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<Vec<bool>>, String>",
                "body": "Ok(self.iter_one_hot_encoded_edge_type_ids()?.collect())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return the node types names.",
                    "",
                    " # Example",
                    " To retrieve the node type names of the graph nodes you can use:",
                    " ```rust",
                    " # let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " # let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " assert!(graph_with_node_types.get_node_type_names().is_ok());",
                    " assert!(graph_without_node_types.get_node_type_names().is_err());",
                    " println!(\"The graph node types are {:?}\", graph_with_node_types.get_node_type_names());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<Option<Vec<String>>>, String>",
                "body": "self.must_have_node_types().map(|_| {\n            self.iter_node_ids()\n                .map(|node_id| unsafe { self.get_unchecked_node_type_names_from_node_id(node_id) })\n                .collect::<Vec<Option<Vec<String>>>>()\n        })"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return the unique node type IDs of the graph nodes.",
                    "",
                    " # Example",
                    " To retrieve the unique node type IDs of the graph nodes you can use:",
                    " ```rust",
                    " # let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " # let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " assert!(graph_with_node_types.get_unique_node_type_ids().is_ok());",
                    " assert!(graph_without_node_types.get_unique_node_type_ids().is_err());",
                    " println!(\"The graph node types are {:?}\", graph_with_node_types.get_unique_node_type_ids());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unique_node_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<NodeTypeT>, String>",
                "body": "self.iter_unique_node_type_ids()\n            .map(|iter_unique_node_type_ids| iter_unique_node_type_ids.collect())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return the unique node types names.",
                    "",
                    " # Example",
                    " To retrieve the unique node type names of the graph nodes you can use:",
                    " ```rust",
                    " # let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " # let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);",
                    " assert!(graph_with_node_types.get_unique_node_type_names().is_ok());",
                    " assert!(graph_without_node_types.get_unique_node_type_names().is_err());",
                    " println!(\"The graph node types are {:?}\", graph_with_node_types.get_unique_node_type_names());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unique_node_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<String>, String>",
                "body": "self.iter_unique_node_type_names()\n            .map(|iter_unique_node_type_names| iter_unique_node_type_names.collect())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return number of the unique edges in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unique_directed_edges_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "self.unique_edges_number"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return the nodes mapping."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_nodes_mapping",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "HashMap<String, NodeT>",
                "body": "self.nodes.map.clone()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return vector with the sorted edge Ids.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "Vec<Vec<NodeT>>",
                "body": "self.par_iter_edge_ids(directed)\n            .map(|(_, src, dst)| vec![src, dst])\n            .collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return vector with the sorted edge names.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "Vec<(String, String)>",
                "body": "self.par_iter_edges(directed)\n            .map(|(_, _, src_name, _, dst_name)| (src_name, dst_name))\n            .collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of nodes with unknown node type.",
                    "",
                    " # Raises",
                    " * If there are no node types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unknown_node_types_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "self.must_have_node_types()\n            .map(|node_types| node_types.get_unknown_count())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns the number of node with known node type.",
                    "",
                    " # Raises",
                    " * If there are no node types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_known_node_types_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "Ok(self.get_nodes_number() - self.get_unknown_node_types_number()?)"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns rate of unknown node types over total nodes number.",
                    "",
                    " # Raises",
                    " * If there are no node types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unknown_node_types_rate",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "self.get_unknown_node_types_number()\n            .map(|unknown_node_types_number| {\n                unknown_node_types_number as f64 / self.get_nodes_number() as f64\n            })"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns rate of known node types over total nodes number.",
                    "",
                    " # Raises",
                    " * If there are no node types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_known_node_types_rate",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "self.get_known_node_types_number()\n            .map(|known_node_types_number| {\n                known_node_types_number as f64 / self.get_nodes_number() as f64\n            })"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns minimum number of node types.",
                    "",
                    " # Raises",
                    " * If there are no node types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_minimum_node_types_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<NodeT, String>",
                "body": "self.must_have_node_types()\n            .map(|node_types| node_types.min_node_type_count())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of singleton node types.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_singleton_node_types_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<NodeTypeT, String>",
                "body": "self.iter_node_type_counts().map(|iter_node_type_counts| {\n            iter_node_type_counts\n                .map(|node_type_count| (node_type_count == 1) as NodeTypeT)\n                .sum()\n        })"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns vector of singleton node types IDs.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_singleton_node_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<NodeTypeT>, String>",
                "body": "self.iter_singleton_node_type_ids()\n            .map(|iter_singleton_node_type_ids| iter_singleton_node_type_ids.collect())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns vector of singleton node types names.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_singleton_node_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<String>, String>",
                "body": "self.iter_singleton_node_type_names()\n            .map(|iter_singleton_node_type_names| iter_singleton_node_type_names.collect())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of unknown edge types.",
                    "",
                    " # Raises",
                    " * If there are no edge types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unknown_edge_types_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<EdgeT, String>",
                "body": "self.must_have_edge_types()\n            .map(|edge_types| edge_types.get_unknown_count())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns the number of edge with known edge type.",
                    "",
                    " # Raises",
                    " * If there are no edge types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_known_edge_types_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<EdgeT, String>",
                "body": "Ok(self.get_directed_edges_number() - self.get_unknown_edge_types_number()?)"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns rate of unknown edge types over total edges number.",
                    "",
                    " # Raises",
                    " * If there are no edge types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unknown_edge_types_rate",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "self.get_unknown_edge_types_number()\n            .map(|unknown_edge_types_number| {\n                unknown_edge_types_number as f64 / self.get_directed_edges_number() as f64\n            })"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns rate of known edge types over total edges number.",
                    "",
                    " # Raises",
                    " * If there are no edge types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_known_edge_types_rate",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<f64, String>",
                "body": "self.get_known_edge_types_number()\n            .map(|known_edge_types_number| {\n                known_edge_types_number as f64 / self.get_directed_edges_number() as f64\n            })"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns minimum number of edge types.",
                    "",
                    " # Raises",
                    " * If there are no edge types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_minimum_edge_types_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<EdgeT, String>",
                "body": "self.must_have_edge_types()\n            .map(|edge_types| edge_types.min_edge_type_count())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of singleton edge types.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_singleton_edge_types_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<EdgeTypeT, String>",
                "body": "self.iter_edge_type_counts().map(|iter_edge_type_counts| {\n            iter_edge_type_counts\n                .map(|edge_type_count| (edge_type_count == 1) as EdgeTypeT)\n                .sum()\n        })"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns vector of singleton edge types IDs.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_singleton_edge_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<EdgeTypeT>, String>",
                "body": "self.iter_singleton_edge_type_ids()\n            .map(|iter_singleton_edge_type_ids| iter_singleton_edge_type_ids.collect())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns vector of singleton edge types names.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_singleton_edge_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<Vec<String>, String>",
                "body": "self.iter_singleton_edge_type_names()\n            .map(|iter_singleton_edge_type_names| iter_singleton_edge_type_names.collect())"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of nodes in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_nodes_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "NodeT",
                "body": "self.nodes.len() as NodeT"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return a vector with the components each node belongs to.",
                    "",
                    " E.g. If we have two components `[0, 2, 3]` and `[1, 4, 5]` the result will look like",
                    " `[0, 1, 0, 0, 1, 1]`",
                    "",
                    " # Arguments",
                    " * `verbose`: bool - Whether to show the loading bar."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_connected_component_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "match self.directed {\n            true => self.spanning_arborescence_kruskal(verbose).1,\n            false => self.connected_components(verbose).unwrap().0,\n        }"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of directed edges in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_directed_edges_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "self.edges.len() as EdgeT"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of edge types in the graph.",
                    "",
                    " # Raises",
                    " * If there are no edge types in the current graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_types_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<EdgeTypeT, String>",
                "body": "self.must_have_edge_types()\n            .map(|ets| ets.len() as EdgeTypeT)"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of node types in the graph.",
                    "",
                    " # Raises",
                    " * If there are no node types in the current graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_types_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<NodeTypeT, String>",
                "body": "self.must_have_node_types()\n            .map(|nts| nts.len() as NodeTypeT)"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns the degree of every node in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_degrees",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "self.par_iter_unweighted_node_degrees().collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return set of nodes that are not singletons."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_not_singletons_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "self.iter_connected_node_ids().collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return mapping from instance not trap nodes to dense nodes."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_dense_nodes_mapping",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "HashMap<NodeT, NodeT>",
                "body": "self.iter_connected_node_ids()\n            .enumerate()\n            .map(|(i, node)| (node as NodeT, i as NodeT))\n            .collect()"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return number of edges that have multigraph syblings."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_multigraph_edges_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "self.get_directed_edges_number() - self.unique_edges_number"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return vector with node cumulative_node_degrees, that is the comulative node degree."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_cumulative_node_degrees",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<EdgeT>",
                "body": "self.cumulative_node_degrees.as_ref().map_or_else(\n            || {\n                self.par_iter_node_ids()\n                    .map(|src| self.get_unchecked_edge_id_from_node_ids(src + 1, 0))\n                    .collect()\n            },\n            |cumulative_node_degrees| cumulative_node_degrees.clone(),\n        )"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns number of the source nodes.",
                    "",
                    " # Example",
                    "```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " println!(\"The number of sources of the graph (not trap nodes) is {}\", graph.get_unique_source_nodes_number());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unique_source_nodes_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "NodeT",
                "body": "self.unique_sources\n            .as_ref()\n            .map_or(self.get_nodes_number(), |x| x.len() as NodeT)"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns edge type IDs counts hashmap.",
                    "",
                    " # Example",
                    " In order to compute an hashmap of the edge type IDs you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " for (edge_type_id, count) in graph.get_edge_type_id_counts_hashmap().unwrap().iter() {",
                    "     println!(\"edge type id {}: count: {}\", edge_type_id, count);",
                    " }",
                    " ```",
                    "",
                    " # Raises",
                    " * If there are no edge types in the current graph instance."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_type_id_counts_hashmap",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<HashMap<EdgeTypeT, EdgeT>, String>",
                "body": "self.iter_unique_edge_type_ids_and_counts()\n            .map(|iter_unique_edge_type_ids_and_counts| {\n                iter_unique_edge_type_ids_and_counts.collect()\n            })"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns edge type names counts hashmap.",
                    "",
                    " # Example",
                    " In order to compute an hashmap of the edge type names you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " for (edge_type_id, count) in graph.get_edge_type_id_counts_hashmap().unwrap().iter() {",
                    "     println!(\"edge type name {}: count: {}\", edge_type_id, count);",
                    " }",
                    " ```",
                    "",
                    " # Raises",
                    " * If there are no edge types in the current graph instance."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_type_names_counts_hashmap",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<HashMap<String, EdgeT>, String>",
                "body": "self.iter_unique_edge_type_names_and_counts().map(\n            |iter_unique_edge_type_names_and_counts| {\n                iter_unique_edge_type_names_and_counts.collect()\n            },\n        )"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns node type IDs counts hashmap.",
                    "",
                    " # Example",
                    " In order to compute an hashmap of the node type IDs you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " for (node_type_id, count) in graph.get_node_type_id_counts_hashmap().unwrap().iter() {",
                    "     println!(\"node type id {}: count: {}\", node_type_id, count);",
                    " }",
                    " ```",
                    "",
                    " # Raises",
                    " * If there are no node types in the current graph instance."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_type_id_counts_hashmap",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<HashMap<NodeTypeT, NodeT>, String>",
                "body": "self.iter_unique_node_type_ids_and_counts()\n            .map(|iter_unique_node_type_ids_and_counts| {\n                iter_unique_node_type_ids_and_counts.collect()\n            })"
            },
            {
                "file": "getters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Getters",
                    " The naming convention we follow is:",
                    " * `/get_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/get_unchecked_(.+)/`"
                ],
                "doc": [
                    " Returns node type names counts hashmap.",
                    "",
                    " # Example",
                    " In order to compute an hashmap of the node type names you can use:",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " for (node_type_id, count) in graph.get_node_type_id_counts_hashmap().unwrap().iter() {",
                    "     println!(\"node type name {}: count: {}\", node_type_id, count);",
                    " }",
                    " ```",
                    "",
                    " # Raises",
                    " * If there are no node types in the current graph instance."
                ],
                "attrs": [
                    "#[no_inverse_method]"
                ],
                "modifiers": "pub",
                "name": "get_node_type_names_counts_hashmap",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<HashMap<String, NodeT>, String>",
                "body": "self.iter_unique_node_type_names_and_counts().map(\n            |iter_unique_node_type_names_and_counts| {\n                iter_unique_node_type_names_and_counts.collect()\n            },\n        )"
            }
        ]
    },
    "vocabulary.rs": {
        "imports": [
            "use super::types::*;",
            "use arbitrary::Arbitrary;",
            "use std::collections::hash_map::Entry;",
            "use std::collections::HashMap;"
        ],
        "functions": [
            {
                "file": "vocabulary.rs",
                "doc": [],
                "attrs": [
                    "#[derive(Debug, Clone, PartialEq, Arbitrary)]"
                ],
                "modifiers": "pub",
                "name": "default",
                "args": [],
                "return_type": "Vocabulary<IndexT>",
                "body": "Vocabulary {\n            map: HashMap::new(),\n            reverse_map: Vec::new(),\n            numeric_ids: false,\n        }"
            },
            {
                "file": "vocabulary.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "normalize_value",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "value",
                        "&str"
                    ]
                ],
                "return_type": "Result<(String, IndexT), String>",
                "body": "Ok(if self.numeric_ids {\n            let parsed_value = value.parse::<usize>().map_err(|_| {\n                format!(\n                    \"The given ID `{}` is not a numeric positive integer.\",\n                    value\n                )\n            })?;\n\n            let string_parsed_value = parsed_value.to_string();\n\n            // Check that there are no extra zeros or separators in the number\n            // E.g. 000 is not supported since it will be traduced to 0\n            if value != string_parsed_value {\n                return Err(format!(\n                    concat!(\n                        \"The given ID is numeric but is not symmetric.\\n\",\n                        \"Specifically, {} != {} where the first value is the user's one \",\n                        \"and the second one is the result of parsing the value as an \",\n                        \" integer and casting back to string.\"\n                    ),\n                    value, string_parsed_value\n                ));\n            }\n\n            (string_parsed_value, IndexT::from_usize(parsed_value))\n        } else {\n            (value.to_string(), IndexT::from_usize(self.map.len()))\n        })"
            },
            {
                "file": "vocabulary.rs",
                "doc": [
                    " Returns id of given value inserted.",
                    "",
                    " # Arguments",
                    "",
                    " * `value`: String - The value to be inserted."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "unchecked_insert",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "value",
                        "String"
                    ]
                ],
                "return_type": "IndexT",
                "body": "let current_length = self.map.len();\n        let numeric_ids = self.numeric_ids;\n        *self.map.entry(value).or_insert_with_key(|value| {\n            IndexT::from_usize(if numeric_ids {\n                unsafe { value.parse::<usize>().unwrap_unchecked() }\n            } else {\n                current_length\n            })\n        })"
            },
            {
                "file": "vocabulary.rs",
                "doc": [
                    " Returns id of given value inserted.",
                    "",
                    " # Arguments",
                    "",
                    " * `value`: String - The value to be inserted."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "insert",
                "generics": "S: AsRef<str>",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "value",
                        "S"
                    ]
                ],
                "return_type": "Result<(IndexT, bool), String>",
                "body": "let value = value.as_ref();\n\n        if value.is_empty() {\n            return Err(\"The value given to the vocabulary was empty\".to_string());\n        }\n\n        let (normalized_value, index) = self.normalize_value(value)?;\n\n        Ok(match self.map.entry(normalized_value) {\n            Entry::Occupied(extracted_index) => (*extracted_index.get(), true),\n            Entry::Vacant(vacant_entry) => (*vacant_entry.insert(index), false),\n        })"
            },
            {
                "file": "vocabulary.rs",
                "doc": [
                    " Compute the reverse mapping vector for fast decoding"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "build_reverse_mapping",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "if !self.reverse_map.is_empty() {\n            panic!(\"Build reverse mapping called multiple times!\");\n        }\n        self.reverse_map = vec![\"\".to_string(); self.map.len()];\n        for (k, v) in self.map.iter() {\n            if *v >= IndexT::from_usize(self.map.len()) {\n                return Err(format!(\n                    concat!(\n                        \"The given set of values is not dense. Found the tuple k:{} v:{} \",\n                        \"which has index bigger than the number of elements in the map {}.\"\n                    ),\n                    k,\n                    v,\n                    self.map.len()\n                ));\n            }\n            let i = IndexT::to_usize(*v);\n            if !self.reverse_map[i].is_empty() {\n                panic!(\n                    concat!(\n                        \"During the building of the reverse mapping, \",\n                        \"one of the elements of the reverse mapping was attempted \",\n                        \"to be assigned multiple times. This means that in the map \",\n                        \"there are multiple nodes with the same id.\\n\",\n                        \"In the past this was caused by improper handling of numeric \",\n                        \"node id.\\n\",\n                        \"In this case, the value is {} and its index is {}.\"\n                    ),\n                    k, i,\n                );\n            }\n            self.reverse_map[i] = k.clone();\n        }\n        Ok(())"
            },
            {
                "file": "vocabulary.rs",
                "doc": [
                    " Returns whether the value is empty or not."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_empty",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.map.is_empty()"
            },
            {
                "file": "vocabulary.rs",
                "doc": [
                    " Returns string name of given id.",
                    "",
                    " # Arguments",
                    "",
                    " * `id`: IndexT - Id to be translated."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "unchecked_translate",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "id",
                        "IndexT"
                    ]
                ],
                "return_type": "String",
                "body": "self.reverse_map[IndexT::to_usize(id)].clone()"
            },
            {
                "file": "vocabulary.rs",
                "doc": [
                    " Returns option with string name of given id.",
                    "",
                    " # Arguments",
                    "",
                    " * `id`: IndexT - Id to be translated."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "translate",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "id",
                        "IndexT"
                    ]
                ],
                "return_type": "Result<String, String>",
                "body": "match self.reverse_map.get(IndexT::to_usize(id)) {\n            Some(name) => Ok(name.clone()),\n            None => Err(\"The requested ID is not available in current dictionary.\".to_string()),\n        }"
            },
            {
                "file": "vocabulary.rs",
                "doc": [
                    " Return the id of given key.",
                    "",
                    " # Arguments",
                    "",
                    " * `key`: &str - the key whose Id is to be retrieved."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "key",
                        "&str"
                    ]
                ],
                "return_type": "Option<&IndexT>",
                "body": "self.map.get(key)"
            },
            {
                "file": "vocabulary.rs",
                "doc": [
                    " Return vector of keys of the map."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "keys",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "self.map.keys().cloned().collect()"
            },
            {
                "file": "vocabulary.rs",
                "doc": [
                    " Return boolean representing if given key is present.",
                    "",
                    " # Arguments",
                    "",
                    " * `key`: &str - the key to check existance of."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "contains_key",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "key",
                        "&str"
                    ]
                ],
                "return_type": "bool",
                "body": "self.map.contains_key(key)"
            },
            {
                "file": "vocabulary.rs",
                "doc": [
                    " Return length of the vocabulary."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "len",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "usize",
                "body": "self.map.len()"
            },
            {
                "file": "vocabulary.rs",
                "doc": [
                    " Set whether to load IDs as numeric.",
                    "",
                    " # Arguments",
                    " * numeric_ids: bool - Whether to load the IDs as numeric",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_numeric_ids",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "numeric_ids",
                        "bool"
                    ]
                ],
                "return_type": "Vocabulary<IndexT>",
                "body": "self.numeric_ids = numeric_ids;\n        self"
            }
        ]
    },
    "node_type_vocabulary.rs": {
        "imports": [
            "use super::*;",
            "use std::collections::hash_map::DefaultHasher;",
            "use std::hash::{Hash, Hasher};"
        ],
        "functions": [
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "impl_doc": [
                    " Remove a value from the vocabulary"
                ],
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "compute_hash",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "u64",
                "body": "let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        hasher.finish()"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "trait": "PartialEq",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "eq",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "other",
                        "&Self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.compute_hash() == other.compute_hash()"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "trait": "Default",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "default",
                "args": [],
                "return_type": "NodeTypeVocabulary",
                "body": "NodeTypeVocabulary {\n            ids: Vec::new(),\n            vocabulary: Vocabulary::default(),\n            counts: Vec::new(),\n            unknown_count: NodeT::from_usize(0),\n            multilabel: false,\n        }"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "from_structs",
                "args": [
                    [
                        "ids",
                        "Vec<Option<Vec<NodeTypeT>>>"
                    ],
                    [
                        "vocabulary",
                        "Option<Vocabulary<NodeTypeT>>"
                    ]
                ],
                "return_type": "Option<NodeTypeVocabulary>",
                "body": "match vocabulary {\n            Some(vocab) => {\n                let multilabel = ids\n                    .iter()\n                    .any(|node_types| node_types.as_ref().map_or(false, |nts| nts.len() > 1));\n                let mut vocabvec = NodeTypeVocabulary {\n                    ids,\n                    vocabulary: vocab,\n                    counts: Vec::new(),\n                    unknown_count: NodeT::from_usize(0),\n                    multilabel,\n                };\n                vocabvec.build_counts();\n                Some(vocabvec)\n            }\n            None => None,\n        }"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "build_counts",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "body": "let mut counts = vec![NodeT::from_usize(0); self.vocabulary.len()];\n        for index in self.ids.iter() {\n            match index {\n                Some(values) => {\n                    values.iter().for_each(|value| {\n                        counts[NodeTypeT::to_usize(*value)] += NodeT::from_usize(1)\n                    });\n                }\n                None => self.unknown_count += NodeT::from_usize(1),\n            }\n        }\n        self.counts = counts;"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Computes the reverse terms mapping.",
                    "",
                    " # Raises",
                    " * If the terms mapping is found to be not dense."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "build_reverse_mapping",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "self.vocabulary.build_reverse_mapping()"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Returns ids of given values inserted.",
                    "",
                    " This method will crash if improper parameters are used.",
                    "",
                    " # Arguments",
                    "",
                    " * `maybe_values`: Option<Vec<S>> - The values to be inserted."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "unchecked_insert_values",
                "generics": "S: AsRef<str> + Into<String> + std::fmt::Debug",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "maybe_values",
                        "Option<Vec<S>>"
                    ]
                ],
                "return_type": "Option<Vec<NodeTypeT>>",
                "body": "match maybe_values {\n            Some(values) => {\n                // Retrieve the ID\n                let ids = values\n                    .into_iter()\n                    .map(|value| self.vocabulary.unchecked_insert(value.into()))\n                    .collect::<Vec<NodeTypeT>>();\n\n                self.multilabel = self.multilabel || ids.len() > 1;\n\n                // Push the sorted IDs\n                self.ids.push(Some(ids.clone()));\n                Some(ids)\n            }\n            None => {\n                self.ids.push(None);\n                None\n            }\n        }"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Returns ids of given values inserted.",
                    "",
                    " # Arguments",
                    "",
                    " * `maybe_values`: Option<Vec<S>> - The values to be inserted."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "insert_values",
                "generics": "S: AsRef<str> + std::fmt::Debug",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "maybe_values",
                        "Option<Vec<S>>"
                    ]
                ],
                "return_type": "Result<Option<Vec<NodeTypeT>>, String>",
                "body": "Ok(match maybe_values {\n            Some(values) => {\n                // Check if there is at least one node type\n                if values.is_empty() {\n                    return Err(\"The given node types vector is empty.\".to_owned());\n                }\n                // Retrieve the ID\n                let mut ids = values\n                    .iter()\n                    .map(|value| {\n                        self.vocabulary\n                            .insert(value.as_ref())\n                            .map(|values| values.0)\n                    })\n                    .collect::<Result<Vec<NodeTypeT>, String>>()?;\n                // Sort the slice\n                ids.sort_unstable();\n\n                // check for duplicates\n                if ids[..ids.len() - 1]\n                    .iter()\n                    .zip(ids[1..].iter())\n                    .any(|(a, b)| a == b)\n                {\n                    return Err(format!(\n                        concat!(\n                            \"Node with duplicated node types was provided.\\n\",\n                            \"Specifically the node types vector of the node is {:?} \",\n                        ),\n                        values\n                    ));\n                }\n                self.multilabel = self.multilabel || ids.len() > 1;\n                // Push the sorted IDs\n                self.ids.push(Some(ids.clone()));\n                Some(ids)\n            }\n            None => {\n                self.ids.push(None);\n                None\n            }\n        })"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Returns whether the vocabulary is empty or not."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_empty",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.vocabulary.is_empty()"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Returns whether the node types are multi-label or not."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_multilabel",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.multilabel"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Returns number of minimum node-count."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "min_node_type_count",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "NodeT",
                "body": "*self.counts.iter().min().unwrap_or(&0)"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Returns number of unknown nodes."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unknown_count",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "NodeT",
                "body": "self.unknown_count"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Returns string name of given id.",
                    "",
                    " # Arguments",
                    "",
                    " * `id`: NodeTypeT - Node Type ID to be translated."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "unchecked_translate",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "id",
                        "NodeTypeT"
                    ]
                ],
                "return_type": "String",
                "body": "self.vocabulary.unchecked_translate(id)"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Returns string name of given id.",
                    "",
                    " # Arguments",
                    "",
                    " * `id`: NodeTypeT - Node Type ID to be translated."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "translate",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "id",
                        "NodeTypeT"
                    ]
                ],
                "return_type": "Result<String, String>",
                "body": "self.vocabulary.translate(id)"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Returns string name of given id.",
                    "",
                    " # Arguments",
                    "",
                    " * `ids`: Vec<NodeTypeT> - Node Type IDs to be translated."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "unchecked_translate_vector",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "ids",
                        "Vec<NodeTypeT>"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "ids.into_iter()\n            .map(|id| self.unchecked_translate(id))\n            .collect()"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Returns string name of given id.",
                    "",
                    " # Arguments",
                    "",
                    " * `ids`: Vec<NodeTypeT> - Node Type IDs to be translated."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "translate_vector",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "ids",
                        "Vec<NodeTypeT>"
                    ]
                ],
                "return_type": "Result<Vec<String>, String>",
                "body": "ids.into_iter().map(|id| self.translate(id)).collect()"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Return the id of given key.",
                    "",
                    " # Arguments",
                    "",
                    " * `key`: &str - the key whose Id is to be retrieved."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "key",
                        "&str"
                    ]
                ],
                "return_type": "Option<&NodeTypeT>",
                "body": "self.vocabulary.get(key)"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Return vector of keys of the map."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "keys",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "self.vocabulary.keys()"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Return length of the vocabulary."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "len",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "usize",
                "body": "self.counts.len()"
            },
            {
                "file": "node_type_vocabulary.rs",
                "struct": "NodeTypeVocabulary",
                "doc": [
                    " Set whether to load IDs as numeric.",
                    "",
                    " # Arguments",
                    " * numeric_ids: bool - Whether to load the IDs as numeric",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_numeric_ids",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "numeric_ids",
                        "bool"
                    ]
                ],
                "return_type": "NodeTypeVocabulary",
                "body": "self.vocabulary = self.vocabulary.set_numeric_ids(numeric_ids);\n        self"
            }
        ]
    },
    "node_file_reader.rs": {
        "imports": [
            "use super::*;"
        ],
        "functions": [
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Return new NodeFileReader object.",
                    "",
                    " # Arguments",
                    "",
                    " * reader: CSVFileParameters - Path where to store/load the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "new",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "path",
                        "S"
                    ]
                ],
                "return_type": "Result<NodeFileReader, String>",
                "body": "Ok(NodeFileReader {\n            reader: CSVFileReader::new(path, \"node list\".to_owned())?,\n            default_node_type: None,\n            nodes_column_number: None,\n            node_types_separator: None,\n            node_types_column_number: None,\n            numeric_node_ids: false,\n            numeric_node_type_ids: false,\n            skip_node_types_if_unavailable: false,\n            might_have_singletons: true,\n        })"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the column of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * nodes_column: Option<String> - The nodes column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_nodes_column",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "nodes_column",
                        "Option<S>"
                    ]
                ],
                "return_type": "Result<NodeFileReader, String>",
                "body": "if let Some(column) = nodes_column {\n            let column = column.into();\n            if column.is_empty() {\n                return Err(\"The given node column is empty.\".to_owned());\n            }\n            self.nodes_column_number = Some(self.reader.get_column_number(column)?);\n        }\n        Ok(self)"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the column_number of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * nodes_column_number: Option<usize> - The nodes column_number to use for the file.",
                    "t"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_nodes_column_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "nodes_column_number",
                        "Option<usize>"
                    ]
                ],
                "return_type": "NodeFileReader",
                "body": "self.nodes_column_number = nodes_column_number;\n        self"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the name of the graph to be loaded.",
                    "",
                    " # Arguments",
                    "",
                    " * graph_name: String - The name of the graph to be loaded.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "set_graph_name",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "graph_name",
                        "String"
                    ]
                ],
                "return_type": "NodeFileReader",
                "body": "self.reader.graph_name = graph_name;\n        self"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the column of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * node_types_column: Option<String> - The node types column to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_node_types_column",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "nodes_type_column",
                        "Option<S>"
                    ]
                ],
                "return_type": "Result<NodeFileReader, String>",
                "body": "if let Some(column) = nodes_type_column {\n            let column = column.into();\n            if column.is_empty() {\n                return Err(\"The given node types column is empty.\".to_owned());\n            }\n            match self.reader.get_column_number(column) {\n                Ok(ecn) => {\n                    self.node_types_column_number = Some(ecn);\n                }\n                Err(e) => {\n                    if !self.skip_node_types_if_unavailable {\n                        return Err(e);\n                    }\n                }\n            }\n        }\n        Ok(self)"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the column_number of the nodes.",
                    "",
                    " # Arguments",
                    "",
                    " * node_types_column_number: Option<usize> - The node types column_number to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_node_types_column_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "node_types_column_number",
                        "Option<usize>"
                    ]
                ],
                "return_type": "NodeFileReader",
                "body": "self.node_types_column_number = node_types_column_number;\n        self"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set whether to automatically skip node_types if they are not avaitable instead of raising an exception.",
                    "",
                    " # Arguments",
                    "",
                    " * skip_node_types_if_unavailable: Option<bool> - Whether to skip node_types if they are not available.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_skip_node_types_if_unavailable",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "skip_node_types_if_unavailable",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<NodeFileReader, String>",
                "body": "if let Some(skip) = skip_node_types_if_unavailable {\n            self.skip_node_types_if_unavailable = skip;\n        }\n        Ok(self)"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set whether you pinky promise that this graph has singletons or not.",
                    "",
                    " # Arguments",
                    "",
                    " * `might_have_singletons`: Option<bool> - Whether this graph has singletons.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_might_have_singleton_nodes",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "might_have_singletons",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<NodeFileReader, String>",
                "body": "if let Some(skip) = might_have_singletons {\n            self.might_have_singletons = skip;\n        }\n        Ok(self)"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the comment symbol to use to skip the lines.",
                    "",
                    " # Arguments",
                    "",
                    " * comment_symbol: Option<String> - if the reader should ignore or not duplicated edges.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_comment_symbol",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "comment_symbol",
                        "Option<String>"
                    ]
                ],
                "return_type": "Result<NodeFileReader, String>",
                "body": "if let Some(cs) = comment_symbol {\n            if cs.is_empty() {\n                return Err(\"The given comment symbol is empty.\".to_string());\n            }\n            self.reader.comment_symbol = Some(cs);\n        }\n        Ok(self)"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set whether the CSV is expected to be well written.",
                    "",
                    " # Arguments",
                    "",
                    " * csv_is_correct: Option<bool> - Whether you pinky swear the node list is correct.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_csv_is_correct",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "csv_is_correct",
                        "Option<bool>"
                    ]
                ],
                "return_type": "NodeFileReader",
                "body": "if let Some(cic) = csv_is_correct {\n            self.reader.csv_is_correct = cic;\n        }\n        self"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the default node type.",
                    "",
                    " # Arguments",
                    "",
                    " * default_node_type: Option<String> - The node type to use when node type is missing.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_default_node_type",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "default_node_type",
                        "Option<S>"
                    ]
                ],
                "return_type": "NodeFileReader",
                "body": "self.default_node_type = default_node_type.map(|val| val.into());\n        self"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the verbose.",
                    "",
                    " # Arguments",
                    "",
                    " * `verbose`: Option<bool> - Whether to show the loading bar or not.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_verbose",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "NodeFileReader",
                "body": "if let Some(v) = verbose {\n            self.reader.verbose = v;\n        }\n        self"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the numeric_id.",
                    "",
                    " # Arguments",
                    "",
                    " * numeric_node_type_ids: Option<bool> - Whether to convert numeric node type Ids to Node Type Ids.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_numeric_node_type_ids",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "numeric_node_type_ids",
                        "Option<bool>"
                    ]
                ],
                "return_type": "NodeFileReader",
                "body": "if let Some(nnti) = numeric_node_type_ids {\n            self.numeric_node_type_ids = nnti;\n        }\n        self"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the numeric_id.",
                    "",
                    " # Arguments",
                    "",
                    " * numeric_node_ids: Option<bool> - Whether to convert numeric node type Ids to Node Type Ids.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_numeric_node_ids",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "numeric_node_ids",
                        "Option<bool>"
                    ]
                ],
                "return_type": "NodeFileReader",
                "body": "if let Some(nni) = numeric_node_ids {\n            self.numeric_node_ids = nni;\n        }\n        self"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the ignore_duplicates.",
                    "",
                    " # Arguments",
                    "",
                    " * ignore_duplicates: Option<bool> - Whether to ignore detected duplicates or raise exception.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_ignore_duplicates",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "ignore_duplicates",
                        "Option<bool>"
                    ]
                ],
                "return_type": "NodeFileReader",
                "body": "if let Some(v) = ignore_duplicates {\n            self.reader.ignore_duplicates = v;\n        }\n        self"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the separator.",
                    "",
                    " # Arguments",
                    "",
                    " * separator: Option<String> - The separator to use for the file.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_separator",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "separator",
                        "Option<S>"
                    ]
                ],
                "return_type": "Result<NodeFileReader, String>",
                "body": "if let Some(sep) = separator {\n            let sep = sep.into();\n            if sep.is_empty() {\n                return Err(\"The separator cannot be empty.\".to_owned());\n            }\n            self.reader.separator = sep;\n        }\n        Ok(self)"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the node types separator.",
                    "",
                    " In the following example we show a column of node IDs and",
                    " a column of node types.",
                    "",
                    " ```bash",
                    " node_id_columns node_types",
                    " node_A node_type_1|node_type_2",
                    " node_B node_type_2",
                    " ```",
                    "",
                    " # Arguments",
                    "",
                    " * node_types_separator: Option<String> - The separator to use for the node types column.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_node_types_separator",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "node_types_separator",
                        "Option<S>"
                    ]
                ],
                "return_type": "Result<NodeFileReader, String>",
                "body": "if let Some(sep) = node_types_separator {\n            let sep = sep.into();\n            if sep.is_empty() {\n                return Err(\"The node type separator cannot be empty.\".to_owned());\n            }\n            self.node_types_separator = Some(sep);\n        }\n        Ok(self)"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the header.",
                    "",
                    " # Arguments",
                    "",
                    " * header: Option<bool> - Whether to expect an header or not.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_header",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "header",
                        "Option<bool>"
                    ]
                ],
                "return_type": "NodeFileReader",
                "body": "if let Some(v) = header {\n            self.reader.header = v;\n        }\n        self"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set number of rows to be skipped when starting to read file.",
                    "",
                    " # Arguments",
                    "",
                    " * rows_to_skip: Option<bool> - Whether to show the loading bar or not.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_rows_to_skip",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "rows_to_skip",
                        "Option<usize>"
                    ]
                ],
                "return_type": "NodeFileReader",
                "body": "if let Some(v) = rows_to_skip {\n            self.reader.rows_to_skip = v;\n        }\n        self"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Set the maximum number of rows to load from the file",
                    "",
                    " # Arguments",
                    "",
                    " * max_rows_number: Option<u64> - The edge type to use when edge type is missing.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_max_rows_number",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "max_rows_number",
                        "Option<u64>"
                    ]
                ],
                "return_type": "NodeFileReader",
                "body": "self.reader.max_rows_number = max_rows_number;\n        self"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Return boolean representing if the node types exist."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_node_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.default_node_type.is_some() || self.node_types_column_number.is_some()"
            },
            {
                "file": "node_file_reader.rs",
                "struct": "NodeFileReader",
                "impl_doc": [
                    " Structure that saves the reader specific to writing and reading a nodes csv file.",
                    "",
                    " # Attributes",
                    " * reader: CSVFile - The common reader for reading and writing a csv.",
                    " * default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
                    " * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
                    " * node_types_separator: Option<String> - Separator to split the node types.",
                    " * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
                    " * numeric_node_ids: bool - Whether to load the node IDs as numeric.",
                    " * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
                    " * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
                    ""
                ],
                "doc": [
                    " Return iterator of the lines of the node file."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "read_lines",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>> + '_, String>",
                "body": "// Validating that at least a column was given.\n        if [self.nodes_column_number, self.node_types_column_number]\n            .iter()\n            .all(|val| val.is_none())\n        {\n            return Err(\"Neither nodes ID column or node types column were given!\".to_string());\n        }\n\n        // Check that the two columns do not have the same value.\n        if self.nodes_column_number == self.node_types_column_number {\n            return Err(\"The node column is the same as the node type one.\".to_string());\n        }\n\n        // Retrieve the expected maximum number of columns.\n        let expected_number_of_elements = self.reader.get_elements_per_line()?;\n\n        // Check that the two columns do not have a value higher than the maximum amount.\n        for column in [self.nodes_column_number, self.node_types_column_number]\n            .iter()\n            .filter_map(|maybe_column| *maybe_column)\n        {\n            if column >= expected_number_of_elements {\n                return Err(format!(\n                    concat!(\n                        \"A column number passed was {} but \",\n                        \"the first parsable line has {} values.\"\n                    ),\n                    column, expected_number_of_elements\n                ));\n            }\n        }\n\n        Ok(self\n            .reader\n            .read_lines()?\n            .enumerate()\n            .map(move |(line_number, values)| match values {\n                Ok(vals) => {\n                    let node_name = match self.nodes_column_number {\n                        Some(column) => match vals[column].to_owned() {\n                            Some(node_name) => node_name,\n                            None => {\n                                return Err(\n                                    \"One of the provided node IDs is empty or None.\".to_owned()\n                                )\n                            }\n                        },\n                        None => line_number.to_string(),\n                    };\n                    let maybe_node_types_string = match self.node_types_column_number {\n                        Some(column) => match vals[column].to_owned() {\n                            Some(node_type) => Some(node_type),\n                            None => self.default_node_type.clone(),\n                        },\n                        None => self.default_node_type.clone(),\n                    };\n\n                    // Split given node types using the provided node type separator.\n                    let node_types = match maybe_node_types_string {\n                        Some(string) => match &self.node_types_separator {\n                            Some(sep) => Some(string.split(sep).map(String::from).collect()),\n                            None => Some(vec![string]),\n                        },\n                        None => None,\n                    };\n\n                    // Return tuple with string and list of node types\n                    Ok((node_name, node_types))\n                }\n                Err(e) => Err(e),\n            }))"
            }
        ]
    },
    "edge_type_vocabulary.rs": {
        "imports": [
            "use super::*;",
            "use std::collections::hash_map::DefaultHasher;",
            "use std::hash::{Hash, Hasher};"
        ],
        "functions": [
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "compute_hash",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "u64",
                "body": "let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        hasher.finish()"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "trait": "PartialEq",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "eq",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "other",
                        "&Self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.compute_hash() == other.compute_hash()"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "default",
                "args": [],
                "return_type": "EdgeTypeVocabulary",
                "body": "EdgeTypeVocabulary {\n            ids: Vec::new(),\n            vocabulary: Vocabulary::default(),\n            counts: Vec::new(),\n            unknown_count: EdgeT::from_usize(0),\n        }"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "from_structs",
                "args": [
                    [
                        "ids",
                        "Vec<Option<EdgeTypeT>>"
                    ],
                    [
                        "vocabulary",
                        "Vocabulary<EdgeTypeT>"
                    ]
                ],
                "return_type": "EdgeTypeVocabulary",
                "body": "let mut vocabvec = EdgeTypeVocabulary {\n            ids,\n            vocabulary,\n            counts: Vec::new(),\n            unknown_count: EdgeT::from_usize(0),\n        };\n\n        vocabvec.build_counts();\n\n        vocabvec"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "from_option_structs",
                "args": [
                    [
                        "ids",
                        "Option<Vec<Option<EdgeTypeT>>>"
                    ],
                    [
                        "vocabulary",
                        "Option<Vocabulary<EdgeTypeT>>"
                    ]
                ],
                "return_type": "Option<EdgeTypeVocabulary>",
                "body": "if let (Some(ids), Some(vocabulary)) = (ids, vocabulary) {\n            Some(EdgeTypeVocabulary::from_structs(ids, vocabulary))\n        } else {\n            None\n        }"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [],
                "attrs": [],
                "modifiers": "pub",
                "name": "build_counts",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "body": "self.counts = vec![EdgeT::from_usize(0); self.vocabulary.len()];\n        for index in self.ids.iter() {\n            match index {\n                Some(value) => {\n                    self.counts[*value as usize] += 1;\n                }\n                None => self.unknown_count += EdgeT::from_usize(1),\n            }\n        }"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [
                    " Returns whether the value is empty or not."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_empty",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.vocabulary.is_empty()"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [
                    " Returns string name of given id.",
                    "",
                    " # Arguments",
                    "",
                    " * `id`: EdgeTypeT - Id to be translated."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "unchecked_translate",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "id",
                        "EdgeTypeT"
                    ]
                ],
                "return_type": "String",
                "body": "self.vocabulary.unchecked_translate(id)"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [
                    " Returns string name of given id.",
                    "",
                    " # Arguments",
                    "",
                    " * `id`: EdgeTypeT - Id to be translated."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "translate",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "id",
                        "EdgeTypeT"
                    ]
                ],
                "return_type": "Result<String, String>",
                "body": "self.vocabulary.translate(id)"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [
                    " Return the id of given key.",
                    "",
                    " # Arguments",
                    "",
                    " * `key`: &str - the key whose Id is to be retrieved."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "key",
                        "&str"
                    ]
                ],
                "return_type": "Option<&EdgeTypeT>",
                "body": "self.vocabulary.get(key)"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [
                    " Return vector of keys of the map."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "keys",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "self.vocabulary.keys()"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [
                    " Return length of the vocabulary."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "len",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "usize",
                "body": "self.counts.len()"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [
                    " Set whether to load IDs as numeric.",
                    "",
                    " # Arguments",
                    " * numeric_ids: bool - Whether to load the IDs as numeric",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "set_numeric_ids",
                "args": [
                    [
                        "self",
                        "mut self"
                    ],
                    [
                        "numeric_ids",
                        "bool"
                    ]
                ],
                "return_type": "EdgeTypeVocabulary",
                "body": "self.vocabulary = self.vocabulary.set_numeric_ids(numeric_ids);\n        self"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [
                    " Returns number of unknown edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unknown_count",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "self.unknown_count"
            },
            {
                "file": "edge_type_vocabulary.rs",
                "struct": "EdgeTypeVocabulary",
                "doc": [
                    " Returns number of minimum edge-count."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "min_edge_type_count",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "*self.counts.iter().min().unwrap_or(&0)"
            }
        ]
    },
    "iters.rs": {
        "imports": [
            "use super::*;",
            "use rayon::prelude::*;"
        ],
        "functions": [
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the node IDs of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "impl Iterator<Item = NodeT> + '_",
                "body": "0..self.get_nodes_number()"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the node names of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "impl Iterator<Item = String> + '_",
                "body": "self.iter_node_ids()\n            .map(move |node_id| self.get_unchecked_node_name_from_node_id(node_id))"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the unique node type IDs of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unique_node_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = NodeTypeT> + '_, String>",
                "body": "Ok(0..self.get_node_types_number()?)"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the unique node type IDs counts of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_node_type_counts",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = NodeT> + '_, String>",
                "body": "self.must_have_node_types()\n            .map(|node_types| node_types.counts.iter().cloned())"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the unique node type IDs and their counts of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unique_node_type_ids_and_counts",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = (NodeTypeT, NodeT)> + '_, String>",
                "body": "Ok(self\n            .iter_unique_node_type_ids()?\n            .zip(self.iter_node_type_counts()?))"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the unique node type names of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unique_node_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = String> + '_, String>",
                "body": "self.must_have_node_types()\n            .map(|node_types| node_types.vocabulary.reverse_map.iter().cloned())"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the unique node type names and their counts of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unique_node_type_names_and_counts",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = (String, NodeT)> + '_, String>",
                "body": "Ok(self\n            .iter_unique_node_type_names()?\n            .zip(self.iter_node_type_counts()?))"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edge type IDs of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unique_edge_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = EdgeTypeT> + '_, String>",
                "body": "Ok(0..self.get_edge_types_number()?)"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the unique edge type IDs counts of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_edge_type_counts",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = EdgeT> + '_, String>",
                "body": "self.must_have_edge_types()\n            .map(|edge_types| edge_types.counts.iter().cloned())"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the unique edge type IDs and their counts of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unique_edge_type_ids_and_counts",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = (EdgeTypeT, EdgeT)> + '_, String>",
                "body": "Ok(self\n            .iter_unique_edge_type_ids()?\n            .zip(self.iter_edge_type_counts()?))"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the unique edge type names and their counts of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unique_edge_type_names_and_counts",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = (String, EdgeT)> + '_, String>",
                "body": "Ok(self\n            .iter_unique_edge_type_names()?\n            .zip(self.iter_edge_type_counts()?))"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the unique edge type names of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unique_edge_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = String> + '_, String>",
                "body": "self.must_have_edge_types()\n            .map(|edge_types| edge_types.vocabulary.reverse_map.iter().cloned())"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the node of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "impl IndexedParallelIterator<Item = NodeT> + '_",
                "body": "(0..self.get_nodes_number()).into_par_iter()"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the unweighted node degrees of the graph.",
                    "",
                    " Note that with unweighted it is meant that if this graph instance",
                    " has weights, the degree will not take them into consideration."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unweighted_node_degrees",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "impl Iterator<Item = NodeT> + '_",
                "body": "self.iter_node_ids()\n            .map(move |node| self.get_unchecked_unweighted_node_degree_from_node_id(node))"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the unweighted node degrees of the graph.",
                    "",
                    " Note that with unweighted it is meant that if this graph instance",
                    " has weights, the degree will not take them into consideration."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_unweighted_node_degrees",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "impl IndexedParallelIterator<Item = NodeT> + '_",
                "body": "self.par_iter_node_ids()\n            .map(move |node_id| self.get_unchecked_unweighted_node_degree_from_node_id(node_id))"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the weighted node degrees of the graph.",
                    "",
                    " Note that with weighted it is meant that if this graph instance",
                    " has weights, the degree will be weighted on the edge weight.",
                    "",
                    " Note that if one or more edges have a negative edge weight,",
                    " the resulting node degree may be negative.",
                    " This check is **NOT** done by this method, as in some situations",
                    " this may be desired by the user."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_weighted_node_degrees",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "impl Iterator<Item = WeightT> + '_",
                "body": "self.iter_node_ids()\n            .map(move |node_id| self.get_unchecked_weighted_node_degree_from_node_id(node_id))"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the weighted node degrees of the graph.",
                    "",
                    " Note that with weighted it is meant that if this graph instance",
                    " has weights, the degree will not take them into consideration.",
                    "",
                    " Note that if one or more edges have a negative edge weight,",
                    " the resulting node degree may be negative.",
                    " This check is **NOT** done by this method, as in some situations",
                    " this may be desired by the user."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_weighted_node_degrees",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "impl IndexedParallelIterator<Item = WeightT> + '_",
                "body": "self.par_iter_node_ids()\n            .map(move |node_id| self.get_unchecked_weighted_node_degree_from_node_id(node_id))"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the non-singleton nodes of the graph.",
                    "",
                    " Note that this includes also the singleton with self-loops and",
                    " the trap nodes within this iterator. Only true singleton nodes,",
                    " that is, nodes without any edge (both inbound and outbound) are",
                    " included.",
                    "",
                    " Since the following requires to be boxed, we cannot create the",
                    " parallel version of this iterator.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_connected_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Box<dyn Iterator<Item = NodeT> + '_>",
                "body": "match self.connected_nodes.as_ref() {\n            Some(nsns) => Box::new(nsns.iter_ones().map(|node_id| node_id as NodeT)),\n            _ => Box::new(self.iter_node_ids()),\n        }"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the singleton nodes IDs of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_singleton_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Box<dyn Iterator<Item = NodeT> + '_>",
                "body": "match self.connected_nodes.as_ref() {\n            Some(nsns) => Box::new(nsns.iter_zeros().map(|node_id| node_id as NodeT)),\n            _ => Box::new(::std::iter::empty()),\n        }"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the singleton nodes names of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_singleton_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "impl Iterator<Item = String> + '_",
                "body": "self.iter_singleton_node_ids()\n            .map(move |node_id| self.get_unchecked_node_name_from_node_id(node_id))"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the singleton with selfloops node IDs of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_singleton_with_selfloops_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Box<dyn Iterator<Item = NodeT> + '_>",
                "body": "match self.singleton_nodes_with_selfloops.as_ref() {\n            Some(nsns) => Box::new(nsns.iter()),\n            _ => Box::new(::std::iter::empty()),\n        }"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the singleton with selfloops node names of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_singleton_with_selfloops_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "impl Iterator<Item = String> + '_",
                "body": "self.iter_singleton_with_selfloops_node_ids()\n            .map(move |node_id| self.get_unchecked_node_name_from_node_id(node_id))"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the singleton node type IDs of the graph.",
                    "",
                    " # Raises",
                    " * If there are no node types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_singleton_node_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = NodeTypeT> + '_, String>",
                "body": "self.iter_unique_node_type_ids_and_counts()\n            .map(|iter_unique_node_type_ids_and_counts| {\n                iter_unique_node_type_ids_and_counts.filter_map(|(node_type_id, count)| {\n                    if count == 1 {\n                        Some(node_type_id)\n                    } else {\n                        None\n                    }\n                })\n            })"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the singleton edge type IDs of the graph.",
                    "",
                    " # Raises",
                    " * If there are no edge types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_singleton_edge_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = EdgeTypeT> + '_, String>",
                "body": "self.iter_unique_edge_type_ids_and_counts()\n            .map(|iter_unique_edge_type_ids_and_counts| {\n                iter_unique_edge_type_ids_and_counts.filter_map(|(edge_type_id, count)| {\n                    if count == 1 {\n                        Some(edge_type_id)\n                    } else {\n                        None\n                    }\n                })\n            })"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the singleton node type names of the graph.",
                    "",
                    " # Raises",
                    " * If there are no node types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_singleton_node_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = String> + '_, String>",
                "body": "self.iter_unique_node_type_names_and_counts().map(\n            |iter_unique_node_type_names_and_counts| {\n                iter_unique_node_type_names_and_counts.filter_map(|(node_type_id, count)| {\n                    if count == 1 {\n                        Some(node_type_id)\n                    } else {\n                        None\n                    }\n                })\n            },\n        )"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the singleton edge type names of the graph.",
                    "",
                    " # Raises",
                    " * If there are no edge types in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_singleton_edge_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = String> + '_, String>",
                "body": "self.iter_unique_edge_type_names_and_counts().map(\n            |iter_unique_edge_type_names_and_counts| {\n                iter_unique_edge_type_names_and_counts.filter_map(|(edge_type_id, count)| {\n                    if count == 1 {\n                        Some(edge_type_id)\n                    } else {\n                        None\n                    }\n                })\n            },\n        )"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the (non unique) source nodes of the graph.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_source_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl Iterator<Item = NodeT> + '_",
                "body": "self.iter_edge_ids(directed).map(move |(_, src, _)| src)"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges' weights.",
                    "",
                    " # Example",
                    " To get an iterator over the edges weights you can use:",
                    " ```rust",
                    " # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);",
                    " # let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);",
                    " assert!(graph_with_weights.iter_edge_weights().is_ok());",
                    " assert!(graph_without_weights.iter_edge_weights().is_err());",
                    " println!(\"The graph weights are {:?}.\", graph_with_weights.iter_edge_weights().unwrap().collect::<Vec<_>>());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_edge_weights",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = WeightT> + '_, String>",
                "body": "self.must_have_edge_weights()?;\n        Ok(self.weights.as_ref().map(|ws| ws.iter().cloned()).unwrap())"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return parallel iterator on the edges' weights.",
                    "",
                    " # Example",
                    " To get an iterator over the edges weights you can use:",
                    " ```rust",
                    " # use rayon::iter::ParallelIterator;",
                    " # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);",
                    " # let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);",
                    " assert!(graph_with_weights.iter_edge_weights().is_ok());",
                    " assert!(graph_without_weights.iter_edge_weights().is_err());",
                    " println!(\"The graph weights are {:?}.\", graph_with_weights.par_iter_edge_weights().unwrap().collect::<Vec<_>>());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_edge_weights",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl ParallelIterator<Item = WeightT> + '_, String>",
                "body": "self.must_have_edge_weights()?;\n        Ok(self\n            .weights\n            .as_ref()\n            .map(|ws| ws.par_iter().cloned())\n            .unwrap())"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return parallel iterator on the (non unique) source nodes of the graph.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_source_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl ParallelIterator<Item = NodeT> + '_",
                "body": "self.par_iter_edge_ids(directed).map(move |(_, src, _)| src)"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the (non unique) destination nodes of the graph.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_destination_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl Iterator<Item = NodeT> + '_",
                "body": "self.iter_edge_ids(directed).map(move |(_, _, dst)| dst)"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return parallel iterator on the (non unique) destination nodes of the graph.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_destination_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl ParallelIterator<Item = NodeT> + '_",
                "body": "self.par_iter_edge_ids(directed).map(move |(_, _, dst)| dst)"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the node IDs and ther node type IDs."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_node_ids_and_node_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "impl Iterator<Item = (NodeT, Option<Vec<NodeTypeT>>)> + '_",
                "body": "self.iter_node_ids().map(move |node_id| unsafe {\n            (\n                node_id,\n                self.get_unchecked_node_type_id_from_node_id(node_id),\n            )\n        })"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the node type IDs.",
                    " Return iterator on the one-hot encoded node type IDs."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_one_hot_encoded_node_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = Vec<bool>> + '_, String>",
                "body": "let node_types_number = self.get_node_types_number()?;\n        Ok(unsafe {\n            self.iter_unchecked_node_type_ids()\n                .map(move |maybe_node_types| {\n                    let mut dummies = vec![false; node_types_number as usize];\n                    if let Some(node_types) = maybe_node_types {\n                        node_types.into_iter().for_each(|node_type| {\n                            dummies[node_type as usize] = true;\n                        });\n                    }\n                    dummies\n                })\n        })"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the node of the graph.",
                    " Return iterator on the node of the graph as Strings."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_node_names_and_node_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "impl Iterator<Item = (NodeT, String, Option<Vec<NodeTypeT>>, Option<Vec<String>>)> + '_",
                "body": "self.iter_node_ids_and_node_type_ids()\n            .map(move |(node_id, node_types)| unsafe {\n                (\n                    node_id,\n                    self.get_unchecked_node_name_from_node_id(node_id),\n                    node_types,\n                    self.get_unchecked_node_type_names_from_node_id(node_id),\n                )\n            })"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges of the graph.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_edge_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "Box<dyn Iterator<Item = (EdgeT, NodeT, NodeT)> + '_>",
                "body": "if self.sources.is_some() && self.destinations.is_some() {\n            return Box::new(\n                (0..self.get_directed_edges_number()).filter_map(move |edge_id| {\n                    let (src, dst) = self.get_unchecked_node_ids_from_edge_id(edge_id);\n                    if !directed && src > dst {\n                        return None;\n                    }\n                    Some((edge_id, src, dst))\n                }),\n            );\n        }\n        Box::new(\n            self.edges\n                .iter()\n                .enumerate()\n                .filter_map(move |(edge_id, edge)| {\n                    let (src, dst) = self.decode_edge(edge);\n                    if !directed && src > dst {\n                        return None;\n                    }\n                    Some((edge_id as EdgeT, src, dst))\n                }),\n        )"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges of the graph with the string name.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_edges",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl Iterator<Item = (EdgeT, NodeT, String, NodeT, String)> + '_",
                "body": "self.iter_edge_ids(directed)\n            .map(move |(edge_id, src, dst)| {\n                (\n                    edge_id,\n                    src,\n                    self.get_unchecked_node_name_from_node_id(src),\n                    dst,\n                    self.get_unchecked_node_name_from_node_id(dst),\n                )\n            })"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges of the graph.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_edge_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl ParallelIterator<Item = (EdgeT, NodeT, NodeT)> + '_",
                "body": "self.edges\n            .par_enumerate()\n            .filter_map(move |(edge_id, edge)| {\n                let (src, dst) = self.decode_edge(edge);\n                if !directed && src > dst {\n                    return None;\n                }\n                Some((edge_id as EdgeT, src, dst))\n            })"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges of the graph with the string name.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_edges",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl ParallelIterator<Item = (EdgeT, NodeT, String, NodeT, String)> + '_",
                "body": "self.par_iter_edge_ids(directed)\n            .map(move |(edge_id, src, dst)| {\n                (\n                    edge_id,\n                    src,\n                    self.get_unchecked_node_name_from_node_id(src),\n                    dst,\n                    self.get_unchecked_node_name_from_node_id(dst),\n                )\n            })"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges of the graph.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_edge_node_ids_and_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl Iterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>)> + '_",
                "body": "self.iter_edge_ids(directed)\n            .map(move |(edge_id, src, dst)| {\n                (\n                    edge_id,\n                    src,\n                    dst,\n                    self.get_unchecked_edge_type_id_from_edge_id(edge_id),\n                )\n            })"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the one-hot encoded edge type IDs.",
                    "",
                    " # Raises",
                    " * If the current graph instance does not contain edge types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_one_hot_encoded_edge_type_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<impl Iterator<Item = Vec<bool>> + '_, String>",
                "body": "let edge_types_number = self.get_edge_types_number()?;\n        Ok(self\n            .get_edge_type_ids()?\n            .into_iter()\n            .map(move |maybe_edge_type| {\n                let mut dummies = vec![false; edge_types_number as usize];\n                if let Some(edge_type) = maybe_edge_type {\n                    dummies[edge_type as usize] = true;\n                }\n                dummies\n            }))"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges of the graph with the string name.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_edge_node_names_and_edge_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl Iterator<\n        Item = (\n            EdgeT,\n            NodeT,\n            String,\n            NodeT,\n            String,\n            Option<EdgeTypeT>,\n            Option<String>,\n        ),\n    > + '_",
                "body": "self.iter_edges(directed)\n            .map(move |(edge_id, src, src_name, dst, dst_name)| {\n                let edge_type_id = self.get_unchecked_edge_type_id_from_edge_id(edge_id);\n                (\n                    edge_id,\n                    src,\n                    src_name,\n                    dst,\n                    dst_name,\n                    edge_type_id,\n                    self.get_unchecked_edge_type_name_from_edge_type_id(edge_type_id),\n                )\n            })"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges of the graph with the ids and string name.",
                    " The result is (edge_id, src, src_name, dst, dst_name, edge_type, edge_type_name)",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_edge_node_names_and_edge_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl ParallelIterator<\n        Item = (\n            EdgeT,\n            NodeT,\n            String,\n            NodeT,\n            String,\n            Option<EdgeTypeT>,\n            Option<String>,\n        ),\n    > + '_",
                "body": "self.par_iter_edges(directed)\n            .map(move |(edge_id, src, src_name, dst, dst_name)| {\n                let edge_type_id = self.get_unchecked_edge_type_id_from_edge_id(edge_id);\n                (\n                    edge_id,\n                    src,\n                    src_name,\n                    dst,\n                    dst_name,\n                    edge_type_id,\n                    self.get_unchecked_edge_type_name_from_edge_type_id(edge_type_id),\n                )\n            })"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges of the graph.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_edge_node_ids_and_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl ParallelIterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>)> + '_",
                "body": "self.par_iter_edge_ids(directed)\n            .map(move |(edge_id, src, dst)| {\n                (\n                    edge_id,\n                    src,\n                    dst,\n                    self.get_unchecked_edge_type_id_from_edge_id(edge_id),\n                )\n            })"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges of the graph with the string name.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_edge_node_names_and_edge_type_name_and_edge_weight",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl ParallelIterator<\n        Item = (\n            EdgeT,\n            NodeT,\n            String,\n            NodeT,\n            String,\n            Option<EdgeTypeT>,\n            Option<String>,\n            Option<WeightT>,\n        ),\n    > + '_",
                "body": "self.par_iter_edge_node_names_and_edge_type_name(directed)\n            .map(\n                move |(edge_id, src, src_name, dst, dst_name, edge_type, edge_type_name)| {\n                    (\n                        edge_id,\n                        src,\n                        src_name,\n                        dst,\n                        dst_name,\n                        edge_type,\n                        edge_type_name,\n                        self.get_unchecked_edge_weight_from_edge_id(edge_id),\n                    )\n                },\n            )"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges of the graph with the string name.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_edge_node_names_and_edge_type_name_and_edge_weight",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl Iterator<\n        Item = (\n            EdgeT,\n            NodeT,\n            String,\n            NodeT,\n            String,\n            Option<EdgeTypeT>,\n            Option<String>,\n            Option<WeightT>,\n        ),\n    > + '_",
                "body": "self.iter_edge_node_names_and_edge_type_name(directed).map(\n            move |(edge_id, src, src_name, dst, dst_name, edge_type, edge_type_name)| {\n                (\n                    edge_id,\n                    src,\n                    src_name,\n                    dst,\n                    dst_name,\n                    edge_type,\n                    edge_type_name,\n                    self.get_unchecked_edge_weight_from_edge_id(edge_id),\n                )\n            },\n        )"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges of the graph with the string name.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "par_iter_edge_node_ids_and_edge_type_id_and_edge_weight",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl ParallelIterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>)> + '_",
                "body": "self.par_iter_edge_node_ids_and_edge_type_id(directed).map(\n            move |(edge_id, src, dst, edge_type)| {\n                (\n                    edge_id,\n                    src,\n                    dst,\n                    edge_type,\n                    self.get_unchecked_edge_weight_from_edge_id(edge_id),\n                )\n            },\n        )"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges of the graph including node IDs, edge type and edge weight.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_edge_node_ids_and_edge_type_id_and_edge_weight",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "impl Iterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>)> + '_",
                "body": "self.iter_edge_node_ids_and_edge_type_id(directed).map(\n            move |(edge_id, src, dst, edge_type)| {\n                (\n                    edge_id,\n                    src,\n                    dst,\n                    edge_type,\n                    self.get_unchecked_edge_weight_from_edge_id(edge_id),\n                )\n            },\n        )"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the edges of the graph.",
                    "",
                    " # Arguments",
                    " * `directed`: bool - Whether to filter out the undirected edges."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unique_edge_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "bool"
                    ]
                ],
                "return_type": "Box<dyn Iterator<Item = (NodeT, NodeT)> + '_>",
                "body": "if self.sources.is_some() && self.destinations.is_some() {\n            return Box::new(\n                (0..self.get_directed_edges_number()).filter_map(move |edge_id| {\n                    let (src, dst) = self.get_unchecked_node_ids_from_edge_id(edge_id);\n                    if edge_id > 0 {\n                        let (last_src, last_dst) =\n                            self.get_unchecked_node_ids_from_edge_id(edge_id - 1);\n                        if last_src == src && last_dst == dst {\n                            return None;\n                        }\n                    }\n                    if !directed && src > dst {\n                        return None;\n                    }\n                    Some((src, dst))\n                }),\n            );\n        }\n        Box::new(self.edges.iter_uniques().filter_map(move |edge| {\n            let (src, dst) = self.decode_edge(edge);\n            if !directed && src > dst {\n                return None;\n            }\n            Some((src, dst))\n        }))"
            },
            {
                "file": "iters.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Iterators",
                    " The naming convention for the iterators is:",
                    " If the method has the `par_` prefix then it should return a parallel iterator.",
                    " By default all the methods retruns both the ids and the name of the item and",
                    " if the method has the suffix `_ids` then it will returns **only** the ids.",
                    " Therefore, the naming convetions are:",
                    " * `/iter_(.+)/`",
                    " * `/iter_unchecked_(.+)/`",
                    " * `/par_iter_(.+)/`",
                    " * `/par_iter_unchecked_(.+)/`"
                ],
                "doc": [
                    " Return iterator on the unique sources of the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "iter_unique_source_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Box<dyn Iterator<Item = NodeT> + '_>",
                "body": "if let Some(x) = &self.unique_sources {\n            return Box::new(x.iter().map(|source| source as NodeT));\n        }\n        Box::new(self.iter_node_ids())"
            }
        ]
    },
    "laplacian.rs": {
        "imports": [
            "use super::*;"
        ],
        "functions": [
            {
                "file": "laplacian.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Generators of laplacian-transformed graphs."
                ],
                "doc": [
                    " Returns unweighted laplacian transformation of the graph.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show a loading bar while building the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unweighted_laplacian_transformed_graph",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Graph",
                "body": "Graph::from_integer_unsorted(\n            self.iter_edge_node_ids_and_edge_type_id(true)\n                .map(|(_, src, dst, edge_type)| {\n                    Ok((\n                        src,\n                        dst,\n                        edge_type,\n                        Some(if src == dst {\n                            self.get_unchecked_unweighted_node_degree_from_node_id(src) as WeightT\n                        } else {\n                            -1.0\n                        }),\n                    ))\n                }),\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.is_directed(),\n            self.get_name(),\n            true,\n            self.has_edge_types(),\n            true,\n            self.has_singleton_nodes(),\n            self.has_singleton_nodes_with_selfloops(),\n            self.has_trap_nodes(),\n            verbose.unwrap_or(true),\n        )\n        .unwrap()"
            },
            {
                "file": "laplacian.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Generators of laplacian-transformed graphs."
                ],
                "doc": [
                    " Returns unweighted random walk normalized laplacian transformation of the graph.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show a loading bar while building the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unweighted_random_walk_normalized_laplacian_transformed_graph",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Graph",
                "body": "Graph::from_integer_unsorted(\n            self.iter_edge_node_ids_and_edge_type_id(true)\n                .map(|(_, src, dst, edge_type)| {\n                    Ok((\n                        src,\n                        dst,\n                        edge_type,\n                        Some(if src == dst {\n                            1.0\n                        } else {\n                            -1.0 / self.get_unchecked_unweighted_node_degree_from_node_id(src)\n                                as WeightT\n                        }),\n                    ))\n                }),\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.is_directed(),\n            self.get_name(),\n            true,\n            self.has_edge_types(),\n            true,\n            self.has_singleton_nodes(),\n            self.has_singleton_nodes_with_selfloops(),\n            self.has_trap_nodes(),\n            verbose.unwrap_or(true),\n        )\n        .unwrap()"
            },
            {
                "file": "laplacian.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Generators of laplacian-transformed graphs."
                ],
                "doc": [
                    " Returns unweighted symmetric normalized laplacian transformation of the graph.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.",
                    "",
                    " # Raises",
                    " * The graph must be undirected, as we do not currently support this transformation for directed graphs."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unweighted_symmetric_normalized_laplacian_transformed_graph",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "self.must_be_undirected()?;\n        Graph::from_integer_unsorted(\n            self.iter_edge_node_ids_and_edge_type_id(true)\n                .map(|(_, src, dst, edge_type)| {\n                    Ok((\n                        src,\n                        dst,\n                        edge_type,\n                        Some(if src == dst {\n                            1.0\n                        } else {\n                            -1.0 / ((self.get_unchecked_unweighted_node_degree_from_node_id(src)\n                                * self.get_unchecked_unweighted_node_degree_from_node_id(dst))\n                                as WeightT)\n                                .sqrt()\n                        }),\n                    ))\n                }),\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.is_directed(),\n            self.get_name(),\n            true,\n            self.has_edge_types(),\n            true,\n            self.has_singleton_nodes(),\n            self.has_singleton_nodes_with_selfloops(),\n            self.has_trap_nodes(),\n            verbose.unwrap_or(true),\n        )"
            },
            {
                "file": "laplacian.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Generators of laplacian-transformed graphs."
                ],
                "doc": [
                    " Returns unweighted symmetric normalized transformation of the graph.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.",
                    "",
                    " # Raises",
                    " * The graph must be undirected, as we do not currently support this transformation for directed graphs."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_unweighted_symmetric_normalized_transformed_graph",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "self.must_be_undirected()?;\n        Graph::from_integer_unsorted(\n            self.iter_edge_node_ids_and_edge_type_id(true)\n                .filter(|(_, src, dst, _)| src != dst)\n                .map(|(_, src, dst, edge_type)| {\n                    Ok((\n                        src,\n                        dst,\n                        edge_type,\n                        Some(\n                            1.0 / ((self.get_unchecked_unweighted_node_degree_from_node_id(src)\n                                * self.get_unchecked_unweighted_node_degree_from_node_id(dst))\n                                as WeightT)\n                                .sqrt(),\n                        ),\n                    ))\n                }),\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.is_directed(),\n            self.get_name(),\n            true,\n            self.has_edge_types(),\n            true,\n            self.has_singleton_nodes() || self.has_singleton_nodes_with_selfloops(),\n            false,\n            self.has_trap_nodes(),\n            verbose.unwrap_or(true),\n        )"
            },
            {
                "file": "laplacian.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Generators of laplacian-transformed graphs."
                ],
                "doc": [
                    " Returns weighted laplacian transformation of the graph.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.",
                    "",
                    " # Raises",
                    " * If the graph is not weighted it is not possible to compute the weighted laplacian transformation."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_weighted_laplacian_transformed_graph",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "self.must_have_edge_weights()?;\n        Graph::from_integer_unsorted(\n            self.iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)\n                .map(|(_, src, dst, edge_type, edge_weight)| {\n                    Ok((\n                        src,\n                        dst,\n                        edge_type,\n                        Some(if src == dst {\n                            self.get_unchecked_weighted_node_degree_from_node_id(src)\n                        } else {\n                            -edge_weight.unwrap()\n                        }),\n                    ))\n                }),\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.is_directed(),\n            self.get_name(),\n            true,\n            self.has_edge_types(),\n            true,\n            self.has_singleton_nodes(),\n            self.has_singleton_nodes_with_selfloops(),\n            self.has_trap_nodes(),\n            verbose.unwrap_or(true),\n        )"
            },
            {
                "file": "laplacian.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Generators of laplacian-transformed graphs."
                ],
                "doc": [
                    " Returns unweighted symmetric normalized laplacian transformation of the graph.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.",
                    "",
                    " # Raises",
                    " * The graph must be undirected, as we do not currently support this transformation for directed graphs.",
                    " * If the graph is not weighted it is not possible to compute the weighted laplacian transformation."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_weighted_symmetric_normalized_laplacian_transformed_graph",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "self.must_have_edge_weights()?;\n        self.must_be_undirected()?;\n        Graph::from_integer_unsorted(\n            self.iter_edge_node_ids_and_edge_type_id(true)\n                .map(|(_, src, dst, edge_type)| {\n                    Ok((\n                        src,\n                        dst,\n                        edge_type,\n                        Some(if src == dst {\n                            1.0\n                        } else {\n                            -1.0 / ((self.get_unchecked_weighted_node_degree_from_node_id(src)\n                                * self.get_unchecked_weighted_node_degree_from_node_id(dst))\n                                as WeightT)\n                                .sqrt()\n                        }),\n                    ))\n                }),\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.is_directed(),\n            self.get_name(),\n            true,\n            self.has_edge_types(),\n            true,\n            self.has_singleton_nodes(),\n            self.has_singleton_nodes_with_selfloops(),\n            self.has_trap_nodes(),\n            verbose.unwrap_or(true),\n        )"
            },
            {
                "file": "laplacian.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Generators of laplacian-transformed graphs."
                ],
                "doc": [
                    " Returns weighted symmetric normalized transformation of the graph.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.",
                    "",
                    " # Raises",
                    " * The graph must be undirected, as we do not currently support this transformation for directed graphs.",
                    " * If the graph is not weighted it is not possible to compute the weighted laplacian transformation."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_weighted_symmetric_normalized_transformed_graph",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "self.must_have_edge_weights()?;\n        self.must_be_undirected()?;\n        Graph::from_integer_unsorted(\n            self.iter_edge_node_ids_and_edge_type_id(true)\n                .filter(|(_, src, dst, _)| src != dst)\n                .map(|(_, src, dst, edge_type)| {\n                    Ok((\n                        src,\n                        dst,\n                        edge_type,\n                        Some(\n                            1.0 / (self.get_unchecked_weighted_node_degree_from_node_id(src)\n                                * self.get_unchecked_weighted_node_degree_from_node_id(dst))\n                            .sqrt(),\n                        ),\n                    ))\n                }),\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.is_directed(),\n            self.get_name(),\n            true,\n            self.has_edge_types(),\n            true,\n            self.has_singleton_nodes() || self.has_singleton_nodes_with_selfloops(),\n            false,\n            self.has_trap_nodes(),\n            verbose.unwrap_or(true),\n        )"
            },
            {
                "file": "laplacian.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Generators of laplacian-transformed graphs."
                ],
                "doc": [
                    " Returns weighted random walk normalized laplacian transformation of the graph.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.",
                    "",
                    " # Raises",
                    " * The graph must be undirected, as we do not currently support this transformation for directed graphs.",
                    " * If the graph is not weighted it is not possible to compute the weighted laplacian transformation."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_weighted_random_walk_normalized_laplacian_transformed_graph",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "self.must_have_edge_weights()?;\n        self.must_be_undirected()?;\n        Graph::from_integer_unsorted(\n            self.iter_edge_node_ids_and_edge_type_id(true)\n                .map(|(_, src, dst, edge_type)| {\n                    Ok((\n                        src,\n                        dst,\n                        edge_type,\n                        Some(if src == dst {\n                            1.0\n                        } else {\n                            -1.0 / self.get_unchecked_weighted_node_degree_from_node_id(src)\n                                as WeightT\n                        }),\n                    ))\n                }),\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.is_directed(),\n            self.get_name(),\n            true,\n            self.has_edge_types(),\n            true,\n            self.has_singleton_nodes(),\n            self.has_singleton_nodes_with_selfloops(),\n            self.has_trap_nodes(),\n            verbose.unwrap_or(true),\n        )"
            }
        ]
    },
    "getters_boolean.rs": {
        "imports": [
            "use super::*;"
        ],
        "functions": [
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Return if the graph has any nodes.",
                    "",
                    " # Example",
                    " To check if the graph has nodes you can use:",
                    " ```rust",
                    " # let graph_with_nodes = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " # let empty_graph = graph::test_utilities::load_empty_graph(false);",
                    " assert!(graph_with_nodes.has_nodes());",
                    " assert!(!empty_graph.has_nodes());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_nodes",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_nodes_number() > 0"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Return if the graph has any edges.",
                    "",
                    " # Example",
                    " To check if the current graph has edges you can use:",
                    " ```rust",
                    " # let graph_with_edges = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " # let empty_graph = graph::test_utilities::load_empty_graph(false);",
                    " assert!(graph_with_edges.has_edges());",
                    " assert!(!empty_graph.has_edges());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_edges",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_edges_number() > 0"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    "",
                    " # Example",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " if graph.has_trap_nodes(){",
                    "     println!(\"There are {} trap nodes in the current graph.\", graph.get_trap_nodes_number());",
                    " } else {",
                    "     println!(\"There are no trap nodes in the current graph.\");",
                    " }",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_trap_nodes",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_trap_nodes_number() > 0"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns boolean representing if graph is directed.",
                    "",
                    " # Example",
                    " ```rust",
                    " let directed_string_ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(directed_string_ppi.is_directed());",
                    " let undirected_string_ppi = graph::test_utilities::load_ppi(true, true, true, false, false, false);",
                    " assert!(!undirected_string_ppi.is_directed());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_directed",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.directed"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns boolean representing whether graph has weights.",
                    "",
                    " # Example",
                    " ```rust",
                    " let weights_string_ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(weights_string_ppi.has_edge_weights());",
                    " let unweights_string_ppi = graph::test_utilities::load_ppi(true, true, false, true, false, false);",
                    " assert!(!unweights_string_ppi.has_edge_weights());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_edge_weights",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.weights.is_some()"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns boolean representing whether graph has negative weights.",
                    "",
                    " # Example",
                    " ```rust",
                    " let weights_string_ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(weights_string_ppi.has_edge_weights());",
                    " let unweights_string_ppi = graph::test_utilities::load_ppi(true, true, false, true, false, false);",
                    " assert!(!unweights_string_ppi.has_edge_weights());",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph does not contain weights."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_negative_edge_weights",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "self.get_min_edge_weight()\n            .map(|min_edge_weight| min_edge_weight < 0.0)"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns boolean representing whether graph has edge types.",
                    "",
                    " # Example",
                    " ```rust",
                    " let string_ppi_with_edge_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(string_ppi_with_edge_types.has_edge_types());",
                    " let string_ppi_without_edge_types = graph::test_utilities::load_ppi(true, false, true, true, false, false);",
                    " assert!(!string_ppi_without_edge_types.has_edge_types());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_edge_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.edge_types.is_some()"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns boolean representing if graph has self-loops.",
                    "",
                    " # Example",
                    " ```rust",
                    " let string_ppi_with_selfloops = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " assert!(string_ppi_with_selfloops.has_selfloops());",
                    " let string_ppi_without_selfloops = graph::test_utilities::load_ppi(true, false, true, true, false, true);",
                    " assert!(!string_ppi_without_selfloops.has_selfloops());",
                    " ```",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_selfloops",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.selfloop_number > 0"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns boolean representing if nodes which are nor singletons nor",
                    " singletons with selfloops.",
                    "",
                    " # Example",
                    " ```rust",
                    " # let graph_with_singletons = graph::test_utilities::load_ppi(true, true, true, false, false, false);",
                    " assert!(graph_with_singletons.has_disconnected_nodes());",
                    " let graph_without_singletons = graph_with_singletons.drop_singleton_nodes(Some(false));",
                    " assert!(!graph_without_singletons.has_disconnected_nodes());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_disconnected_nodes",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_disconnected_nodes_number() > 0"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns boolean representing if graph has singletons.",
                    "",
                    " # Example",
                    " ```rust",
                    " # let graph_with_singletons = graph::test_utilities::load_ppi(true, true, true, false, false, false);",
                    " assert!(graph_with_singletons.has_singleton_nodes());",
                    " let graph_without_singletons = graph_with_singletons.drop_singleton_nodes(Some(false));",
                    " assert!(!graph_without_singletons.has_singleton_nodes());",
                    " ```"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_singleton_nodes",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_singleton_nodes_number() > 0"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns boolean representing if graph has singletons."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_singleton_nodes_with_selfloops",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_singleton_nodes_with_selfloops_number() > 0"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns whether the graph is connected.",
                    "",
                    " # Arguments",
                    " * `verbose`: Option<bool> - Whether to show the loading bar while computing the connected components, if necessary."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_connected",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_nodes_number() <= 1\n            || !self.has_singleton_nodes()\n                && !self.has_singleton_nodes_with_selfloops()\n                && self.get_connected_components_number(verbose).0 == 1"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns boolean representing if graph has node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_node_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.node_types.is_some()"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns boolean representing if graph has multilabel node types.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_multilabel_node_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "self.must_have_node_types()\n            .map(|node_types| node_types.is_multilabel())"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns whether there are unknown node types.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_unknown_node_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "Ok(self.get_unknown_node_types_number()? > 0)"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns whether there are unknown edge types.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_unknown_edge_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "Ok(self.get_unknown_edge_types_number()? > 0)"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns whether the nodes have an homogenous node type.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_homogeneous_node_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "Ok(self.get_node_types_number()? == 1)"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns whether the edges have an homogenous edge type.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_homogeneous_edge_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "Ok(self.get_edge_types_number()? == 1)"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns whether there is at least singleton node type, that is a node type that only appears once.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_singleton_node_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "Ok(self.get_minimum_node_types_number()? == 1)"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Return whether the graph has any known node-related graph oddities."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_node_oddities",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "[\n            self.has_singleton_nodes(),\n            self.has_singleton_nodes_with_selfloops(),\n        ]\n        .iter()\n        .any(|value| *value)"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Return whether the graph has any known node type-related graph oddities.",
                    "",
                    " # Raises",
                    " * If the graph does not have node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_node_types_oddities",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "Ok([\n            self.has_singleton_node_types()?,\n            self.has_homogeneous_node_types()?,\n            self.has_unknown_node_types()?,\n        ]\n        .iter()\n        .any(|value| *value))"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Returns whether there is at least singleton edge type, that is a edge type that only appears once.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_singleton_edge_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "Ok(self.get_minimum_edge_types_number()? == 1)"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Return whether the graph has any known edge type-related graph oddities.",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "has_edge_types_oddities",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Result<bool, String>",
                "body": "Ok([\n            self.has_singleton_edge_types()?,\n            self.has_homogeneous_edge_types()?,\n            self.has_unknown_edge_types()?,\n        ]\n        .iter()\n        .any(|value| *value))"
            },
            {
                "file": "getters_boolean.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Boolean Getters",
                    " The naming convention we follow is:",
                    " * `/has_(.+)/`",
                    " * `/is_(.+)/`",
                    "",
                    " The naming convention for unchecked methods follows:",
                    " * `/has_unchecked_(.+)/`",
                    " * `/is_unchecked_(.+)/`."
                ],
                "doc": [
                    " Return if there are multiple edges between two nodes"
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "is_multigraph",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.get_multigraph_edges_number() > 0"
            }
        ]
    },
    "from_csv.rs": {
        "imports": [
            "use super::*;"
        ],
        "functions": [
            {
                "file": "from_csv.rs",
                "struct": "Graph",
                "doc": [
                    " Return graph renderized from given files.",
                    "",
                    " # Arguments",
                    "",
                    " * `edge_file_reader`: EdgeFileReader - Reader of the edge file.",
                    " * `node_file_reader`: Option<NodeFileReader> - Reader of the node file.",
                    " * `directed`: bool - Whether the graph is to be read as directed or undirected.",
                    " * `directed_edge_list`: bool - Whether to read the edge list as directed.",
                    " * `edges_number`: usize - Number of edges of the graph.",
                    " * `nodes_number`: NodeT - Number of the nodes of the graph.",
                    " * `name`: S - Name of the graph.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "from_sorted_csv",
                "generics": "S: Clone + Into<String>",
                "args": [
                    [
                        "edge_file_reader",
                        "EdgeFileReader"
                    ],
                    [
                        "node_file_reader",
                        "Option<NodeFileReader>"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "directed_edge_list",
                        "bool"
                    ],
                    [
                        "edges_number",
                        "usize"
                    ],
                    [
                        "nodes_number",
                        "NodeT"
                    ],
                    [
                        "name",
                        "S"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "edge_file_reader = edge_file_reader.set_graph_name(name.clone().into());\n        node_file_reader = node_file_reader.map(|nfr| nfr.set_graph_name(name.clone().into()));\n        Graph::from_string_sorted(\n            edge_file_reader.read_lines()?,\n            node_file_reader\n                .as_ref()\n                .map_or(Ok::<_, String>(None), |nfr| Ok(Some(nfr.read_lines()?)))?,\n            directed,\n            directed_edge_list,\n            name,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.ignore_duplicates),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.csv_is_correct),\n            edge_file_reader.reader.ignore_duplicates,\n            edge_file_reader.reader.csv_is_correct,\n            edges_number,\n            nodes_number,\n            edge_file_reader.numeric_edge_type_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_ids),\n            edge_file_reader.numeric_node_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_type_ids),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.has_node_types()),\n            edge_file_reader.has_edge_types(),\n            edge_file_reader.has_edge_weights(),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.might_have_singletons),\n            edge_file_reader.might_have_singletons_with_selfloops,\n            edge_file_reader.might_have_trap_nodes,\n        )"
            },
            {
                "file": "from_csv.rs",
                "struct": "Graph",
                "doc": [
                    " Return graph renderized from given files.",
                    "",
                    " # Arguments",
                    "",
                    " * `edge_file_reader`: EdgeFileReader - Reader of the edge file.",
                    " * `node_file_reader`: Option<NodeFileReader> - Reader of the node file.",
                    " * `directed`: bool - Whether the graph is to be read as directed or undirected.",
                    " * `directed_edge_list`: bool - Whether to read the edge list as directed.",
                    " * `name`: S - The name for the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "from_unsorted_csv",
                "generics": "S: Clone + Into<String>",
                "args": [
                    [
                        "edge_file_reader",
                        "EdgeFileReader"
                    ],
                    [
                        "node_file_reader",
                        "Option<NodeFileReader>"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "directed_edge_list",
                        "bool"
                    ],
                    [
                        "name",
                        "S"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "edge_file_reader = edge_file_reader.set_graph_name(name.clone().into());\n        node_file_reader = node_file_reader.map(|nfr| nfr.set_graph_name(name.clone().into()));\n        Graph::from_string_unsorted(\n            edge_file_reader.read_lines()?,\n            node_file_reader\n                .as_ref()\n                .map_or(Ok::<_, String>(None), |nfr| Ok(Some(nfr.read_lines()?)))?,\n            directed,\n            directed_edge_list,\n            name,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.ignore_duplicates),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.csv_is_correct),\n            edge_file_reader.reader.ignore_duplicates,\n            edge_file_reader.reader.csv_is_correct,\n            edge_file_reader.numeric_edge_type_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_ids),\n            edge_file_reader.numeric_node_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_type_ids),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.has_node_types()),\n            edge_file_reader.has_edge_types(),\n            edge_file_reader.has_edge_weights(),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.might_have_singletons),\n            edge_file_reader.might_have_singletons_with_selfloops,\n            edge_file_reader.might_have_trap_nodes,\n            edge_file_reader.reader.verbose,\n        )"
            }
        ]
    },
    "lib.rs": {
        "imports": [
            "use dijkstra_queue::*;",
            "use tags::*;"
        ],
        "functions": []
    },
    "hash.rs": {
        "imports": [
            "use super::*;",
            "use std::collections::hash_map::DefaultHasher;",
            "use std::hash::{Hash, Hasher};"
        ],
        "functions": [
            {
                "file": "hash.rs",
                "doc": [
                    " Hashing floats is usually a bad idea",
                    " But we want to know if any weight changed significantly",
                    " THUS we will hash only the order of magnitude and the",
                    " first few bits of the mantissa.",
                    "",
                    " This should be an hash which is kinda robust to float erros."
                ],
                "attrs": [
                    "#[inline(always)]"
                ],
                "modifiers": "",
                "name": "hash_float",
                "generics": "H: Hasher",
                "args": [
                    [
                        "x",
                        "f32"
                    ],
                    [
                        "state",
                        "&mut H"
                    ]
                ],
                "body": "// basically we are converting the float to a u32 and\n    // clear out the lower bits of the mantissa.\n    let mut hack = u32::from_le_bytes(x.to_le_bytes());\n\n    // Clear the lower bits of the mantissa\n    //        seeeeeeeemmmmmmmmmmmmmmmmmmmmmmm\n    hack &= 0b11111111111111111111000000000000;\n\n    state.write_u32(hack);"
            },
            {
                "file": "hash.rs",
                "struct": "Graph",
                "doc": [],
                "attrs": [
                    "#[no_binding]"
                ],
                "modifiers": "pub",
                "name": "compute_hash",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "u64",
                "body": "let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        hasher.finish()"
            },
            {
                "file": "hash.rs",
                "struct": "Graph",
                "trait": "PartialEq",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "eq",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "other",
                        "&Self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.compute_hash() == other.compute_hash()"
            },
            {
                "file": "hash.rs",
                "struct": "Graph",
                "trait": "Hash",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "hash",
                "generics": "H: Hasher",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "state",
                        "&mut H"
                    ]
                ],
                "body": "// These fields are fundamentals\n        self.directed.hash(state);\n        self.nodes.hash(state);\n        self.edges.hash(state);\n\n        if let Some(ws) = &self.weights {\n            for w in ws {\n                hash_float(*w, state);\n            }\n        }\n\n        if let Some(nt) = &self.node_types {\n            nt.hash(state);\n        }\n\n        if let Some(et) = &self.edge_types {\n            et.hash(state);\n        }\n\n        // These fields are derivative from the other ones and thus not needed.\n        // self.unique_sources.hash(state);\n        // self.node_bits.hash(state);\n        // self.node_bit_mask.hash(state);\n        // self.unique_selfloop_number.hash(state);\n        // self.selfloop_number.hash(state);\n        // self.connected_nodes_number.hash(state);\n        // self.singleton_nodes_with_selfloops_number.hash(state);\n        // self.unique_edges_number.hash(state);\n\n        // These fields are not meaningfull to hash imho\n        // self.name.hash(state);\n        // self.singleton_nodes_with_selfloops_number.hash(state);\n        // self.sources.hash(state);\n        // self.cumulative_node_degrees.hash(state);\n        // self.cached_destinations.hash(state);\n        // self.embedding.hash(state);"
            },
            {
                "file": "hash.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "hash",
                "generics": "H: Hasher",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "state",
                        "&mut H"
                    ]
                ],
                "body": "// The hashmap is not hashable, so we convert it to a\n        // sorted array of tuples.\n\n        let mut vector: Vec<(&String, &IndexT)> = self.map.iter().collect();\n        vector.sort();\n        vector.hash(state);\n\n        self.reverse_map.hash(state);\n        self.numeric_ids.hash(state);"
            },
            {
                "file": "hash.rs",
                "struct": "NodeTypeVocabulary",
                "trait": "Hash",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "hash",
                "generics": "H: Hasher",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "state",
                        "&mut H"
                    ]
                ],
                "body": "self.ids.hash(state);\n        self.vocabulary.hash(state);\n        self.counts.hash(state);"
            },
            {
                "file": "hash.rs",
                "struct": "EdgeTypeVocabulary",
                "trait": "Hash",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "hash",
                "generics": "H: Hasher",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "state",
                        "&mut H"
                    ]
                ],
                "body": "self.ids.hash(state);\n        self.vocabulary.hash(state);\n        self.counts.hash(state);"
            }
        ]
    },
    "thickeners.rs": {
        "imports": [
            "use super::*;",
            "use indicatif::ParallelProgressIterator;",
            "use num_traits::Pow;",
            "use rayon::prelude::*;",
            "use std::convert::TryFrom;"
        ],
        "functions": [
            {
                "file": "thickeners.rs",
                "struct": "Distance",
                "trait": "TryFrom<&str>",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "try_from",
                "args": [
                    [
                        "value",
                        "&str"
                    ]
                ],
                "return_type": "Result<Self, Self::Error>",
                "body": "match value {\n            \"L2\" => Ok(Distance::L2),\n            \"COSINE\" => Ok(Distance::Cosine),\n            _ => Err(format!(\"Unknown distance metric {}\", value)),\n        }"
            },
            {
                "file": "thickeners.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Methods to thicken the graph."
                ],
                "doc": [
                    " Returns graph with edges added extracted from given node_features.",
                    "",
                    " This operation might distrupt the graph topology.",
                    " Proceed with caution!",
                    "",
                    " # Arguments",
                    " * `features`: Vec<Vec<f64>> - node_features to use to identify the new neighbours.",
                    " * `neighbours_number`: Option<NodeT> - Number of neighbours to add.",
                    " * `max_degree`: Option<NodeT> - The maximum degree a node can have its neighbours augmented. By default 0, that is, only singletons are augmented.",
                    " * `distance_name`: Option<&str> - Name of distance to use. Can either be L2 or COSINE. By default COSINE.",
                    " * `verbose`: Option<bool> - Whether to show loading bars.",
                    "",
                    " # Raises",
                    " * If the graph does not have nodes.",
                    " * If the given node_features are not provided exactly for each node.",
                    " * If the node_features do not have a consistent shape.",
                    " * If the provided number of neighbours is zero."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "generate_new_edges_from_node_features",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "features",
                        "Vec<Vec<f64>>"
                    ],
                    [
                        "neighbours_number",
                        "Option<NodeT>"
                    ],
                    [
                        "max_degree",
                        "Option<NodeT>"
                    ],
                    [
                        "distance_name",
                        "Option<&str>"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "// check that the parameters are sane\n        self.must_have_nodes()?;\n        validate_features(&features, self.get_nodes_number() as usize)?;\n        let max_degree = max_degree.unwrap_or(0);\n\n        // compute the neighbours nodes to add\n        let neighbours_number =\n            neighbours_number.unwrap_or(self.get_node_degrees_mean()?.ceil() as NodeT);\n        if neighbours_number == 0 {\n            return Err(\"The number of neighbours to add per node cannot be zero!\".to_string());\n        }\n\n        // initialize the progress bar\n        let verbose = verbose.unwrap_or(true);\n        let pb = get_loading_bar(\n            verbose,\n            \"Computing additional edges to thicken graph\",\n            self.get_nodes_number() as usize,\n        );\n\n        // initialize the distance metric\n        let distance_metric = match Distance::try_from(distance_name.unwrap_or(\"COSINE\"))? {\n            Distance::L2 => |current_node_features: &Vec<f64>, node_features: &Vec<f64>| -> f64 {\n                current_node_features\n                    .iter()\n                    .zip(node_features.iter())\n                    .map(|(&left, &right)| (left - right).pow(2))\n                    .sum()\n            },\n            Distance::Cosine => {\n                |current_node_features: &Vec<f64>, node_features: &Vec<f64>| -> f64 {\n                    let numerator = current_node_features\n                        .iter()\n                        .zip(node_features.iter())\n                        .map(|(&left, &right)| left * right)\n                        .sum::<f64>();\n                    let denominator_left = current_node_features\n                        .iter()\n                        .map(|&left| left.pow(2))\n                        .sum::<f64>()\n                        .sqrt();\n                    let denominator_right = node_features\n                        .iter()\n                        .map(|&right| right.pow(2))\n                        .sum::<f64>()\n                        .sqrt();\n                    1.0 - numerator / (denominator_left * denominator_right + f64::EPSILON)\n                }\n            }\n        };\n\n        // compute the new edges to add\n        let new_edges = self\n            .par_iter_node_ids()\n            .zip(self.par_iter_unweighted_node_degrees())\n            .progress_with(pb)\n            .map(|(source_node_id, node_degree)| {\n                if node_degree <= max_degree {\n                    let mut closest_nodes = Vec::with_capacity(neighbours_number as usize);\n                    // for each node find the k closest nodes (based on the distance choosen and their features)\n                    let current_node_features = &features[source_node_id as usize];\n                    let mut closest_nodes_distances =\n                        vec![f64::INFINITY; neighbours_number as usize];\n\n                    features\n                        .iter()\n                        .zip(self.iter_node_ids())\n                        // every node is the closest to itself so we filter it out\n                        .filter(|(_, destination_node_id)| source_node_id != *destination_node_id)\n                        .for_each(|(node_features, destination_node_id)| {\n                            // compute the distance\n                            let distance = distance_metric(current_node_features, node_features);\n                            // get the max distance in the currently cosest nodes\n                            let (i, max_distance) =\n                                unsafe { closest_nodes_distances.argmax().unwrap_unchecked() };\n                            // update the closest nodes inserting the current node if needed\n                            if max_distance > distance {\n                                if max_distance == f64::INFINITY {\n                                    closest_nodes.push(destination_node_id);\n                                } else {\n                                    closest_nodes[i] = destination_node_id;\n                                }\n                                closest_nodes_distances[i] = distance;\n                            }\n                        });\n                    closest_nodes\n                } else {\n                    Vec::new()\n                }\n            })\n            .collect::<Vec<Vec<NodeT>>>();\n\n        Graph::from_integer_unsorted(\n            self.iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)\n                .map(|(_, src_node_id, dst_node_id, edge_type, weight)| {\n                    Ok((src_node_id, dst_node_id, edge_type, weight))\n                })\n                .chain(\n                    new_edges\n                        .into_iter()\n                        .enumerate()\n                        .map(|(source_node_id, new_neighbours)| {\n                            new_neighbours\n                                .into_iter()\n                                .map(move |destination_node_id| {\n                                    if !self.is_directed() {\n                                        vec![\n                                            Ok((\n                                                source_node_id as NodeT,\n                                                destination_node_id,\n                                                None,\n                                                None,\n                                            )),\n                                            Ok((\n                                                destination_node_id,\n                                                source_node_id as NodeT,\n                                                None,\n                                                None,\n                                            )),\n                                        ]\n                                    } else {\n                                        vec![Ok((\n                                            source_node_id as NodeT,\n                                            destination_node_id,\n                                            None,\n                                            None,\n                                        ))]\n                                    }\n                                })\n                                .flatten()\n                        })\n                        .flatten(),\n                ),\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.is_directed(),\n            self.get_name(),\n            true,\n            self.has_edge_types(),\n            self.has_edge_weights(),\n            self.has_singleton_nodes(),\n            self.has_singleton_nodes_with_selfloops(),\n            self.has_trap_nodes(),\n            verbose,\n        )"
            }
        ]
    },
    "constructors.rs": {
        "imports": [
            "use super::*;",
            "use bitvec::prelude::*;",
            "use elias_fano_rust::EliasFano;",
            "use indicatif::ProgressIterator;",
            "use itertools::Itertools;",
            "use log::info;",
            "use rayon::prelude::ParallelSliceMut;",
            "use roaring::RoaringBitmap;",
            "use std::cmp::Ordering;",
            "use std::collections::BTreeMap;"
        ],
        "functions": [
            {
                "file": "constructors.rs",
                "doc": [
                    " Returns result representing if the given combination of numeric node ids and edge node ids is valid.",
                    "",
                    " The error message given within the method should contain all informations",
                    " relative to the logic of this check.",
                    "",
                    " # Arguments",
                    " * `has_nodes_list`: bool - Whether the graph has a node list.",
                    " * `numeric_node_ids`: bool - Whether the node IDs should be loaded as integers.",
                    " * `numeric_edge_node_ids`: bool - Whether the edge node IDs should be loaded as integers.",
                    "",
                    " # Raises",
                    " * If the given combination of numeric nodes is not feaseable."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "check_numeric_ids_compatibility",
                "args": [
                    [
                        "has_nodes_list",
                        "bool"
                    ],
                    [
                        "numeric_node_ids",
                        "bool"
                    ],
                    [
                        "numeric_edge_node_ids",
                        "bool"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "if has_nodes_list && numeric_node_ids && !numeric_edge_node_ids {\n        return Err(concat!(\n            \"You are trying to load a numeric node list and a non numeric edge list.\\n\",\n            \"This is a problem because an edge composed of two nodes (e.g. \\\"2, 8\\\") is \",\n            \"not necessarily mapped internally to the same node ids of the node list.\\n\",\n            \"Possibily you want to also enable the parameter for the numeric edge node ids.\"\n        )\n        .to_string());\n    }\n    Ok(())"
            },
            {
                "file": "constructors.rs",
                "doc": [
                    " Returns iterator of nodes handling the node IDs.",
                    "",
                    " # Arguments",
                    " nodes_iter: impl Iterator<Item = Result<(String, Option<Vec<String>>), String>> + 'a,",
                    "     Iterator over the node list.",
                    " ignore_duplicated_nodes: bool,",
                    "     Whether to just ignore the duplicated node types.",
                    " node_list_is_correct: bool,",
                    "     Parameter to pinky promise that the node list is correct.",
                    "     If you provide a broken node list to this method while promising",
                    "     that the node list is correct, be prepared to deal with the fallout.",
                    "     This parameter is mainly meant to be used internally when creating",
                    "     graphs that CANNOT BE BROKEN by design. If you use this parameter",
                    "     from any of the bindings, be SURE that the node list is actually",
                    "     correct.",
                    "     We assume that any provided node list is broken until disproved.",
                    " nodes: &'b mut Vocabulary<NodeT>,",
                    "     Vocabulary of the nodes to be populated."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "parse_node_ids",
                "generics": "'a",
                "args": [
                    [
                        "nodes_iter",
                        "impl Iterator<Item = Result<(String, Option<Vec<String>>), String>> + 'a"
                    ],
                    [
                        "ignore_duplicated_nodes",
                        "bool"
                    ],
                    [
                        "node_list_is_correct",
                        "bool"
                    ],
                    [
                        "nodes",
                        "&'a mut Vocabulary<NodeT>"
                    ]
                ],
                "return_type": "Box<dyn Iterator<Item = Result<(NodeT, Option<Vec<String>>), String>> + 'a>",
                "body": "// If the user is telling us that the node list is **surely correct**,\n    // we can skip a significant amount of checks and therefore create\n    // a simpler iterator.\n    if node_list_is_correct {\n        Box::new(\n            nodes_iter.map_ok(move |(node_name, node_type)| {\n                (nodes.unchecked_insert(node_name), node_type)\n            }),\n        )\n    } else {\n        Box::new(nodes_iter.filter_map(move |row| {\n            row.map_or_else(|err| Some(Err(err)),  |(node_name, node_type)| {\n                nodes.insert(node_name.as_str()).map_or_else(|err| Some(Err(err)), |(node_id, already_present_in_vocabulary)|{\n                    if already_present_in_vocabulary{\n                        if ignore_duplicated_nodes {\n                            None\n                        } else {\n                            Some(Err(format!(\n                                concat!(\n                                    \"The node {node_name} appears multiple times in the node list.\\n\",\n                                    \"The node type of the row is {node_type:?}.\\n\",\n                                    \"The library does not currently support multiple node types for a single node.\"\n                                ),\n                                node_name = node_name,\n                                node_type = node_type\n                            )))\n                        }\n                    } else {\n                        Some(Ok((node_id, node_type)))\n                    }\n                })\n            })\n        }))\n    }"
            },
            {
                "file": "constructors.rs",
                "doc": [
                    " Returns iterator of nodes handling the node type IDs.",
                    "",
                    " # Arguments",
                    " nodes_iter: impl Iterator<Item = Result<(NodeT, Option<Vec<String>>), String>> + 'a,",
                    "     Iterator over the node list.",
                    " node_list_is_correct: bool,",
                    "     Parameter to pinky promise that the node list is correct.",
                    "     If you provide a broken node list to this method while promising",
                    "     that the node list is correct, be prepared to deal with the fallout.",
                    "     This parameter is mainly meant to be used internally when creating",
                    "     graphs that CANNOT BE BROKEN by design. If you use this parameter",
                    "     from any of the bindings, be SURE that the node list is actually",
                    "     correct.",
                    "     We assume that any provided node list is broken until disproved.",
                    " node_types_vocabulary: &'b mut NodeTypeVocabulary,",
                    "     Node types vocabulary to be populated."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "parse_node_type_ids",
                "generics": "'a",
                "args": [
                    [
                        "nodes_iter",
                        "impl Iterator<Item = Result<(NodeT, Option<Vec<String>>), String>> + 'a"
                    ],
                    [
                        "node_list_is_correct",
                        "bool"
                    ],
                    [
                        "node_types_vocabulary",
                        "&'a mut NodeTypeVocabulary"
                    ]
                ],
                "return_type": "Box<dyn Iterator<Item = Result<(NodeT, Option<Vec<NodeTypeT>>), String>> + 'a>",
                "body": "if node_list_is_correct {\n        Box::new(nodes_iter.map_ok(move |(node_id, node_type_names)| {\n            (\n                node_id,\n                node_types_vocabulary.unchecked_insert_values(node_type_names),\n            )\n        }))\n    } else {\n        Box::new(nodes_iter.map(move |row| {\n            row.and_then(|(node_id, node_type_names)| {\n                Ok((\n                    node_id,\n                    node_types_vocabulary.insert_values(node_type_names)?,\n                ))\n            })\n        }))\n    }"
            },
            {
                "file": "constructors.rs",
                "doc": [
                    " Returns modified iterator, adding what is need to digest edge node names into edge node IDs.",
                    " edges_iterator: impl Iterator<Item = Result<StringQuadruple, String>> + 'a,",
                    "     Iterator over the edge node names list.",
                    " edge_list_is_correct: bool,",
                    "     Parameter to pinky promise that the edge list is correct.",
                    "     If you provide a broken edge list to this method while promising",
                    "     that the edge list is correct, be prepared to deal with the fallout.",
                    "     This parameter is mainly meant to be used internally when creating",
                    "     graphs that CANNOT BE BROKEN by design. If you use this parameter",
                    "     from any of the bindings, be SURE that the edge list is actually",
                    "     correct.",
                    "     We assume that any provided edge list is broken until disproved.",
                    " nodes: &'b mut Vocabulary<NodeT>,",
                    "     Vocabulary of the nodes to be populated."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "parse_edges_node_ids",
                "generics": "'a",
                "args": [
                    [
                        "edges_iterator",
                        "impl Iterator<Item = Result<StringQuadruple, String>> + 'a"
                    ],
                    [
                        "edge_list_is_correct",
                        "bool"
                    ],
                    [
                        "nodes",
                        "&'a mut Vocabulary<NodeT>"
                    ]
                ],
                "return_type": "Box<dyn Iterator<Item = Result<(NodeT, NodeT, Option<String>, Option<WeightT>), String>> + 'a>",
                "body": "let empty_nodes_mapping = nodes.is_empty();\n    // If the user is telling us that the edge list is **surely correct**,\n    // we can skip a significant amount of checks and therefore create\n    // a simpler iterator.\n    if edge_list_is_correct {\n        Box::new(\n            edges_iterator.map_ok(move |(src_name, dst_name, edge_type, weight)| {\n                (\n                    nodes.unchecked_insert(src_name),\n                    nodes.unchecked_insert(dst_name),\n                    edge_type,\n                    weight,\n                )\n            }),\n        )\n    } else {\n        Box::new(\n            edges_iterator.map(move |row: Result<StringQuadruple, String>| {\n                row.and_then(|(src_name, dst_name, edge_type, weight)| {\n                    let (source_node_id, source_was_present) = nodes.insert(src_name.as_str())?;\n                    let (destination_node_id, destination_was_present) =\n                        nodes.insert(dst_name.as_str())?;\n                    if !empty_nodes_mapping && (!source_was_present || !destination_was_present) {\n                        Err(format!(\n                            concat!(\n                                \"In the edge list was found the edge ({} => {}) \",\n                                \"containing nodes that do not appear in the given node list.\"\n                            ),\n                            src_name, dst_name\n                        ))\n                    } else {\n                        Ok((source_node_id, destination_node_id, edge_type, weight))\n                    }\n                })\n            }),\n        )\n    }"
            },
            {
                "file": "constructors.rs",
                "doc": [
                    " Returns iterator of edges handling the edge type IDs.",
                    "",
                    " # Arguments",
                    " edges_iter: impl Iterator<Item = Result<(NodeT, NodeT, Option<String>, Option<WeightT>), String>> + 'a,",
                    "     Iterator over the edge node names list.",
                    " edge_list_is_correct: bool,",
                    "     Parameter to pinky promise that the edge list is correct.",
                    "     If you provide a broken edge list to this method while promising",
                    "     that the edge list is correct, be prepared to deal with the fallout.",
                    "     This parameter is mainly meant to be used internally when creating",
                    "     graphs that CANNOT BE BROKEN by design. If you use this parameter",
                    "     from any of the bindings, be SURE that the edge list is actually",
                    "     correct.",
                    "     We assume that any provided edge list is broken until disproved.",
                    " edge_types: &'b mut Vocabulary<EdgeTypeT>,",
                    "     Vocabulary of the edge types to be populated."
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "parse_edge_type_ids_vocabulary",
                "generics": "'a",
                "args": [
                    [
                        "edges_iter",
                        "impl Iterator<Item = Result<(NodeT, NodeT, Option<String>, Option<WeightT>), String>>\n        + 'a"
                    ],
                    [
                        "edge_list_is_correct",
                        "bool"
                    ],
                    [
                        "edge_types",
                        "&'a mut Vocabulary<EdgeTypeT>"
                    ]
                ],
                "return_type": "Box<dyn Iterator<Item = Result<Quadruple, String>> + 'a>",
                "body": "if edge_list_is_correct {\n        Box::new(edges_iter.map_ok(move |(src, dst, edge_type, weight)| {\n            (\n                src,\n                dst,\n                edge_type.map(|et| edge_types.unchecked_insert(et)),\n                weight,\n            )\n        }))\n    } else {\n        Box::new(edges_iter.map(move |row| {\n            row.and_then(|(src, dst, edge_type, weight)| {\n                Ok((\n                    src,\n                    dst,\n                    edge_type.map_or_else(\n                        || Ok::<_, String>(None),\n                        |et| Ok(Some(edge_types.insert(et)?.0)),\n                    )?,\n                    weight,\n                ))\n            })\n        }))\n    }"
            },
            {
                "file": "constructors.rs",
                "doc": [
                    " TODO: I think this method can be made better!"
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "parse_sorted_edges",
                "generics": "'a",
                "args": [
                    [
                        "edges_iter",
                        "impl Iterator<Item = Result<Quadruple, String>> + 'a"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "directed_edge_list",
                        "bool"
                    ]
                ],
                "return_type": "Box<dyn Iterator<Item = Result<Quadruple, String>> + 'a>",
                "body": "if directed || directed_edge_list {\n        return Box::new(edges_iter);\n    }\n    let mut sorting_tmp: BTreeMap<Triple, Option<WeightT>> = BTreeMap::new();\n    Box::new(edges_iter\n        .map(Some)\n        .chain(vec![None])\n        .flat_map(move |maybe_row| match maybe_row {\n            Some(row) => {\n                let mut results: Vec<Result<Quadruple, String>> = Vec::with_capacity(1);\n                let result = match row {\n                    Ok((src, dst, edge_type, weight)) => {\n                        if !directed && src < dst {\n                            sorting_tmp.insert((dst, src, edge_type), weight);\n                        }\n                        while !sorting_tmp.is_empty()\n                            && *sorting_tmp.first_key_value().unwrap().0 < (src, dst, edge_type)\n                        {\n                            let ((smaller_src, smaller_dst, smaller_edge_type), smaller_weight) =\n                                sorting_tmp.pop_first().unwrap();\n                            results.push(Ok((\n                                smaller_src,\n                                smaller_dst,\n                                smaller_edge_type,\n                                smaller_weight,\n                            )));\n                        }\n                        Ok((src, dst, edge_type, weight))\n                    }\n                    Err(e) => Err(e),\n                };\n                results.push(result);\n                results\n            }\n            None => sorting_tmp\n                .iter()\n                .map(|((src, dst, edge_type), weight)| Ok((*src, *dst, *edge_type, *weight)))\n                .collect::<Vec<_>>(),\n        }))"
            },
            {
                "file": "constructors.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "parse_unsorted_quadruples",
                "args": [
                    [
                        "edges",
                        "Vec<Quadruple>"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "(usize, impl Iterator<Item = Result<Quadruple, String>>)",
                "body": "info!(\"Sorting edges.\");\n    edges.par_sort_by(|(src1, dst1, edt1, _), (src2, dst2, edt2, _)| {\n        (*src1, *dst1, *edt1).cmp(&(*src2, *dst2, *edt2))\n    });\n\n    let edges_number = edges.len();\n    let pb = get_loading_bar(verbose, \"Building sorted graph\", edges_number);\n\n    (\n        edges_number,\n        edges.into_iter().progress_with(pb).map(Result::Ok),\n    )"
            },
            {
                "file": "constructors.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "parse_integer_unsorted_edges",
                "generics": "'a",
                "args": [
                    [
                        "edges_iter",
                        "impl Iterator<Item = Result<(NodeT, NodeT, Option<NodeTypeT>, Option<WeightT>), String>>"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "directed_edge_list",
                        "bool"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(usize, impl Iterator<Item = Result<Quadruple, String>> + 'a), String>",
                "body": "let edge_quadruples: Vec<Quadruple> = edges_iter\n        .flat_map(|tuple| match tuple {\n            Ok((src, dst, edt, weight)) => {\n                if !directed && src != dst && !directed_edge_list {\n                    vec![Ok((src, dst, edt, weight)), Ok((dst, src, edt, weight))]\n                } else {\n                    vec![Ok((src, dst, edt, weight))]\n                }\n            }\n            Err(e) => vec![Err(e)],\n        })\n        .collect::<Result<Vec<Quadruple>, String>>()?;\n\n    Ok(parse_unsorted_quadruples(edge_quadruples, verbose))"
            },
            {
                "file": "constructors.rs",
                "doc": [
                    " TODO: LUCA: I Think this method can be made better"
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "parse_string_unsorted_edges",
                "generics": "'a",
                "args": [
                    [
                        "edges_iter",
                        "impl Iterator<Item = Result<StringQuadruple, String>>"
                    ],
                    [
                        "nodes",
                        "Vocabulary<NodeT>"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "directed_edge_list",
                        "bool"
                    ],
                    [
                        "edge_list_is_correct",
                        "bool"
                    ],
                    [
                        "has_edge_types",
                        "bool"
                    ],
                    [
                        "verbose",
                        "bool"
                    ],
                    [
                        "numeric_edge_type_ids",
                        "bool"
                    ]
                ],
                "return_type": "Result<\n    (\n        usize,\n        impl Iterator<Item = Result<Quadruple, String>> + 'a,\n        Vocabulary<NodeT>,\n        Option<Vocabulary<EdgeTypeT>>,\n    ),\n    String,\n>",
                "body": "let mut edge_types_vocabulary = if has_edge_types {\n        Some(Vocabulary::default().set_numeric_ids(numeric_edge_type_ids))\n    } else {\n        None\n    };\n    let (edges_number, edges_iter) = {\n        let edges_iter = parse_edges_node_ids(edges_iter, edge_list_is_correct, &mut nodes);\n        let edges_iter: Box<dyn Iterator<Item = Result<Quadruple, String>>> =\n            if let Some(ets) = &mut edge_types_vocabulary {\n                Box::new(parse_edge_type_ids_vocabulary(\n                    edges_iter,\n                    edge_list_is_correct,\n                    ets,\n                ))\n            } else {\n                Box::new(edges_iter.map_ok(|(src, dst, _, weight)| (src, dst, None, weight)))\n            };\n        let edge_quadruples: Vec<Quadruple> = edges_iter\n            .flat_map(|tuple| match tuple {\n                Ok((src, dst, edt, weight)) => {\n                    if !directed && src != dst && !directed_edge_list {\n                        vec![Ok((src, dst, edt, weight)), Ok((dst, src, edt, weight))]\n                    } else {\n                        vec![Ok((src, dst, edt, weight))]\n                    }\n                }\n                Err(e) => vec![Err(e)],\n            })\n            .collect::<Result<Vec<Quadruple>, String>>()?;\n\n        parse_unsorted_quadruples(edge_quadruples, verbose)\n    };\n    info!(\"Building nodes reverse mapping.\");\n    nodes.build_reverse_mapping()?;\n    if let Some(ets) = &mut edge_types_vocabulary {\n        info!(\"Building edge types reverse mapping.\");\n        ets.build_reverse_mapping()?;\n    }\n    Ok((edges_number, edges_iter, nodes, edge_types_vocabulary))"
            },
            {
                "file": "constructors.rs",
                "doc": [
                    " TODO! add docstring"
                ],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "build_edges",
                "args": [
                    [
                        "edges_iter",
                        "impl Iterator<Item = Result<Quadruple, String>>"
                    ],
                    [
                        "edges_number",
                        "usize"
                    ],
                    [
                        "nodes_number",
                        "NodeT"
                    ],
                    [
                        "ignore_duplicated_edges",
                        "bool"
                    ],
                    [
                        "has_edge_weights",
                        "bool"
                    ],
                    [
                        "has_edge_types",
                        "bool"
                    ],
                    [
                        "might_have_singletons",
                        "bool"
                    ],
                    [
                        "might_have_singletons_with_selfloops",
                        "bool"
                    ],
                    [
                        "might_have_trap_nodes",
                        "bool"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "edge_list_is_correct",
                        "bool"
                    ]
                ],
                "return_type": "Result<\n    (\n        EliasFano,\n        Option<EliasFano>,\n        Option<Vec<Option<EdgeTypeT>>>,\n        Option<Vec<WeightT>>,\n        Option<WeightT>,\n        Option<WeightT>,\n        EdgeT,\n        EdgeT,\n        NodeT,\n        NodeT,\n        NodeT,\n        u8,\n        u64,\n        Option<BitVec<Lsb0, u8>>,\n        Option<RoaringBitmap>,\n        NodeT,\n        NodeT,\n    ),\n    String,\n>",
                "body": "info!(\"Started building of EliasFano edges data structure.\");\n    let node_bits = get_node_bits(nodes_number);\n    let node_bit_mask = (1 << node_bits) - 1;\n    let mut edges: EliasFano =\n        EliasFano::new(encode_max_edge(nodes_number, node_bits), edges_number)?;\n\n    // The graph might still contain duplicated edges, therefore the provided edges\n    // number is a maximal value.\n    let mut edge_type_ids: Option<Vec<Option<EdgeTypeT>>> = if has_edge_types {\n        Some(Vec::with_capacity(edges_number))\n    } else {\n        None\n    };\n\n    let (mut weights, mut min_edge_weight, mut max_edge_weight): (\n        Option<Vec<WeightT>>,\n        Option<WeightT>,\n        Option<WeightT>,\n    ) = if has_edge_weights {\n        (\n            Some(Vec::with_capacity(edges_number)),\n            Some(WeightT::INFINITY),\n            Some(WeightT::NEG_INFINITY),\n        )\n    } else {\n        (None, None, None)\n    };\n\n    // The unique sources variable is equal to the set of nodes of the graph when\n    // there are no singletons and the graph is undirected. Otherwise, if there is\n    // a singleton node, that must not appear in this set.\n    // We will use this set during the random walks and other graph algorithms\n    // in order to obtain the nth source node. For this reason we cannot\n    // use a bitvec here, since we need to execute an unchecked select when the\n    // object is not equal to the set of the nodes to remap the nth source node\n    // to the nth unique source node, excluding the eventual; singleton nodes.\n    // Similarly, in directed graphs, only a subset of the nodes might be a\n    // source as there might be traps.\n    // In the case of directed graphs, we have additionally the might have trap nodes\n    // parameter which allows to specify whether the graph is known to contain\n    // trap nodes. The parameter only makes sense in directed graphs.\n    // Since we expect that the average use case (when we arew not dealing with pathological graphs)\n    // the following set should be relatively dense, when we know that the set of unique\n    // sources will be needed but it will be equal to the nodes with edges set, we compute it\n    // afterwards. This is because it is known that an Elias Fano data structure\n    // uses more than twice the memory required by a bitvec to memorize a set of\n    // dense values.\n    let mut unique_sources: Option<EliasFano> =\n        if directed && (might_have_trap_nodes || might_have_singletons) {\n            Some(EliasFano::new(nodes_number as u64, nodes_number as usize)?)\n        } else {\n            None\n        };\n    // When the graph is either undirected or directed without trap nodes, the unique sources set and the\n    // nodes with edges set are equal one another.\n    // We need to compute the following set when it is not trivial, that is when\n    // either the graph is undirected and there are no singletons or alternatively\n    // when the graph is directed and there are neither trap nodes nor singletons.\n    // Additionally, since we need this support data structure when computing the\n    // number of singletons with selfloops, we need to create it also when it has\n    // been specified that there might be singletons with selfloops.\n    let mut connected_nodes: Option<_> =\n        if (might_have_singletons || might_have_singletons_with_selfloops) && nodes_number > 0 {\n            Some(bitvec![Lsb0, u8; 0; nodes_number as usize])\n        } else {\n            None\n        };\n\n    // Last source inserted\n    let mut last_src: NodeT = 0;\n    let mut last_dst: NodeT = 0;\n    let mut min_node_degree: NodeT = NodeT::MAX;\n    let mut max_node_degree: NodeT = 0;\n    let mut current_node_degree: NodeT = 0;\n    let mut last_edge_type: Option<EdgeTypeT> = None;\n    let mut unique_edges_number: EdgeT = 0;\n    let mut unique_selfloop_number: NodeT = 0;\n    let mut selfloop_number: EdgeT = 0;\n    let mut forward_undirected_edges_counter: EdgeT = 0;\n    let mut backward_undirected_edges_counter: EdgeT = 0;\n    let mut connected_nodes_number: NodeT =\n        if might_have_singletons || might_have_singletons_with_selfloops {\n            0\n        } else {\n            nodes_number\n        };\n    // This bitvec should be really sparse ON SANE GRAPHS\n    // so we use a roaring bitvec to save memory.\n    let mut singleton_nodes_with_selfloops = if might_have_singletons_with_selfloops {\n        Some(RoaringBitmap::new())\n    } else {\n        None\n    };\n\n    let mut first = true;\n    for value in edges_iter {\n        let (src, dst, edge_type, weight) = value?;\n        let different_src = last_src != src || first;\n        let different_dst = last_dst != dst || first;\n        let selfloop = src == dst;\n        let different_edge_type = last_edge_type != edge_type || first;\n        if !(different_src || different_dst || different_edge_type) {\n            if ignore_duplicated_edges {\n                continue;\n            } else {\n                return Err(\"A duplicated edge was found while building the graph.\".to_owned());\n            }\n        }\n\n        if let Some(ets) = &mut edge_type_ids {\n            ets.push(edge_type);\n        }\n        match (\n            &mut weights,\n            &mut min_edge_weight,\n            &mut max_edge_weight,\n            weight,\n        ) {\n            (Some(ws), Some(min_w), Some(max_w), Some(w)) => {\n                validate_weight(w)?;\n                *min_w = (*min_w).min(w);\n                *max_w = (*max_w).max(w);\n                ws.push(w);\n                Ok(())\n            }\n            (None, _, _, Some(_)) => Err(concat!(\n                \"A non-None weight was provided but no weights are expected \",\n                \"because the has_edge_weights flag has been set to false.\"\n            )),\n            (Some(_), _, _, None) => Err(concat!(\n                \"A None weight was found.\\n\",\n                \"This might mean you have either provided a None weight to the edge list or \",\n                \"you may have an empty weight in your edge list file.\\n\",\n                \"If you intend to load this edge list WITHOUT weights, do not provide the \",\n                \"edge weights colum or column number.\\n\",\n                \"If you intend to load this edge with its weight, add a default weight.\"\n            )),\n            _ => Ok(()),\n        }?;\n\n        if !directed && !edge_list_is_correct {\n            match src.cmp(&dst) {\n                Ordering::Greater => {\n                    // We retrieve the edge id of the forward edge, the one going from\n                    // dst to src.\n                    let maybe_edge_id = edges.rank(encode_edge(dst, src, node_bits));\n                    // Now we need to find, starting from edge id, if the edge types are given,\n                    // the correct edge id: if we are in a multi-graph the edge may be the same\n                    // but have multiple edge types and hence be reported multiple times.\n                    let maybe_edge_id = maybe_edge_id.and_then(|min_edge_id| {\n                        edge_type_ids.as_ref().map_or(Some(min_edge_id), |ets| {\n                            (min_edge_id\n                                ..edges.unchecked_rank(encode_edge(dst, src + 1, node_bits)))\n                                .find(|edge_id| ets[*edge_id as usize] == edge_type)\n                        })\n                    });\n                    // Finally now we need to check if the weights of the two edges, if given\n                    // are actually equal.\n                    // For the time being we do not allow for undirected graphs to have\n                    // asymmetrical weights.\n                    // let has_unbalanced_undirected_edge = maybe_edge_id.map_or(true, |edge_id| {\n                    //     weights.as_ref().map_or(false, |ws| {\n                    //         (ws[edge_id as usize] - weight.unwrap()).abs() >= f32::EPSILON\n                    //     })\n                    // });\n                    if maybe_edge_id.is_none() {\n                        return Err(concat!(\n                            \"You are trying to load an undirected \",\n                            \"graph using the directed edge list \",\n                            \"paremeter that requires for ALL edges to \",\n                            \"be fully defined in both directions.\\n\",\n                            \"The edge list you have provided does not \",\n                            \"provide the edges in both directions.\",\n                        )\n                        .to_string());\n                    }\n                    backward_undirected_edges_counter += 1\n                }\n                Ordering::Less => forward_undirected_edges_counter += 1,\n                Ordering::Equal => {}\n            }\n        }\n        last_edge_type = edge_type;\n        edges.unchecked_push(encode_edge(src, dst, node_bits));\n        if selfloop {\n            selfloop_number += 1;\n        }\n        // If either the source node or the destination node in the\n        // edge list has changed (keep in mind that the edge list\n        // at this point is sorted)\n        if different_src || different_dst {\n            if let Some(nwe) = &mut connected_nodes {\n                for node in &[src, dst] {\n                    unsafe {\n                        let mut ptr = nwe.get_unchecked_mut(*node as usize);\n                        if !*ptr {\n                            *ptr = true;\n                            if !selfloop || singleton_nodes_with_selfloops.is_none() {\n                                connected_nodes_number += 1;\n                            } else {\n                                if let Some(bitmap) = &mut singleton_nodes_with_selfloops {\n                                    bitmap.insert(*node);\n                                }\n                                break;\n                            }\n                        } else if !selfloop\n                            && singleton_nodes_with_selfloops\n                                .as_mut()\n                                .map_or(false, |bitmap| bitmap.remove(*node))\n                        {\n                            connected_nodes_number += 1;\n                        }\n                    }\n                }\n            }\n            unique_edges_number += 1;\n            if selfloop {\n                unique_selfloop_number += 1;\n            }\n            // If the src has changed we need to update multiple things,\n            // including the set of unique source nodes and the\n            // minimum and maximum node degrees.\n            if different_src {\n                if let Some(us) = &mut unique_sources {\n                    us.unchecked_push(src as u64);\n                }\n                // If it is not the first edge\n                if !first {\n                    // We update the minimum node degree\n                    min_node_degree = min_node_degree.min(current_node_degree);\n                    // And the maximum node degree\n                    max_node_degree = max_node_degree.max(current_node_degree);\n                    // And reset the current node degree to 0.\n                    current_node_degree = 0;\n                }\n            }\n        }\n        // We increase the current source node ID degree.\n        current_node_degree += 1;\n\n        last_src = src;\n        last_dst = dst;\n        first = false;\n    }\n\n    // We need to update the minimum and maximum node degrees\n    // for the last edge.\n\n    // We update the minimum node degree\n    if current_node_degree > 0 {\n        min_node_degree = min_node_degree.min(current_node_degree);\n    }\n    // And the maximum node degree\n    max_node_degree = max_node_degree.max(current_node_degree);\n\n    if forward_undirected_edges_counter != backward_undirected_edges_counter {\n        return Err(concat!(\n            \"You are trying to load an undirected graph \",\n            \"from a directed edge list but the edge list is not \",\n            \"complete.\"\n        )\n        .to_owned());\n    }\n\n    if let Some(ws) = &weights {\n        if edges.len() != ws.len() {\n            panic!(\n                \"The number of weights {} does not match the number of edges {}.\",\n                ws.len(),\n                edges.len()\n            );\n        }\n        if ws.is_empty() {\n            weights = None;\n            min_edge_weight = None;\n            max_edge_weight = None;\n        }\n    }\n\n    if let Some(ets) = &edge_type_ids {\n        if edges.len() != ets.len() {\n            panic!(\n                \"The number of edge types {} does not match the number of edges {}.\",\n                ets.len(),\n                edges.len()\n            );\n        }\n\n        if ets.is_empty() {\n            edge_type_ids = None;\n        }\n    }\n\n    if connected_nodes_number > nodes_number {\n        panic!(\n            \"There is an error in the constructor, the not singleton  node number '{}' is bigger than node number '{}'\",\n            connected_nodes_number, nodes_number\n        );\n    }\n\n    let singleton_nodes_with_selfloops_number = singleton_nodes_with_selfloops\n        .as_ref()\n        .map_or(0, |bitmap| bitmap.len() as NodeT);\n\n    // While on internal methods nodes_number is always exact, the user may\n    // provide a wrong value for nodes_number when loading a sorted csv.\n    // If this happens, it might cause a slow down in the walk and other\n    // currently unforseen consequences.\n    if unique_sources\n        .as_ref()\n        .map_or(false, |us| us.len() as NodeT == nodes_number)\n    {\n        unique_sources = None;\n    }\n\n    // When we have computed the nodes with edges set but we have left None\n    // the unique sources elias fano, this is done to avoid using extra memory\n    // for no reason. We need to create the elias fano object starting from the\n    // nodes with edges now to normalize the returned values.\n    if might_have_singletons\n        && unique_sources.is_none()\n        && nodes_number != connected_nodes_number + singleton_nodes_with_selfloops_number\n    {\n        unique_sources = connected_nodes\n            .as_ref()\n            .map_or(Ok::<_, String>(None), |nsns| {\n                Ok(Some(EliasFano::from_iter(\n                    nsns.iter_ones().into_iter().map(|x| x as u64),\n                    nodes_number as u64,\n                    connected_nodes_number as usize\n                        + singleton_nodes_with_selfloops_number as usize,\n                )?))\n            })?;\n    }\n\n    if !directed\n        && unique_sources\n            .as_ref()\n            .map_or(false, |x| connected_nodes_number > x.len() as NodeT)\n    {\n        panic!(\n            \"There is an error in the constructor, the not singleton node number '{}' is bigger than the len of unique sources which is '{}'\",\n            connected_nodes_number, unique_sources.unwrap().len()\n        );\n    }\n\n    // If the singleton_nodes_with_selfloops bitmap if empty, we return a None instead.\n    if singleton_nodes_with_selfloops\n        .as_ref()\n        .map_or(false, |bitmap| bitmap.is_empty())\n    {\n        singleton_nodes_with_selfloops = None;\n    }\n\n    // If we have found singleton nodes, information that when there are\n    // singleton nodes we know only after parsing both the node list and the\n    // edge list, we need to update the min node degree to 0.\n    if nodes_number > connected_nodes_number + singleton_nodes_with_selfloops_number\n        // this check is needed only if the graph is directed to verify if it \n        // has trap nodes, when there are trapnodes the number of unique sources\n        // is less than the number of nodes\n        || unique_sources\n            .as_ref()\n            .map_or(false, |us| (us.len() as NodeT) < nodes_number)\n    {\n        min_node_degree = 0;\n    }\n\n    Ok((\n        edges,\n        unique_sources,\n        edge_type_ids,\n        weights,\n        min_edge_weight,\n        max_edge_weight,\n        unique_edges_number,\n        selfloop_number,\n        unique_selfloop_number,\n        connected_nodes_number,\n        singleton_nodes_with_selfloops_number,\n        node_bits,\n        node_bit_mask,\n        connected_nodes,\n        singleton_nodes_with_selfloops,\n        min_node_degree,\n        max_node_degree,\n    ))"
            },
            {
                "file": "constructors.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "parse_nodes",
                "args": [
                    [
                        "nodes_iterator",
                        "Option<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>>>"
                    ],
                    [
                        "ignore_duplicated_nodes",
                        "bool"
                    ],
                    [
                        "node_list_is_correct",
                        "bool"
                    ],
                    [
                        "numeric_node_ids",
                        "bool"
                    ],
                    [
                        "numeric_node_types_ids",
                        "bool"
                    ],
                    [
                        "numeric_edge_node_ids",
                        "bool"
                    ],
                    [
                        "has_node_types",
                        "bool"
                    ]
                ],
                "return_type": "Result<(Vocabulary<NodeT>, Option<NodeTypeVocabulary>), String>",
                "body": "let mut nodes = Vocabulary::default()\n        .set_numeric_ids(numeric_node_ids || numeric_edge_node_ids && nodes_iterator.is_none());\n\n    let node_types = if let Some(ni) = nodes_iterator {\n        // TODO: the following can likely be dealt with in a better way.\n        let node_iterator = parse_node_ids(\n            ni,\n            ignore_duplicated_nodes,\n            node_list_is_correct,\n            &mut nodes,\n        );\n        // In the case there is a node types we need to add its proper iterator.\n        if has_node_types {\n            let mut node_types =\n                NodeTypeVocabulary::default().set_numeric_ids(numeric_node_types_ids);\n            for row in parse_node_type_ids(node_iterator, node_list_is_correct, &mut node_types) {\n                row?;\n            }\n            node_types.build_reverse_mapping()?;\n            node_types.build_counts();\n\n            if node_types.is_empty() {\n                Ok(None)\n            } else {\n                Ok::<_, String>(Some(node_types))\n            }\n        } else {\n            for row in node_iterator {\n                row?;\n            }\n            Ok::<_, String>(None)\n        }?\n    } else {\n        None\n    };\n\n    Ok((nodes, node_types))"
            },
            {
                "file": "constructors.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "parse_string_edges",
                "args": [
                    [
                        "edges_iter",
                        "impl Iterator<Item = Result<StringQuadruple, String>>"
                    ],
                    [
                        "edges_number",
                        "usize"
                    ],
                    [
                        "nodes_number",
                        "NodeT"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "nodes",
                        "Vocabulary<NodeT>"
                    ],
                    [
                        "numeric_edge_type_ids",
                        "bool"
                    ],
                    [
                        "directed_edge_list",
                        "bool"
                    ],
                    [
                        "edge_list_is_correct",
                        "bool"
                    ],
                    [
                        "ignore_duplicated_edges",
                        "bool"
                    ],
                    [
                        "has_edge_types",
                        "bool"
                    ],
                    [
                        "has_edge_weights",
                        "bool"
                    ],
                    [
                        "might_have_singletons",
                        "bool"
                    ],
                    [
                        "might_have_singletons_with_selfloops",
                        "bool"
                    ],
                    [
                        "might_have_trap_nodes",
                        "bool"
                    ]
                ],
                "return_type": "ParsedStringEdgesType",
                "body": "let mut edge_types_vocabulary: Vocabulary<EdgeTypeT> =\n        Vocabulary::default().set_numeric_ids(numeric_edge_type_ids);\n\n    // This is not equivalent to nodes_iterator.is_some() because the iterator\n    // could also be empty, this is a corner-case that might happen when over-filtering\n    // or fuzzing or loading an empty file with improper configurations.\n    // There might be singletons if the user has told us that there might be singletons\n    // and the node list is not empty. If the node list is empty, then it is not possible\n    // to have singletons.\n    let might_have_singletons = !nodes.is_empty() && might_have_singletons;\n    // If the graph is undirected there cannot be trap nodes\n    let might_have_trap_nodes = directed && might_have_trap_nodes;\n\n    let edges_iter = parse_sorted_edges(\n        parse_edge_type_ids_vocabulary(\n            parse_edges_node_ids(edges_iter, edge_list_is_correct, &mut nodes),\n            edge_list_is_correct,\n            &mut edge_types_vocabulary,\n        ),\n        directed,\n        directed_edge_list,\n    );\n\n    let (\n        edges,\n        unique_sources,\n        edge_type_ids,\n        weights,\n        min_edge_weight,\n        max_edge_weight,\n        unique_edges_number,\n        selfloop_number,\n        unique_selfloop_number,\n        connected_nodes_number,\n        singleton_nodes_with_selfloops_number,\n        node_bits,\n        node_bit_mask,\n        connected_nodes,\n        singleton_nodes_with_selfloops,\n        min_node_degree,\n        max_node_degree,\n    ) = build_edges(\n        edges_iter,\n        edges_number,\n        nodes_number,\n        ignore_duplicated_edges,\n        has_edge_weights,\n        has_edge_types,\n        might_have_singletons,\n        might_have_singletons_with_selfloops,\n        might_have_trap_nodes,\n        directed,\n        edge_list_is_correct,\n    )?;\n\n    nodes.build_reverse_mapping()?;\n    edge_types_vocabulary.build_reverse_mapping()?;\n    let edge_types =\n        EdgeTypeVocabulary::from_option_structs(edge_type_ids, optionify!(edge_types_vocabulary));\n\n    Ok((\n        edges,\n        unique_sources,\n        nodes,\n        edge_types,\n        weights,\n        min_edge_weight,\n        max_edge_weight,\n        unique_edges_number,\n        selfloop_number,\n        unique_selfloop_number,\n        connected_nodes_number,\n        singleton_nodes_with_selfloops_number,\n        node_bit_mask,\n        node_bits,\n        connected_nodes,\n        singleton_nodes_with_selfloops,\n        min_node_degree,\n        max_node_degree,\n    ))"
            },
            {
                "file": "constructors.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "parse_integer_edges",
                "args": [
                    [
                        "edges_iter",
                        "impl Iterator<Item = Result<Quadruple, String>>"
                    ],
                    [
                        "edges_number",
                        "usize"
                    ],
                    [
                        "nodes_number",
                        "NodeT"
                    ],
                    [
                        "edge_types_vocabulary",
                        "Option<Vocabulary<EdgeTypeT>>"
                    ],
                    [
                        "ignore_duplicated_edges",
                        "bool"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "edge_list_is_correct",
                        "bool"
                    ],
                    [
                        "has_edge_types",
                        "bool"
                    ],
                    [
                        "has_edge_weights",
                        "bool"
                    ],
                    [
                        "might_have_singletons",
                        "bool"
                    ],
                    [
                        "might_have_singletons_with_selfloops",
                        "bool"
                    ],
                    [
                        "might_have_trap_nodes",
                        "bool"
                    ]
                ],
                "return_type": "Result<\n    (\n        EliasFano,\n        Option<EliasFano>,\n        Option<EdgeTypeVocabulary>,\n        Option<Vec<WeightT>>,\n        Option<WeightT>,\n        Option<WeightT>,\n        EdgeT,\n        EdgeT,\n        NodeT,\n        NodeT,\n        NodeT,\n        u64,\n        u8,\n        Option<BitVec<Lsb0, u8>>,\n        Option<RoaringBitmap>,\n        NodeT,\n        NodeT,\n    ),\n    String,\n>",
                "body": "let (\n        edges,\n        unique_sources,\n        edge_type_ids,\n        weights,\n        min_edge_weight,\n        max_edge_weight,\n        unique_edges_number,\n        selfloop_number,\n        unique_selfloop_number,\n        connected_nodes_number,\n        singleton_nodes_with_selfloops_number,\n        node_bits,\n        node_bit_mask,\n        connected_nodes,\n        singleton_nodes_with_selfloops,\n        min_node_degree,\n        max_node_degree,\n    ) = build_edges(\n        edges_iter,\n        edges_number,\n        nodes_number,\n        ignore_duplicated_edges,\n        has_edge_weights,\n        has_edge_types,\n        might_have_singletons,\n        might_have_singletons_with_selfloops,\n        might_have_trap_nodes,\n        directed,\n        edge_list_is_correct,\n    )?;\n\n    let edge_types = EdgeTypeVocabulary::from_option_structs(edge_type_ids, edge_types_vocabulary);\n\n    Ok((\n        edges,\n        unique_sources,\n        edge_types,\n        weights,\n        min_edge_weight,\n        max_edge_weight,\n        unique_edges_number,\n        selfloop_number,\n        unique_selfloop_number,\n        connected_nodes_number,\n        singleton_nodes_with_selfloops_number,\n        node_bit_mask,\n        node_bits,\n        connected_nodes,\n        singleton_nodes_with_selfloops,\n        min_node_degree,\n        max_node_degree,\n    ))"
            },
            {
                "file": "constructors.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Graph Constructors"
                ],
                "doc": [],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "build_graph",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "edges_iter",
                        "impl Iterator<Item = Result<Quadruple, String>>"
                    ],
                    [
                        "edges_number",
                        "usize"
                    ],
                    [
                        "nodes",
                        "Vocabulary<NodeT>"
                    ],
                    [
                        "node_types",
                        "Option<NodeTypeVocabulary>"
                    ],
                    [
                        "edge_types_vocabulary",
                        "Option<Vocabulary<EdgeTypeT>>"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "edge_list_is_correct",
                        "bool"
                    ],
                    [
                        "name",
                        "S"
                    ],
                    [
                        "ignore_duplicated_edges",
                        "bool"
                    ],
                    [
                        "has_edge_types",
                        "bool"
                    ],
                    [
                        "has_edge_weights",
                        "bool"
                    ],
                    [
                        "might_have_singletons",
                        "bool"
                    ],
                    [
                        "might_have_singletons_with_selfloops",
                        "bool"
                    ],
                    [
                        "might_have_trap_nodes",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let (\n            edges,\n            unique_sources,\n            edge_types,\n            weights,\n            min_edge_weight,\n            max_edge_weight,\n            unique_edges_number,\n            selfloop_number,\n            unique_selfloop_number,\n            connected_nodes_number,\n            singleton_nodes_with_selfloops_number,\n            node_bit_mask,\n            node_bits,\n            connected_nodes,\n            singleton_nodes_with_selfloops,\n            min_node_degree,\n            max_node_degree,\n        ) = parse_integer_edges(\n            edges_iter,\n            edges_number,\n            nodes.len() as NodeT,\n            edge_types_vocabulary,\n            ignore_duplicated_edges,\n            directed,\n            edge_list_is_correct,\n            has_edge_types,\n            has_edge_weights,\n            might_have_singletons,\n            might_have_singletons_with_selfloops,\n            might_have_trap_nodes,\n        )?;\n\n        Ok(Graph::new(\n            directed,\n            unique_selfloop_number,\n            selfloop_number,\n            connected_nodes_number,\n            singleton_nodes_with_selfloops_number,\n            unique_edges_number,\n            edges,\n            unique_sources,\n            nodes,\n            node_bit_mask,\n            node_bits,\n            edge_types,\n            name,\n            weights,\n            min_edge_weight,\n            max_edge_weight,\n            node_types,\n            connected_nodes,\n            singleton_nodes_with_selfloops,\n            min_node_degree,\n            max_node_degree,\n        ))"
            },
            {
                "file": "constructors.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Graph Constructors"
                ],
                "doc": [
                    " Create new Graph object from unsorted source.",
                    "",
                    " # Arguments",
                    " * `edges_iterator`: impl Iterator<Item = Result<StringQuadruple, String>> - Iterator on the edge list composed of strings.",
                    " * `nodes_iterator`: Option<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>>> - Option of an iterator on the node list composed of strings.",
                    " * `directed`: bool - Whether the edge list should be loaded as directed or undirected.",
                    " * `directed_edge_list`: bool - Whether the edge list is expressed as directed. If this is an undirected graph, we expect a directed edge list to contain edges in BOTH directions.",
                    " * `name`: S - The name of the graph.",
                    " * `ignore_duplicated_nodes`: bool - Whether to ignore and skip the detected duplicated node names or to raise an error.",
                    " * `node_list_is_correct`: bool - Whether the user pinky promises that the node list is correct. This feature will lead to panics if used improperly by an over-optimistic user. Enable this flag only if you are sure you are correct.",
                    " * `ignore_duplicated_edges`: bool - Whether to ignore and skip the detected duplicated edges or to raise an error.",
                    " * `edge_list_is_correct`: bool - Whether the user pinky promises that the edge list is correct. This feature will lead to panics if used improperly by an over-optimistic user. Enable this flag only if you are sure you are correct.",
                    " * `numeric_edge_type_ids`: bool - Whether the edge type IDs should be loaded as numeric, casting them to integers. The range of edge type IDs MUST be dense.",
                    " * `numeric_node_ids`: bool - Whether the node IDs should be loaded as numeric, casting them to integers. The range of node IDs MUST be dense.",
                    " * `numeric_edge_node_ids`: bool - Whether the edge node IDs should be loaded as numeric, casting them to integers. The range of edge node IDs MUST be dense.",
                    " * `numeric_node_types_ids`: bool - Whether the node type IDs should be loaded as numeric, casting them to integers. The range of node type IDs MUST be dense.",
                    " * `has_node_types`: bool - Whether the graph has node types.",
                    " * `has_edge_types`: bool - Whether the graph has edge types.",
                    " * `has_edge_weights`: bool - Whether the graph has edge weights.",
                    " * `might_have_singletons`: bool - Whether the graph is KNOWN to have or not singleton nodes. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct.",
                    " * `might_have_singletons_with_selfloops`: bool - Whether the graph is KNOWN to have or not singleton nodes with selfloops. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct.",
                    " * `might_have_trap_nodes`: bool - Whether the graph is KNOWN to have or not trap nodes. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct.",
                    " * `verbose`: bool - Whether we should show loading bars while building the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "from_string_unsorted",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "edges_iterator",
                        "impl Iterator<Item = Result<StringQuadruple, String>>"
                    ],
                    [
                        "nodes_iterator",
                        "Option<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>>>"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "directed_edge_list",
                        "bool"
                    ],
                    [
                        "name",
                        "S"
                    ],
                    [
                        "ignore_duplicated_nodes",
                        "bool"
                    ],
                    [
                        "node_list_is_correct",
                        "bool"
                    ],
                    [
                        "ignore_duplicated_edges",
                        "bool"
                    ],
                    [
                        "edge_list_is_correct",
                        "bool"
                    ],
                    [
                        "numeric_edge_type_ids",
                        "bool"
                    ],
                    [
                        "numeric_node_ids",
                        "bool"
                    ],
                    [
                        "numeric_edge_node_ids",
                        "bool"
                    ],
                    [
                        "numeric_node_types_ids",
                        "bool"
                    ],
                    [
                        "has_node_types",
                        "bool"
                    ],
                    [
                        "has_edge_types",
                        "bool"
                    ],
                    [
                        "has_edge_weights",
                        "bool"
                    ],
                    [
                        "might_have_singletons",
                        "bool"
                    ],
                    [
                        "might_have_singletons_with_selfloops",
                        "bool"
                    ],
                    [
                        "might_have_trap_nodes",
                        "bool"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "check_numeric_ids_compatibility(\n            nodes_iterator.is_some(),\n            numeric_node_ids,\n            numeric_edge_node_ids,\n        )?;\n\n        let (nodes, node_types) = parse_nodes(\n            nodes_iterator,\n            ignore_duplicated_nodes,\n            node_list_is_correct,\n            numeric_node_ids,\n            numeric_node_types_ids,\n            numeric_edge_node_ids,\n            has_node_types,\n        )?;\n\n        // This is not equivalent to nodes_iterator.is_some() because the iterator\n        // could also be empty, this is a corner-case that might happen when over-filtering\n        // or fuzzing or loading an empty file with improper configurations.\n        // There might be singletons if the user has told us that there might be singletons\n        // and the node list is not empty. If the node list is empty, then it is not possible\n        // to have singletons.\n        let might_have_singletons = !nodes.is_empty() && might_have_singletons;\n        // If the graph is undirected there cannot be trap nodes\n        let might_have_trap_nodes = directed && might_have_trap_nodes;\n\n        info!(\"Parse unsorted edges.\");\n        let (edges_number, edges_iterator, nodes, edge_types_vocabulary) =\n            parse_string_unsorted_edges(\n                edges_iterator,\n                nodes,\n                directed,\n                directed_edge_list,\n                edge_list_is_correct,\n                has_edge_types,\n                verbose,\n                numeric_edge_type_ids,\n            )?;\n\n        Graph::build_graph(\n            edges_iterator,\n            edges_number,\n            nodes,\n            node_types,\n            edge_types_vocabulary,\n            directed,\n            edge_list_is_correct || !directed_edge_list,\n            name,\n            ignore_duplicated_edges,\n            has_edge_types,\n            has_edge_weights,\n            might_have_singletons,\n            might_have_singletons_with_selfloops,\n            might_have_trap_nodes,\n        )"
            },
            {
                "file": "constructors.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Graph Constructors"
                ],
                "doc": [
                    " Create new Graph object from unsorted source.",
                    "",
                    " # Arguments",
                    " * `edges_iterator`: impl Iterator<Item = Result<(NodeT, NodeT, Option<NodeTypeT>, Option<WeightT>), String>> - Iterator over the egde node IDs.",
                    " * `nodes`: Vocabulary<NodeT> - Vocabulary of the node IDs.",
                    " * `node_types`: Option<NodeTypeVocabulary> - Option of the vocabulary of the node type IDs.",
                    " * `edge_types_vocabulary`: Option<Vocabulary<EdgeTypeT>> - Option of the Vocabulary of the edge type IDs.",
                    " * `directed`: bool - Whether to load the graph as directed or undirected.",
                    " * `name`: String - Name of the graph.",
                    " * `ignore_duplicated_edges`: bool - Whether to ignore and skip the detected duplicated edges or to raise an error.",
                    " * `has_edge_types`: bool - Whether the graph has edge types.",
                    " * `has_edge_weights`: bool - Whether the graph has edge weights.",
                    " * `might_have_singletons`: bool - Whether the graph is KNOWN to have or not singleton nodes. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct.",
                    " * `might_have_singletons_with_selfloops`: bool - Whether the graph is KNOWN to have or not singleton nodes with selfloops. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct.",
                    " * `might_have_trap_nodes`: bool - Whether the graph is KNOWN to have or not trap nodes. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct.",
                    " * `verbose`: bool - Whether to show theloading bars while loading the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "from_integer_unsorted",
                "args": [
                    [
                        "edges_iterator",
                        "impl Iterator<\n            Item = Result<(NodeT, NodeT, Option<NodeTypeT>, Option<WeightT>), String>,\n        >"
                    ],
                    [
                        "nodes",
                        "Vocabulary<NodeT>"
                    ],
                    [
                        "node_types",
                        "Option<NodeTypeVocabulary>"
                    ],
                    [
                        "edge_types_vocabulary",
                        "Option<Vocabulary<EdgeTypeT>>"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "name",
                        "String"
                    ],
                    [
                        "ignore_duplicated_edges",
                        "bool"
                    ],
                    [
                        "has_edge_types",
                        "bool"
                    ],
                    [
                        "has_edge_weights",
                        "bool"
                    ],
                    [
                        "might_have_singletons",
                        "bool"
                    ],
                    [
                        "might_have_singletons_with_selfloops",
                        "bool"
                    ],
                    [
                        "might_have_trap_nodes",
                        "bool"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "let (edges_number, edges_iterator) =\n            parse_integer_unsorted_edges(edges_iterator, directed, true, verbose)?;\n\n        Graph::build_graph(\n            edges_iterator,\n            edges_number,\n            nodes,\n            node_types,\n            edge_types_vocabulary,\n            directed,\n            true,\n            name,\n            ignore_duplicated_edges,\n            has_edge_types,\n            has_edge_weights,\n            might_have_singletons,\n            might_have_singletons_with_selfloops,\n            might_have_trap_nodes,\n        )"
            },
            {
                "file": "constructors.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Graph Constructors"
                ],
                "doc": [
                    " Create new Graph object from sorted sources.",
                    "",
                    " # Arguments",
                    " * `edges_iterator`: impl Iterator<Item = Result<StringQuadruple, String>> - Iterator on the edge list composed of strings.",
                    " * `nodes_iterator`: Option<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>>> - Option of an iterator on the node list composed of strings.",
                    " * `directed`: bool - Whether the edge list should be loaded as directed or undirected.",
                    " * `directed_edge_list`: bool - Whether the edge list is expressed as directed. If this is an undirected graph, we expect a directed edge list to contain edges in BOTH directions.",
                    " * `name`: S - The name of the graph.",
                    " * `ignore_duplicated_nodes`: bool - Whether to ignore and skip the detected duplicated node names or to raise an error.",
                    " * `node_list_is_correct`: bool - Whether the user pinky promises that the node list is correct. This feature will lead to panics if used improperly by an over-optimistic user. Enable this flag only if you are sure you are correct.",
                    " * `ignore_duplicated_edges`: bool - Whether to ignore and skip the detected duplicated edges or to raise an error.",
                    " * `edge_list_is_correct`: bool - Whether the user pinky promises that the edge list is correct. This feature will lead to panics if used improperly by an over-optimistic user. Enable this flag only if you are sure you are correct.",
                    " * `edges_number`: usize - Exact number of edges in the graph.",
                    " * `nodes_number`: NodeT - Exact number of nodes in the graph.",
                    " * `numeric_edge_type_ids`: bool - Whether the edge type IDs should be loaded as numeric, casting them to integers. The range of edge type IDs MUST be dense.",
                    " * `numeric_node_ids`: bool - Whether the node IDs should be loaded as numeric, casting them to integers. The range of node IDs MUST be dense.",
                    " * `numeric_edge_node_ids`: bool - Whether the edge node IDs should be loaded as numeric, casting them to integers. The range of edge node IDs MUST be dense.",
                    " * `numeric_node_types_ids`: bool - Whether the node type IDs should be loaded as numeric, casting them to integers. The range of node type IDs MUST be dense.",
                    " * `has_node_types`: bool - Whether the graph has node types.",
                    " * `has_edge_types`: bool - Whether the graph has edge types.",
                    " * `has_edge_weights`: bool - Whether the graph has edge weights.",
                    " * `might_have_singletons`: bool - Whether the graph is KNOWN to have or not singleton nodes. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct.",
                    " * `might_have_singletons_with_selfloops`: bool - Whether the graph is KNOWN to have or not singleton nodes with selfloops. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct.",
                    " * `might_have_trap_nodes`: bool - Whether the graph is KNOWN to have or not trap nodes. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "from_string_sorted",
                "generics": "S: Into<String>",
                "args": [
                    [
                        "edges_iterator",
                        "impl Iterator<Item = Result<StringQuadruple, String>>"
                    ],
                    [
                        "nodes_iterator",
                        "Option<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>>>"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "directed_edge_list",
                        "bool"
                    ],
                    [
                        "name",
                        "S"
                    ],
                    [
                        "ignore_duplicated_nodes",
                        "bool"
                    ],
                    [
                        "node_list_is_correct",
                        "bool"
                    ],
                    [
                        "ignore_duplicated_edges",
                        "bool"
                    ],
                    [
                        "edge_list_is_correct",
                        "bool"
                    ],
                    [
                        "edges_number",
                        "usize"
                    ],
                    [
                        "nodes_number",
                        "NodeT"
                    ],
                    [
                        "numeric_edge_type_ids",
                        "bool"
                    ],
                    [
                        "numeric_node_ids",
                        "bool"
                    ],
                    [
                        "numeric_edge_node_ids",
                        "bool"
                    ],
                    [
                        "numeric_node_types_ids",
                        "bool"
                    ],
                    [
                        "has_node_types",
                        "bool"
                    ],
                    [
                        "has_edge_types",
                        "bool"
                    ],
                    [
                        "has_edge_weights",
                        "bool"
                    ],
                    [
                        "might_have_singletons",
                        "bool"
                    ],
                    [
                        "might_have_singletons_with_selfloops",
                        "bool"
                    ],
                    [
                        "might_have_trap_nodes",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "check_numeric_ids_compatibility(\n            nodes_iterator.is_some(),\n            numeric_node_ids,\n            numeric_edge_node_ids,\n        )?;\n        let (nodes, node_types) = parse_nodes(\n            nodes_iterator,\n            ignore_duplicated_nodes,\n            node_list_is_correct,\n            numeric_node_ids,\n            numeric_node_types_ids,\n            numeric_edge_node_ids,\n            has_node_types,\n        )?;\n\n        if !nodes.is_empty() {\n            nodes_number = nodes.len() as NodeT;\n        }\n\n        let (\n            edges,\n            unique_sources,\n            nodes,\n            edge_types,\n            weights,\n            min_edge_weight,\n            max_edge_weight,\n            unique_edges_number,\n            selfloop_number,\n            unique_selfloop_number,\n            connected_nodes_number,\n            singleton_nodes_with_selfloops_number,\n            node_bit_mask,\n            node_bits,\n            connected_nodes,\n            singleton_nodes_with_selfloops,\n            min_node_degree,\n            max_node_degree,\n        ) = parse_string_edges(\n            edges_iterator,\n            edges_number,\n            nodes_number,\n            directed,\n            nodes,\n            numeric_edge_type_ids,\n            directed_edge_list,\n            edge_list_is_correct,\n            ignore_duplicated_edges,\n            has_edge_types,\n            has_edge_weights,\n            might_have_singletons,\n            might_have_singletons_with_selfloops,\n            might_have_trap_nodes,\n        )?;\n\n        Ok(Graph::new(\n            directed,\n            unique_selfloop_number,\n            selfloop_number,\n            connected_nodes_number,\n            singleton_nodes_with_selfloops_number,\n            unique_edges_number,\n            edges,\n            unique_sources,\n            nodes,\n            node_bit_mask,\n            node_bits,\n            edge_types,\n            name,\n            weights,\n            min_edge_weight,\n            max_edge_weight,\n            node_types,\n            connected_nodes,\n            singleton_nodes_with_selfloops,\n            min_node_degree,\n            max_node_degree,\n        ))"
            }
        ]
    },
    "holdouts.rs": {
        "imports": [
            "use super::*;",
            "use counter::Counter;",
            "use indicatif::ParallelProgressIterator;",
            "use indicatif::ProgressIterator;",
            "use rand::rngs::SmallRng;",
            "use rand::seq::SliceRandom;",
            "use rand::SeedableRng;",
            "use rayon::iter::IndexedParallelIterator;",
            "use rayon::iter::IntoParallelIterator;",
            "use rayon::iter::ParallelIterator;",
            "use roaring::{RoaringBitmap, RoaringTreemap};",
            "use std::collections::HashSet;",
            "use vec_rand::xorshift::xorshift as rand_u64;",
            "use vec_rand::{gen_random_vec, sample_uniform};"
        ],
        "functions": [
            {
                "file": "holdouts.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Holdouts."
                ],
                "doc": [
                    " Returns Graph with given amount of negative edges as positive edges.",
                    "",
                    " The graph generated may be used as a testing negatives partition to be",
                    " fed into the argument \"graph_to_avoid\" of the link_prediction or the",
                    " skipgrams algorithm.",
                    "",
                    "",
                    " # Arguments",
                    "",
                    " * `random_state`: EdgeT - random_state to use to reproduce negative edge set.",
                    " * `negatives_number`: EdgeT - Number of negatives edges to include.",
                    " * `seed_graph`: Option<&Graph> - Optional graph to use to filter the negative edges. The negative edges generated when this variable is provided will always have a node within this graph.",
                    " * `only_from_same_component`: bool - Whether to sample negative edges only from nodes that are from the same component.",
                    " * `verbose`: bool - Whether to show the loading bar.",
                    ""
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "sample_negatives",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "random_state",
                        "EdgeT"
                    ],
                    [
                        "negatives_number",
                        "EdgeT"
                    ],
                    [
                        "seed_graph",
                        "Option<&Graph>"
                    ],
                    [
                        "only_from_same_component",
                        "bool"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "if negatives_number == 0 {\n            return Err(String::from(\"The number of negatives cannot be zero.\"));\n        }\n        let seed_nodes: Option<RoaringBitmap> = if let Some(sg) = &seed_graph {\n            if !self.overlaps(&sg)? {\n                return Err(String::from(\n                    \"The given seed graph does not overlap with the current graph instance.\",\n                ));\n            }\n            Some(\n                sg.iter_node_names_and_node_type_names()\n                    .map(|(_, node_name, _, _)| {\n                        self.get_unchecked_node_id_from_node_name(&node_name)\n                    })\n                    .collect::<RoaringBitmap>(),\n            )\n        } else {\n            None\n        };\n        // In a complete directed graph allowing selfloops with N nodes there are N^2\n        // edges. In a complete directed graph without selfloops there are N*(N-1) edges.\n        // We can rewrite the first formula as (N*(N-1)) + N.\n        //\n        // In a complete undirected graph allowing selfloops with N nodes there are\n        // (N*(N-1))/2 + N edges.\n\n        // Here we use unique edges number because on a multigraph the negative\n        // edges cannot have an edge type.\n        let nodes_number = self.get_nodes_number() as EdgeT;\n\n        // whether to sample negative edges only from the same connected component.\n        let (node_components, mut complete_edges_number) = if only_from_same_component {\n            let node_components = self.get_node_connected_component_ids(verbose);\n            let complete_edges_number: EdgeT = Counter::init(node_components.clone())\n                .into_iter()\n                .map(|(_, nodes_number): (_, &usize)| {\n                    let mut edge_number = (*nodes_number * (*nodes_number - 1)) as EdgeT;\n                    if !self.is_directed() {\n                        edge_number /= 2;\n                    }\n                    edge_number\n                })\n                .sum();\n            (Some(node_components), complete_edges_number)\n        } else {\n            let mut edge_number = nodes_number * (nodes_number - 1);\n            if !self.is_directed() {\n                edge_number /= 2;\n            }\n            (None, edge_number)\n        };\n\n        // Here we compute the number of edges that a complete graph would have if it had the same number of nodes\n        // of the current graph. Moreover, the complete graph will have selfloops IFF the current graph has at\n        // least one of them.\n        if self.has_selfloops() {\n            complete_edges_number += nodes_number;\n        }\n\n        // Now we compute the maximum number of negative edges that we can actually generate\n        let max_negative_edges = complete_edges_number - self.get_unique_edges_number();\n\n        // We check that the number of requested negative edges is compatible with the\n        // current graph instance.\n        if negatives_number > max_negative_edges {\n            return Err(format!(\n                concat!(\n                    \"The requested negatives number {} is more than the \",\n                    \"number of negative edges that exist in the graph ({}).\"\n                ),\n                negatives_number, max_negative_edges\n            ));\n        }\n\n        // As the above check, it is not possible to generate some negative\n        // graphs when some conditions.\n        if negatives_number % 2 == 1 && !self.is_directed() && !self.has_selfloops() {\n            return Err(format!(\n                concat!(\n                    \"The requested negatives number {} is an odd number and \",\n                    \"the graph is neither directed nor has selfloops, so it is \",\n                    \"not possible to sample an odd number of edges.\"\n                ),\n                negatives_number\n            ));\n        }\n\n        let pb1 = get_loading_bar(\n            verbose,\n            \"Computing negative edges\",\n            negatives_number as usize,\n        );\n\n        // xorshift breaks if the random_state is zero\n        // so we initialize xor it with a constat\n        // to mitigate this problem\n        random_state ^= SEED_XOR as EdgeT;\n\n        let mut negative_edges_hashset = HashSet::with_capacity(negatives_number as usize);\n        let mut last_length = 0;\n        let mut sampling_round: usize = 0;\n\n        // randomly extract negative edges until we have the choosen number\n        while negative_edges_hashset.len() < negatives_number as usize {\n            // generate two random_states for reproducibility porpouses\n            let src_random_state = rand_u64(random_state);\n            let dst_random_state = rand_u64(src_random_state);\n            random_state = rand_u64(dst_random_state);\n\n            let tmp_tb = get_loading_bar(\n                verbose,\n                format!(\"Negatives sampling round {}\", sampling_round).as_ref(),\n                negatives_number as usize,\n            );\n            sampling_round += 1;\n\n            // generate the random edge-sources\n            let sampled_edge_ids = gen_random_vec(negatives_number as usize, src_random_state)\n                .into_par_iter()\n                .zip(gen_random_vec(negatives_number as usize, dst_random_state).into_par_iter())\n                // convert them to plain (src, dst)\n                .progress_with(tmp_tb)\n                .filter_map(|(src_seed, dst_seed)| {\n                    let src = sample_uniform(nodes_number as u64, src_seed as u64) as NodeT;\n                    let dst = sample_uniform(nodes_number as u64, dst_seed as u64) as NodeT;\n                    if !self.is_directed() && src > dst {\n                        return None;\n                    }\n\n                    if !self.has_selfloops() && src == dst {\n                        return None;\n                    }\n\n                    if let Some(sn) = &seed_nodes {\n                        if !sn.contains(src) && !sn.contains(dst) {\n                            return None;\n                        }\n                    }\n                    if let Some(ncs) = &node_components {\n                        if ncs[src as usize] != ncs[dst as usize] {\n                            return None;\n                        }\n                    }\n                    // If the edge is not a self-loop or the user allows self-loops and\n                    // the graph is directed or the edges are inserted in a way to avoid\n                    // inserting bidirectional edges.\n                    match self.has_edge_from_node_ids(src, dst) {\n                        true => None,\n                        false => Some(self.encode_edge(src, dst)),\n                    }\n                })\n                .collect::<Vec<EdgeT>>();\n\n            let pb3 = get_loading_bar(\n                verbose,\n                format!(\n                    \"Inserting negative graph edges (iteration {})\",\n                    sampling_round\n                )\n                .as_ref(),\n                negatives_number as usize,\n            );\n\n            for edge_id in sampled_edge_ids.iter().progress_with(pb3) {\n                if negative_edges_hashset.len() >= negatives_number as usize {\n                    break;\n                }\n                negative_edges_hashset.insert(*edge_id);\n            }\n\n            if sampling_round > 50000 {\n                panic!(\"Deadlock in sampling negatives!\");\n            }\n\n            pb1.inc((negative_edges_hashset.len() - last_length as usize) as u64);\n            last_length = negative_edges_hashset.len();\n        }\n\n        pb1.finish();\n\n        Graph::from_integer_unsorted(\n            negative_edges_hashset.into_iter().flat_map(|edge| {\n                let (src, dst) = self.decode_edge(edge);\n                if !self.is_directed() && src != dst {\n                    vec![Ok((src, dst, None, None)), Ok((dst, src, None, None))]\n                } else {\n                    vec![Ok((src, dst, None, None))]\n                }\n            }),\n            self.nodes.clone(),\n            self.node_types.clone(),\n            None,\n            self.directed,\n            format!(\"Negative {}\", self.name.clone()),\n            false,\n            false,\n            false,\n            true,\n            self.has_selfloops(),\n            true,\n            verbose,\n        )"
            },
            {
                "file": "holdouts.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Holdouts."
                ],
                "doc": [
                    " Compute the training and validation elements number from the training rate",
                    "",
                    " # Raises",
                    " * If the training size is either greater than one or negative.",
                    " * If the graph instance has only one edge.",
                    " * If the resulting training edges number is 0.",
                    " * If the resulting validation edges number is 0."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "get_holdouts_elements_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "train_size",
                        "f64"
                    ],
                    [
                        "total_elements",
                        "usize"
                    ]
                ],
                "return_type": "Result<(usize, usize), String>",
                "body": "if train_size <= 0.0 || train_size >= 1.0 {\n            return Err(String::from(\"Train rate must be strictly between 0 and 1.\"));\n        }\n        if self.directed && self.get_directed_edges_number() == 1\n            || !self.directed && self.get_directed_edges_number() == 2\n        {\n            return Err(String::from(\n                \"The current graph instance has only one edge. You cannot build an holdout with one edge.\",\n            ));\n        }\n        let train_elements_number = (total_elements as f64 * train_size) as usize;\n        let valid_elements_number = total_elements - train_elements_number;\n\n        if train_elements_number == 0 || train_elements_number >= total_elements {\n            return Err(String::from(\n                \"The training set has 0 elements! Change the training rate.\",\n            ));\n        }\n        if valid_elements_number == 0 {\n            return Err(String::from(\n                \"The validation set has 0 elements! Change the training rate.\",\n            ));\n        }\n\n        Ok((train_elements_number, valid_elements_number))"
            },
            {
                "file": "holdouts.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Holdouts."
                ],
                "doc": [
                    " Returns training and validation graph.",
                    "",
                    " # Arguments",
                    " * `random_state`: EdgeT - The random state to reproduce the holdout.",
                    " * `validation_edges_number`: EdgeT - The number of edges to reserve for the validation graph.",
                    " * `include_all_edge_types`: bool - Whether to include all the edge types in the graph, if the graph is a multigraph.",
                    " * `user_condition_for_validation_edges`: impl Fn(EdgeT, NodeT, NodeT, Option<EdgeTypeT>) -> bool - The function to use to put edges in validation set.",
                    " * `verbose`: bool - Whether to show the loading bar or not.",
                    " * `train_graph_might_have_singletons`: bool - Whether it is known that the resulting training graph may have singletons.",
                    " * `train_graph_might_have_singletons_with_selfloops`: bool - Whether it is known that the resulting training graph may have singletons with selfloops.",
                    "",
                    " # Raises",
                    " * If the sampled validation edges are not enough for the required validation edges number."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "edge_holdout",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "random_state",
                        "EdgeT"
                    ],
                    [
                        "validation_edges_number",
                        "EdgeT"
                    ],
                    [
                        "include_all_edge_types",
                        "bool"
                    ],
                    [
                        "user_condition_for_validation_edges",
                        "impl Fn(EdgeT, NodeT, NodeT, Option<EdgeTypeT>) -> bool"
                    ],
                    [
                        "verbose",
                        "bool"
                    ],
                    [
                        "train_graph_might_have_singletons",
                        "bool"
                    ],
                    [
                        "train_graph_might_have_singletons_with_selfloops",
                        "bool"
                    ]
                ],
                "return_type": "Result<(Graph, Graph), String>",
                "body": "let validation_edges_pb = get_loading_bar(\n            verbose,\n            \"Picking validation edges\",\n            validation_edges_number as usize,\n        );\n\n        // generate and shuffle the indices of the edges\n        let mut rng = SmallRng::seed_from_u64(random_state ^ SEED_XOR as EdgeT);\n        let mut edge_indices: Vec<EdgeT> = (0..self.get_directed_edges_number()).collect();\n        edge_indices.shuffle(&mut rng);\n\n        let mut valid_edges_bitmap = RoaringTreemap::new();\n        let mut last_length = 0;\n\n        for (edge_id, (src, dst, edge_type)) in edge_indices.into_iter().map(|edge_id| {\n            (\n                edge_id,\n                self.get_unchecked_node_ids_and_edge_type_id_from_edge_id(edge_id),\n            )\n        }) {\n            // If the graph is undirected and we have extracted an edge that is a\n            // simmetric one, we can skip this iteration.\n            if !self.directed && src > dst {\n                continue;\n            }\n\n            // We stop adding edges when we have reached the minimum amount.\n            if user_condition_for_validation_edges(edge_id, src, dst, edge_type) {\n                // Compute the forward edge ids that are required.\n                valid_edges_bitmap.extend(self.compute_edge_ids_vector(\n                    edge_id,\n                    src,\n                    dst,\n                    include_all_edge_types,\n                ));\n\n                // If the graph is undirected\n                if !self.directed {\n                    // we compute also the backward edge ids that are required.\n                    valid_edges_bitmap.extend(self.compute_edge_ids_vector(\n                        self.get_unchecked_edge_id_from_node_ids_and_edge_type_id(\n                            dst, src, edge_type,\n                        ),\n                        dst,\n                        src,\n                        include_all_edge_types,\n                    ));\n                }\n                validation_edges_pb.inc(valid_edges_bitmap.len() - last_length);\n                last_length = valid_edges_bitmap.len();\n            }\n\n            // We stop the iteration when we found all the edges.\n            if valid_edges_bitmap.len() >= validation_edges_number {\n                break;\n            }\n        }\n\n        if valid_edges_bitmap.len() < validation_edges_number {\n            let actual_validation_edges_number = valid_edges_bitmap.len();\n            return Err(format!(\n                concat!(\n                    \"With the given configuration for the holdout, it is not possible to \",\n                    \"generate a validation set composed of {validation_edges_number} edges from the current graph.\\n\",\n                    \"The validation set can be composed of at most {actual_validation_edges_number} edges.\\n\"\n                ),\n                validation_edges_number=validation_edges_number,\n                actual_validation_edges_number=actual_validation_edges_number,\n            ));\n        }\n\n        // Creating the loading bar for the building of both the training and validation.\n        let pb_valid = get_loading_bar(\n            verbose,\n            \"Building the validation graph\",\n            valid_edges_bitmap.len() as usize,\n        );\n        let pb_train = get_loading_bar(\n            verbose,\n            \"Building the train graph\",\n            (self.get_directed_edges_number() - valid_edges_bitmap.len()) as usize,\n        );\n\n        Ok((\n            Graph::build_graph(\n                (0..self.get_directed_edges_number())\n                    .filter(|edge_id| !valid_edges_bitmap.contains(*edge_id))\n                    .progress_with(pb_train)\n                    .map(|edge_id| {\n                        Ok(self\n                            .get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(\n                                edge_id,\n                            ))\n                    }),\n                self.get_directed_edges_number() as usize - valid_edges_bitmap.len() as usize,\n                self.nodes.clone(),\n                self.node_types.clone(),\n                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n                self.directed,\n                true,\n                format!(\"{} training\", self.name.clone()),\n                true,\n                self.has_edge_types(),\n                self.has_edge_weights(),\n                train_graph_might_have_singletons,\n                train_graph_might_have_singletons_with_selfloops,\n                true,\n            )?,\n            Graph::build_graph(\n                valid_edges_bitmap\n                    .iter()\n                    .progress_with(pb_valid)\n                    .map(|edge_id| {\n                        Ok(self\n                            .get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(\n                                edge_id,\n                            ))\n                    }),\n                valid_edges_bitmap.len() as usize,\n                self.nodes.clone(),\n                self.node_types.clone(),\n                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n                self.directed,\n                true,\n                format!(\"{} testing\", self.name.clone()),\n                true,\n                self.has_edge_types(),\n                self.has_edge_weights(),\n                true,\n                self.has_selfloops(),\n                true,\n            )?,\n        ))"
            },
            {
                "file": "holdouts.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Holdouts."
                ],
                "doc": [
                    " Returns holdout for training ML algorithms on the graph structure.",
                    "",
                    " The holdouts returned are a tuple of graphs. The first one, which",
                    " is the training graph, is garanteed to have the same number of",
                    " graph components as the initial graph. The second graph is the graph",
                    " meant for testing or validation of the algorithm, and has no garantee",
                    " to be connected. It will have at most (1-train_size) edges,",
                    " as the bound of connectivity which is required for the training graph",
                    " may lead to more edges being left into the training partition.",
                    "",
                    " In the option where a list of edge types has been provided, these",
                    " edge types will be those put into the validation set.",
                    "",
                    " # Arguments",
                    "",
                    " * `random_state`: EdgeT - The random_state to use for the holdout,",
                    " * `train_size`: f64 - Rate target to reserve for training.",
                    " * `edge_types`: Option<Vec<Option<String>>> - Edge types to be selected for in the validation set.",
                    " * `include_all_edge_types`: bool - Whether to include all the edges between two nodes.",
                    " * `verbose`: bool - Whether to show the loading bar.",
                    "",
                    " # Raises",
                    " * If the edge types have been specified but the graph does not have edge types.",
                    " * If the required training size is not a real value between 0 and 1.",
                    " * If the current graph does not allow for the creation of a spanning tree for the requested training size."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "connected_holdout",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "random_state",
                        "EdgeT"
                    ],
                    [
                        "train_size",
                        "f64"
                    ],
                    [
                        "edge_types",
                        "Option<Vec<Option<String>>>"
                    ],
                    [
                        "include_all_edge_types",
                        "bool"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(Graph, Graph), String>",
                "body": "// If the user has requested to restrict the connected holdout to a\n        // limited set of edge types, the graph must have edge types.\n        if edge_types.is_some() {\n            self.must_have_edge_types()?;\n        }\n        if train_size <= 0.0 || train_size >= 1.0 {\n            return Err(String::from(\"Train rate must be strictly between 0 and 1.\"));\n        }\n\n        let edge_type_ids = edge_types.map_or(Ok::<_, String>(None), |ets| {\n            Ok(Some(\n                self.get_edge_type_ids_from_edge_type_names(ets)?\n                    .into_iter()\n                    .collect::<HashSet<Option<EdgeTypeT>>>(),\n            ))\n        })?;\n\n        let tree = self\n            .random_spanning_arborescence_kruskal(random_state, &edge_type_ids, verbose)\n            .0;\n\n        let edge_factor = if self.is_directed() { 1 } else { 2 };\n        let train_edges_number = (self.get_directed_edges_number() as f64 * train_size) as usize;\n        let mut validation_edges_number =\n            (self.get_directed_edges_number() as f64 * (1.0 - train_size)) as EdgeT;\n\n        // We need to check if the connected holdout can actually be built with\n        // the additional constraint of the edge types.\n        if let Some(etis) = &edge_type_ids {\n            let selected_edges_number: EdgeT = etis\n                .iter()\n                .map(|et| self.get_unchecked_edge_count_from_edge_type_id(*et) as EdgeT)\n                .sum();\n            validation_edges_number = (selected_edges_number as f64 * (1.0 - train_size)) as EdgeT;\n        }\n\n        if tree.len() * edge_factor > train_edges_number {\n            return Err(format!(\n                concat!(\n                    \"The given spanning tree of the graph contains {} edges \",\n                    \"that is more than the required training edges number {}.\\n\",\n                    \"This makes impossible to create a validation set using \",\n                    \"{} edges.\\nIf possible, you should increase the \",\n                    \"train_size parameter which is currently equal to \",\n                    \"{}.\\nThe deny map, by itself, is requiring at least \",\n                    \"a train rate of {}.\"\n                ),\n                tree.len() * edge_factor,\n                train_edges_number,\n                validation_edges_number,\n                train_size,\n                (tree.len() * edge_factor) as f64 / train_edges_number as f64\n            ));\n        }\n\n        self.edge_holdout(\n            random_state,\n            validation_edges_number,\n            include_all_edge_types,\n            |_, src, dst, edge_type| {\n                let is_in_tree = tree.contains(&(src, dst));\n                let singleton_selfloop = self.is_singleton_with_selfloops_from_node_id(src);\n                let correct_edge_type = edge_type_ids\n                    .as_ref()\n                    .map_or(true, |etis| etis.contains(&edge_type));\n                // The tree must not contain the provided edge ID\n                // And this is not a self-loop edge with degree 1\n                // And the edge type of the edge ID is within the provided edge type\n                !is_in_tree && !singleton_selfloop && correct_edge_type\n            },\n            verbose,\n            self.has_singleton_nodes(),\n            self.has_singleton_nodes_with_selfloops(),\n        )"
            },
            {
                "file": "holdouts.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Holdouts."
                ],
                "doc": [
                    " Returns random holdout for training ML algorithms on the graph edges.",
                    "",
                    " The holdouts returned are a tuple of graphs. In neither holdouts the",
                    " graph connectivity is necessarily preserved. To maintain that, use",
                    " the method `connected_holdout`.",
                    "",
                    " # Arguments",
                    "",
                    " * `random_state`: EdgeT - The random_state to use for the holdout,",
                    " * `train_size`: f64 - rate target to reserve for training",
                    " * `include_all_edge_types`: bool - Whether to include all the edges between two nodes.",
                    " * `edge_types`: Option<Vec<Option<String>>> - The edges to include in validation set.",
                    " * `min_number_overlaps`: Option<EdgeT> - The minimum number of overlaps to include the edge into the validation set.",
                    " * `verbose`: bool - Whether to show the loading bar.",
                    "",
                    " # Raises",
                    " * If the edge types have been specified but the graph does not have edge types.",
                    " * If the minimum number of overlaps have been specified but the graph is not a multigraph.",
                    " * If one or more of the given edge type names is not present in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "random_holdout",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "random_state",
                        "EdgeT"
                    ],
                    [
                        "train_size",
                        "f64"
                    ],
                    [
                        "include_all_edge_types",
                        "bool"
                    ],
                    [
                        "edge_types",
                        "Option<Vec<Option<String>>>"
                    ],
                    [
                        "min_number_overlaps",
                        "Option<EdgeT>"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(Graph, Graph), String>",
                "body": "// If the user has requested to restrict the connected holdout to a\n        // limited set of edge types, the graph must have edge types.\n        if edge_types.is_some() {\n            self.must_have_edge_types()?;\n        }\n        let total_edges_number = if include_all_edge_types {\n            self.unique_edges_number\n        } else {\n            self.get_directed_edges_number()\n        };\n\n        let (_, validation_edges_number) =\n            self.get_holdouts_elements_number(train_size, total_edges_number as usize)?;\n        let edge_type_ids = edge_types.map_or(Ok::<_, String>(None), |ets| {\n            Ok(Some(\n                self.get_edge_type_ids_from_edge_type_names(ets)?\n                    .into_iter()\n                    .collect::<HashSet<Option<EdgeTypeT>>>(),\n            ))\n        })?;\n        if min_number_overlaps.is_some() {\n            self.must_be_multigraph()?;\n        }\n        self.edge_holdout(\n            random_state,\n            validation_edges_number as EdgeT,\n            include_all_edge_types,\n            |_, src, dst, edge_type| {\n                // If a list of edge types was provided and the edge type\n                // of the current edge is not within the provided list,\n                // we skip the current edge.\n                if !edge_type_ids\n                    .as_ref()\n                    .map_or(true, |etis| etis.contains(&edge_type))\n                {\n                    return false;\n                }\n                // If a minimum number of overlaps was provided and the current\n                // edge has not the required minimum amount of overlaps.\n                if let Some(mno) = min_number_overlaps {\n                    if self.get_unchecked_edge_degree_from_node_ids(src, dst) < mno {\n                        return false;\n                    }\n                }\n                // Otherwise we accept the provided edge for the validation set\n                true\n            },\n            verbose,\n            // Singletons may be generated during the holdouts process\n            true,\n            // Singletons with selfloops may be generated during the holdouts process only when there are selfloops in the graph\n            self.has_selfloops(),\n        )"
            },
            {
                "file": "holdouts.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Holdouts."
                ],
                "doc": [
                    " Returns node-label holdout for training ML algorithms on the graph node labels.",
                    "",
                    " # Arguments",
                    " * `train_size`: f64 - rate target to reserve for training,",
                    " * `use_stratification`: bool - Whether to use node-label stratification,",
                    " * `random_state`: EdgeT - The random_state to use for the holdout,",
                    "",
                    " # Example",
                    " This example create an 80-20 split of the nodes in the graph",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    "   let (train, test) = graph.node_label_holdout(0.8, true, 0xbad5eed).unwrap();",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph does not have node types.",
                    " * If stratification is requested but the graph has a single node type.",
                    " * If stratification is requested but the graph has a multilabel node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "node_label_holdout",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "train_size",
                        "f64"
                    ],
                    [
                        "use_stratification",
                        "bool"
                    ],
                    [
                        "random_state",
                        "EdgeT"
                    ]
                ],
                "return_type": "Result<(Graph, Graph), String>",
                "body": "self.must_have_node_types()?;\n        if use_stratification {\n            if self.has_multilabel_node_types()? {\n                return Err(\"It is impossible to create a stratified holdout when the graph has multi-label node types.\".to_string());\n            }\n            if self.has_singleton_node_types()? {\n                return Err(\"It is impossible to create a stratified holdout when the graph has node types with cardinality one.\".to_string());\n            }\n        }\n\n        if self.get_known_node_types_number()? < 2 {\n            return Err(\"It is not possible to create a node label holdout when the number of nodes with known node type is less than two.\".to_string());\n        }\n\n        // Compute the vectors with the indices of the nodes which node type matches\n        // therefore the expected shape is:\n        // (node_types_number, number of nodes of that node type)\n        let node_sets: Vec<Vec<NodeT>> = self\n            .node_types\n            .as_ref()\n            .map(|nts| {\n                if use_stratification {\n                    // Initialize the vectors for each node type\n                    let mut node_sets: Vec<Vec<NodeT>> =\n                        vec![Vec::new(); self.get_node_types_number().unwrap() as usize];\n                    // itering over the indices and adding each node to the\n                    // vector of the corresponding node type.\n                    nts.ids.iter().enumerate().for_each(|(node_id, node_type)| {\n                        // if the node has a node_type\n                        if let Some(nt) = node_type {\n                            // Get the index of the correct node type vector.\n                            node_sets[nt[0] as usize].push(node_id as NodeT);\n                        };\n                    });\n\n                    node_sets\n                } else {\n                    // just compute a vector with a single vector of the indices\n                    //  of the nodes with node\n                    vec![nts\n                        .ids\n                        .iter()\n                        .enumerate()\n                        .filter_map(|(node_id, node_type)| {\n                            node_type.as_ref().map(|_| node_id as NodeT)\n                        })\n                        .collect()]\n                }\n            })\n            .unwrap();\n\n        // initialize the seed for a re-producible shuffle\n        let mut rnd = SmallRng::seed_from_u64(random_state ^ SEED_XOR as u64);\n\n        // Allocate the vectors for the nodes of each\n        let mut train_node_types = vec![None; self.get_nodes_number() as usize];\n        let mut test_node_types = vec![None; self.get_nodes_number() as usize];\n\n        for mut node_set in node_sets {\n            // Shuffle in a reproducible way the nodes of the current node_type\n            node_set.shuffle(&mut rnd);\n            // Compute how many of these nodes belongs to the training set\n            let (train_size, _) = self.get_holdouts_elements_number(train_size, node_set.len())?;\n            // add the nodes to the relative vectors\n            node_set[..train_size].iter().for_each(|node_id| unsafe {\n                train_node_types[*node_id as usize] =\n                    self.get_unchecked_node_type_id_from_node_id(*node_id)\n            });\n            node_set[train_size..].iter().for_each(|node_id| unsafe {\n                test_node_types[*node_id as usize] =\n                    self.get_unchecked_node_type_id_from_node_id(*node_id)\n            });\n        }\n\n        // Clone the current graph\n        // here we could manually initialize the clones so that we don't waste\n        // time and memory cloning the node_types which will be immediately\n        // overwrite. We argue that this should not be impactfull so we prefer\n        // to prioritze the simplicity of the code\n        let mut train_graph = self.clone();\n        let mut test_graph = self.clone();\n\n        // Replace the node_types with the one computes above\n        train_graph.node_types = NodeTypeVocabulary::from_structs(\n            train_node_types,\n            self.node_types.as_ref().map(|ntv| ntv.vocabulary.clone()),\n        );\n        test_graph.node_types = NodeTypeVocabulary::from_structs(\n            test_node_types,\n            self.node_types.as_ref().map(|ntv| ntv.vocabulary.clone()),\n        );\n\n        Ok((train_graph, test_graph))"
            },
            {
                "file": "holdouts.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Holdouts."
                ],
                "doc": [
                    " Returns edge-label holdout for training ML algorithms on the graph edge labels.",
                    " This is commonly used for edge type prediction tasks.",
                    "",
                    " This method returns two graphs, the train and the test one.",
                    " The edges of the graph will be splitted in the train and test graphs according",
                    " to the `train_size` argument.",
                    "",
                    " If stratification is enabled, the train and test will have the same ratios of",
                    " edge types.",
                    "",
                    " # Arguments",
                    " * `train_size`: f64 - rate target to reserve for training,",
                    " * `use_stratification`: bool - Whether to use edge-label stratification,",
                    " * `random_state`: EdgeT - The random_state to use for the holdout,",
                    "",
                    " # Example",
                    " This example creates an 80-20 split of the edges mantaining the edge label ratios",
                    " in train and test.",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    "   let (train, test) = graph.edge_label_holdout(0.8, true, 0xbad5eed).unwrap();",
                    " ```",
                    "",
                    " # Raises",
                    " * If the graph does not have edge types.",
                    " * If stratification is required but the graph has singleton edge types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "edge_label_holdout",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "train_size",
                        "f64"
                    ],
                    [
                        "use_stratification",
                        "bool"
                    ],
                    [
                        "random_state",
                        "EdgeT"
                    ]
                ],
                "return_type": "Result<(Graph, Graph), String>",
                "body": "if self.get_known_edge_types_number()? < 2 {\n            return Err(\"It is not possible to create a edge label holdout when the number of edges with known edge type is less than two.\".to_string());\n        }\n        if use_stratification && self.has_singleton_edge_types()? {\n            return Err(\"It is impossible to create a stratified holdout when the graph has edge types with cardinality one.\".to_string());\n        }\n\n        // Compute the vectors with the indices of the edges which edge type matches\n        // therefore the expected shape is:\n        // (edge_types_number, number of edges of that edge type)\n        let edge_sets: Vec<Vec<EdgeT>> = self\n            .edge_types\n            .as_ref()\n            .map(|nts| {\n                if use_stratification {\n                    // Initialize the vectors for each edge type\n                    let mut edge_sets: Vec<Vec<EdgeT>> =\n                        vec![Vec::new(); self.get_edge_types_number().unwrap() as usize];\n                    // itering over the indices and adding each edge to the\n                    // vector of the corresponding edge type.\n                    nts.ids.iter().enumerate().for_each(|(edge_id, edge_type)| {\n                        // if the edge has a edge_type\n                        if let Some(et) = edge_type {\n                            // Get the index of the correct edge type vector.\n                            edge_sets[*et as usize].push(edge_id as EdgeT);\n                        };\n                    });\n\n                    edge_sets\n                } else {\n                    // just compute a vector with a single vector of the indices\n                    //  of the edges with edge\n                    vec![nts\n                        .ids\n                        .iter()\n                        .enumerate()\n                        .filter_map(|(edge_id, edge_type)| {\n                            edge_type.as_ref().map(|_| edge_id as EdgeT)\n                        })\n                        .collect()]\n                }\n            })\n            .unwrap();\n\n        // initialize the seed for a re-producible shuffle\n        let mut rnd = SmallRng::seed_from_u64(random_state ^ SEED_XOR as u64);\n\n        // Allocate the vectors for the edges of each\n        let mut train_edge_types = vec![None; self.get_directed_edges_number() as usize];\n        let mut test_edge_types = vec![None; self.get_directed_edges_number() as usize];\n\n        for mut edge_set in edge_sets {\n            // Shuffle in a reproducible way the edges of the current edge_type\n            edge_set.shuffle(&mut rnd);\n            // Compute how many of these edges belongs to the training set\n            let (train_size, _) = self.get_holdouts_elements_number(train_size, edge_set.len())?;\n            // add the edges to the relative vectors\n            edge_set[..train_size].iter().for_each(|edge_id| {\n                train_edge_types[*edge_id as usize] =\n                    self.get_unchecked_edge_type_id_from_edge_id(*edge_id)\n            });\n            edge_set[train_size..].iter().for_each(|edge_id| {\n                test_edge_types[*edge_id as usize] =\n                    self.get_unchecked_edge_type_id_from_edge_id(*edge_id)\n            });\n        }\n\n        // Clone the current graph\n        // here we could manually initialize the clones so that we don't waste\n        // time and memory cloning the edge_types which will be immediately\n        // overwrite. We argue that this should not be impactfull so we prefer\n        // to prioritze the simplicity of the code\n        let mut train_graph = self.clone();\n        let mut test_graph = self.clone();\n\n        // Replace the edge_types with the one computes above\n        train_graph.edge_types = Some(EdgeTypeVocabulary::from_structs(\n            train_edge_types,\n            self.edge_types\n                .as_ref()\n                .map(|etv| etv.vocabulary.clone())\n                .unwrap(),\n        ));\n        test_graph.edge_types = Some(EdgeTypeVocabulary::from_structs(\n            test_edge_types,\n            self.edge_types\n                .as_ref()\n                .map(|etv| etv.vocabulary.clone())\n                .unwrap(),\n        ));\n\n        Ok((train_graph, test_graph))"
            },
            {
                "file": "holdouts.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Holdouts."
                ],
                "doc": [
                    " Returns subgraph with given number of nodes.",
                    "",
                    " **This method creates a subset of the graph starting from a random node",
                    " sampled using given random_state and includes all neighbouring nodes until",
                    " the required number of nodes is reached**. All the edges connecting any",
                    " of the selected nodes are then inserted into this graph.",
                    "",
                    " This is meant to execute distributed node embeddings.",
                    " It may also sample singleton nodes.",
                    "",
                    " # Arguments",
                    " * `random_state`: usize - Random random_state to use.",
                    " * `nodes_number`: NodeT - Number of nodes to extract.",
                    " * `verbose`: bool - Whether to show the loading bar.",
                    "",
                    " # Example",
                    " this generates a random subgraph with 1000 nodes.",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    "   let random_graph = graph.random_subgraph(0xbad5eed, 1000, true).unwrap();",
                    " ```",
                    "",
                    " # Raises",
                    " * If the requested number of nodes is one or less.",
                    " * If the graph has less than the requested number of nodes."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "random_subgraph",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "random_state",
                        "usize"
                    ],
                    [
                        "nodes_number",
                        "NodeT"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<Graph, String>",
                "body": "if nodes_number <= 1 {\n            return Err(String::from(\"Required nodes number must be more than 1.\"));\n        }\n        let connected_nodes_number = self.get_connected_nodes_number();\n        if nodes_number > connected_nodes_number {\n            return Err(format!(\n                concat!(\n                    \"Required number of nodes ({}) is more than available \",\n                    \"number of nodes ({}) that have edges in current graph.\"\n                ),\n                nodes_number, connected_nodes_number\n            ));\n        }\n\n        // Creating the loading bars\n        let pb1 = get_loading_bar(verbose, \"Sampling nodes subset\", nodes_number as usize);\n        let pb2 = get_loading_bar(verbose, \"Computing subgraph edges\", nodes_number as usize);\n        let pb3 = get_loading_bar(\n            verbose,\n            \"Building subgraph\",\n            self.get_directed_edges_number() as usize,\n        );\n\n        // Creating the random number generator\n        let mut rnd = SmallRng::seed_from_u64((random_state ^ SEED_XOR) as u64);\n\n        // Nodes indices\n        let mut nodes: Vec<NodeT> = (0..self.get_nodes_number()).collect();\n\n        // Shuffling the components using the given random_state.\n        nodes.shuffle(&mut rnd);\n\n        // Initializing stack and set of nodes\n        let mut unique_nodes = RoaringBitmap::new();\n        let mut stack: Vec<NodeT> = Vec::new();\n\n        // We iterate on the components\n        'outer: for node in nodes.iter() {\n            // If the current node is a trap there is no need to continue with the current loop.\n            if self.is_trap_node_from_node_id(*node).unwrap() {\n                continue;\n            }\n            stack.push(*node);\n            while !stack.is_empty() {\n                let src = stack.pop().unwrap();\n                for dst in self.iter_unchecked_neighbour_node_ids_from_source_node_id(src) {\n                    if !unique_nodes.contains(dst) && src != dst {\n                        stack.push(dst);\n                    }\n\n                    unique_nodes.insert(*node);\n                    unique_nodes.insert(dst);\n                    pb1.inc(2);\n\n                    // If we reach the desired number of unique nodes we can stop the iteration.\n                    if unique_nodes.len() as NodeT >= nodes_number {\n                        break 'outer;\n                    }\n                }\n            }\n        }\n\n        pb1.finish();\n\n        let edges_bitmap: RoaringTreemap = unique_nodes\n            .iter()\n            .progress_with(pb2)\n            .flat_map(|src| {\n                let (min_edge_id, max_edge_id) =\n                    self.get_unchecked_minmax_edge_ids_from_source_node_id(src);\n                (min_edge_id..max_edge_id)\n                    .filter(|edge_id| {\n                        unique_nodes\n                            .contains(self.get_unchecked_destination_node_id_from_edge_id(*edge_id))\n                    })\n                    .collect::<Vec<EdgeT>>()\n            })\n            .collect();\n\n        Graph::build_graph(\n            edges_bitmap.iter().progress_with(pb3).map(|edge_id| {\n                Ok(self\n                    .get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(edge_id))\n            }),\n            edges_bitmap.len() as usize,\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.directed,\n            true,\n            format!(\"{} subgraph\", self.name.clone()),\n            false,\n            self.has_edge_types(),\n            self.has_edge_weights(),\n            true,\n            self.has_selfloops(),\n            true,\n        )"
            },
            {
                "file": "holdouts.rs",
                "struct": "Graph",
                "impl_doc": [
                    " # Holdouts."
                ],
                "doc": [
                    " Returns train and test graph following kfold validation scheme.",
                    "",
                    " The edges are splitted into k chunks. The k_index-th chunk is used to build",
                    " the validation graph, all the other edges create the training graph.",
                    "",
                    " # Arguments",
                    " * `k`: EdgeT - The number of folds.",
                    " * `k_index`: u64 - Which fold to use for the validation.",
                    " * `edge_types`: Option<Vec<Option<String>>> - Edge types to be selected when computing the folds (All the edge types not listed here will be always be used in the training set).",
                    " * `random_state`: EdgeT - The random_state (seed) to use for the holdout,",
                    " * `verbose`: bool - Whether to show the loading bar.",
                    "",
                    " # Example",
                    " ```rust",
                    " # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                    " for i in 0..5 {",
                    "     let (train, test) = graph.kfold(5, i, None, 0xbad5eed, true).unwrap();",
                    "     // Run the training",
                    " }",
                    " ```",
                    " If We pass a vector of edge types, the K-fold will be executed only on the edges which match",
                    " that type. All the other edges will always appear in the traning set.",
                    "",
                    " # Raises",
                    " * If the number of requested k folds is one or zero.",
                    " * If the given k fold index is greater than the number of k folds.",
                    " * If edge types have been specified but it's an empty list.",
                    " * If the number of k folds is higher than the number of edges in the graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "kfold",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "k",
                        "EdgeT"
                    ],
                    [
                        "k_index",
                        "u64"
                    ],
                    [
                        "edge_types",
                        "Option<Vec<Option<String>>>"
                    ],
                    [
                        "random_state",
                        "EdgeT"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "Result<(Graph, Graph), String>",
                "body": "if k <= 1 {\n            return Err(String::from(\n                \"Cannot do a k-fold with only one or zero folds.\",\n            ));\n        }\n        if k_index >= k {\n            return Err(String::from(\n                \"The index of the k-fold must be strictly less than the number of folds.\",\n            ));\n        }\n\n        // If edge types is not None, to compute the chunks only use the edges\n        // of the chosen edge_types\n        let mut indices = if let Some(ets) = edge_types {\n            if ets.is_empty() {\n                return Err(String::from(\n                    \"Required edge types must be a non-empty list.\",\n                ));\n            }\n\n            let edge_type_ids = self\n                .get_edge_type_ids_from_edge_type_names(ets)?\n                .into_iter()\n                .collect::<HashSet<Option<EdgeTypeT>>>();\n\n            self.iter_edge_node_ids_and_edge_type_id(self.directed)\n                .filter_map(|(edge_id, _, _, edge_type)| {\n                    if !edge_type_ids.contains(&edge_type) {\n                        return None;\n                    }\n                    Some(edge_id)\n                })\n                .collect::<Vec<EdgeT>>()\n        } else {\n            self.iter_edge_ids(self.directed)\n                .map(|(edge_id, _, _)| edge_id)\n                .collect::<Vec<EdgeT>>()\n        };\n\n        if k >= indices.len() as EdgeT {\n            return Err(String::from(\n                \"Cannot do a number of k-fold greater than the number of available edges.\",\n            ));\n        }\n\n        // if the graph has 8 edges and k = 3\n        // we want the chunks sized to be:\n        // 3, 3, 2\n\n        // if the graph has 4 edges and k = 3\n        // we want the chunks sized to be:\n        // 2, 1, 1\n\n        // shuffle the indices\n        let mut rng = SmallRng::seed_from_u64(random_state ^ SEED_XOR as EdgeT);\n        indices.shuffle(&mut rng);\n        // Get the k_index-th chunk\n        let chunk_size = indices.len() as f64 / k as f64;\n        let start = (k_index as f64 * chunk_size).ceil() as EdgeT;\n        let end = std::cmp::min(\n            indices.len() as EdgeT,\n            (((k_index + 1) as f64) * chunk_size).ceil() as EdgeT,\n        );\n        let chunk: RoaringTreemap = indices[start as usize..end as usize]\n            .iter()\n            .cloned()\n            .collect();\n        // Create the two graphs\n        self.edge_holdout(\n            random_state,\n            end - start,\n            false,\n            |edge_id, _, _, _| chunk.contains(edge_id),\n            verbose,\n            true,\n            self.has_selfloops(),\n        )"
            }
        ]
    }
}