[
    {
        "file": "queries_walk.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Walk Queries",
            "These are the queries that are used mainly in the random walk."
        ],
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "get_node_edges_and_destinations",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "max_neighbours",
                "Option<NodeT>"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "node",
                "NodeT"
            ]
        ],
        "return_type": "(EdgeT, EdgeT, Option<Vec<NodeT>>, Option<Vec<u64>>)",
        "body": "// We retrieve the range of edge ids, the minimum and maximum value.\n        let (min_edge_id, max_edge_id) =\n            self.get_unchecked_minmax_edge_ids_from_source_node_id(node);\n\n        // We check if subsampling is enabled and if so, if it makes sense:\n        // that is, if the range of neighbours (max_edge_id-min_edge_id) is smaller\n        // than the required sub-sampling we do not use it as it would be useless.\n        if let Some(indices) = max_neighbours.and_then(|mn| {\n            sorted_unique_sub_sampling(min_edge_id, max_edge_id, mn as u64, random_state).ok()\n        }) {\n            let destinations: Vec<NodeT> = match self\n                .cached_destinations\n                .as_ref()\n                .and_then(|cds| cds.get(&node))\n            {\n                Some(dsts) => indices\n                    .iter()\n                    .map(|edge_id| dsts[(*edge_id - min_edge_id) as usize])\n                    .collect(),\n                None => indices\n                    .iter()\n                    .map(|edge_id| self.get_unchecked_destination_node_id_from_edge_id(*edge_id))\n                    .collect(),\n            };\n            return (min_edge_id, max_edge_id, Some(destinations), Some(indices));\n        }\n\n        // If the destinations are stored explicitly because the time-memory tradeoff is enabled we are done.\n        if self.destinations.is_some() {\n            return (min_edge_id, max_edge_id, None, None);\n        }\n\n        // Finally if we are using the cache without sub-sampling\n        let destinations = match self\n            .cached_destinations\n            .as_ref()\n            .map_or(false, |cds| cds.contains_key(&node))\n        {\n            true => None,\n            false => Some(self.iter_unchecked_neighbour_node_ids_from_source_node_id(node).collect()),\n        };\n        (min_edge_id, max_edge_id, destinations, None)"
    },
    {
        "file": "queries_walk.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Walk Queries",
            "These are the queries that are used mainly in the random walk."
        ],
        "doc": [
            "Returns slice of destinations corresponding to given minmax edge ID and node."
        ],
        "modifiers": "pub(crate)",
        "name": "get_destinations_slice",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "min_edge_id",
                "EdgeT"
            ],
            [
                "max_edge_id",
                "EdgeT"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "destinations",
                "&'a Option<Vec<NodeT>>"
            ]
        ],
        "return_type": "&'a [NodeT]",
        "body": "match (&self.destinations, &self.cached_destinations, destinations) {\n            (_, _, Some(dsts)) => &dsts.as_slice(),\n            (Some(dsts), None, None) => &dsts[min_edge_id as usize..max_edge_id as usize],\n            (None, Some(dsts), None) => dsts.get(&node).unwrap(),\n            _ => unreachable!(\n                \"It is not possible to have both destinations and cached destinations at once.\"\n            ),\n        }"
    },
    {
        "file": "operators.rs",
        "doc": [],
        "modifiers": "",
        "name": "build_operator_graph_name",
        "args": [
            [
                "main",
                "&Graph"
            ],
            [
                "other",
                "&Graph"
            ],
            [
                "operator",
                "String"
            ]
        ],
        "return_type": "String",
        "body": "format!(\"({} {} {})\", main.name, operator, other.name)"
    },
    {
        "file": "operators.rs",
        "doc": [
            "Return graph composed of the two near-incompatible graphs.",
            "",
            "The two graphs can have different nodes, edge types and node types.",
            "These operators are slower than the generic integer operators since they",
            "require a reverse mapping step.",
            "",
            "# Arguments",
            "",
            "* `main`: &Graph - The current graph instance.",
            "* `other`: &Graph - The other graph.",
            "* `operator`: String - The operator used.",
            "* `graphs`: Vec<(&Graph, Option<&Graph>, Option<&Graph>)> - Graph list for the operation.",
            "* `might_have_singletons`: bool - Whether we expect the graph to have singletons.",
            "* `might_have_singletons_with_selfloops`: bool - Whether we expect the graph to have singletons with self-loops.",
            "* `might_have_trap_nodes`: bool - Whether we expect the graph to have trap nodes."
        ],
        "modifiers": "",
        "name": "generic_string_operator",
        "args": [
            [
                "main",
                "&Graph"
            ],
            [
                "other",
                "&Graph"
            ],
            [
                "operator",
                "String"
            ],
            [
                "graphs",
                "Vec<(&Graph, Option<&Graph>, Option<&Graph>)>"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "// one: left hand side of the operator\n    // deny_graph: right hand edges \"deny list\"\n    // must_have_graph: right hand edges \"must have list\n    let edges_iterator = graphs\n        .iter()\n        .flat_map(|(one, deny_graph, must_have_graph)| {\n            one.iter_edge_node_names_and_edge_type_name_and_edge_weight(main.directed)\n                .filter(move |(_, _, src_name, _, dst_name, _, edge_type_name, _)| {\n                    // If the secondary graph is given\n                    // we filter out the edges that were previously added to avoid\n                    // introducing duplicates.\n                    // TODO: handle None type edge types and avoid duplicating those!\n                    if let Some(dg) = deny_graph {\n                        return !dg.has_edge_from_node_names_and_edge_type_name(\n                            src_name,\n                            dst_name,\n                            edge_type_name.as_ref(),\n                        );\n                    }\n                    if let Some(mhg) = must_have_graph {\n                        return mhg.has_edge_from_node_names_and_edge_type_name(\n                            src_name,\n                            dst_name,\n                            edge_type_name.as_ref(),\n                        );\n                    }\n                    true\n                })\n                .map(|(_, _, src_name, _, dst_name, _, edge_type_name, weight)| {\n                    Ok((src_name, dst_name, edge_type_name, weight))\n                })\n        });\n\n    // Chaining node types in a way that merges the information between\n    // two node type sets where one of the two has some unknown node types\n    let nodes_iterator = main\n        .iter_nodes()\n        .map(|(_, node_name, _, node_type_names)| {\n            let node_type_names = match node_type_names {\n                Some(ntns) => Some(ntns),\n                None => other\n                    .get_node_id_from_node_name(&node_name)\n                    .ok()\n                    .and_then(|node_id| other.get_node_type_name_from_node_id(node_id).unwrap()),\n            };\n            Ok((node_name, node_type_names))\n        })\n        .chain(\n            other\n                .iter_nodes()\n                .filter_map(|(_, node_name, _, node_type_names)| {\n                    match main.has_node_from_node_name(&node_name) {\n                        true => None,\n                        false => Some(Ok((node_name, node_type_names))),\n                    }\n                }),\n        );\n\n    Graph::from_string_unsorted(\n        edges_iterator,\n        Some(nodes_iterator),\n        main.directed,\n        false,\n        build_operator_graph_name(main, other, operator),\n        true,\n        true,\n        false,\n        true,\n        false,\n        false,\n        false,\n        false,\n        false,\n        main.has_node_types(),\n        main.has_edge_types(),\n        main.has_edge_weights(),\n        might_have_singletons,\n        might_have_singletons_with_selfloops,\n        might_have_trap_nodes,\n    )"
    },
    {
        "file": "operators.rs",
        "doc": [
            "Return graph composed of the two compatible graphs.",
            "",
            "The two graphs CANNOT have different nodes, edge types and node types.",
            "These operators are faster than the generic string operators since they",
            "do NOT require a reverse mapping step.",
            "",
            "# Arguments",
            "",
            "* `main`: &Graph - The current graph instance.",
            "* `other`: &Graph - The other graph.",
            "* `operator`: String - The operator used.",
            "* `graphs`: Vec<(&Graph, Option<&Graph>, Option<&Graph>)> - Graph list for the operation.",
            "* `might_have_singletons`: bool - Whether we expect the graph to have singletons.",
            "* `might_have_singletons_with_selfloops`: bool - Whether we expect the graph to have singletons with self-loops.",
            "* `might_have_trap_nodes`: bool - Whether we expect the graph to have trap nodes."
        ],
        "modifiers": "",
        "name": "generic_integer_operator",
        "args": [
            [
                "main",
                "&Graph"
            ],
            [
                "other",
                "&Graph"
            ],
            [
                "operator",
                "String"
            ],
            [
                "graphs",
                "Vec<(&Graph, Option<&Graph>, Option<&Graph>)>"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "// one: left hand side of the operator\n    // deny_graph: right hand edges \"deny list\"\n    // must_have_graph: right hand edges \"must have list\n    let edges_iterator = graphs\n        .iter()\n        .flat_map(|(one, deny_graph, must_have_graph)| {\n            one.iter_edge_node_ids_and_edge_type_id_and_edge_weight(main.directed)\n                .filter(move |(_, src, dst, edge_type, _)| {\n                    // If the secondary graph is given\n                    // we filter out the edges that were previously added to avoid\n                    // introducing duplicates.\n                    if let Some(dg) = deny_graph {\n                        return !dg.has_edge_from_node_ids_and_edge_type_id(*src, *dst, *edge_type);\n                    }\n                    if let Some(mhg) = must_have_graph {\n                        return mhg.has_edge_from_node_ids_and_edge_type_id(*src, *dst, *edge_type);\n                    }\n                    true\n                })\n                .map(|(_, src, dst, edge_type, weight)| Ok((src, dst, edge_type, weight)))\n        });\n\n    let node_types = match (&main.node_types, &other.node_types) {\n        (Some(mnts), Some(onts)) => Some(match mnts == onts {\n            true => mnts.clone(),\n            false => {\n                let mut main_node_types = mnts.ids.clone();\n                main_node_types\n                    .iter_mut()\n                    .zip(onts.ids.iter())\n                    .for_each(|(mid, oid)| {\n                        if mid.is_none() {\n                            *mid = oid.clone();\n                        }\n                    });\n                NodeTypeVocabulary::from_structs(main_node_types, Some(mnts.vocabulary.clone()))\n                    .unwrap()\n            }\n        }),\n        (Some(mnts), _) => Some(mnts.clone()),\n        (_, Some(onts)) => Some(onts.clone()),\n        _ => None,\n    };\n\n    Graph::from_integer_unsorted(\n        edges_iterator,\n        main.nodes.clone(),\n        node_types,\n        main.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n        main.directed,\n        build_operator_graph_name(main, other, operator),\n        false,\n        main.has_edge_types(),\n        main.has_edge_weights(),\n        false,\n        might_have_singletons,\n        might_have_singletons_with_selfloops,\n        might_have_trap_nodes,\n    )"
    },
    {
        "file": "operators.rs",
        "doc": [
            "Return true if the graphs can be elaborated through graph algebra.",
            "",
            "# Arguments",
            "",
            "* `other`: &Graph - The other graph."
        ],
        "modifiers": "pub",
        "name": "validate_operator_terms",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "other",
                "&'b Graph"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "if self.directed != other.directed {\n            return Err(String::from(\n                \"The graphs must either be both directed or undirected.\",\n            ));\n        }\n\n        if self.has_edge_weights() != other.has_edge_weights() {\n            return Err(String::from(\n                \"Both graphs need to have weights or neither can.\",\n            ));\n        }\n\n        if self.has_node_types() != other.has_node_types() {\n            return Err(String::from(\n                \"Both graphs need to have node types or neither can.\",\n            ));\n        }\n\n        if self.has_edge_types() != other.has_edge_types() {\n            return Err(String::from(\n                \"Both graphs need to have edge types or neither can.\",\n            ));\n        }\n\n        Ok(())"
    },
    {
        "file": "operators.rs",
        "struct": "Graph",
        "doc": [
            "Return true if the graphs are compatible.",
            "",
            "# Arguments",
            "",
            "* `other`: &Graph - The other graph."
        ],
        "modifiers": "pub(crate)",
        "name": "is_compatible",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "other",
                "&Graph"
            ]
        ],
        "return_type": "Result<bool, String>",
        "body": "self.validate_operator_terms(other)?;\n        if self.nodes != other.nodes {\n            return Ok(false);\n        }\n        if let (Some(snts), Some(onts)) = (&self.node_types, &other.node_types) {\n            if snts.vocabulary != onts.vocabulary {\n                return Ok(false);\n            }\n        }\n        if let (Some(sets), Some(oets)) = (&self.edge_types, &other.edge_types) {\n            if sets.vocabulary != oets.vocabulary {\n                return Ok(false);\n            }\n        }\n        Ok(true)"
    },
    {
        "file": "operators.rs",
        "struct": "Graph",
        "doc": [
            "Return graph composed of the two near-incompatible graphs.",
            "",
            "The two graphs can have different nodes, edge types and node types.",
            "These operators are slower than the generic integer operators since they",
            "require a reverse mapping step.",
            "",
            "# Arguments",
            "",
            "* `other`: &Graph - The other graph.",
            "* `operator`: String - The operator used.",
            "* `graphs`: Vec<(&Graph, Option<&Graph>, Option<&Graph>)> - Graph list for the operation.",
            "* `might_have_singletons`: bool - Whether we expect the graph to have singletons.",
            "* `might_have_singletons_with_selfloops`: bool - Whether we expect the graph to have singletons with self-loops.",
            "* `might_have_trap_nodes`: bool - Whether we expect the graph to have trap nodes."
        ],
        "modifiers": "pub(crate)",
        "name": "generic_operator",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "other",
                "&Graph"
            ],
            [
                "operator",
                "String"
            ],
            [
                "graphs",
                "Vec<(&Graph, Option<&Graph>, Option<&Graph>)>"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "match self.is_compatible(other)? {\n            true => generic_integer_operator(\n                self,\n                other,\n                operator,\n                graphs,\n                might_have_singletons,\n                might_have_singletons_with_selfloops,\n                might_have_trap_nodes,\n            ),\n            false => generic_string_operator(\n                self,\n                other,\n                operator,\n                graphs,\n                might_have_singletons,\n                might_have_singletons_with_selfloops,\n                might_have_trap_nodes,\n            ),\n        }"
    },
    {
        "file": "operators.rs",
        "doc": [
            "Return graph composed of the two graphs.",
            "",
            "The two graphs must have the same nodes, node types and edge types.",
            "",
            "# Arguments",
            "",
            "* `other`: &Graph - Graph to be summed.",
            ""
        ],
        "modifiers": "",
        "name": "bitor",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "other",
                "&'b Graph"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "self.generic_operator(\n            other,\n            \"|\".to_owned(),\n            vec![(self, None, None), (other, Some(self), None)],\n            // TODO: it is possible to make the following more precise!\n            self.has_singletons() || other.has_singletons(),\n            // TODO: it is possible to make the following more precise!\n            self.has_singletons_with_selfloops() || other.has_singletons_with_selfloops(),\n            // TODO: it is possible to make the following more precise!\n            self.has_trap_nodes() || other.has_trap_nodes(),\n        )"
    },
    {
        "file": "operators.rs",
        "doc": [
            "Return graph composed of the two graphs.",
            "",
            "The two graphs must have the same nodes, node types and edge types.",
            "",
            "# Arguments",
            "",
            "* `other`: &Graph - Graph to be summed.",
            ""
        ],
        "modifiers": "",
        "name": "bitxor",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "other",
                "&'b Graph"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "self.generic_operator(\n            self,\n            \"^\".to_owned(),\n            vec![(self, Some(other), None), (other, Some(self), None)],\n            true,\n            // TODO: it is possible to make the following more precise!\n            self.has_selfloops() || other.has_selfloops(),\n            true,\n        )"
    },
    {
        "file": "operators.rs",
        "doc": [
            "Return subtraction for graphs objects.",
            "",
            "The two graphs must have the same nodes, node types and edge types.",
            "",
            "# Arguments",
            "",
            "* `other`: &Graph - Graph to be subtracted.",
            ""
        ],
        "modifiers": "",
        "name": "sub",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "other",
                "&'b Graph"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "self.generic_operator(\n            other,\n            \"-\".to_owned(),\n            vec![(self, Some(other), None)],\n            true,\n            self.has_selfloops(),\n            true,\n        )"
    },
    {
        "file": "operators.rs",
        "doc": [
            "Return graph obtained from the intersection of the two graph.",
            "",
            "The two graphs must have the same nodes, node types and edge types.",
            "",
            "# Arguments",
            "",
            "* `other`: &Graph - Graph to be subtracted.",
            ""
        ],
        "modifiers": "",
        "name": "bitand",
        "args": [
            [
                "self",
                "self"
            ],
            [
                "other",
                "&'b Graph"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "self.generic_operator(\n            other,\n            \"&\".to_owned(),\n            vec![(self, None, Some(other))],\n            true,\n            self.has_selfloops() && other.has_selfloops(),\n            true,\n        )"
    },
    {
        "file": "walks_parameters.rs",
        "doc": [
            "Struct to wrap walk weights.",
            "Struct to wrap parameters relative to a single walk.",
            "Struct to wrap parameters relative to a set of walks.",
            "Create new WalkWeights object.",
            "",
            "The default WalkWeights object is parametrized to execute a first-order walk."
        ],
        "modifiers": "",
        "name": "default",
        "args": [],
        "return_type": "WalkWeights",
        "body": "WalkWeights {\n            return_weight: 1.0,\n            explore_weight: 1.0,\n            change_node_type_weight: 1.0,\n            change_edge_type_weight: 1.0,\n        }"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalkWeights",
        "doc": [
            "Validate given weight and format the exception if necessary, eventually.",
            "",
            "# Arguments",
            "",
            "* `weight_name`: &str - name of the weight, used for building the exception.",
            "* `weight`: Option<WeightT> - Value of the weight.",
            "",
            "TODO: is this a duplicate?"
        ],
        "modifiers": "",
        "name": "validate_weight",
        "args": [
            [
                "weight_name",
                "&str"
            ],
            [
                "weight",
                "WeightT"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "if weight <= 0.0 || !weight.is_finite() {\n            Err(format!(\n                concat!(\n                    \"Given '{}' ({}) \",\n                    \"is not a strictly positive real number.\"\n                ),\n                weight_name, weight\n            ))\n        } else {\n            Ok(weight)\n        }"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalkWeights",
        "doc": [
            "Return boolean value representing if walk is of first order.",
            "",
            "# Example",
            "The default parametrization defines a first order walk:",
            "",
            "```rust",
            "# use graph::walks_parameters::WalkWeights;",
            "let weights = WalkWeights::default();",
            "assert!(weights.is_first_order_walk());",
            "```"
        ],
        "modifiers": "pub",
        "name": "is_first_order_walk",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "let weights = vec![\n            self.change_node_type_weight,\n            self.change_edge_type_weight,\n            self.return_weight,\n            self.explore_weight,\n        ];\n        weights.iter().all(|weight| !not_one(*weight))"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "SingleWalkParameters",
        "doc": [
            "Create new WalksParameters object.",
            "",
            "By default the object is parametrized for a simple first-order walk.",
            "",
            "# Arguments",
            "",
            "* `walk_length`: usize - Maximal walk_length of the walk.",
            "",
            "# Example",
            "You can create a single walk parameters struct as follows:",
            "",
            "```rust",
            "# use graph::walks_parameters::SingleWalkParameters;",
            "assert!(SingleWalkParameters::new(45).is_ok());",
            "```",
            "",
            "as long as you don't try to make a zero walk length you'll be fine:",
            "",
            "```rust",
            "# use graph::walks_parameters::SingleWalkParameters;",
            "assert!(SingleWalkParameters::new(0).is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "new",
        "args": [
            [
                "walk_length",
                "u64"
            ]
        ],
        "return_type": "Result<SingleWalkParameters, String>",
        "body": "if walk_length == 0 {\n            return Err(String::from(\"The provided lenght for the walk is zero!\"));\n        }\n        Ok(SingleWalkParameters {\n            walk_length,\n            weights: WalkWeights::default(),\n            max_neighbours: None,\n        })"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "SingleWalkParameters",
        "doc": [
            "Return boolean value representing if walk is of first order.",
            "",
            "# Example",
            "The default parametrization defines a first order walk:",
            "",
            "```rust",
            "# use graph::walks_parameters::SingleWalkParameters;",
            "let weights = SingleWalkParameters::new(32).unwrap();",
            "assert!(weights.is_first_order_walk());",
            "```"
        ],
        "modifiers": "pub",
        "name": "is_first_order_walk",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.weights.is_first_order_walk()"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalksParameters",
        "impl_doc": [
            "Setters for the Walk's parameters"
        ],
        "doc": [
            "Create new WalksParameters object.",
            "",
            "By default the object is parametrized for a simple first-order walk.",
            "",
            "# Arguments",
            "",
            "* `walk_length`: NodeT - Maximal walk_length of the walk.",
            ""
        ],
        "modifiers": "pub",
        "name": "new",
        "args": [
            [
                "walk_length",
                "u64"
            ]
        ],
        "return_type": "Result<WalksParameters, String>",
        "body": "Ok(WalksParameters {\n            single_walk_parameters: SingleWalkParameters::new(walk_length)?,\n            iterations: 1,\n            random_state: (42 ^ SEED_XOR) as NodeT,\n            dense_node_mapping: None,\n        })"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalksParameters",
        "impl_doc": [
            "Setters for the Walk's parameters"
        ],
        "doc": [
            "Set the iterations.",
            "",
            "# Arguments",
            "",
            "* `iterations`: Option<NodeT> - Whether to show the loading bar or not.",
            "",
            "# Example",
            "You can change the `iterations` parameter as follows:",
            "",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "assert!(WalksParameters::new(32).unwrap().set_iterations(Some(0)).is_err());",
            "assert!(WalksParameters::new(32).unwrap().set_iterations(Some(2)).is_ok());",
            "```",
            "",
            "You can also call the method with an option None, in order to avoid a match",
            "wrapper above. This will end up don't doing anything, just a passthrough.",
            "",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "assert!(WalksParameters::new(32).unwrap().set_iterations(None).is_ok());",
            "```"
        ],
        "modifiers": "pub",
        "name": "set_iterations",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "iterations",
                "Option<NodeT>"
            ]
        ],
        "return_type": "Result<WalksParameters, String>",
        "body": "if let Some(it) = iterations {\n            if it == 0 {\n                return Err(String::from(\n                    \"Iterations parameter must be a strictly positive integer.\",\n                ));\n            }\n            self.iterations = it;\n        }\n        Ok(self)"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalksParameters",
        "impl_doc": [
            "Setters for the Walk's parameters"
        ],
        "doc": [
            "Return the iterations.",
            "",
            "# Example",
            "To retrieve the number of iterations you can do the following:",
            "",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "let mut walk_parameters = WalksParameters::new(32).unwrap();",
            "assert_eq!(walk_parameters.get_iterations(), 1);",
            "let iterations_number = 56;",
            "walk_parameters = walk_parameters.set_iterations(Some(iterations_number)).unwrap();",
            "assert_eq!(walk_parameters.get_iterations(), iterations_number);",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_iterations",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.iterations"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalksParameters",
        "impl_doc": [
            "Setters for the Walk's parameters"
        ],
        "doc": [
            "Set the maximum neighbours number to consider, making the walk probabilistic.",
            "",
            "# Arguments",
            "",
            "* `max_neighbours`: Option<NodeT> - Number of neighbours to consider for each extraction.",
            "",
            "# Example",
            "You can change the `max_neighbours` parameter as follows:",
            "",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "assert!(WalksParameters::new(32).unwrap().set_max_neighbours(Some(0)).is_err());",
            "assert!(WalksParameters::new(32).unwrap().set_max_neighbours(Some(2)).is_ok());",
            "```",
            "",
            "You can also call the method with an option None, in order to avoid a match",
            "wrapper above. This will end up don't doing anything, just a passthrough.",
            "",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "assert!(WalksParameters::new(32).unwrap().set_max_neighbours(None).is_ok());",
            "```"
        ],
        "modifiers": "pub",
        "name": "set_max_neighbours",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "max_neighbours",
                "Option<NodeT>"
            ]
        ],
        "return_type": "Result<WalksParameters, String>",
        "body": "if let Some(mn) = max_neighbours {\n            if mn == 0 {\n                return Err(String::from(\n                    \"max_neighbours parameter must be a strictly positive integer.\",\n                ));\n            }\n            self.single_walk_parameters.max_neighbours = Some(mn);\n        }\n        Ok(self)"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalksParameters",
        "impl_doc": [
            "Setters for the Walk's parameters"
        ],
        "doc": [
            "Set the random_state.",
            "",
            "# Arguments",
            "",
            "* `random_state`: Option<usize> - random_state for reproducible random walks.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_random_state",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "random_state",
                "Option<usize>"
            ]
        ],
        "return_type": "WalksParameters",
        "body": "if let Some(s) = random_state {\n            self.random_state = (s ^ SEED_XOR) as NodeT;\n        }\n        self"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalksParameters",
        "impl_doc": [
            "Setters for the Walk's parameters"
        ],
        "doc": [
            "Set the dense_node_mapping.",
            "",
            "The nodes mapping primary porpose is to map a sparse set of nodes into",
            "a smaller dense set of nodes.",
            "",
            "# Arguments",
            "",
            "* `dense_node_mapping`: Option<HashMap<NodeT, NodeT>> - mapping for the mapping the nodes of the walks.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_dense_node_mapping",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "dense_node_mapping",
                "Option<HashMap<NodeT, NodeT>>"
            ]
        ],
        "return_type": "WalksParameters",
        "body": "self.dense_node_mapping = dense_node_mapping;\n        self"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalksParameters",
        "impl_doc": [
            "Setters for the Walk's parameters"
        ],
        "doc": [
            "Set the return weight.",
            "",
            "# Arguments",
            "",
            "* `return_weight`: Option<WeightT> - weight for the exploitation factor.",
            "",
            "# Example",
            "You can change the `return_weight` parameter as follows:",
            "",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "assert!(WalksParameters::new(32).unwrap().set_return_weight(Some(-1.0)).is_err());",
            "assert!(WalksParameters::new(32).unwrap().set_return_weight(Some(2.0)).is_ok());",
            "assert!(WalksParameters::new(32).unwrap().set_return_weight(Some(1.0)).is_ok());",
            "assert!(WalksParameters::new(32).unwrap().set_return_weight(Some(1.0)).unwrap().is_first_order_walk());",
            "```",
            "",
            "You can also call the method with an option None, in order to avoid a match",
            "wrapper above. This will end up don't doing anything, just a passthrough.",
            "",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "assert!(WalksParameters::new(32).unwrap().set_return_weight(None).unwrap().is_first_order_walk());",
            "```"
        ],
        "modifiers": "pub",
        "name": "set_return_weight",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "return_weight",
                "Option<WeightT>"
            ]
        ],
        "return_type": "Result<WalksParameters, String>",
        "body": "if let Some(rw) = return_weight {\n            self.single_walk_parameters.weights.return_weight =\n                WalkWeights::validate_weight(\"return_weight\", rw)?;\n        }\n        Ok(self)"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalksParameters",
        "impl_doc": [
            "Setters for the Walk's parameters"
        ],
        "doc": [
            "Set the explore weight.",
            "",
            "# Arguments",
            "",
            "* `explore_weight`: Option<WeightT> - weight for the exploration factor.",
            "",
            "# Example",
            "You can change the `explore_weight` parameter as follows:",
            "",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "assert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(-1.0)).is_err());",
            "assert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(2.0)).is_ok());",
            "assert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(1.0)).is_ok());",
            "assert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(1.0)).unwrap().is_first_order_walk());",
            "```",
            "",
            "You can also call the method with an option None, in order to avoid a match",
            "wrapper above. This will end up don't doing anything, just a passthrough.",
            "",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "assert!(WalksParameters::new(32).unwrap().set_explore_weight(None).unwrap().is_first_order_walk());",
            "```"
        ],
        "modifiers": "pub",
        "name": "set_explore_weight",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "explore_weight",
                "Option<WeightT>"
            ]
        ],
        "return_type": "Result<WalksParameters, String>",
        "body": "if let Some(ew) = explore_weight {\n            self.single_walk_parameters.weights.explore_weight =\n                WalkWeights::validate_weight(\"explore_weight\", ew)?;\n        }\n        Ok(self)"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalksParameters",
        "impl_doc": [
            "Setters for the Walk's parameters"
        ],
        "doc": [
            "Set the change_node_type weight.",
            "",
            "# Arguments",
            "",
            "* `change_node_type_weight`: Option<WeightT> - weight for the exploration of different node types.",
            "",
            "# Example",
            "You can change the `change_node_type_weight` parameter as follows:",
            "",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(-1.0)).is_err());",
            "assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(2.0)).is_ok());",
            "assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(1.0)).is_ok());",
            "assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(1.0)).unwrap().is_first_order_walk());",
            "```",
            "",
            "You can also call the method with an option None, in order to avoid a match",
            "wrapper above. This will end up don't doing anything, just a passthrough.",
            "",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(None).unwrap().is_first_order_walk());",
            "```"
        ],
        "modifiers": "pub",
        "name": "set_change_node_type_weight",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "change_node_type_weight",
                "Option<WeightT>"
            ]
        ],
        "return_type": "Result<WalksParameters, String>",
        "body": "if let Some(cntw) = change_node_type_weight {\n            self.single_walk_parameters.weights.change_node_type_weight =\n                WalkWeights::validate_weight(\"change_node_type_weight\", cntw)?;\n        }\n        Ok(self)"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalksParameters",
        "impl_doc": [
            "Setters for the Walk's parameters"
        ],
        "doc": [
            "Set the change_edge_type weight.",
            "",
            "# Arguments",
            "",
            "* `change_edge_type_weight`: Option<WeightT> - weight for the exploration of different node types.",
            "",
            "# Example",
            "You can change the `change_edge_type_weight` parameter as follows:",
            "",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(-1.0)).is_err());",
            "assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(2.0)).is_ok());",
            "assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(1.0)).is_ok());",
            "assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(1.0)).unwrap().is_first_order_walk());",
            "```",
            "You can also call the method with an option None, in order to avoid a match",
            "wrapper above. This will end up don't doing anything, just a passthrough.",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(None).unwrap().is_first_order_walk());",
            "```"
        ],
        "modifiers": "pub",
        "name": "set_change_edge_type_weight",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "change_edge_type_weight",
                "Option<WeightT>"
            ]
        ],
        "return_type": "Result<WalksParameters, String>",
        "body": "if let Some(cetw) = change_edge_type_weight {\n            self.single_walk_parameters.weights.change_edge_type_weight =\n                WalkWeights::validate_weight(\"change_edge_type_weight\", cetw)?;\n        }\n        Ok(self)"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalksParameters",
        "impl_doc": [
            "Setters for the Walk's parameters"
        ],
        "doc": [
            "Validate for graph.",
            "",
            "Check if walks parameters are compatible with given graph.",
            "",
            "# Arguments",
            "",
            "* `graph`: Graph - Graph object for which parameters are to be validated.",
            "",
            "# Example",
            "A graph is always remappable to itself:",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "# let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "# let mut parameters = WalksParameters::new(32).unwrap();",
            "assert!(parameters.set_dense_node_mapping(Some(ppi.get_dense_nodes_mapping())).validate(&ppi).is_ok());",
            "```",
            "Two different graphs, like Cora and STRING, are not remappable:",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "# let cora = graph::test_utilities::load_cora().unwrap();",
            "# let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "# let mut parameters = WalksParameters::new(32).unwrap();",
            "assert!(parameters.set_dense_node_mapping(Some(ppi.get_dense_nodes_mapping())).validate(&cora).is_err());",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "validate",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "graph",
                "&Graph"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "if let Some(dense_node_mapping) = &self.dense_node_mapping {\n            if !graph\n                .iter_unique_source_node_ids()\n                .all(|node| dense_node_mapping.contains_key(&(node as NodeT)))\n            {\n                return Err(String::from(concat!(\n                    \"Given nodes mapping does not contain \",\n                    \"one or more NOT trap nodes that may be extracted from walk.\"\n                )));\n            }\n        }\n\n        Ok(())"
    },
    {
        "file": "walks_parameters.rs",
        "struct": "WalksParameters",
        "impl_doc": [
            "Setters for the Walk's parameters"
        ],
        "doc": [
            "Return boolean value representing if walk is of first order.",
            "",
            "# Example",
            "The default parametrization defines a first order walk:",
            "",
            "```rust",
            "# use graph::walks_parameters::WalksParameters;",
            "assert!(WalksParameters::new(32).unwrap().is_first_order_walk());",
            "```"
        ],
        "modifiers": "pub",
        "name": "is_first_order_walk",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.single_walk_parameters.is_first_order_walk()"
    },
    {
        "file": "trees.rs",
        "doc": [
            "Returns a rayon thread pool handling Creation errors.",
            "",
            "Getting a thread pool might return the error \"Resource temporarly unavailable\"",
            "if the number of processes currently on the system is more than what set in",
            "`ulimit -a`, which by default is 256851.",
            "",
            "Moreover, we return an error if the number of selected CPUS is 1 or less.",
            "Because the algorithms which use the pool requires at least 2 threads, and",
            "we generally provide also an optimized single-thread version."
        ],
        "modifiers": "",
        "name": "get_thread_pool",
        "args": [],
        "return_type": "Result<(usize, ThreadPool), String>",
        "body": "let cpu_number = rayon::current_num_threads();\n\n    if cpu_number <= 1 {\n        return Err(concat!(\n            \"Cannot execute the parallel connected_components method when\",\n            \" only a single CPU is made available.\\n\",\n            \"This might be an erroroneus configuration of the envionment\",\n            \" variable RAYON_NUM_THREADS.\\n\",\n            \"If you really want to compute the connected components with\",\n            \" these configurations, consider using random_spanning_arborescence_kruskal.\"\n        )\n        .to_string());\n    }\n\n    let mut attempts_left = 1_000;\n    loop {\n        match rayon::ThreadPoolBuilder::new()\n            .num_threads(cpu_number)\n            .build()\n        {\n            Ok(thread_pool) => return Ok((cpu_number, thread_pool)),\n            Err(internal_error) => {\n                if attempts_left == 0 {\n                    return Err(format!(\n                        concat!(\n                            \"Unknown error while trying to allocate the thread pool for \",\n                            \"executing the parallel connected components algorithm.\\n\",\n                            \"In our experience this happens once in every 100 milions calls\\n\",\n                            \"The interal error is {:?}.\"\n                        ),\n                        internal_error\n                    ));\n                }\n                let delay = std::time::Duration::from_millis(50);\n                std::thread::sleep(delay);\n                attempts_left -= 1;\n            }\n        }\n    }"
    },
    {
        "file": "trees.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Implementation of algorithms relative to trees.",
            "",
            "# Definitions",
            "- **Self-loops**: Edges with source equal to the destination.",
            "- **Singleton**: A node with no incident edges, (self-loops are not considered).",
            "- **Spanning Tree**: A set of edges that allows to build a path between every",
            "node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
            "- **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
            "with multiple components. Being a tree it trivially contains no self-loops.",
            "For a grpah with n nodes and c components the spanning arborescence will have",
            "n - c edges.",
            "- **Component**: Set of nodes in which any two vertices in it are connected to",
            "each other by paths. A singleton is a component and so is a singleton with a",
            "self-loop."
        ],
        "doc": [
            "Returns iterator over shuffled edge IDs and node IDs.",
            "",
            "# Arguments",
            "* `random_state`: u64 - The random state to reproduce the given edge sampling."
        ],
        "modifiers": "",
        "name": "iter_edges_from_random_state",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "u64"
            ]
        ],
        "return_type": "impl Iterator<Item = (EdgeT, NodeT, NodeT)> + '_",
        "body": "let edges_number = self.get_directed_edges_number();\n        // We execute two times the xorshift to improve the randomness of the seed.\n        let updated_random_state = rand_u64(rand_u64(random_state ^ SEED_XOR as u64));\n        (updated_random_state..edges_number + updated_random_state).filter_map(move |i| {\n            let edge_id = i % edges_number;\n            let (src, dst) = self.get_unchecked_node_ids_from_edge_id(edge_id);\n            match src == dst || !self.directed && src > dst {\n                true => None,\n                false => Some((edge_id, src, dst)),\n            }\n        })"
    },
    {
        "file": "trees.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Implementation of algorithms relative to trees.",
            "",
            "# Definitions",
            "- **Self-loops**: Edges with source equal to the destination.",
            "- **Singleton**: A node with no incident edges, (self-loops are not considered).",
            "- **Spanning Tree**: A set of edges that allows to build a path between every",
            "node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
            "- **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
            "with multiple components. Being a tree it trivially contains no self-loops.",
            "For a grpah with n nodes and c components the spanning arborescence will have",
            "n - c edges.",
            "- **Component**: Set of nodes in which any two vertices in it are connected to",
            "each other by paths. A singleton is a component and so is a singleton with a",
            "self-loop."
        ],
        "doc": [
            "Returns iterator over shuffled edge IDs and node IDs with preference to given edge types.",
            "",
            "# Arguments",
            "* `random_state`: u64 - The random state to reproduce the given edge sampling.",
            "* `undesired_edge_types`: &'a Option<HashSet<Option<EdgeTypeT>>> - The edge types whose edges are to leave as last.",
            "* `verbose`: bool - Whether to show a loading bar."
        ],
        "modifiers": "",
        "name": "iter_on_edges_with_preference_from_random_state",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "undesired_edge_types",
                "&'a Option<HashSet<Option<EdgeTypeT>>>"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<Item = (NodeT, NodeT)> + 'a",
        "body": "let pb = get_loading_bar(\n            verbose,\n            format!(\"Building random spanning tree for {}\", self.name).as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n        let result: Box<dyn Iterator<Item = (NodeT, NodeT)>> = if let (Some(uet), _) =\n            (undesired_edge_types, &self.edge_types)\n        {\n            Box::new(\n                self.iter_edges_from_random_state(random_state)\n                    .filter_map(move |(edge_id, src, dst)| {\n                        if uet.contains(&self.get_unchecked_edge_type_id_from_edge_id(edge_id)) {\n                            return None;\n                        }\n                        Some((src, dst))\n                    })\n                    .chain(self.iter_edges_from_random_state(random_state).filter_map(\n                        move |(edge_id, src, dst)| {\n                            if !uet.contains(&self.get_unchecked_edge_type_id_from_edge_id(edge_id))\n                            {\n                                return None;\n                            }\n                            Some((src, dst))\n                        },\n                    )),\n            )\n        } else {\n            Box::new(\n                self.iter_edges_from_random_state(random_state)\n                    .map(|(_, src, dst)| (src, dst)),\n            )\n        };\n\n        result.progress_with(pb)"
    },
    {
        "file": "trees.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Implementation of algorithms relative to trees.",
            "",
            "# Definitions",
            "- **Self-loops**: Edges with source equal to the destination.",
            "- **Singleton**: A node with no incident edges, (self-loops are not considered).",
            "- **Spanning Tree**: A set of edges that allows to build a path between every",
            "node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
            "- **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
            "with multiple components. Being a tree it trivially contains no self-loops.",
            "For a grpah with n nodes and c components the spanning arborescence will have",
            "n - c edges.",
            "- **Component**: Set of nodes in which any two vertices in it are connected to",
            "each other by paths. A singleton is a component and so is a singleton with a",
            "self-loop."
        ],
        "doc": [
            "Returns set of edges composing a spanning tree and connected components.",
            "",
            "If the graph is composed of a single node with one or more self-loops,",
            "we consider such a graph as a graph with an empty spanning tree, with",
            "a single component of size one.",
            "",
            "# Arguments",
            "",
            "`edges`: impl Iterator<Item = (NodeT, NodeT)> + 'a - Iterator for the edges to explore. If sorted, computed a minimum spanning tree.",
            "",
            "# Returns",
            "Tuple with:",
            "- Set of the edges",
            "- Vector of the nodes components",
            "- Total components number",
            "- Minimum component size",
            "- Maximum component size"
        ],
        "modifiers": "pub(crate)",
        "name": "kruskal",
        "generics": "'a",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edges",
                "impl Iterator<Item = (NodeT, NodeT)> + 'a"
            ]
        ],
        "return_type": "(HashSet<(NodeT, NodeT)>, Vec<NodeT>, NodeT, NodeT, NodeT)",
        "body": "// If the graph does not have nodes, we return all\n        // results as empty to provide an uniform, though pathological,\n        // return value.\n        if !self.has_nodes() {\n            return (HashSet::new(), Vec::new(), 0, 0, 0);\n        }\n        // Similarly, when dealing with a graph with no edges, we define\n        // the spanning tree as empty and the components as the set of the\n        // nodes themselves. Since all nodes are singletons, both the\n        // maximum component size and minimum component size equals to one.\n        if !self.has_edges() {\n            return (\n                HashSet::new(),\n                self.get_nodes(),\n                self.get_nodes_number(),\n                1,\n                1,\n            );\n        }\n\n        let nodes_number = self.get_nodes_number() as usize;\n        let mut tree = HashSet::with_capacity(self.get_nodes_number() as usize);\n        let mut components = vec![NOT_PRESENT; nodes_number];\n        let mut component_sizes: Vec<NodeT> = Vec::new();\n        let mut components_remapping: Vec<NodeT> = Vec::new();\n        let mut max_component_size: NodeT = 0;\n        let mut min_component_size = NodeT::MAX;\n\n        // When there are singleton nodes with self-loops,\n        // which is an arguability weird feature of some graphs,\n        // Kruskal fails to identify them because by definition\n        // a tree cannot contain self-loop.\n        // We call these nodes with one or more self-loops\n        // (in the case of a multigraph) `singletons with self-loops` for lack of\n        // a better term. These nodes are treated as nodes in their own\n        // component and their edges (the self-loops) are not added to the tree.\n        if self.has_singletons() {\n            // When there are singleton nodes, the minimum component size\n            // surely becomes one.\n            min_component_size = 1;\n            // Similarly we need to bump up the max component size, as if\n            // this graph is composed of only singleton nodes with self-loops\n            // we would not iterate thorugh them in the Kruskal loop\n            // since it skips self-loops.\n            max_component_size = 1;\n            // We iterate through the singleton nodes and the singleton nodes\n            // with self-loops.\n            self.iter_singleton_node_ids()\n                .chain(self.iter_singleton_with_selfloops_node_ids())\n                .enumerate()\n                .for_each(|(component_number, node_id)| {\n                    components[node_id as usize] = component_number as NodeT;\n                });\n            // We can re-initialize the component sizes as the vector with\n            // all ones bit as the singleton nodes number.\n            component_sizes = vec![1; self.get_singleton_nodes_number() as usize];\n            // Similarly, the components remapping can be initialized to a range.\n            components_remapping = (0..self.get_singleton_nodes_number()).collect::<Vec<NodeT>>();\n        }\n\n        edges.for_each(|(src, dst)| {\n            // If this is a self-loop we skip it.\n            if src == dst {\n                return;\n            }\n            let src_component = components[src as usize];\n            let dst_component = components[dst as usize];\n            match (src_component == NOT_PRESENT, dst_component == NOT_PRESENT) {\n                // If neither nodes have a component, they must be inserted\n                // both in the components vector and in the tree.\n                // The edge must be added to the three.\n                (true, true) => {\n                    let new_component_id = components_remapping.len() as NodeT;\n                    components[src as usize] = new_component_id;\n                    components[dst as usize] = new_component_id;\n                    components_remapping.push(new_component_id);\n                    component_sizes.push(2);\n                    max_component_size = max_component_size.max(2);\n                }\n                // If both nodes have a component, the two components must be merged\n                // if they are not the same one.\n                // The edge must be added to the three.\n                // The components mapping must be updated and afterwards the other nodes\n                // must be updated accordingly to this update.\n                (false, false) => {\n                    if src_component == dst_component {\n                        return;\n                    }\n                    let src_component = components_remapping[src_component as usize];\n                    let dst_component = components_remapping[dst_component as usize];\n                    if src_component == dst_component {\n                        return;\n                    }\n                    let (node_id_to_update, min_component_id, max_component_id) =\n                        match src_component < dst_component {\n                            true => (dst, src_component, dst_component),\n                            false => (src, dst_component, src_component),\n                        };\n\n                    // We update the node to update with the new component ID.\n                    components[node_id_to_update as usize] = min_component_id;\n\n                    // We merge the two component sizes.\n                    component_sizes[min_component_id as usize] +=\n                        component_sizes[max_component_id as usize];\n\n                    // We check if we have a new component size record\n                    max_component_size =\n                        max_component_size.max(component_sizes[min_component_id as usize]);\n\n                    // If the component we have removed and integrated with\n                    // the component with the smaller has a size greater than\n                    // one, we may need to remap some element of the component\n                    // to this new component.\n                    // Since the components within this loops start from edges\n                    // they cannot be smaller in cardinality than\n                    // two nodes.\n                    components_remapping\n                        .iter_mut()\n                        .zip(component_sizes.iter_mut())\n                        .for_each(|(component_id, component_size)| {\n                            // If one of other components is being remapped to\n                            // the maximum component, we need to update its value\n                            // to the new value this component is being remapped to.\n                            if *component_id == max_component_id {\n                                *component_id = min_component_id;\n                                // We need to invalidate the size of the component\n                                // we have remapped because otherwise we may count it\n                                // when computing the minimum component size.\n                                *component_size = NOT_PRESENT;\n                            }\n                        });\n                }\n                // If only one node has a component, the second node must be added.\n                _ => {\n                    let (component_id, not_inserted_node) = match src_component == NOT_PRESENT {\n                        true => (dst_component, src),\n                        false => (src_component, dst),\n                    };\n                    let component_id = components_remapping[component_id as usize];\n                    component_sizes[component_id as usize] += 1;\n                    max_component_size =\n                        max_component_size.max(component_sizes[component_id as usize]);\n                    components[not_inserted_node as usize] = component_id as NodeT;\n                }\n            };\n            tree.insert((src, dst));\n        });\n\n        // Remapping components to a dense remapping\n        let mut components_number = 0;\n        for i in 0..components_remapping.len() {\n            if components_remapping[i] >= components_number {\n                components_remapping[i] = components_number;\n                components_number += 1;\n            } else {\n                components_remapping[i] = components_remapping[components_remapping[i] as usize];\n            }\n        }\n\n        components.par_iter_mut().for_each(|remapped| {\n            *remapped = components_remapping[*remapped as usize];\n        });\n\n        // If the minimum component size is still bigger than one\n        // that is, we do not know alredy that there is a singleton\n        // we need to compute it.\n        if min_component_size > 1 {\n            min_component_size = match components_number {\n                1 => max_component_size,\n                2 => self.get_nodes_number() - max_component_size,\n                _ => component_sizes.into_par_iter().min().unwrap(),\n            };\n        }\n\n        (\n            tree,\n            components,\n            components_number as NodeT,\n            min_component_size,\n            max_component_size,\n        )"
    },
    {
        "file": "trees.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Implementation of algorithms relative to trees.",
            "",
            "# Definitions",
            "- **Self-loops**: Edges with source equal to the destination.",
            "- **Singleton**: A node with no incident edges, (self-loops are not considered).",
            "- **Spanning Tree**: A set of edges that allows to build a path between every",
            "node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
            "- **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
            "with multiple components. Being a tree it trivially contains no self-loops.",
            "For a grpah with n nodes and c components the spanning arborescence will have",
            "n - c edges.",
            "- **Component**: Set of nodes in which any two vertices in it are connected to",
            "each other by paths. A singleton is a component and so is a singleton with a",
            "self-loop."
        ],
        "doc": [
            "Returns set of edges composing a spanning tree and connected components.",
            "",
            "The spanning tree is NOT minimal.",
            "The given random_state is NOT the root of the tree.",
            "",
            "# Arguments",
            "",
            "* `random_state`: EdgeT - The random_state to use for the holdout,",
            "* `undesired_edge_types`: &Option<HashSet<Option<EdgeTypeT>>> - Which edge types id to try to avoid.",
            "* `verbose`: bool - Whether to show a loading bar or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "random_spanning_arborescence_kruskal",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "EdgeT"
            ],
            [
                "undesired_edge_types",
                "&Option<HashSet<Option<EdgeTypeT>>>"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "(HashSet<(NodeT, NodeT)>, Vec<NodeT>, NodeT, NodeT, NodeT)",
        "body": "self.kruskal(self.iter_on_edges_with_preference_from_random_state(\n            random_state,\n            undesired_edge_types,\n            verbose,\n        ))"
    },
    {
        "file": "trees.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Implementation of algorithms relative to trees.",
            "",
            "# Definitions",
            "- **Self-loops**: Edges with source equal to the destination.",
            "- **Singleton**: A node with no incident edges, (self-loops are not considered).",
            "- **Spanning Tree**: A set of edges that allows to build a path between every",
            "node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
            "- **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
            "with multiple components. Being a tree it trivially contains no self-loops.",
            "For a grpah with n nodes and c components the spanning arborescence will have",
            "n - c edges.",
            "- **Component**: Set of nodes in which any two vertices in it are connected to",
            "each other by paths. A singleton is a component and so is a singleton with a",
            "self-loop."
        ],
        "doc": [
            "Returns consistent spanning arborescence using Kruskal.",
            "",
            "The spanning tree is NOT minimal.",
            "",
            "# Arguments",
            "",
            "* `verbose`: bool - Whether to show a loading bar or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "spanning_arborescence_kruskal",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "(HashSet<(NodeT, NodeT)>, Vec<NodeT>, NodeT, NodeT, NodeT)",
        "body": "let pb = get_loading_bar(\n            verbose,\n            &format!(\n                \"Computing spanning arborescence with Kruskal for {}\",\n                self.get_name()\n            ),\n            self.get_unique_edges_number() as usize,\n        );\n        self.kruskal(\n            self.iter_unique_edge_node_ids(self.directed)\n                .progress_with(pb),\n        )"
    },
    {
        "file": "trees.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Implementation of algorithms relative to trees.",
            "",
            "# Definitions",
            "- **Self-loops**: Edges with source equal to the destination.",
            "- **Singleton**: A node with no incident edges, (self-loops are not considered).",
            "- **Spanning Tree**: A set of edges that allows to build a path between every",
            "node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
            "- **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
            "with multiple components. Being a tree it trivially contains no self-loops.",
            "For a grpah with n nodes and c components the spanning arborescence will have",
            "n - c edges.",
            "- **Component**: Set of nodes in which any two vertices in it are connected to",
            "each other by paths. A singleton is a component and so is a singleton with a",
            "self-loop."
        ],
        "doc": [
            "Returns set of edges composing a spanning tree.",
            "",
            "This is the implementaiton of [A Fast, Parallel Spanning Tree Algorithm for Symmetric Multiprocessors (SMPs)](https://smartech.gatech.edu/bitstream/handle/1853/14355/GT-CSE-06-01.pdf)",
            "by David A. Bader and Guojing Cong.",
            "",
            "# Arguments",
            "",
            "* `verbose`: bool - Whether to show a loading bar or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "spanning_arborescence",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(usize, impl Iterator<Item = (NodeT, NodeT)> + '_), String>",
        "body": "self.must_be_undirected()?;\n        let nodes_number = self.get_nodes_number() as usize;\n        let mut parents = vec![NOT_PRESENT; nodes_number];\n        let (cpu_number, pool) = get_thread_pool()?;\n        let shared_stacks: Arc<Vec<Mutex<Vec<NodeT>>>> = Arc::from(\n            (0..std::cmp::max(cpu_number - 1, 1))\n                .map(|_| Mutex::from(Vec::new()))\n                .collect::<Vec<Mutex<Vec<NodeT>>>>(),\n        );\n        let active_nodes_number = AtomicUsize::new(0);\n        let completed = AtomicBool::new(false);\n        let total_inserted_edges = AtomicUsize::new(0);\n        let thread_safe_parents = ThreadSafe {\n            value: std::cell::UnsafeCell::new(&mut parents),\n        };\n\n        // since we were able to build a stub tree with cpu.len() leafs,\n        // we spawn the treads and make anyone of them build the sub-trees.\n        pool.scope(|s| {\n            // for each leaf of the previous stub tree start a DFS keeping track\n            // of which nodes we visited and updating accordingly the parents vector.\n            // the nice trick here is that, since all the leafs are part of the same tree,\n            // if two processes find the same node, we don't care which one of the two take\n            // it so we can proceed in a lockless fashion (and maybe even without atomics\n            // if we manage to remove the colors vecotr and only keep the parents one)\n            s.spawn(|_| {\n                let pb = get_loading_bar(\n                    verbose,\n                    format!(\"Computing spanning tree of graph {}\", self.get_name()).as_ref(),\n                    nodes_number,\n                );\n                let parents = thread_safe_parents.value.get();\n                (0..nodes_number).progress_with(pb).for_each(|src| {\n                    // If the node has already been explored we skip ahead.\n                    if unsafe { (*parents)[src] != NOT_PRESENT} {\n                        return;\n                    }\n\n                    // find the first not explored node (this is guardanteed to be in a new component)\n                    if self.is_unchecked_singleton_from_node_id(src as NodeT) {\n                        // We set singletons as self-loops for now.\n                        unsafe{ (*parents)[src] = src as NodeT };\n                        return;\n                    }\n                    loop {\n                        if unsafe { (*parents)[src] != NOT_PRESENT} {\n                            break;\n                        }\n                        if active_nodes_number.load(Ordering::SeqCst) == 0 {\n                            if unsafe { (*parents)[src] != NOT_PRESENT} {\n                                break;\n                            }\n                            unsafe {\n                                (*parents)[src] = src as NodeT;\n                            }\n                            shared_stacks[0].lock().expect(\"The lock is poisoned from the panic of another thread\")\n                                .push(src as NodeT);\n                            active_nodes_number.fetch_add(1, Ordering::SeqCst);\n                            break;\n                        }\n                    }\n                });\n                completed.store(true, Ordering::SeqCst);\n            });\n            (0..shared_stacks.len()).for_each(|_| {\n                s.spawn(|_| 'outer: loop {\n                    let thread_id = rayon::current_thread_index().expect(\"current_thread_id not called from a rayon thread. This should not be possible because this is in a Rayon Thread Pool.\");\n                    let src = 'inner: loop {\n                        {\n                            for mut stack in (thread_id..(shared_stacks.len() + thread_id))\n                                .map(|id| shared_stacks[id % shared_stacks.len()].lock().expect(\"The lock is poisoned from the panic of another thread\"))\n                            {\n                                if let Some(src) = stack.pop() {\n                                    break 'inner src;\n                                }\n                            }\n\n                            if completed.load(Ordering::SeqCst) {\n                                break 'outer;\n                            }\n                        }\n                    };\n                    let parents = thread_safe_parents.value.get();\n                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(src)\n                        .for_each(|dst| unsafe {\n                            if (*parents)[dst as usize] == NOT_PRESENT {\n                                (*parents)[dst as usize] = src;\n                                total_inserted_edges.fetch_add(1, Ordering::SeqCst);\n                                active_nodes_number.fetch_add(1, Ordering::SeqCst);\n                                shared_stacks[rand_u64(dst as u64) as usize % shared_stacks.len()]\n                                    .lock()\n                                    .expect(\"The lock is poisoned from the panic of another thread\")\n                                    .push(dst);\n                            }\n                        });\n                    active_nodes_number.fetch_sub(1, Ordering::SeqCst);\n                });\n            });\n        });\n\n        // convert the now completed parents vector to a list of tuples representing the edges\n        // of the spanning arborescense.\n        Ok((\n            // Number of edges inserted\n            total_inserted_edges.load(Ordering::SeqCst),\n            // Return an iterator over all the edges in the spanning arborescence\n            parents.into_iter().enumerate().filter_map(|(src, dst)| {\n                if src as NodeT == dst {\n                    return None;\n                }\n                Some((src as NodeT, dst))\n            }),\n        ))"
    },
    {
        "file": "trees.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Implementation of algorithms relative to trees.",
            "",
            "# Definitions",
            "- **Self-loops**: Edges with source equal to the destination.",
            "- **Singleton**: A node with no incident edges, (self-loops are not considered).",
            "- **Spanning Tree**: A set of edges that allows to build a path between every",
            "node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.",
            "- **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs",
            "with multiple components. Being a tree it trivially contains no self-loops.",
            "For a grpah with n nodes and c components the spanning arborescence will have",
            "n - c edges.",
            "- **Component**: Set of nodes in which any two vertices in it are connected to",
            "each other by paths. A singleton is a component and so is a singleton with a",
            "self-loop."
        ],
        "doc": [
            "Compute the connected components building in parallel a spanning tree using [bader's algorithm](https://www.sciencedirect.com/science/article/abs/pii/S0743731505000882).",
            "**This works only for undirected graphs.**",
            "",
            "This method is **not thread save and not deterministic** but by design of the algorithm this",
            "shouldn't matter but if we will encounter non-detemristic bugs here is where we want to look.",
            "",
            "Returns (Components membership, components number, size of the smallest components, size of the biggest components).",
            "We assign to each node the index of its component, so nodes in the same components will have the same index.",
            "This component index is the returned Components membership vector.",
            "",
            "# Arguments",
            "",
            "* `verbose`: bool - Whether to show a loading bar or not.",
            "",
            "# Example",
            "```rust",
            "# #![feature(impl_trait_in_bindings)]",
            "# use graph::Graph;",
            "// Graph is a weightless graph with the edges",
            "// [(0, 1), (1, 4), (2, 3)]",
            "# let edge: Vec<Result<(String, String, Option<String>, Option<f32>), String>> = vec![",
            "#        Ok((\"0\".to_string(), \"1\".to_string(), None, None)),",
            "#        Ok((\"1\".to_string(), \"4\".to_string(), None, None)),",
            "#        Ok((\"2\".to_string(), \"3\".to_string(), None, None)),",
            "#     ];",
            "#",
            "# let nodes = None.map(|x: Vec<Result<(String, Option<Vec<String>>), String>>| x.into_iter());",
            "#",
            "# let graph = Graph::from_string_unsorted(",
            "#     edge.into_iter(),",
            "#     nodes,      // nodes",
            "#     false,     // directed",
            "#     false,      // directe edge list",
            "#     \"test graph\",// name",
            "#     false,     // ignore_duplicated_nodes",
            "#     true,     // node_list_is_correct",
            "#     false,     // ignore_duplicated_nodes",
            "#     true,     // node_list_is_correct",
            "#     false,     // verbose",
            "#     false,     // numeric_edge_types_ids",
            "#     false,     // numeric_node_ids",
            "#     false,     // numeric_edge_node_ids",
            "#     false,     // numeric_node_types_ids",
            "#     false,     // has_node_types",
            "#     false,     // has_edge_types",
            "#     false,     // has_edge_weights",
            "#     true,",
            "#     true,",
            "#     true,",
            "# ).unwrap();",
            "let (components, number_of_components, smallest, biggest) =",
            "graph.connected_components(false).unwrap();",
            "",
            "//   nodes names:       0  1  4  2  3",
            "assert_eq!(components, [0, 0, 0, 1, 1].to_vec());",
            "",
            "assert_eq!(number_of_components, 2);",
            "assert_eq!(smallest, 2); // the size of the smallest component",
            "assert_eq!(biggest, 3);  // the size of the biggest component",
            "```"
        ],
        "modifiers": "pub",
        "name": "connected_components",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(Vec<NodeT>, NodeT, NodeT, NodeT), String>",
        "body": "self.must_be_undirected()?;\n        if !self.has_nodes() {\n            return Ok((Vec::new(), 0, 0, 0));\n        }\n        if self.get_edges_number() == 0 {\n            return Ok((\n                (0..self.get_nodes_number()).collect(),\n                self.get_nodes_number(),\n                1,\n                1,\n            ));\n        }\n        let components = (0..self.get_nodes_number())\n            .map(|_| AtomicU32::new(NOT_PRESENT))\n            .collect::<Vec<_>>();\n        let mut min_component_size: NodeT = NodeT::MAX;\n        let mut max_component_size: NodeT = 0;\n        let mut components_number: NodeT = 0;\n        let (cpu_number, pool) = get_thread_pool()?;\n        let shared_stacks: Arc<Vec<Mutex<Vec<NodeT>>>> = Arc::from(\n            (0..std::cmp::max(cpu_number - 1, 1))\n                .map(|_| Mutex::from(Vec::new()))\n                .collect::<Vec<Mutex<Vec<NodeT>>>>(),\n        );\n        let active_nodes_number = AtomicUsize::new(0);\n        let current_component_size = AtomicU32::new(0);\n        let completed = AtomicBool::new(false);\n        let thread_safe_min_component_size = ThreadSafe {\n            value: std::cell::UnsafeCell::new(&mut min_component_size),\n        };\n        let thread_safe_max_component_size = ThreadSafe {\n            value: std::cell::UnsafeCell::new(&mut max_component_size),\n        };\n        let thread_safe_components_number = ThreadSafe {\n            value: std::cell::UnsafeCell::new(&mut components_number),\n        };\n\n        // since we were able to build a stub tree with cpu.len() leafs,\n        // we spawn the treads and make anyone of them build the sub-trees.\n        pool.scope(|s| {\n            // for each leaf of the previous stub tree start a DFS keeping track\n            // of which nodes we visited and updating accordingly the components vector.\n            // the nice trick here is that, since all the leafs are part of the same tree,\n            // if two processes find the same node, we don't care which one of the two take\n            // it so we can proceed in a lockless fashion (and maybe even without atomics\n            // if we manage to remove the colors vecotr and only keep the components one)\n            s.spawn(|_| {\n                let pb = get_loading_bar(\n                    verbose,\n                    format!(\n                        \"Computing connected components of graph {}\",\n                        self.get_name()\n                    )\n                    .as_ref(),\n                    self.get_nodes_number() as usize,\n                );\n                let min_component_size = thread_safe_min_component_size.value.get();\n                let max_component_size = thread_safe_max_component_size.value.get();\n                let components_number = thread_safe_components_number.value.get();\n                (0..self.get_nodes_number())\n                    .progress_with(pb)\n                    .for_each(|src| {\n                        // If the node has already been explored we skip ahead.\n                        if components[src as usize].load(Ordering::Relaxed) != NOT_PRESENT {\n                            return;\n                        }\n\n                        // find the first not explored node (this is guardanteed to be in a new component)\n                        if self.has_singletons()\n                            && (self.is_unchecked_singleton_from_node_id(src)\n                                || self.is_singleton_with_selfloops_from_node_id(src))\n                        {\n                            // We set singletons as self-loops for now.\n                            unsafe {\n                                components[src as usize]\n                                    .store(**components_number, Ordering::Relaxed);\n                                **components_number += 1;\n                                **min_component_size = 1;\n                                **max_component_size = (**max_component_size).max(1);\n                            }\n                            return;\n                        }\n\n                        loop {\n                            // if the node has been now mapped to a component by anyone of the\n                            // parallel threads, move on to the next node.\n                            if components[src as usize].load(Ordering::Relaxed) != NOT_PRESENT {\n                                break;\n                            }\n                            // Otherwise, Check if the parallel threads are finished\n                            // and are all waiting for a new node to explore.\n                            // In that case add the currently not explored node to the\n                            // work stack of the first thread.\n                            if active_nodes_number.load(Ordering::Relaxed) == 0 {\n                                // The check here might seems redundant but its' needed\n                                // to prevent data races.\n                                //\n                                // If the last parallel thread finishes its stack between the\n                                // presence check above and the active nodes numbers check\n                                // the src node will never increase the component size and thus\n                                // leading to wrong results.\n                                if components[src as usize].load(Ordering::Relaxed) != NOT_PRESENT {\n                                    break;\n                                }\n                                let ccs =\n                                    current_component_size.swap(1, Ordering::Relaxed) as NodeT;\n                                unsafe {\n                                    **max_component_size = (**max_component_size).max(ccs);\n                                    if ccs > 1 {\n                                        **min_component_size = (**min_component_size).min(ccs);\n                                    }\n                                    components[src as usize]\n                                        .store(**components_number, Ordering::Relaxed);\n                                    **components_number += 1;\n                                }\n                                active_nodes_number.fetch_add(1, Ordering::Relaxed);\n                                shared_stacks[0].lock().expect(\"The lock is poisoned from the panic of another thread\").push(src);\n                                break;\n                            }\n                            // Otherwise, Loop until the parallel threads are finished.\n                        }\n                    });\n                completed.store(true, Ordering::Relaxed);\n            });\n\n            // Spawn the parallel threads that handle the components mapping,\n            // these threads use work-stealing, meaning that if their stack is empty,\n            // they will steal nodes from the stack of another random thread.\n            (0..shared_stacks.len()).for_each(|_| {\n                s.spawn(|_| 'outer: loop {\n                    // get the id, we use this as an idex for the stacks vector.\n                    let thread_id = rayon::current_thread_index().expect(\"current_thread_id not called from a rayon thread. This should not be possible because this is in a Rayon Thread Pool.\");\n\n                    let src = 'inner: loop {\n                        {\n                            for mut stack in (thread_id..(shared_stacks.len() + thread_id))\n                                .map(|id| shared_stacks[id % shared_stacks.len()].lock().expect(\"The lock is poisoned from the panic of another thread\"))\n                            {\n                                if let Some(src) = stack.pop() {\n                                    break 'inner src;\n                                }\n                            }\n\n                            if completed.load(Ordering::Relaxed) {\n                                break 'outer;\n                            }\n                        }\n                    };\n\n                    let src_component = components[src as usize].load(Ordering::Relaxed);\n                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(src)\n                        .for_each(|dst| {\n                            if components[dst as usize].swap(src_component, Ordering::SeqCst)\n                                == NOT_PRESENT\n                            {\n                                active_nodes_number.fetch_add(1, Ordering::SeqCst);\n                                current_component_size.fetch_add(1, Ordering::SeqCst);\n                                shared_stacks[rand_u64(dst as u64) as usize % shared_stacks.len()]\n                                    .lock()\n                                    .expect(\"The lock is poisoned from the panic of another thread\")\n                                    .push(dst);\n                            }\n                        });\n                    active_nodes_number.fetch_sub(1, Ordering::SeqCst);\n                });\n            });\n        });\n\n        let ccs = current_component_size.load(Ordering::SeqCst);\n        max_component_size = max_component_size.max(ccs);\n        if ccs > 1 {\n            min_component_size = min_component_size.min(ccs);\n        }\n\n        Ok((\n            unsafe { std::mem::transmute::<Vec<AtomicU32>, Vec<u32>>(components) },\n            components_number,\n            min_component_size,\n            max_component_size,\n        ))"
    },
    {
        "file": "csv_file_writer.rs",
        "struct": "CSVFileWriter",
        "impl_doc": [
            "Structure that saves the common parameters for reading csv files.",
            "",
            "# Attributes",
            "* path: String - The path where to save the file. E.g. \"/tmp/test.csv\"",
            "* `verbose`: bool - If the progress bars and logging must be displayed.",
            "* separator: String - The separator to use, usually, this is \"\\t\" for tsv and \",\" for csv.",
            "* header: bool - If the file (will / must) have the header with the titles of the columns.",
            "# Builder methods"
        ],
        "doc": [
            "Return new CSVFileWriter object.",
            "",
            "# Arguments",
            "",
            "* path: String - Path where to store/load the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "new",
        "generics": "S: Into<String>",
        "args": [
            [
                "path",
                "S"
            ]
        ],
        "return_type": "CSVFileWriter",
        "body": "CSVFileWriter {\n            path: path.into(),\n            verbose: true,\n            separator: \"\\t\".to_string(),\n            header: true,\n        }"
    },
    {
        "file": "csv_file_writer.rs",
        "struct": "CSVFileWriter",
        "impl_doc": [
            "Structure that saves the common parameters for reading csv files.",
            "",
            "# Attributes",
            "* path: String - The path where to save the file. E.g. \"/tmp/test.csv\"",
            "* `verbose`: bool - If the progress bars and logging must be displayed.",
            "* separator: String - The separator to use, usually, this is \"\\t\" for tsv and \",\" for csv.",
            "* header: bool - If the file (will / must) have the header with the titles of the columns.",
            "# Builder methods"
        ],
        "doc": [
            "Write given rows iterator to file.",
            "",
            "# Arguments",
            "",
            "* `lines_number`: u64 - Number of lines to expect to write out.",
            "* `header`: Vec<String> - The header to write out, if so required.",
            "* `values`: impl Iterator<Item = Vec<String>> - Iterator of rows to write out."
        ],
        "modifiers": "pub(crate)",
        "name": "write_lines",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "lines_number",
                "usize"
            ],
            [
                "header",
                "Vec<String>"
            ],
            [
                "values",
                "impl Iterator<Item = Vec<String>>"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "let pb = get_loading_bar(self.verbose, \"Writing to file\", lines_number);\n\n        let file = match File::create(self.path.clone()) {\n            Ok(f) => Ok(f),\n            Err(_) => Err(format!(\"Cannot open in writing the file {}\", self.path)),\n        }?;\n\n        let mut stream = BufWriter::new(file);\n\n        if self.header {\n            let mut line = header.join(&self.separator);\n            line.push('\\n');\n            match stream.write(line.as_bytes()) {\n                Ok(_) => Ok(()),\n                Err(_) => {\n                    Err(\"Cannot write the header. There might have been an I/O error.\".to_string())\n                }\n            }?;\n        }\n\n        for (i, value) in values.progress_with(pb).enumerate() {\n            let mut line = value.join(&self.separator);\n            line.push('\\n');\n            match stream.write(line.as_bytes()) {\n                Ok(_) => Ok(()),\n                Err(_) => Err(format!(\n                    \"Cannot write the {i} line. There might have been an I/O error.\",\n                    i = i\n                )),\n            }?;\n        }\n\n        match stream.flush() {\n            Ok(_) => Ok(()),\n            Err(_) => Err(\"Unable to close file. There might have been an I/O error.\".to_string()),\n        }"
    },
    {
        "file": "csv_file_writer.rs",
        "doc": [
            "Return formatted vector of rows.",
            "",
            "# Arguments",
            "",
            "* `number_of_columns`: usize - Total number of columns to renderize.",
            "* `pairs`: Vec<(String, usize)> - Vector of tuples of column names and their position."
        ],
        "modifiers": "pub(crate)",
        "name": "compose_lines",
        "args": [
            [
                "number_of_columns",
                "usize"
            ],
            [
                "pairs",
                "Vec<(String"
            ]
        ],
        "return_type": "Vec<String>",
        "body": "let mut values = vec![\"\".to_string(); number_of_columns];\n    for (name, pos) in pairs {\n        values[pos] = name\n    }\n    values"
    },
    {
        "file": "graph.rs",
        "struct": "Graph",
        "impl_doc": [
            "A graph representation optimized for executing random walks on huge graphs.",
            "",
            "This class should be initialized using the two constructors:",
            "`graph::Graph::new_directed` or `graph::Graph::new_undirected`",
            "",
            "# Example",
            "",
            "# Graph utility methods"
        ],
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "new",
        "generics": "S: Into<String>",
        "args": [
            [
                "directed",
                "bool"
            ],
            [
                "unique_selfloop_number",
                "NodeT"
            ],
            [
                "selfloop_number",
                "EdgeT"
            ],
            [
                "not_singleton_nodes_number",
                "NodeT"
            ],
            [
                "singleton_nodes_with_selfloops_number",
                "NodeT"
            ],
            [
                "unique_edges_number",
                "EdgeT"
            ],
            [
                "edges",
                "EliasFano"
            ],
            [
                "unique_sources",
                "Option<EliasFano>"
            ],
            [
                "nodes",
                "Vocabulary<NodeT>"
            ],
            [
                "node_bit_mask",
                "EdgeT"
            ],
            [
                "node_bits",
                "u8"
            ],
            [
                "edge_types",
                "Option<EdgeTypeVocabulary>"
            ],
            [
                "name",
                "S"
            ],
            [
                "weights",
                "Option<Vec<WeightT>>"
            ],
            [
                "node_types",
                "Option<NodeTypeVocabulary>"
            ],
            [
                "not_singleton_nodes",
                "Option<BitVec<Lsb0, u8>>"
            ],
            [
                "singleton_nodes_with_selfloops",
                "Option<RoaringBitmap>"
            ]
        ],
        "return_type": "Graph",
        "body": "Graph {\n            directed,\n            unique_selfloop_number,\n            selfloop_number,\n            not_singleton_nodes_number,\n            singleton_nodes_with_selfloops_number,\n            unique_edges_number,\n            edges,\n            unique_sources,\n            node_bit_mask,\n            node_bits,\n            weights,\n            node_types: node_types.map(|nts| nts.set_numeric_ids(false)),\n            edge_types: edge_types.map(|ets| ets.set_numeric_ids(false)),\n            nodes: nodes.set_numeric_ids(false),\n            sources: None,\n            destinations: None,\n            cumulative_node_degrees: None,\n            cached_destinations: None,\n            name: name.into(),\n            not_singleton_nodes,\n            singleton_nodes_with_selfloops,\n            cached_report: ClonableRwLock::new(None),\n        }"
    },
    {
        "file": "graph.rs",
        "struct": "Graph",
        "impl_doc": [
            "A graph representation optimized for executing random walks on huge graphs.",
            "",
            "This class should be initialized using the two constructors:",
            "`graph::Graph::new_directed` or `graph::Graph::new_undirected`",
            "",
            "# Example",
            "",
            "# Graph utility methods"
        ],
        "doc": [
            "Return true if given graph has any edge overlapping with current graph.",
            "",
            "# Arguments",
            "",
            "* `other`: &Graph - The graph to check against.",
            ""
        ],
        "modifiers": "pub",
        "name": "overlaps",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "other",
                "&Graph"
            ]
        ],
        "return_type": "Result<bool, String>",
        "body": "Ok(match self.is_compatible(other)? {\n            true => other\n                .par_iter_edge_node_ids_and_edge_type_id(other.directed)\n                .any(|(_, src, dst, et)| {\n                    self.has_edge_from_node_ids_and_edge_type_id(src, dst, et)\n                }),\n            false => other.par_iter_edge_node_names_and_edge_type_name(other.directed).any(\n                |(_, _, src_name, _, dst_name, _, edge_type_name)| {\n                    self.has_edge_from_node_names_and_edge_type_name(\n                        &src_name,\n                        &dst_name,\n                        edge_type_name.as_ref(),\n                    )\n                },\n            ),\n        })"
    },
    {
        "file": "graph.rs",
        "struct": "Graph",
        "impl_doc": [
            "A graph representation optimized for executing random walks on huge graphs.",
            "",
            "This class should be initialized using the two constructors:",
            "`graph::Graph::new_directed` or `graph::Graph::new_undirected`",
            "",
            "# Example",
            "",
            "# Graph utility methods"
        ],
        "doc": [
            "Return true if given graph edges are all contained within current graph.",
            "",
            "# Arguments",
            "",
            "* `other`: &Graph - The graph to check against.",
            ""
        ],
        "modifiers": "pub",
        "name": "contains",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "other",
                "&Graph"
            ]
        ],
        "return_type": "Result<bool, String>",
        "body": "Ok(match self.is_compatible(other)? {\n            true => other\n                .par_iter_edge_node_ids_and_edge_type_id(other.directed)\n                .all(|(_, src, dst, et)| {\n                    self.has_edge_from_node_ids_and_edge_type_id(src, dst, et)\n                }),\n            false => other.par_iter_edge_node_names_and_edge_type_name(other.directed).all(\n                |(_, _, src_name, _, dst_name, _, edge_type_name)| {\n                    self.has_edge_from_node_names_and_edge_type_name(\n                        &src_name,\n                        &dst_name,\n                        edge_type_name.as_ref(),\n                    )\n                },\n            ),\n        })"
    },
    {
        "file": "preprocessing.rs",
        "doc": [
            "Computes val % n using lemires fast method for u32.",
            "https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/",
            "This is supposed to be ~5 times faster."
        ],
        "modifiers": "",
        "name": "fast_u32_modulo",
        "args": [
            [
                "val",
                "u32"
            ],
            [
                "n",
                "u32"
            ]
        ],
        "return_type": "u32",
        "body": "((val as u64 * n as u64) >> 32) as u32"
    },
    {
        "file": "preprocessing.rs",
        "doc": [
            "Return training batches for Word2Vec models.",
            "",
            "The batch is composed of a tuple as the following:",
            "",
            "- (Contexts indices, central nodes indices): the tuple of nodes",
            "",
            "This does not provide any output value as the model uses NCE loss",
            "and basically the central nodes that are fed as inputs work as the",
            "outputs value.",
            "",
            "# Arguments",
            "",
            "* `sequences`: impl ParallelIterator<Item = Vec<NodeT>> + 'a - the sequence of sequences of integers to preprocess.",
            "* `window_size`: usize - Window size to consider for the sequences.",
            ""
        ],
        "modifiers": "pub",
        "name": "word2vec",
        "generics": "'a",
        "args": [
            [
                "sequences",
                "impl ParallelIterator<Item = Vec<NodeT>> + 'a"
            ],
            [
                "window_size",
                "usize"
            ]
        ],
        "return_type": "Result<impl ParallelIterator<Item = (Vec<NodeT>, NodeT)> + 'a, String>",
        "body": "Ok(sequences.flat_map_iter(move |sequence| {\n        let sequence_length = sequence.len();\n        if sequence_length < window_size * 2 + 1 {\n            panic!(\n                \"\n            Cannot compute word2vec, got a sequence of length {} and window size {}.\n            for the current window_size the minimum sequence length required is {}\",\n                sequence_length,\n                window_size,\n                window_size * 2 + 1,\n            );\n        }\n        (window_size..(sequence_length - window_size)).map(move |i| {\n            (\n                (i - window_size..i)\n                    .chain(i + 1..window_size + i + 1)\n                    .map(|j| sequence[j])\n                    .collect(),\n                sequence[i],\n            )\n        })\n    }))"
    },
    {
        "file": "preprocessing.rs",
        "doc": [
            "Return triple with CSR representation of cooccurrence matrix.",
            "",
            "The first vector has the sources, the second vector the destinations",
            "and the third one contains the min-max normalized frequencies.",
            "",
            "# Arguments",
            "",
            "* `sequences`: impl ParallelIterator<Item = Vec<NodeT>> - the sequence of sequences of integers to preprocess.",
            "* `window_size`: Option<usize> - Window size to consider for the sequences.",
            "* `verbose`: Option<bool> - Whether to show the progress bars. The default behaviour is false.",
            ""
        ],
        "modifiers": "pub",
        "name": "cooccurence_matrix",
        "args": [
            [
                "sequences",
                "impl ParallelIterator<Item = Vec<NodeT>>"
            ],
            [
                "window_size",
                "usize"
            ],
            [
                "number_of_sequences",
                "usize"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(usize, impl Iterator<Item = (NodeT, NodeT, f64)>), String>",
        "body": "let mut cooccurence_matrix: HashMap<(NodeT, NodeT), f64> = HashMap::new();\n    let mut max_frequency = 0.0;\n    let pb1 = get_loading_bar(verbose, \"Computing frequencies\", number_of_sequences);\n\n    // TODO!: Avoid this collect and create the cooccurrence matrix in a parallel way.\n    // We are currently working on this but is terribly non-trivial,\n    // as most parallel implementations end up being slower than sequential\n    // ones or require massive amounts of additional memory.\n    let vec = sequences.collect::<Vec<Vec<NodeT>>>();\n    vec.iter().progress_with(pb1).for_each(|sequence| {\n        let walk_length = sequence.len();\n        for (central_index, &central_word_id) in sequence.iter().enumerate() {\n            let upperbound = std::cmp::min(1 + window_size, walk_length - central_index);\n\n            for distance in 1..upperbound {\n                let context_id = sequence[central_index + distance];\n\n                let (smaller, bigger) = (\n                    std::cmp::min(central_word_id, context_id),\n                    std::cmp::max(central_word_id, context_id),\n                );\n\n                let freq = 1.0 / distance as f64;\n\n                // Get the current value for this pair of nodes\n                let ptr = cooccurence_matrix\n                    .entry((smaller, bigger))\n                    .and_modify(|e| *e += freq)\n                    .or_insert(freq);\n                // Update the max\n                if *ptr > max_frequency {\n                    max_frequency = *ptr;\n                }\n            }\n        }\n    });\n\n    let number_of_elements = cooccurence_matrix.len();\n    let pb2 = get_loading_bar(\n        verbose,\n        \"Converting mapping into CSR matrix\",\n        cooccurence_matrix.len(),\n    );\n    Ok((\n        number_of_elements,\n        cooccurence_matrix\n            .into_iter()\n            .progress_with(pb2)\n            .map(move |((word, context), frequency)| (word, context, frequency / max_frequency)),\n    ))"
    },
    {
        "file": "preprocessing.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Preprocessing for ML algorithms on graph."
        ],
        "doc": [
            "Return training batches for Node2Vec models.",
            "",
            "The batch is composed of a tuple as the following:",
            "",
            "- (Contexts indices, central nodes indices): the tuple of nodes",
            "",
            "This does not provide any output value as the model uses NCE loss",
            "and basically the central nodes that are fed as inputs work as the",
            "outputs value.",
            "",
            "# Arguments",
            "",
            "* `walk_parameters`: &'a WalksParameters - the weighted walks parameters.",
            "* `quantity`: NodeT - Number of nodes to consider.",
            "* `window_size`: usize - Window size to consider for the sequences.",
            ""
        ],
        "modifiers": "pub",
        "name": "node2vec",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "walk_parameters",
                "&'a WalksParameters"
            ],
            [
                "quantity",
                "NodeT"
            ],
            [
                "window_size",
                "usize"
            ]
        ],
        "return_type": "Result<impl ParallelIterator<Item = (Vec<NodeT>, NodeT)> + 'a, String>",
        "body": "// do the walks and check the result\n        word2vec(\n            self.iter_random_walks(quantity, walk_parameters)?,\n            window_size,\n        )"
    },
    {
        "file": "preprocessing.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Preprocessing for ML algorithms on graph."
        ],
        "doc": [
            "Return triple with CSR representation of cooccurrence matrix.",
            "",
            "The first vector has the sources, the second vector the destinations",
            "and the third one contains the min-max normalized frequencies.",
            "",
            "# Arguments",
            "",
            "* `walks_parameters`: &'a WalksParameters - the walks parameters.",
            "* `window_size`: usize - Window size to consider for the sequences.",
            "* `verbose`: bool - Whether to show the progress bars. The default behaviour is false.",
            ""
        ],
        "modifiers": "pub",
        "name": "cooccurence_matrix",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "walks_parameters",
                "&'a WalksParameters"
            ],
            [
                "window_size",
                "usize"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(usize, impl Iterator<Item = (NodeT, NodeT, f64)> + 'a), String>",
        "body": "self.must_have_edges()?;\n        let walks = self.iter_complete_walks(walks_parameters)?;\n        cooccurence_matrix(\n            walks,\n            window_size,\n            (self.get_unique_source_nodes_number() * walks_parameters.iterations) as usize,\n            verbose,\n        )"
    },
    {
        "file": "preprocessing.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Preprocessing for ML algorithms on graph."
        ],
        "doc": [
            "Return iterator over neighbours for the given node ID, optionally including given node ID.",
            "",
            "This method is meant to be used to predict node labels using the NoLaN model.",
            "",
            "If you need to predict the node label of a node, not during training,",
            "use `max_neighbours=None`.",
            "",
            "# Arguments",
            "",
            "* `central_node_id`: NodeT - The node ID to retrieve neighbours for.",
            "* `random_state`: u64 - The random state to use to extract the neighbours.",
            "* `include_central_node`: bool - Whether to include the node ID in the returned iterator.",
            "* `offset`: NodeT - Offset for padding porposes.",
            "* `max_neighbours`: Option<NodeT> - Number of maximum neighbours to consider.",
            ""
        ],
        "modifiers": "pub(crate)",
        "name": "get_neighbours_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "central_node_id",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "include_central_node",
                "bool"
            ],
            [
                "offset",
                "NodeT"
            ],
            [
                "max_neighbours",
                "Option<NodeT>"
            ]
        ],
        "return_type": "impl Iterator<Item = NodeT> + '_",
        "body": "(if include_central_node {\n            vec![central_node_id]\n        } else {\n            vec![]\n        })\n        .into_iter()\n        .chain(\n            self.get_unchecked_destination_node_ids_from_node_id(\n                central_node_id,\n                random_state,\n                max_neighbours,\n            )\n            .into_iter(),\n        )\n        .map(move |node_id| node_id + offset)"
    },
    {
        "file": "preprocessing.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Preprocessing for ML algorithms on graph."
        ],
        "doc": [
            "Return tuple with iterator over neighbours for the given node ID, optionally including given node ID, and node type.",
            "",
            "This method is meant to be used to predict node labels using the NoLaN model.",
            "",
            "If you need to predict the node label of a node, not during training,",
            "use `max_neighbours=None`.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - The node ID to retrieve neighbours for.",
            "* `random_state`: u64 - The random state to use to extract the neighbours.",
            "* `include_central_node`: bool - Whether to include the node ID in the returned iterator.",
            "* `offset`: NodeT - Offset for padding porposes.",
            "* `max_neighbours`: Option<NodeT> - Number of maximum neighbours to consider.",
            ""
        ],
        "modifiers": "pub(crate)",
        "name": "get_node_label_prediction_tuple_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "include_central_node",
                "bool"
            ],
            [
                "offset",
                "NodeT"
            ],
            [
                "max_neighbours",
                "Option<NodeT>"
            ]
        ],
        "return_type": "(impl Iterator<Item = NodeT> + '_, Option<Vec<NodeTypeT>>)",
        "body": "(\n            self.get_neighbours_from_node_id(\n                node_id,\n                random_state,\n                include_central_node,\n                offset,\n                max_neighbours,\n            ),\n            self.get_unchecked_node_type_id_from_node_id(node_id),\n        )"
    },
    {
        "file": "preprocessing.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Preprocessing for ML algorithms on graph."
        ],
        "doc": [
            "Return iterator over neighbours for the given node IDs, optionally including given the node IDs, and node type.",
            "",
            "This method is meant to be used to predict node labels using the NoLaN model.",
            "",
            "If you need to predict the node label of a node, not during training,",
            "use `max_neighbours=None`.",
            "",
            "# Arguments",
            "",
            "* `node_ids`: Vec<NodeT> - The node ID to retrieve neighbours for.",
            "* `random_state`: u64 - The random state to use to extract the neighbours.",
            "* `include_central_node`: bool - Whether to include the node ID in the returned iterator.",
            "* `offset`: NodeT - Offset for padding porposes.",
            "* `max_neighbours`: Option<NodeT> - Number of maximum neighbours to consider.",
            "",
            "# Example",
            "Suppose you want to the get the neighbours of the first 10 nodes:",
            "```rust",
            "# use rayon::iter::ParallelIterator;",
            "# use graph::NodeT;",
            "# use rayon::iter::IndexedParallelIterator;",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, false, false, false).unwrap();",
            "let node_ids = (0..10).collect::<Vec<NodeT>>();",
            "let include_central_nodes = true;",
            "let offset = 0;",
            "let max_neighbours = 5;",
            "let iterator = graph.get_node_label_prediction_tuple_from_node_ids(",
            "node_ids.clone(), 42, include_central_nodes, offset, Some(max_neighbours)",
            ").unwrap();",
            "iterator.enumerate().for_each(|(i, (neighbours_iter, labels))|{",
            "for (j, node_id) in neighbours_iter.enumerate(){",
            "if j==0 && include_central_nodes{",
            "assert!(node_id==node_ids[i]);",
            "}",
            "assert!(",
            "max_neighbours + include_central_nodes as NodeT > j as NodeT,",
            "\"The index {} is higher than the given maximum neighbours number {}!\",",
            "j,",
            "max_neighbours",
            ");",
            "}",
            "});",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "get_node_label_prediction_tuple_from_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_ids",
                "Vec<NodeT>"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "include_central_node",
                "bool"
            ],
            [
                "offset",
                "NodeT"
            ],
            [
                "max_neighbours",
                "Option<NodeT>"
            ]
        ],
        "return_type": "Result<\n        impl Iterator<Item = (impl Iterator<Item = NodeT> + '_, Option<Vec<NodeTypeT>>)> + '_,\n        String,\n    >",
        "body": "self.must_have_node_types()?;\n        Ok(node_ids.into_iter().map(move |node_id| {\n            self.get_node_label_prediction_tuple_from_node_id(\n                node_id,\n                random_state,\n                include_central_node,\n                offset,\n                max_neighbours,\n            )\n        }))"
    },
    {
        "file": "preprocessing.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Preprocessing for ML algorithms on graph."
        ],
        "doc": [
            "Returns triple with the degrees of source nodes, destination nodes and labels for training model for link prediction.",
            "This method is just for setting the lowerbound on the simplest possible model.",
            "",
            "# Arguments",
            "",
            "* `idx`: u64 - The index of the batch to generate, behaves like a random random_state,",
            "* `batch_size`: usize - The maximal size of the batch to generate,",
            "* `normalize`: bool - Divide the degrees by the max, this way the values are in [0, 1],",
            "* `negative_samples`: f64 - The component of netagetive samples to use,",
            "* `avoid_false_negatives`: bool - Whether to remove the false negatives when generated. It should be left to false, as it has very limited impact on the training, but enabling this will slow things down.",
            "* `maximal_sampling_attempts`: usize - Number of attempts to execute to sample the negative edges.",
            "* `graph_to_avoid`: &'a Option<&Graph> - The graph whose edges are to be avoided during the generation of false negatives,",
            ""
        ],
        "modifiers": "pub",
        "name": "link_prediction_degrees",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "idx",
                "u64"
            ],
            [
                "batch_size",
                "usize"
            ],
            [
                "normalize",
                "bool"
            ],
            [
                "negative_samples",
                "f64"
            ],
            [
                "avoid_false_negatives",
                "bool"
            ],
            [
                "maximal_sampling_attempts",
                "usize"
            ],
            [
                "graph_to_avoid",
                "&'a Option<&Graph>"
            ]
        ],
        "return_type": "Result<impl ParallelIterator<Item = (usize, f64, f64, bool)> + 'a, String>",
        "body": "let iter = self.link_prediction_ids(\n            idx,\n            batch_size,\n            negative_samples,\n            avoid_false_negatives,\n            maximal_sampling_attempts,\n            graph_to_avoid,\n        )?;\n\n        let max_degree = match normalize {\n            true => self.get_max_node_degree()? as f64,\n            false => 1.0,\n        };\n\n        Ok(iter.map(move |(index, src, dst, label)| {\n            (\n                index,\n                self.get_unchecked_node_degree_from_node_id(src) as f64 / max_degree,\n                self.get_unchecked_node_degree_from_node_id(dst) as f64 / max_degree,\n                label,\n            )\n        }))"
    },
    {
        "file": "preprocessing.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Preprocessing for ML algorithms on graph."
        ],
        "doc": [
            "Returns triple with the ids of source nodes, destination nodes and labels for training model for link prediction.",
            "",
            "# Arguments",
            "",
            "* `idx`: u64 - The index of the batch to generate, behaves like a random random_state,",
            "* `batch_size`: usize - The maximal size of the batch to generate,",
            "* `negative_samples`: f64 - The component of netagetive samples to use,",
            "* `avoid_false_negatives`: bool - Whether to remove the false negatives when generated. It should be left to false, as it has very limited impact on the training, but enabling this will slow things down.",
            "* `maximal_sampling_attempts`: usize - Number of attempts to execute to sample the negative edges.",
            "* `graph_to_avoid`: &'a Option<&Graph> - The graph whose edges are to be avoided during the generation of false negatives,",
            ""
        ],
        "modifiers": "pub",
        "name": "link_prediction_ids",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "idx",
                "u64"
            ],
            [
                "batch_size",
                "usize"
            ],
            [
                "negative_samples",
                "f64"
            ],
            [
                "avoid_false_negatives",
                "bool"
            ],
            [
                "maximal_sampling_attempts",
                "usize"
            ],
            [
                "graph_to_avoid",
                "&'a Option<&Graph>"
            ]
        ],
        "return_type": "Result<impl ParallelIterator<Item = (usize, NodeT, NodeT, bool)> + 'a, String>",
        "body": "// xor the random_state with a constant so that we have a good amount of 0s and 1s in the number\n        // even with low values (this is needed becasue the random_state 0 make xorshift return always 0)\n        let random_state = idx ^ SEED_XOR as u64;\n\n        if negative_samples < 0.0 || !negative_samples.is_finite() {\n            return Err(\"Negative sample must be a posive real value.\".to_string());\n        }\n\n        // The number of negatives is given by computing their fraction of batchsize\n        let negative_number: usize =\n            ((batch_size as f64 / (1.0 + negative_samples)) * negative_samples) as usize;\n        // All the remaining values then are positives\n        let positive_number: usize = batch_size - negative_number;\n        let graph_has_no_selfloops = !self.has_selfloops();\n\n        let edges_number = self.get_directed_edges_number() as u64;\n        let nodes_number = self.get_nodes_number() as u32;\n\n        let mut rng: StdRng = SeedableRng::seed_from_u64(random_state);\n        let random_values = gen_random_vec(batch_size, random_state);\n        let mut indices: Vec<usize> = (0..batch_size).collect();\n        indices.shuffle(&mut rng);\n\n        Ok((0..batch_size)\n            .into_par_iter()\n            .map(move |i| {\n                let mut sampled = random_values[i];\n                if i < positive_number{\n                    let (src, dst) = self.get_unchecked_node_ids_from_edge_id(sampled % edges_number);\n                    (indices[i], src, dst, true)\n                } else {\n                    for _ in 0..maximal_sampling_attempts {\n                        // split the random u64 into 2 u32 and mod them to have\n                        // usable nodes (this is slightly biased towards low values)\n                        let src = fast_u32_modulo((sampled & 0xffffffff) as u32, nodes_number);\n                        let dst = fast_u32_modulo((sampled >> 32) as u32, nodes_number);\n\n                        if avoid_false_negatives && self.has_edge_from_node_ids(src, dst) {\n                            sampled = xorshift(sampled);\n                            continue;\n                        }\n\n                        if let Some(g) = &graph_to_avoid {\n                            if g.has_edge_from_node_ids(src, dst)  {\n                                sampled = xorshift(sampled);\n                                continue;\n                            }\n                        }\n\n                        if graph_has_no_selfloops && src == dst {\n                            sampled = xorshift(sampled);\n                            continue;\n                        }\n\n                        return (indices[i], src, dst, false);\n                    }\n                    panic!(\n                        concat!(\n                            \"Executed more than {} attempts to sample a negative edge.\\n\",\n                            \"If your graph is so small that you see this error, you may want to consider \",\n                            \"using one of the edge embedding transformer from the Embiggen library.\"\n                        ),\n                        maximal_sampling_attempts\n                    );\n                }\n            }))"
    },
    {
        "file": "utils.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "get_loading_bar",
        "args": [
            [
                "verbose",
                "bool"
            ],
            [
                "desc",
                "&str"
            ],
            [
                "total_iterations",
                "usize"
            ]
        ],
        "return_type": "ProgressBar",
        "body": "if verbose {\n        let pb = ProgressBar::new(total_iterations as u64);\n        pb.set_draw_delta(total_iterations as u64 / 100);\n        pb.set_style(ProgressStyle::default_bar().template(&format!(\n            \"{desc} {{spinner:.green}} [{{elapsed_precise}}] [{{bar:40.cyan/blue}}] ({{pos}}/{{len}}, ETA {{eta}})\",\n            desc=desc\n        )));\n        pb\n    } else {\n        ProgressBar::hidden()\n    }"
    },
    {
        "file": "utils.rs",
        "doc": [
            "Return true if the given weight is near to one."
        ],
        "modifiers": "pub(crate)",
        "name": "not_one",
        "args": [
            [
                "weight",
                "WeightT"
            ]
        ],
        "return_type": "bool",
        "body": "(weight - 1.0).abs() > WeightT::EPSILON"
    },
    {
        "file": "utils.rs",
        "struct": "Graph",
        "doc": [
            "Return vector of edges to be inserted in the holdout."
        ],
        "modifiers": "pub(crate)",
        "name": "compute_edge_ids_vector",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "include_all_edge_types",
                "bool"
            ]
        ],
        "return_type": "Vec<EdgeT>",
        "body": "if include_all_edge_types {\n            let (min_edge_id, max_edge_id) =\n                self.get_unchecked_minmax_edge_ids_from_node_ids(src, dst);\n            (min_edge_id..max_edge_id).collect::<Vec<EdgeT>>()\n        } else {\n            vec![edge_id]\n        }"
    },
    {
        "file": "utils.rs",
        "doc": [
            "Return validated weight.",
            "",
            "A weight, to be valid in the context of graph machine learning",
            "as we have defined, must be strictly positive and non infinite.",
            "",
            "# Arguments",
            "",
            "* `weight`: WeightT - The weight to validate.",
            "",
            "# Example",
            "The weight can be validated as follows:",
            "```rust",
            "# use graph::utils::validate_weight;",
            "assert!(validate_weight(0.0).is_err());",
            "assert!(validate_weight(-1.0).is_err());",
            "assert!(validate_weight(2.0).is_ok());",
            "assert_eq!(validate_weight(2.0).unwrap(), 2.0);",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "validate_weight",
        "args": [
            [
                "weight",
                "WeightT"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "if weight.is_finite() && weight > 0.0 {\n        Ok(weight)\n    } else {\n        Err(format!(\n            \"The weight is '{}' but the weights must be strictly positives and finite.\",\n            weight\n        ))\n    }"
    },
    {
        "file": "utils.rs",
        "doc": [
            "Return given weight parsed from string to float.",
            "",
            "# Arguments",
            "",
            "* `weight`: String - The weight to be parsed.",
            "",
            "# Example",
            "The weight can be validated as follows:",
            "```rust",
            "# use graph::utils::parse_weight;",
            "assert!(parse_weight(\"0.0\".to_string()).is_ok());",
            "assert!(parse_weight(\"-1.0\".to_string()).is_ok());",
            "assert!(parse_weight(\"2.0\".to_string()).is_ok());",
            "assert!(parse_weight(\"2ghgjh.0\".to_string()).is_err());",
            "assert_eq!(parse_weight(\"2.0\".to_string()).unwrap(), 2.0);",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "parse_weight",
        "args": [
            [
                "weight",
                "String"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "match weight.parse::<WeightT>() {\n        Ok(val) => Ok(val),\n        Err(_) => Err(format!(\"Cannot parse weight {} as a float.\", weight)),\n    }"
    },
    {
        "file": "csv_file_reader.rs",
        "struct": "CSVFileReader",
        "impl_doc": [
            "Structure that saves the common parameters for reading csv files.",
            "# Builder methods"
        ],
        "doc": [
            "Return new CSVFileReader object.",
            "",
            "# Arguments",
            "",
            "* path: String - Path where to store/load the file.",
            "* list_name: String - Name of the list that is being loaded.",
            ""
        ],
        "modifiers": "pub",
        "name": "new",
        "generics": "S: Into<String>",
        "args": [
            [
                "path",
                "S"
            ],
            [
                "list_name",
                "String"
            ]
        ],
        "return_type": "Result<CSVFileReader, String>",
        "body": "let path = path.into();\n        // check file existance\n        match File::open(&path) {\n            Ok(_) => Ok(CSVFileReader {\n                path,\n                verbose: true,\n                separator: \"\\t\".to_string(),\n                header: true,\n                rows_to_skip: 0,\n                ignore_duplicates: true,\n                csv_is_correct: false,\n                max_rows_number: None,\n                comment_symbol: None,\n                list_name,\n                graph_name: \"Graph\".to_string(),\n            }),\n            Err(_) => Err(format!(\"Cannot open the file at {}\", path)),\n        }"
    },
    {
        "file": "csv_file_reader.rs",
        "struct": "CSVFileReader",
        "impl_doc": [
            "Structure that saves the common parameters for reading csv files.",
            "# Builder methods"
        ],
        "doc": [
            "Read the whole file and return how many rows it has."
        ],
        "modifiers": "pub(crate)",
        "name": "count_rows",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "usize",
        "body": "std::cmp::min(\n            BufReader::new(File::open(&self.path).unwrap())\n                .lines()\n                .count(),\n            self.max_rows_number.unwrap_or(u64::MAX) as usize,\n        )"
    },
    {
        "file": "csv_file_reader.rs",
        "struct": "CSVFileReader",
        "impl_doc": [
            "Structure that saves the common parameters for reading csv files.",
            "# Builder methods"
        ],
        "doc": [
            "Return list of components of the header."
        ],
        "modifiers": "pub",
        "name": "get_header",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<Vec<String>, String>",
        "body": "if let Some(first_line) = self.get_lines_iterator(false)?.next() {\n            Ok(first_line?\n                .split(&self.separator)\n                .map(|s| s.to_string())\n                .collect::<Vec<String>>())\n        } else {\n            Err(\"The given file has no lines!\".to_string())\n        }"
    },
    {
        "file": "csv_file_reader.rs",
        "struct": "CSVFileReader",
        "impl_doc": [
            "Structure that saves the common parameters for reading csv files.",
            "# Builder methods"
        ],
        "doc": [],
        "modifiers": "pub",
        "name": "get_lines_iterator",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "skip_header",
                "bool"
            ]
        ],
        "return_type": "Result<impl Iterator<Item = Result<String, String>> + '_, String>",
        "body": "let rows_to_skip = match skip_header {\n            true => match (self.rows_to_skip as u64).checked_add(self.header as u64) {\n                Some(v) => Ok(v),\n                None => Err(concat!(\n                    \"This overflow was caused because rows to skip = 2**64 - 1\",\n                    \"and header is setted to true which causes to skip one extra line.\",\n                    \"Do you **really** want to skip 18446744073709551615 lines? Bad person. Bad.\"\n                )),\n            }?,\n            false => self.rows_to_skip as u64,\n        } as usize;\n        Ok(BufReader::new(File::open(&self.path).unwrap())\n            .lines()\n            .map(|line| match line {\n                Ok(l)=>Ok(l),\n                Err(_)=>Err(\"There might have been an I/O error or the line could contains bytes that are not valid UTF-8\".to_string()),\n            })\n            .filter_ok(move |line| !line.is_empty() && match &self.comment_symbol {\n                Some(cs) => !line.starts_with(cs),\n                _ => true,\n            })\n            .skip(rows_to_skip))"
    },
    {
        "file": "csv_file_reader.rs",
        "struct": "CSVFileReader",
        "impl_doc": [
            "Structure that saves the common parameters for reading csv files.",
            "# Builder methods"
        ],
        "doc": [
            "Return elements of the first line not to be skipped."
        ],
        "modifiers": "pub",
        "name": "get_elements_per_line",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<usize, String>",
        "body": "let first_line = self.get_lines_iterator(true)?.next();\n        match first_line {\n            Some(fl) => {\n                match fl {\n                    Ok(f) => {\n                        Ok(f.matches(&self.separator).count() + 1)\n                    },\n                    Err(_) => Err(\"There might have been an I/O error or the line could contains bytes that are not valid UTF-8\".to_string())\n                }\n            },\n            None => Err(concat!(\n                \"Unable to read the first non skipped line of the file.\\n\",\n                \"The file has possibly less than the expected amount of lines\"\n            ).to_string())\n        }"
    },
    {
        "file": "csv_file_reader.rs",
        "struct": "CSVFileReader",
        "impl_doc": [
            "Structure that saves the common parameters for reading csv files.",
            "# Builder methods"
        ],
        "doc": [
            "Return iterator that read a CSV file rows."
        ],
        "modifiers": "pub(crate)",
        "name": "read_lines",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<impl Iterator<Item = Result<Vec<Option<String>>, String>> + '_, String>",
        "body": "let pb = get_loading_bar(\n            self.verbose,\n            format!(\"Reading {}'s {}\", self.graph_name, self.list_name).as_ref(),\n            if self.verbose { self.count_rows() } else { 0 },\n        );\n\n        let number_of_elements_per_line = self.get_elements_per_line()?;\n        Ok(self\n            .get_lines_iterator(true)?\n            .progress_with(pb)\n            // skip empty lines\n            .take(self.max_rows_number.unwrap_or(u64::MAX) as usize)\n            // Handling NaN values and padding them to the number of rows\n            .map_ok(move |line| {\n                let mut elements: Vec<Option<String>> = line\n                    .split(&self.separator)\n                    .map(|element| match element.is_empty() {\n                        true => None,\n                        false => Some(element.to_string()),\n                    })\n                    .collect();\n                elements.resize(number_of_elements_per_line, None);\n                elements\n            }))"
    },
    {
        "file": "csv_file_reader.rs",
        "struct": "CSVFileReader",
        "impl_doc": [
            "Structure that saves the common parameters for reading csv files.",
            "# Builder methods"
        ],
        "doc": [
            "Return number of the given column in header.",
            "",
            "# Arguments",
            "",
            "* column_name: String - Column to get the number of.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_column_number",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "column_name",
                "String"
            ]
        ],
        "return_type": "Result<usize, String>",
        "body": "let header = self.get_header()?;\n\n        match header.iter().position(|x| *x == column_name) {\n            Some(column_number) => Ok(column_number),\n            None => Err(format!(\n                \"The column '{}' is not present in the header\\n{:?}\",\n                column_name, header\n            )),\n        }"
    },
    {
        "file": "remap.rs",
        "struct": "Graph",
        "doc": [
            "Return whether nodes are remappable to those of the given graph.",
            "",
            "# Arguments",
            "* `other`: &Graph - graph towards remap the nodes to.",
            "",
            "# Example",
            "A graph is always remappable to itself:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(graph.are_nodes_remappable(&graph));",
            "```",
            "Two different graphs, like Cora and STRING, are not remappable:",
            "```rust",
            "# let cora = graph::test_utilities::load_cora().unwrap();",
            "# let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(!cora.are_nodes_remappable(&ppi));",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "are_nodes_remappable",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "other",
                "&Graph"
            ]
        ],
        "return_type": "bool",
        "body": "if self.get_nodes_number() != other.get_nodes_number() {\n            return false;\n        }\n        self.iter_nodes().all(|(_, node_name, _, node_type)| {\n            other.has_node_from_node_name_and_node_type_name(&node_name, node_type)\n        })"
    },
    {
        "file": "remap.rs",
        "struct": "Graph",
        "doc": [
            "Return graph remapped towards nodes of the given graph.",
            "",
            "# Arguments",
            "",
            "* `other`: &Graph - The graph to remap towards.",
            "* `verbose`: bool - Whether to show a loding bar.",
            "",
            "# Example",
            "A graph is always remappable to itself:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert_eq!(graph, graph.remap(&graph, false).unwrap());",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "remap",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "other",
                "&Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "let pb = get_loading_bar(\n            verbose,\n            format!(\"Building remapped {}\", self.name).as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n\n        if !self.are_nodes_remappable(&other) {\n            return Err(\"The two graphs nodes sets are not remappable one-another.\".to_owned());\n        }\n\n        Graph::from_integer_unsorted(\n            self.iter_edge_node_names_and_edge_type_name_and_edge_weight(true)\n                .progress_with(pb)\n                .map(|(_, _, src_name, _, dst_name, _, edge_type, weight)| {\n                    Ok((\n                        other.get_unchecked_node_id_from_node_name(&src_name),\n                        other.get_unchecked_node_id_from_node_name(&dst_name),\n                        edge_type.and_then(|et| {\n                            self.get_unchecked_edge_type_id_from_edge_type_name(et.as_str())\n                        }),\n                        weight,\n                    ))\n                }),\n            other.nodes.clone(),\n            other.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.directed,\n            self.name.clone(),\n            false,\n            self.has_edge_types(),\n            self.has_edge_weights(),\n            verbose,\n            self.has_singletons(),\n            self.has_singletons_with_selfloops(),\n            self.has_trap_nodes(),\n        )"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Return new EdgeFileReader object.",
            "",
            "# Arguments",
            "",
            "* reader: CSVFilereader - Path where to store/load the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "new",
        "generics": "S: Into<String>",
        "args": [
            [
                "path",
                "S"
            ]
        ],
        "return_type": "Result<EdgeFileReader, String>",
        "body": "Ok(EdgeFileReader {\n            reader: CSVFileReader::new(path, \"edge list\".to_owned())?,\n            sources_column_number: 0,\n            destinations_column_number: 1,\n            edge_types_column_number: None,\n            default_edge_type: None,\n            weights_column_number: None,\n            default_weight: None,\n            skip_selfloops: false,\n            numeric_edge_type_ids: false,\n            numeric_node_ids: false,\n            skip_weights_if_unavailable: false,\n            skip_edge_types_if_unavailable: false,\n            might_have_singletons_with_selfloops: true,\n            might_have_trap_nodes: true,\n        })"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column of the source nodes.",
            "",
            "# Arguments",
            "",
            "* sources_column: Option<String> - The source nodes column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_sources_column",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "sources_column",
                "Option<S>"
            ]
        ],
        "return_type": "Result<EdgeFileReader, String>",
        "body": "if let Some(column) = sources_column {\n            let column = column.into();\n            if column.is_empty() {\n                return Err(\"The given node types column is empty.\".to_owned());\n            }\n\n            match self.reader.get_column_number(column) {\n                Ok(ecn) => {\n                    self = self.set_sources_column_number(Some(ecn))?;\n                }\n                Err(e) => {\n                    if !self.skip_edge_types_if_unavailable {\n                        return Err(e);\n                    }\n                }\n            }\n        }\n        Ok(self)"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column_number of the nodes.",
            "",
            "# Arguments",
            "",
            "* sources_column_number: Option<usize> - The sources column number to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_sources_column_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "sources_column_number",
                "Option<usize>"
            ]
        ],
        "return_type": "Result<EdgeFileReader, String>",
        "body": "if let Some(column) = sources_column_number {\n            let expected_elements = self.reader.get_elements_per_line()?;\n            if column >= expected_elements {\n                return Err(format!(\n                    concat!(\n                        \"The source column number passed was {} but \",\n                        \"the first parsable line has {} values.\"\n                    ),\n                    column, expected_elements\n                ));\n            }\n            self.sources_column_number = column;\n        }\n        Ok(self)"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column of the nodes.",
            "",
            "# Arguments",
            "",
            "* destination_column: Option<String> - The node types column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_destinations_column",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "destinations_column",
                "Option<S>"
            ]
        ],
        "return_type": "Result<EdgeFileReader, String>",
        "body": "if let Some(column) = destinations_column {\n            let column = column.into();\n            if column.is_empty() {\n                return Err(\"The given node types column is empty.\".to_owned());\n            }\n            match self.reader.get_column_number(column) {\n                Ok(ecn) => {\n                    self = self.set_destinations_column_number(Some(ecn))?;\n                }\n                Err(e) => {\n                    if !self.skip_edge_types_if_unavailable {\n                        return Err(e);\n                    }\n                }\n            }\n        }\n        Ok(self)"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column_number of the nodes.",
            "",
            "# Arguments",
            "",
            "* destinations_column_number: Option<usize> - The destinations column number to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_destinations_column_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "destinations_column_number",
                "Option<usize>"
            ]
        ],
        "return_type": "Result<EdgeFileReader, String>",
        "body": "if let Some(column) = destinations_column_number {\n            let expected_elements = self.reader.get_elements_per_line()?;\n            if column >= expected_elements {\n                return Err(format!(\n                    concat!(\n                        \"The destinations column number passed was {} but \",\n                        \"the first parsable line has {} values.\"\n                    ),\n                    column, expected_elements\n                ));\n            }\n            self.destinations_column_number = column;\n        }\n        Ok(self)"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column of the nodes.",
            "",
            "# Arguments",
            "",
            "* destination_column: Option<String> - The node types column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_edge_types_column",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "edge_type_column",
                "Option<S>"
            ]
        ],
        "return_type": "Result<EdgeFileReader, String>",
        "body": "if let Some(column) = edge_type_column {\n            let column = column.into();\n            if column.is_empty() {\n                return Err(\"The given node types column is empty.\".to_owned());\n            }\n            match self.reader.get_column_number(column) {\n                Ok(ecn) => {\n                    self = self.set_edge_types_column_number(Some(ecn))?;\n                }\n                Err(e) => {\n                    if !self.skip_edge_types_if_unavailable {\n                        return Err(e);\n                    }\n                }\n            }\n        }\n        Ok(self)"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column_number of the nodes.",
            "",
            "# Arguments",
            "",
            "* edge_types_column_number: Option<usize> - The edge_types column number to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_edge_types_column_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "edge_types_column_number",
                "Option<usize>"
            ]
        ],
        "return_type": "Result<EdgeFileReader, String>",
        "body": "if let Some(etcn) = &edge_types_column_number {\n            let expected_elements = self.reader.get_elements_per_line()?;\n            if *etcn >= expected_elements {\n                if !self.skip_edge_types_if_unavailable {\n                    return Err(format!(\n                        concat!(\n                            \"The edge types column number passed was {} but \",\n                            \"the first parsable line has {} values.\"\n                        ),\n                        etcn, expected_elements\n                    ));\n                }\n            } else {\n                self.edge_types_column_number = edge_types_column_number;\n            }\n        }\n        Ok(self)"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column of the edge weights.",
            "",
            "# Arguments",
            "",
            "* weights_column: Option<String> - The edge weights column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_weights_column",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "weights_column",
                "Option<S>"
            ]
        ],
        "return_type": "Result<EdgeFileReader, String>",
        "body": "if let Some(column) = weights_column {\n            let column = column.into();\n            if column.is_empty() {\n                return Err(\"The given edge weights column is empty.\".to_owned());\n            }\n            match self.reader.get_column_number(column) {\n                Ok(wcn) => {\n                    self = self.set_weights_column_number(Some(wcn))?;\n                }\n                Err(e) => {\n                    if !self.skip_weights_if_unavailable {\n                        return Err(e);\n                    }\n                }\n            }\n        }\n        Ok(self)"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column_number of the nodes.",
            "",
            "# Arguments",
            "",
            "* weights_column_number: Option<usize> - The weights column number to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_weights_column_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "weights_column_number",
                "Option<usize>"
            ]
        ],
        "return_type": "Result<EdgeFileReader, String>",
        "body": "if let Some(wcn) = &weights_column_number {\n            let expected_elements = self.reader.get_elements_per_line()?;\n            if *wcn >= expected_elements {\n                if !self.skip_edge_types_if_unavailable {\n                    return Err(format!(\n                        concat!(\n                            \"The weights column number passed was {} but \",\n                            \"the first parsable line has {} values.\"\n                        ),\n                        wcn, expected_elements\n                    ));\n                }\n            } else {\n                self.weights_column_number = weights_column_number;\n            }\n        }\n        Ok(self)"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set whether to automatically skip weights if they are not avaitable instead of raising an exception.",
            "",
            "# Arguments",
            "",
            "* skip_weights_if_unavailable: Option<bool> - Whether to skip weights if they are not available.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_skip_weights_if_unavailable",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "skip_weights_if_unavailable",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "if let Some(skip) = skip_weights_if_unavailable {\n            self.skip_weights_if_unavailable = skip;\n        }\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set whether to automatically skip edge types if they are not avaitable instead of raising an exception.",
            "",
            "# Arguments",
            "",
            "* skip_edge_types_if_unavailable: Option<bool> - Whether to skip edge types if they are not available.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_skip_edge_types_if_unavailable",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "skip_edge_types_if_unavailable",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "if let Some(skip) = skip_edge_types_if_unavailable {\n            self.skip_edge_types_if_unavailable = skip;\n        }\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the default default_weight.",
            "",
            "# Arguments",
            "",
            "* default_weight: Option<WeightT> - The default_weight to use when default_weight is missing.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_default_weight",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "default_weight",
                "Option<WeightT>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "self.default_weight = default_weight;\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the name of the graph to be loaded.",
            "",
            "# Arguments",
            "",
            "* graph_name: String - The name of the graph to be loaded.",
            ""
        ],
        "modifiers": "pub(crate)",
        "name": "set_graph_name",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "graph_name",
                "String"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "self.reader.graph_name = graph_name;\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the default edge type.",
            "",
            "# Arguments",
            "",
            "* default_edge_type: Option<String> - The edge type to use when edge type is missing.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_default_edge_type",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "default_edge_type",
                "Option<S>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "self.default_edge_type = default_edge_type.map(|val| val.into());\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set whether should ignore or not selfloops.",
            "",
            "# Arguments",
            "",
            "* `skip_selfloops`: Option<bool> - Whether should ignore or not selfloops.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_skip_selfloops",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "skip_selfloops",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "if let Some(ssl) = skip_selfloops {\n            self.skip_selfloops = ssl;\n            self.might_have_singletons_with_selfloops = !ssl;\n        }\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set whether the CSV is expected to be well written.",
            "",
            "# Arguments",
            "",
            "* csv_is_correct: Option<bool> - Whether you pinky swear the edge list is correct.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_csv_is_correct",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "csv_is_correct",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "if let Some(cic) = csv_is_correct {\n            self.reader.csv_is_correct = cic;\n        }\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the comment symbol to use to skip the lines.",
            "",
            "# Arguments",
            "",
            "* comment_symbol: Option<String> - if the reader should ignore or not duplicated edges.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_comment_symbol",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "comment_symbol",
                "Option<String>"
            ]
        ],
        "return_type": "Result<EdgeFileReader, String>",
        "body": "if let Some(cs) = comment_symbol {\n            if cs.is_empty() {\n                return Err(\"The given comment symbol is empty.\".to_string());\n            }\n            self.reader.comment_symbol = Some(cs);\n        }\n        Ok(self)"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the verbose.",
            "",
            "# Arguments",
            "",
            "* `verbose`: Option<bool> - Whether to show the loading bar or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_verbose",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "verbose",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "if let Some(v) = verbose {\n            self.reader.verbose = v;\n        }\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set whether you pinky promise that this graph has singletons with self-loops or not.",
            "",
            "# Arguments",
            "",
            "* `might_have_singletons_with_selfloops`: Option<bool> - Whether this graph has singletons with self-loops.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_might_have_singletons_with_selfloops",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "might_have_singletons_with_selfloops",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "if let Some(skip) = might_have_singletons_with_selfloops {\n            self.might_have_singletons_with_selfloops = !self.skip_selfloops && skip;\n        }\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set whether you pinky promise that this graph has trap nodes or not.",
            "",
            "# Arguments",
            "",
            "* `might_have_trap_nodes`: Option<bool> - Whether this graph has trap nodes with self-loops.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_might_have_trap_nodes",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "might_have_trap_nodes",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "if let Some(skip) = might_have_trap_nodes {\n            self.might_have_trap_nodes = skip;\n        }\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "",
            "* numeric_id: Option<bool> - Whether to convert numeric Ids to Node Id.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_numeric_edge_type_ids",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "numeric_edge_type_ids",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "if let Some(neti) = numeric_edge_type_ids {\n            self.numeric_edge_type_ids = neti;\n        }\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the numeric_id.",
            "",
            "# Arguments",
            "",
            "* numeric_id: Option<bool> - Whether to convert numeric Ids to Node Id.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_numeric_node_ids",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "numeric_node_ids",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "if let Some(nni) = numeric_node_ids {\n            self.numeric_node_ids = nni;\n        }\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the ignore_duplicates.",
            "",
            "# Arguments",
            "",
            "* ignore_duplicates: Option<bool> - Whether to ignore detected duplicates or raise exception.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_ignore_duplicates",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "ignore_duplicates",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "if let Some(v) = ignore_duplicates {\n            self.reader.ignore_duplicates = v;\n        }\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the separator.",
            "",
            "# Arguments",
            "",
            "* separator: Option<String> - The separator to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_separator",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "separator",
                "Option<S>"
            ]
        ],
        "return_type": "Result<EdgeFileReader, String>",
        "body": "if let Some(sep) = separator {\n            let sep = sep.into();\n            if sep.is_empty() {\n                return Err(\"The separator cannot be empty.\".to_owned());\n            }\n            self.reader.separator = sep;\n        }\n        Ok(self)"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the header.",
            "",
            "# Arguments",
            "",
            "* header: Option<bool> - Whether to expect an header or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_header",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "header",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "if let Some(v) = header {\n            self.reader.header = v;\n        }\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set number of rows to be skipped when starting to read file.",
            "",
            "# Arguments",
            "",
            "* rows_to_skip: Option<bool> - Whether to show the loading bar or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_rows_to_skip",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "rows_to_skip",
                "Option<usize>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "if let Some(v) = rows_to_skip {\n            self.reader.rows_to_skip = v;\n        }\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the maximum number of rows to load from the file",
            "",
            "# Arguments",
            "",
            "* max_rows_number: Option<u64> - The edge type to use when edge type is missing.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_max_rows_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "max_rows_number",
                "Option<u64>"
            ]
        ],
        "return_type": "EdgeFileReader",
        "body": "self.reader.max_rows_number = max_rows_number;\n        self"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Return boolean representing if the edge types exist."
        ],
        "modifiers": "pub",
        "name": "has_edge_types",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.default_edge_type.is_some() || self.edge_types_column_number.is_some()"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Return boolean representing if the weight types exist."
        ],
        "modifiers": "pub",
        "name": "has_edge_weights",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.default_weight.is_some() || self.weights_column_number.is_some()"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Parse a single line (vecotr of strings already splitted)",
            "# Arguments",
            "",
            "* vals: Vec<String> - Vector of the values of the line to be parsed"
        ],
        "modifiers": "",
        "name": "parse_edge_line",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "vals",
                "Vec<Option<String>>"
            ]
        ],
        "return_type": "Result<StringQuadruple, String>",
        "body": "// extract the values\n        let maybe_source_node_name = vals[self.sources_column_number].clone();\n        let maybe_destination_node_name = vals[self.destinations_column_number].clone();\n        if maybe_source_node_name.is_none() || maybe_destination_node_name.is_none() {\n            return Err(\"Either the source or destination node ID are undefined.\".to_string());\n        }\n\n        let source_node_name = maybe_source_node_name.unwrap();\n        let destination_node_name = maybe_destination_node_name.unwrap();\n\n        // Handle the extraction of the edge types.\n        let maybe_edge_types_string = match self.edge_types_column_number {\n            Some(column) => match vals[column].to_owned() {\n                Some(edge_type) => Some(edge_type),\n                None => self.default_edge_type.clone(),\n            },\n            None => self.default_edge_type.clone(),\n        };\n\n        // Handle the extraction of the weights.\n        let maybe_weight_string = match self.weights_column_number {\n            Some(column) => match vals[column].to_owned() {\n                Some(w) => Some(parse_weight(w)?),\n                None => self.default_weight,\n            },\n            None => self.default_weight,\n        };\n\n        Ok((\n            source_node_name,\n            destination_node_name,\n            maybe_edge_types_string,\n            maybe_weight_string,\n        ))"
    },
    {
        "file": "edge_file_reader.rs",
        "struct": "EdgeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Return iterator of rows of the edge file."
        ],
        "modifiers": "pub",
        "name": "read_lines",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<impl Iterator<Item = Result<StringQuadruple, String>> + '_, String>",
        "body": "if self.destinations_column_number == self.sources_column_number {\n            return Err(\"The destinations column is the same as the sources one.\".to_string());\n        }\n        if Some(self.destinations_column_number) == self.weights_column_number {\n            return Err(\"The destinations column is the same as the weights one.\".to_string());\n        }\n        if Some(self.sources_column_number) == self.weights_column_number {\n            return Err(\"The sources column is the same as the weights one.\".to_string());\n        }\n        if Some(self.sources_column_number) == self.edge_types_column_number {\n            return Err(\"The sources column is the same as the edge types one.\".to_string());\n        }\n        if Some(self.destinations_column_number) == self.edge_types_column_number {\n            return Err(\"The destinations column is the same as the edge types one.\".to_string());\n        }\n        if self.weights_column_number.is_some()\n            && self.weights_column_number == self.edge_types_column_number\n        {\n            return Err(\"The weights column is the same as the edge types one.\".to_string());\n        }\n\n        let expected_elements = self.reader.get_elements_per_line()?;\n        if self.sources_column_number >= expected_elements {\n            return Err(format!(\n                concat!(\n                    \"The sources column number passed was {} but \",\n                    \"the first parsable line has {} values.\"\n                ),\n                self.sources_column_number, expected_elements\n            ));\n        }\n        if self.destinations_column_number >= expected_elements {\n            return Err(format!(\n                concat!(\n                    \"The destinations column number passed was {} but \",\n                    \"the first parsable line has {} values.\"\n                ),\n                self.destinations_column_number, expected_elements\n            ));\n        }\n        Ok(self\n            .reader\n            .read_lines()?\n            .map(move |values| match values {\n                Ok(vals) => self.parse_edge_line(vals),\n                Err(e) => Err(e),\n            })\n            .filter_ok(move |(source_node_name, destination_node_name, _, _)| {\n                !self.skip_selfloops || source_node_name != destination_node_name\n            }))"
    },
    {
        "file": "queries_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Boolean Queries",
            "The naming convention for unchecked methods follows:",
            "* `is_(.+?)_from_(.+)`",
            "* `has_(.+?)_from_(.+)`",
            "* `is_unchecked_(.+?)_from_(.+)`",
            "* `has_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns boolean representing if given node is a singleton.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - The node to be checked for."
        ],
        "modifiers": "pub",
        "name": "is_unchecked_singleton_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "bool",
        "body": "self.not_singleton_nodes\n            .as_ref()\n            .map_or(true, |nsns| !nsns[node_id as usize])"
    },
    {
        "file": "queries_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Boolean Queries",
            "The naming convention for unchecked methods follows:",
            "* `is_(.+?)_from_(.+)`",
            "* `has_(.+?)_from_(.+)`",
            "* `is_unchecked_(.+?)_from_(.+)`",
            "* `has_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns boolean representing if given node is a singleton.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - The node to be checked for."
        ],
        "modifiers": "pub",
        "name": "is_singleton_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<bool, String>",
        "body": "self.validate_node_id(node_id)\n            .map(|node_id| self.is_unchecked_singleton_from_node_id(node_id))"
    },
    {
        "file": "queries_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Boolean Queries",
            "The naming convention for unchecked methods follows:",
            "* `is_(.+?)_from_(.+)`",
            "* `has_(.+?)_from_(.+)`",
            "* `is_unchecked_(.+?)_from_(.+)`",
            "* `has_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns boolean representing if given node is a singleton with self-loops.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - The node to be checked for."
        ],
        "modifiers": "pub",
        "name": "is_singleton_with_selfloops_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "bool",
        "body": "self.singleton_nodes_with_selfloops\n            .as_ref()\n            .map_or(false, |snsls| snsls.contains(node_id))"
    },
    {
        "file": "queries_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Boolean Queries",
            "The naming convention for unchecked methods follows:",
            "* `is_(.+?)_from_(.+)`",
            "* `has_(.+?)_from_(.+)`",
            "* `is_unchecked_(.+?)_from_(.+)`",
            "* `has_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns boolean representing if given node is a singleton.",
            "",
            "# Arguments",
            "* `node_name`: &str - The node name to be checked for."
        ],
        "modifiers": "pub",
        "name": "is_singleton_from_node_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "Result<bool, String>",
        "body": "Ok(self.is_unchecked_singleton_from_node_id(self.get_node_id_from_node_name(node_name)?))"
    },
    {
        "file": "queries_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Boolean Queries",
            "The naming convention for unchecked methods follows:",
            "* `is_(.+?)_from_(.+)`",
            "* `has_(.+?)_from_(.+)`",
            "* `is_unchecked_(.+?)_from_(.+)`",
            "* `has_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns whether the graph has the given node name.",
            "",
            "# Arguments",
            "",
            "* `node_name`: &str - Name of the node.",
            "",
            "# Example",
            "To check if a node appears in the graph you can use:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let node_name = \"ENSP00000000233\";",
            "let unexistent_node_name = \"I_do_not_exist!\";",
            "assert!(graph.has_node_from_node_name(node_name));",
            "assert!(!graph.has_node_from_node_name(unexistent_node_name));",
            "```"
        ],
        "modifiers": "pub",
        "name": "has_node_from_node_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_node_id_from_node_name(node_name).is_ok()"
    },
    {
        "file": "queries_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Boolean Queries",
            "The naming convention for unchecked methods follows:",
            "* `is_(.+?)_from_(.+)`",
            "* `has_(.+?)_from_(.+)`",
            "* `is_unchecked_(.+?)_from_(.+)`",
            "* `has_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns whether edge passing between given node ids exists.",
            "",
            "# Arguments",
            "",
            "* `src`: NodeT - Source node id.",
            "* `dst`: NodeT - Destination node id.",
            "",
            "# Example",
            "To check if an edge appears in the graph you can use:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "assert!(graph.has_edge_from_node_ids(0, 1));",
            "assert!(!graph.has_edge_from_node_ids(0, 4565));",
            "```"
        ],
        "modifiers": "pub",
        "name": "has_edge_from_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_edge_id_from_node_ids(src, dst).is_ok()"
    },
    {
        "file": "queries_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Boolean Queries",
            "The naming convention for unchecked methods follows:",
            "* `is_(.+?)_from_(.+)`",
            "* `has_(.+?)_from_(.+)`",
            "* `is_unchecked_(.+?)_from_(.+)`",
            "* `has_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns whether edge with the given type passing between given nodes exists.",
            "",
            "# Arguments",
            "",
            "* `src`: NodeT - The source node of the edge.",
            "* `dst`: NodeT - The destination node of the edge.",
            "* `edge_type`: Option<EdgeTypeT> - The (optional) edge type.",
            "",
            "# Example",
            "To check if an edge with given type appears in the graph you can use:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "assert!(graph.has_edge_from_node_ids_and_edge_type_id(0, 1, Some(0)));",
            "assert!(!graph.has_edge_from_node_ids_and_edge_type_id(0, 1, Some(1)));",
            "```"
        ],
        "modifiers": "pub",
        "name": "has_edge_from_node_ids_and_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "edge_type",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_edge_id_from_node_ids_and_edge_type_id(src, dst, edge_type)\n            .is_ok()"
    },
    {
        "file": "queries_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Boolean Queries",
            "The naming convention for unchecked methods follows:",
            "* `is_(.+?)_from_(.+)`",
            "* `has_(.+?)_from_(.+)`",
            "* `is_unchecked_(.+?)_from_(.+)`",
            "* `has_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns boolean representing if given node is a trap.",
            "",
            "If the provided node_id is higher than the number of nodes in the graph,",
            "the method will panic.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - Integer ID of the node, if this is bigger that the number of nodes it will panic.",
            ""
        ],
        "modifiers": "pub",
        "name": "is_unchecked_trap_node_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_unchecked_node_degree_from_node_id(node_id) == 0\n            && self\n                .not_singleton_nodes\n                .as_ref()\n                .map_or(true, |nsns| nsns[node_id as usize])"
    },
    {
        "file": "queries_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Boolean Queries",
            "The naming convention for unchecked methods follows:",
            "* `is_(.+?)_from_(.+)`",
            "* `has_(.+?)_from_(.+)`",
            "* `is_unchecked_(.+?)_from_(.+)`",
            "* `has_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns boolean representing if given node is a trap.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - Integer ID of the node, if this is bigger that the number of nodes it will panic.",
            ""
        ],
        "modifiers": "pub",
        "name": "is_trap_node_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<bool, String>",
        "body": "self.validate_node_id(node_id)\n            .map(|node_id| self.is_unchecked_trap_node_from_node_id(node_id))"
    },
    {
        "file": "queries_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Boolean Queries",
            "The naming convention for unchecked methods follows:",
            "* `is_(.+?)_from_(.+)`",
            "* `has_(.+?)_from_(.+)`",
            "* `is_unchecked_(.+?)_from_(.+)`",
            "* `has_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns whether the given node name and node type name exist in current graph.",
            "",
            "# Arguments",
            "",
            "* `node_name`: &str - The node name.",
            "* `node_type_name`: Option<Vec<String>> - The node types name.",
            ""
        ],
        "modifiers": "pub",
        "name": "has_node_from_node_name_and_node_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_name",
                "&str"
            ],
            [
                "node_type_name",
                "Option<Vec<String>>"
            ]
        ],
        "return_type": "bool",
        "body": "match self.get_node_id_from_node_name(node_name) {\n            Err(_) => false,\n            Ok(node_id) => {\n                let our_node_types = self.get_node_type_name_from_node_id(node_id);\n                match (our_node_types, node_type_name) {\n                    (Err(_), None) => true,\n                    (Ok(None), None) => true,\n                    (Ok(Some(mut our_nts)), Some(mut other_nts)) => {\n                        our_nts.sort();\n                        other_nts.sort();\n                        our_nts == other_nts\n                    }\n                    _ => false,\n                }\n            }\n        }"
    },
    {
        "file": "queries_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Boolean Queries",
            "The naming convention for unchecked methods follows:",
            "* `is_(.+?)_from_(.+)`",
            "* `has_(.+?)_from_(.+)`",
            "* `is_unchecked_(.+?)_from_(.+)`",
            "* `has_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns whether if edge passing between given nodes exists.",
            "",
            "# Arguments",
            "",
            "* `src_name`: &str - The source node name of the edge.",
            "* `dst_name`: &str - The destination node name of the edge.",
            "",
            "# Example",
            "To check if an edge in the graph you can use:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "assert!(graph.has_edge_from_node_names(\"ENSP00000000233\", \"ENSP00000432568\"));",
            "assert!(!graph.has_edge_from_node_names(\"ENSP00000000233\", \"NonExistent\"));",
            "```"
        ],
        "modifiers": "pub",
        "name": "has_edge_from_node_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src_name",
                "&str"
            ],
            [
                "dst_name",
                "&str"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_edge_id_from_node_names(src_name, dst_name).is_ok()"
    },
    {
        "file": "queries_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Boolean Queries",
            "The naming convention for unchecked methods follows:",
            "* `is_(.+?)_from_(.+)`",
            "* `has_(.+?)_from_(.+)`",
            "* `is_unchecked_(.+?)_from_(.+)`",
            "* `has_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns whether if edge with type passing between given nodes exists.",
            "",
            "# Arguments",
            "",
            "* `src_name`: &str - The source node name of the edge.",
            "* `dst_name`: &str - The destination node name of the edge.",
            "* `edge_type_name`: Option<&String> - The (optional) edge type name.",
            "",
            "# Example",
            "To check if an edge with type in the graph you can use:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "let edge_type = \"red\".to_string();",
            "let unexistent_edge_type = \"NonExistent\".to_string();",
            "assert!(graph.has_edge_from_node_names_and_edge_type_name(\"ENSP00000000233\", \"ENSP00000432568\", Some(&edge_type)));",
            "assert!(!graph.has_edge_from_node_names_and_edge_type_name(\"ENSP00000000233\", \"ENSP00000432568\", Some(&unexistent_edge_type)));",
            "assert!(!graph.has_edge_from_node_names_and_edge_type_name(\"ENSP00000000233\", \"NonExistent\", Some(&edge_type)));",
            "assert!(!graph.has_edge_from_node_names_and_edge_type_name(\"ENSP00000000233\", \"NonExistent\", Some(&unexistent_edge_type)));",
            "```"
        ],
        "modifiers": "pub",
        "name": "has_edge_from_node_names_and_edge_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src_name",
                "&str"
            ],
            [
                "dst_name",
                "&str"
            ],
            [
                "edge_type_name",
                "Option<&String>"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_edge_id_from_node_names_and_edge_type_name(src_name, dst_name, edge_type_name)\n            .is_ok()"
    },
    {
        "file": "bitmaps.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Drop.",
            "The naming convention we follow is:",
            "* `.*bitmap.*`"
        ],
        "doc": [
            "Return a roaringbitmap with the node ids to keep.",
            "",
            "If both node\\_names and node\\_types are specified the result will be the",
            "union of both queries.",
            "",
            "# Arguments",
            "* `node_names` - The nodes to keep as strings",
            "* `node_types` - The nodes types to keep as strings",
            ""
        ],
        "modifiers": "pub(crate)",
        "name": "get_filter_bitmap",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_names",
                "Option<Vec<String>>"
            ],
            [
                "node_types",
                "Option<Vec<Option<String>>>"
            ]
        ],
        "return_type": "Result<Option<RoaringBitmap>, String>",
        "body": "let mut node_ids = RoaringBitmap::new();\n\n        if let Some(ns) = node_names {\n            node_ids.extend(\n                ns.iter()\n                    .map(|node_name| self.get_node_id_from_node_name(node_name))\n                    .collect::<Result<Vec<NodeT>, String>>()?,\n            );\n        }\n\n        if let Some(ndt) = node_types {\n            let node_type_ids = self.get_node_type_ids_from_node_type_names(ndt)?;\n            node_ids.extend(\n                self.iter_node_ids_and_node_type_ids()\n                    .filter_map(|(node_id, nts)| {\n                        if nts.map_or_else(\n                            //DEFAULT\n                            || node_type_ids.contains(&None),\n                            // If some\n                            |ns| {\n                                ns.into_iter().any(|node_type_name| {\n                                    node_type_ids.contains(&Some(node_type_name))\n                                })\n                            },\n                        ) {\n                            Some(node_id)\n                        } else {\n                            None\n                        }\n                    }),\n            );\n        }\n\n        Ok(optionify!(node_ids))"
    },
    {
        "file": "test_utilities.rs",
        "doc": [
            "Computes a random string of the chosen length"
        ],
        "modifiers": "pub",
        "name": "random_string",
        "args": [
            [
                "len",
                "usize"
            ]
        ],
        "return_type": "String",
        "body": "let mut rng = rand::thread_rng();\n\n    (0..len)\n        .map(|_| {\n            let idx = rng.gen_range(0, CHARSET.len());\n            CHARSET[idx] as char\n        })\n        .collect()"
    },
    {
        "file": "test_utilities.rs",
        "doc": [
            "Computes a random path."
        ],
        "modifiers": "pub",
        "name": "random_path",
        "args": [
            [
                "path",
                "Option<&str>"
            ]
        ],
        "return_type": "String",
        "body": "Path::new(path.unwrap_or(DEFAULT_PATH))\n        .join(random_string(64))\n        .to_str()\n        .unwrap()\n        .to_string()"
    },
    {
        "file": "test_utilities.rs",
        "doc": [
            "Load the Strings Protein Protein Interaction graph with given parametrization.",
            "This is our default graph we use on tests."
        ],
        "modifiers": "pub",
        "name": "load_ppi",
        "args": [
            [
                "load_nodes",
                "bool"
            ],
            [
                "load_edge_types",
                "bool"
            ],
            [
                "load_weights",
                "bool"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "verbose",
                "bool"
            ],
            [
                "skip_selfloops",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "let graph_name = \"STRING PPI\".to_owned();\n    let nodes_reader = if load_nodes {\n        Some(\n            NodeFileReader::new(\"tests/data/ppi/nodes.tsv\".to_string())?\n                .set_verbose(Some(false))\n                .set_node_types_column_number(Some(1))\n                .set_nodes_column_number(Some(0))\n                .set_node_types_column(Some(\"category\".to_string()))?\n                .set_default_node_type(Some(\"default\".to_string()))\n                .set_nodes_column(Some(\"id\".to_string()))?\n                .set_ignore_duplicates(Some(true))\n                .set_separator(Some(\"\\t\"))\n                .unwrap()\n                .set_header(Some(true))\n                .set_max_rows_number(Some(100000))\n                .set_rows_to_skip(Some(0))\n                .clone(),\n        )\n    } else {\n        None\n    };\n    let edges_reader = EdgeFileReader::new(\"tests/data/ppi/edges.tsv\".to_string())?\n        .set_verbose(Some(verbose))\n        .set_ignore_duplicates(Some(true))\n        .set_separator(Some(\"\\t\"))\n        .unwrap()\n        .set_header(Some(true))\n        .set_rows_to_skip(Some(0))\n        .set_sources_column(Some(\"subject\".to_string()))?\n        .set_destinations_column(Some(\"object\".to_string()))?\n        .set_weights_column(if load_weights {\n            Some(\"weight\".to_string())\n        } else {\n            None\n        })?\n        .set_edge_types_column(if load_edge_types {\n            Some(\"edge_label\".to_string())\n        } else {\n            None\n        })?\n        .set_default_edge_type(if load_edge_types {\n            Some(\"Kebab\".to_string())\n        } else {\n            None\n        })\n        .set_max_rows_number(Some(100000))\n        .set_default_weight(if load_weights { Some(5.0) } else { None })\n        .set_skip_selfloops(Some(skip_selfloops))\n        .clone();\n\n    let ppi = Graph::from_unsorted_csv(\n        edges_reader,\n        nodes_reader,\n        directed,\n        false,\n        graph_name.clone(),\n    );\n    assert!(\n        ppi.is_ok(),\n        \"We expect to be able to load the String PPI graph.\"\n    );\n    let ppi = ppi?;\n    assert_eq!(ppi.has_node_types(), load_nodes);\n    assert_eq!(ppi.has_edge_types(), load_edge_types,);\n    assert_eq!(ppi.has_edge_weights(), load_weights);\n    assert_eq!(\n        ppi.has_selfloops(),\n        !skip_selfloops,\n        concat!(\n            \"I was expecting the graph self-loops status to be {} \",\n            \"since we have given parameter skip_selfloops equal to {}, \",\n            \"but actually is {}.\\n\",\n            \"The graph report is: \\n {:?}\"\n        ),\n        !skip_selfloops,\n        skip_selfloops,\n        ppi.has_selfloops(),\n        ppi.textual_report(false)\n    );\n    Ok(ppi)"
    },
    {
        "file": "test_utilities.rs",
        "doc": [
            "Load an empty graph instance"
        ],
        "modifiers": "pub",
        "name": "load_empty_graph",
        "args": [
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Graph",
        "body": "Graph::build_graph(\n        std::iter::empty(),\n        0,\n        Vocabulary::default(),\n        None,\n        None,\n        directed,\n        false,\n        \"Empty graph\",\n        false,\n        false,\n        false,\n        false,\n        false,\n        false,\n    )\n    .unwrap()"
    },
    {
        "file": "test_utilities.rs",
        "doc": [
            "This is our default graph we use on tests with node types."
        ],
        "modifiers": "pub",
        "name": "load_cora",
        "args": [],
        "return_type": "Result<Graph, String>",
        "body": "let graph_name = \"Cora\".to_owned();\n    let edges_reader = EdgeFileReader::new(\"tests/data/cora/edges.tsv\")?\n        .set_separator(Some(\"\\t\"))?\n        .set_verbose(Some(false))\n        .set_sources_column(Some(\"subject\"))?\n        .set_destinations_column(Some(\"object\"))?\n        .set_edge_types_column(Some(\"edge_type\"))?;\n    let nodes_reader = Some(\n        NodeFileReader::new(\"tests/data/cora/nodes.tsv\")?\n            .set_separator(Some(\"\\t\"))?\n            .set_nodes_column(Some(\"id\"))?\n            .set_verbose(Some(false))\n            .set_node_types_column(Some(\"node_type\"))?,\n    );\n    let cora =\n        Graph::from_unsorted_csv(edges_reader, nodes_reader, false, false, graph_name.clone())?;\n    Ok(cora)"
    },
    {
        "file": "test_utilities.rs",
        "doc": [
            "Return WalksParameters to execute a first order walk."
        ],
        "modifiers": "pub",
        "name": "first_order_walker",
        "args": [
            [
                "graph",
                "&Graph"
            ]
        ],
        "return_type": "Result<WalksParameters, String>",
        "body": "Ok(WalksParameters::new(8)?\n        .set_iterations(Some(1))?\n        .set_random_state(Some(43))\n        .set_dense_node_mapping(Some(graph.get_dense_nodes_mapping())))"
    },
    {
        "file": "test_utilities.rs",
        "doc": [
            "Return WalksParameters to execute a second order walk."
        ],
        "modifiers": "pub",
        "name": "second_order_walker",
        "args": [
            [
                "graph",
                "&Graph"
            ],
            [
                "return_weight",
                "WeightT"
            ],
            [
                "explore_weight",
                "WeightT"
            ]
        ],
        "return_type": "Result<WalksParameters, String>",
        "body": "Ok(WalksParameters::new(8)?\n        .set_iterations(Some(1))?\n        .set_return_weight(Some(return_weight))?\n        .set_explore_weight(Some(explore_weight))?\n        .set_max_neighbours(Some(3))?\n        .set_change_edge_type_weight(Some(2.0))?\n        .set_change_node_type_weight(Some(2.0))?\n        .set_dense_node_mapping(Some(graph.get_dense_nodes_mapping()))\n        .set_random_state(Some(43)))"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "",
        "name": "validate_vocabularies",
        "args": [
            [
                "graph",
                "&Graph"
            ]
        ],
        "body": "if let Some(ets) = &graph.edge_types {\n        assert_eq!(!ets.ids.is_empty(), graph.has_edge_types());\n    }\n\n    if let Some(nts) = &graph.node_types {\n        assert_eq!(!nts.ids.is_empty(), graph.has_node_types());\n    }\n\n    if let Some(ws) = &graph.weights {\n        assert_eq!(\n            !ws.is_empty(), graph.has_edge_weights(),\n            concat!(\n                \"We expect the edge weights vector to NOT be empty if the graph says it has weights.\\n\",\n                \"The graph report is:\\n{:?}\"\n            ),\n            graph.textual_report(false)\n        );\n    }"
    },
    {
        "file": "test_utilities.rs",
        "doc": [
            "Executes the default test suite for holdouts."
        ],
        "modifiers": "pub",
        "name": "default_holdout_test_suite",
        "args": [
            [
                "graph",
                "&Graph"
            ],
            [
                "train",
                "&Graph"
            ],
            [
                "test",
                "&Graph"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "for g in &[graph, train, test] {\n        validate_vocabularies(g);\n    }\n    assert!(\n        !train.overlaps(&test)?,\n        \"Training graph overlaps with test graph!\"\n    );\n    assert!(\n        !test.overlaps(&train)?,\n        \"Test graph overlaps with training graph!\"\n    );\n    assert!(graph.contains(&train)?, \"Graph does not training graph.\");\n    assert!(graph.contains(&test)?, \"Graph does not contain test graph.\");\n    let summed = (train | test)?;\n    validate_vocabularies(&summed);\n    assert!(\n        summed.contains(&graph)?,\n        \"Composed train and test graph do not contained original graph.\"\n    );\n    let subtracted = (graph - test)?;\n    validate_vocabularies(&subtracted);\n    assert!(\n        subtracted.contains(&train)?,\n        \"Main graph subtracted test does not contain training graph.\"\n    );\n    assert!(\n        !subtracted.overlaps(&test)?,\n        \"Main graph subtracted train does not contain test graph.\"\n    );\n    let xorred = (graph ^ test)?;\n    validate_vocabularies(&xorred);\n    assert!(\n        xorred.contains(&train)?,\n        \"Main graph xorred test does not contain training graph.\"\n    );\n    assert!(\n        !xorred.overlaps(&test)?,\n        \"Main graph xorred train does not contain testing graph.\"\n    );\n    let anded = (graph & test)?;\n    validate_vocabularies(&anded);\n    assert!(\n        anded.contains(&test)?,\n        \"Main graph anded test does not contain training graph.\"\n    );\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [
            "Test that the spanning arborescence algorithm from bader is working correctly."
        ],
        "modifiers": "pub",
        "name": "test_spanning_arborescence_bader",
        "args": [
            [
                "graph",
                "&Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "body": "let kruskal_tree = graph.spanning_arborescence_kruskal(verbose).0;\n    let random_kruskal_tree = graph\n        .random_spanning_arborescence_kruskal(42, &None, verbose)\n        .0;\n    if !graph.directed {\n        let spanning_arborescence_bader: Vec<(NodeT, NodeT)> =\n            graph.spanning_arborescence(verbose).unwrap().1.collect();\n        assert_eq!(\n            spanning_arborescence_bader.len(), kruskal_tree.len(),\n            \"The number of extracted edges forming the spanning arborescence computed by the bader's algorithm does not match the one computed by kruskal. The graph report is:\\n{:?}\\nThe bader's tree is:\\n{:?}\\nThe kruskal's tree is:\\n{:?}\",\n            graph.textual_report(false), spanning_arborescence_bader, kruskal_tree,\n        );\n    } else {\n        assert!(graph.spanning_arborescence(verbose).is_err());\n    }\n    assert_eq!(random_kruskal_tree.len() as usize, kruskal_tree.len());"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_graph_properties",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "// Testing that vocabularies are properly loaded\n    validate_vocabularies(graph);\n\n    // Test get_edge_id_from_node_names_and_edge_type_name()\n    assert!(\n        graph\n            .get_edge_id_from_node_names_and_edge_type_name(NONEXISTENT, NONEXISTENT, None)\n            .is_err(),\n        \"Graph contains non-existing edge.\"\n    );\n\n    // Test has_node_from_name\n    assert!(\n        !(graph.has_node_from_node_name_and_node_type_name(NONEXISTENT, None)),\n        \"The graph seems to have a non-existing node.\"\n    );\n    assert!(\n        !(graph.has_node_from_node_name(NONEXISTENT)),\n        \"The graph seems to have a non-existing node.\"\n    );\n\n    // Test translate_edge|node_types()\n    assert!(\n        graph\n            .get_edge_type_ids_from_edge_type_names(vec![Some(NONEXISTENT.to_string())])\n            .is_err(),\n        \"The graph seems to have a non-existing edge type.\"\n    );\n\n    assert!(\n        graph\n            .get_node_type_ids_from_node_type_names(vec![Some(NONEXISTENT.to_string())])\n            .is_err(),\n        \"The graph seems to have a non-existing node type.\"\n    );\n\n    assert_eq!(\n        graph.get_not_singleton_nodes_number() + graph.get_singleton_nodes_number(),\n        graph.get_nodes_number(),\n        \"Sum of singleton and non singleton nodes number does not match.\"\n    );\n\n    warn!(\"Running connected components tests.\");\n    let (_components_number, smallest, biggest) = graph.get_connected_components_number(false);\n    assert!(\n        biggest >= smallest,\n        \"smallest: {} biggest: {}\",\n        smallest,\n        biggest\n    );\n\n    if smallest == 1 {\n        assert!(\n            graph.has_singletons() || graph.has_singletons_with_selfloops(),\n            \"When the smallest component is one the graph must have singletons! Graph report: \\n{:?}\",\n            graph.textual_report(false)\n        );\n    }\n\n    if smallest == 0 {\n        assert!(\n            !graph.has_nodes(),\n            \"When the smallest component is zero the graph must be empty! Graph report: \\n{:?}\",\n            graph.textual_report(false)\n        );\n    }\n\n    // Get one edge from the graph if there are any presents\n    if let Some(edge) = graph.iter_unique_edge_node_ids(true).next() {\n        let src_string = graph.get_unchecked_node_name_from_node_id(edge.0);\n        let dst_string = graph.get_unchecked_node_name_from_node_id(edge.1);\n        let edge_id = graph.get_edge_id_from_node_names(&src_string, &dst_string)?;\n        if graph.has_edge_types() {\n            let edge_type = graph.get_edge_type_name_from_edge_id(edge_id)?;\n            assert!(\n                graph.has_edge_from_node_names_and_edge_type_name(&src_string, &dst_string, edge_type.as_ref()),\n                \"I was expecting for the edge ({}, {}, {:?}) to exist, but it seems to not exist in graph {:?}\",\n                src_string,\n                dst_string,\n                edge_type,\n                graph.textual_report(false)\n            );\n        } else {\n            assert!(\n                graph.has_edge_from_node_names(&src_string, &dst_string),\n                \"I was expecting for the edge ({}, {}) without type to exist, but it seems to not exist in graph {:?}\",\n                src_string,\n                dst_string,\n                graph.textual_report(false)\n            );\n        }\n        assert!(\n            graph.has_node_from_node_name(&src_string)\n                && graph.has_node_from_node_name(&dst_string)\n        );\n        if graph.has_node_types() {\n            assert!(\n                graph.has_node_from_node_name_and_node_type_name(\n                    &src_string,\n                    graph.get_node_type_name_from_node_name(&src_string)?\n                ) && graph.has_node_from_node_name_and_node_type_name(\n                    &dst_string,\n                    graph.get_node_type_name_from_node_name(&dst_string)?\n                ),\n                concat!(\n                    \"The nodes {:?} and {:?} with node types are not present in the graph.\\n\",\n                    \"The node types are {:?} and {:?}.\\n\",\n                    \"The first node existance is {}\\n\",\n                    \"The second node existance is {}\\n\",\n                    \"The graph report is {:?}\"\n                ),\n                src_string,\n                dst_string,\n                graph.get_node_type_name_from_node_name(&src_string),\n                graph.get_node_type_name_from_node_name(&dst_string),\n                graph.has_node_from_node_name_and_node_type_name(\n                    &src_string,\n                    graph.get_node_type_name_from_node_name(&src_string)?\n                ),\n                graph.has_node_from_node_name_and_node_type_name(\n                    &dst_string,\n                    graph.get_node_type_name_from_node_name(&dst_string)?\n                ),\n                graph.textual_report(false)\n            );\n        }\n        assert_eq!(\n            graph.get_edge_id_from_node_names(&src_string, &dst_string)?,\n            graph.get_edge_id_from_node_ids(edge.0, edge.1).unwrap(),\n            \"Check of given edge ID does not match.\"\n        );\n    }\n\n    // Test the generation of the textual report, this includes the connected components algorithm.\n    graph.report();\n    graph.textual_report(verbose)?;\n\n    // Compute degrees metrics\n    for src in 0..5 {\n        for dst in 0..5 {\n            let _ = graph.degrees_product(src, dst);\n            let _ = graph.jaccard_index(src, dst);\n            let _ = graph.adamic_adar_index(src, dst);\n            let _ = graph.resource_allocation_index(src, dst);\n        }\n    }\n\n    assert_eq!(\n        graph.has_node_types(),\n        graph.get_node_type_id_from_node_id(0).is_ok()\n    );\n\n    assert!(\n        graph.get_node_type_id_from_node_id(graph.get_nodes_number() + 1).is_err(),\n        \"Given graph does not raise an exception when a node's node type greater than the number of available nodes is requested.\"\n    );\n\n    assert_eq!(\n        graph.has_edge_types(),\n        graph.get_edge_type_id_from_edge_id(0).is_ok()\n    );\n\n    assert!(\n        graph.get_edge_type_id_from_edge_id(graph.get_directed_edges_number() + 1).is_err(),\n        \"Given graph does not raise an exception when a edge's edge type greater than the number of available edges is requested.\"\n    );\n\n    // Evaluate get_node_type\n    assert_eq!(\n        graph.get_node_type_id_from_node_id(0).is_ok(),\n        graph.has_node_types()\n    );\n\n    // Evaluate get_edge_type\n    assert_eq!(\n        graph.get_edge_type_id_from_edge_id(0).is_ok(),\n        graph.has_edge_types()\n    );\n\n    // Evaluate get_node_type_counts\n    assert_eq!(graph.get_node_type_counter().is_ok(), graph.has_node_types());\n\n    // Evaluate get_edge_type_counts\n    assert_eq!(graph.get_edge_type_counter().is_ok(), graph.has_edge_types());\n\n    // Evaluate get_edge_type_counts_hashmap\n    assert_eq!(\n        graph.get_edge_type_counts_hashmap().is_ok(),\n        graph.has_edge_types()\n    );\n\n    graph.set_name(graph.get_name());\n    graph.strongly_connected_components();\n\n    // Checking that the connected components are a dense range.\n    let (_, connected_components, total_connected_components, _, _) =\n        graph.random_spanning_arborescence_kruskal(42, &None, verbose);\n    let actual_components_number = connected_components.iter().unique().count() as NodeT;\n    assert_eq!(\n        actual_components_number,\n        total_connected_components,\n        \"The measured number of connected components ({}) does not match the computed number of connected components ({}).\",\n        actual_components_number,\n        total_connected_components\n    );\n    let max_component_id = connected_components.iter().max();\n    if let Some(mci) = max_component_id {\n        assert_eq!(\n            *mci as usize,\n            total_connected_components as usize - 1,\n            \"We expected the connected components to be a dense set.\\n The obtained components are: \\n{:?}\\n The graph report is:\\n{:?}\",\n            connected_components,\n            graph.textual_report(false)\n        );\n    }\n    if !graph.is_directed() {\n        // Checking that the connected components are a dense range.\n        let (connected_components, total_connected_components, _, _) =\n            graph.connected_components(verbose)?;\n        let actual_components_number = connected_components.iter().unique().count() as NodeT;\n        assert_eq!(\n            actual_components_number,\n            total_connected_components,\n            \"The measured number of connected components ({}) does not match the computed number of connected components ({}).\",\n            actual_components_number,\n            total_connected_components\n        );\n        let max_component_id = connected_components.iter().max();\n        if let Some(mci) = max_component_id {\n            assert_eq!(\n                *mci as usize,\n                total_connected_components as usize - 1,\n                \"We expected the connected components to be a dense set.\\n The obtained components are: \\n{:?}\\n The graph report is:\\n{:?}\",\n                connected_components,\n                graph.textual_report(false)\n            );\n        }\n    }\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_random_walks",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "_verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "// Testing principal random walk algorithms\n    let walker = first_order_walker(&graph)?;\n    assert_eq!(walker.clone(), walker);\n    let walker2 = second_order_walker(&graph, 2.0, 2.0)?;\n    assert_eq!(walker2.clone(), walker2);\n\n    if !graph.directed {\n        warn!(\"Executing random walks tests.\");\n        for mode in 0..3 {\n            if mode == 1 {\n                graph.enable(false, true, true, None)?;\n                if let Some(cumulative_node_degrees) = &graph.cumulative_node_degrees {\n                    assert_eq!(\n                        cumulative_node_degrees.len(),\n                        graph.get_nodes_number() as usize,\n                        \"Length of cumulative_node_degrees does not match number of nodes in the graph.\"\n                    );\n                }\n                if let Some(destinations) = &graph.destinations {\n                    assert_eq!(\n                        destinations.len(),\n                        graph.get_directed_edges_number() as usize,\n                        \"Length of destinations does not match number of edges in the graph.\"\n                    );\n                }\n            }\n            if mode == 2 {\n                graph.enable(false, false, false, Some(0.05))?;\n                assert!(\n                    graph.cached_destinations.is_some(),\n                    \"Cached destinations are not None when cache is enabled.\"\n                );\n            }\n            assert_eq!(\n                graph\n                    .iter_random_walks(1, &walker)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                graph\n                    .iter_random_walks(1, &walker)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                \"Walks of first order are not reproducible!\"\n            );\n\n            assert_eq!(\n                graph\n                    .iter_random_walks(1, &second_order_walker(&graph, 2.0, 2.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                graph\n                    .iter_random_walks(1, &second_order_walker(&graph, 2.0, 2.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                \"Walks of second order are not reproducible!\"\n            );\n\n            assert_eq!(\n                graph\n                    .iter_complete_walks(&walker)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                graph\n                    .iter_complete_walks(&walker)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                \"Complete first order walks are not reproducible!\"\n            );\n\n            assert_eq!(\n                graph\n                    .iter_complete_walks(&second_order_walker(&graph, 2.0, 2.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                graph\n                    .iter_complete_walks(&second_order_walker(&graph, 2.0, 2.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                \"Complete second order walks are not reproducible!\"\n            );\n\n            assert_eq!(\n                graph\n                    .iter_complete_walks(&second_order_walker(&graph, 2.0, 1.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                graph\n                    .iter_complete_walks(&second_order_walker(&graph, 2.0, 1.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                \"Complete second order walks are not reproducible!\"\n            );\n\n            assert_eq!(\n                graph\n                    .iter_complete_walks(&second_order_walker(&graph, 1.0, 2.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                graph\n                    .iter_complete_walks(&second_order_walker(&graph, 1.0, 2.0)?)\n                    .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),\n                \"Complete second order walks are not reproducible!\"\n            );\n        }\n    } else {\n        assert!(graph.iter_complete_walks(&walker).is_err());\n    }\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_edge_holdouts",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "for include_all_edge_types in &[false, true] {\n        let (train, test) =\n            graph.random_holdout(4, 0.6, *include_all_edge_types, None, None, verbose)?;\n        default_holdout_test_suite(graph, &train, &test)?;\n        let (train, test) =\n            graph.connected_holdout(4, 0.8, None, *include_all_edge_types, verbose)?;\n        let (total, min_comp, max_comp) = graph.get_connected_components_number(verbose);\n        assert_eq!(\n            graph.get_connected_components_number(verbose),\n            train.get_connected_components_number(verbose),\n            \"The number of components of the original graph and the connected training set does not match. Particularly, the number of nodes in the graph is {nodes_number}.\",\n            nodes_number=graph.get_nodes_number().to_string()\n        );\n        if total == 1 {\n            assert_eq!(\n                min_comp,\n                graph.get_nodes_number(),\n                concat!(\n                    \"We expect for the minimum size of connected components \",\n                    \"in a graph with a single connected component to \",\n                    \"match the number of nodes of the graph, but we got \",\n                    \"the minimum component with size {} and the number \",\n                    \"of nodes in the graph equal to {}.\\n\",\n                    \"The graph report is: \\n {:?}\",\n                ),\n                min_comp,\n                graph.get_nodes_number(),\n                graph.textual_report(false)\n            );\n            assert_eq!(max_comp, graph.get_nodes_number());\n            assert_eq!(min_comp, test.get_nodes_number());\n            assert_eq!(max_comp, test.get_nodes_number());\n        }\n        if total == 2 {\n            assert_eq!(\n                max_comp + min_comp, graph.get_nodes_number(),\n                \"We expected that the number of the minimum component ({}) plus the maximum component ({}), when the components are two, made up the graph nodes ({}).\\nThe graph report is:\\n {:?}\",\n                min_comp, max_comp, graph.get_nodes_number(),\n                graph.textual_report(false)\n            );\n            assert_eq!(max_comp + min_comp, test.get_nodes_number());\n        }\n        default_holdout_test_suite(graph, &train, &test)?;\n    }\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_remove_components",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "if graph.get_connected_components_number(verbose).0 > 1 {\n        let without_selfloops = graph.remove(\n            None, None, None, None, None, None, None, None, false, false, false, false, true,\n            verbose,\n        )?;\n\n        assert_eq!(\n            graph.get_connected_components_number(verbose),\n            without_selfloops.get_connected_components_number(verbose),\n            concat!(\n                \"We expected the graph to have the same components once we remove the selfloops.\\n\",\n                \"The report of the original graph is {:?}\\n\",\n                \"The report of the filtered graph is {:?}\\n\",\n            ),\n            graph.textual_report(false),\n            without_selfloops.textual_report(false),\n        );\n\n        let single_component = graph.remove_components(None, None, None, None, Some(1), verbose);\n        assert!(\n            single_component.is_ok(),\n            concat!(\n                \"Removing all the components except the first one returned an error.\\n\",\n                \"The error is:\\n{:?}\\nand the graph report is:\\n{:?}\"\n            ),\n            single_component,\n            graph.textual_report(false)\n        );\n        let single_component_number = single_component\n            .unwrap()\n            .get_connected_components_number(verbose)\n            .0;\n        assert_eq!(\n            single_component_number,\n            1,\n            concat!(\n                \"Removing all the components except the first one returned a graph \",\n                \"with {} components, which is not one.\\nThe report of the graph is:{:?}\\n\"\n            ),\n            single_component_number,\n            graph.textual_report(false)\n        );\n\n        let test = graph.remove_components(\n            Some(vec![graph.nodes.unchecked_translate(0)]),\n            None,\n            None,\n            None,\n            None,\n            verbose,\n        )?;\n        let no_selfloops = test.remove(\n            None, None, None, None, None, None, None, None, false, false, false, false, true,\n            verbose,\n        )?;\n        assert_eq!(\n            no_selfloops.get_connected_components_number(verbose).0,\n            1,\n            concat!(\n                \"Expected number of components (1) is not matched!\\n\",\n                \"The report of the original graph is {:?}\\n\",\n                \"The report of the graph with only one component is {:?}\\n\",\n                \"The report of the graph without selfloops is {:?}\\n\",\n            ),\n            graph.textual_report(false),\n            test.textual_report(false),\n            no_selfloops.textual_report(false)\n        );\n        if let Ok(node_type_name) = graph.get_node_type_name_from_node_type_id(0) {\n            assert!(graph\n                .remove_components(\n                    None,\n                    Some(vec![Some(node_type_name)]),\n                    None,\n                    None,\n                    None,\n                    verbose\n                )\n                .is_ok());\n        }\n        if graph.has_unknown_node_types() {\n            let without_unknowns =\n                graph.remove_components(None, Some(vec![None]), None, None, None, verbose);\n            assert!(\n                without_unknowns.is_ok(),\n                \"Could not remove components without node type None.\\nThe error is {:?}\\nThe graph report is {:?}\",\n                without_unknowns, graph.textual_report(false)\n            );\n        }\n        if let Ok(edge_type_name) = graph.get_edge_type_name_from_edge_type_id(0) {\n            assert!(graph\n                .remove_components(\n                    None,\n                    None,\n                    Some(vec![Some(edge_type_name)]),\n                    None,\n                    None,\n                    verbose\n                )\n                .is_ok());\n        }\n        if graph.has_unknown_edge_types() {\n            assert!(graph\n                .remove_components(None, None, Some(vec![None]), None, None, verbose)\n                .is_ok());\n        }\n    } else {\n        assert!(\n            graph\n                .remove_components(None, None, None, None, None, verbose)\n                .is_ok(),\n            \"We expect it to be possible, now, to create empty graphs.\"\n        );\n    }\n\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_kfold",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "_verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "let k = 3;\n    for i in 0..k {\n        let (train, test) = graph.kfold(k, i, None, 42, false)?;\n        assert!(\n            test.get_edges_number() <= (graph.get_edges_number() / k) + 1,\n            concat!(\n                \"Check that test kfolds respect size bound has failed!\\n\",\n                \"The value of k is {}.\\n\",\n                \"The report of the original graph is:\\n{:?}\\n\",\n                \"The report of the train graph is:\\n{:?}\\n\",\n                \"The report of the test graph is:\\n{:?}\\n\",\n                \"We expect that the test graph has at most {} edges but it has {}.\\n\",\n                \"The holdout index is {}.\\n\",\n            ),\n            k,\n            graph.textual_report(false),\n            train.textual_report(false),\n            test.textual_report(false),\n            (graph.get_edges_number() / k) + 1,\n            test.get_edges_number(),\n            i\n        );\n        default_holdout_test_suite(graph, &train, &test)?;\n    }\n\n    if let Ok(edge_t) = graph.get_edge_type_name_from_edge_type_id(0) {\n        for i in 0..k {\n            let (train, test) = graph.kfold(k, i, Some(vec![Some(edge_t.clone())]), 1337, false)?;\n            default_holdout_test_suite(graph, &train, &test)?;\n        }\n    }\n\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_negative_edges_generation",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "for only_from_same_component in &[true, false] {\n        let negatives = graph.sample_negatives(\n            4,\n            graph.get_edges_number(),\n            None,\n            *only_from_same_component,\n            verbose,\n        )?;\n        assert_eq!(\n            graph.get_edges_number(),\n            negatives.get_edges_number(),\n            \"We expect the graph and its negative graph to have the same number of edges but we got {} and {}.\",\n            graph.get_edges_number(),\n            negatives.get_edges_number()\n        );\n        validate_vocabularies(&negatives);\n        if !graph.has_edge_types() {\n            assert!(!graph.overlaps(&negatives)?);\n            assert!(!negatives.overlaps(&graph)?);\n        }\n        // Testing holdouts executed on negative edges.\n        let (neg_train, neg_test) =\n            negatives.random_holdout(32, 0.8, false, None, None, verbose)?;\n\n        neg_test.get_trap_nodes_number();\n\n        default_holdout_test_suite(&negatives, &neg_train, &neg_test)?;\n    }\n\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_subgraph_generation",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "let expected_nodes = graph.get_not_singleton_nodes_number() / 10;\n    let subgraph = graph.random_subgraph(6, expected_nodes, verbose)?;\n    assert!(subgraph.overlaps(&graph)?);\n    assert!(subgraph.get_not_singleton_nodes_number() <= expected_nodes + 1);\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_dump_graph",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "let node_file = random_path(None);\n    let nodes_writer = NodeFileWriter::new(node_file.clone())\n        .set_verbose(Some(verbose))\n        .set_separator(Some(\"\\t\"))\n        .set_header(Some(true))\n        .set_node_types_column_number(Some(4))\n        .set_nodes_column_number(Some(6))\n        .set_node_types_column(Some(\"node_types\"))\n        .set_nodes_column(Some(\"node_column\".to_string()));\n    nodes_writer.dump(&graph)?;\n    fs::remove_file(node_file).unwrap();\n\n    let edges_file = random_path(None);\n    let edges_writer = EdgeFileWriter::new(edges_file.clone())\n        .set_verbose(Some(verbose))\n        .set_separator(Some(\"\\t\"))\n        .set_header(Some(true))\n        .set_edge_types_column(Some(\"edge_types\"))\n        .set_destinations_column_number(Some(3))\n        .set_weights_column(Some(\"weight\".to_string()))\n        .set_weights_column_number(Some(2))\n        .set_sources_column(Some(\"The land of sushi\".to_string()))\n        .set_sources_column_number(Some(0))\n        .set_destinations_column(Some(\"The land of pizza\".to_string()))\n        .set_destinations_column_number(Some(1));\n\n    edges_writer.dump(&graph)?;\n    fs::remove_file(edges_file).unwrap();\n\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_embiggen_preprocessing",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "let walker = first_order_walker(&graph)?;\n    if !graph.directed {\n        let (terms_number, iterator) = graph.cooccurence_matrix(&walker, 3, verbose)?;\n        assert_eq!(terms_number, iterator.count());\n\n        let window_size = 3;\n        let batch_size = 256;\n        let data = graph\n            .node2vec(&walker, batch_size, window_size)?\n            .collect::<Vec<_>>();\n        assert_eq!(\n            data.len(),\n            batch_size as usize\n                * walker.iterations as usize\n                * (walker.single_walk_parameters.walk_length as usize - window_size * 2)\n        );\n        for (context, _) in data.iter() {\n            assert_eq!(context.len(), window_size * 2);\n        }\n    }\n    if graph.has_edges() {\n        graph\n            .link_prediction_degrees(0, 256, true, 10.0, false, 10, &None)\n            .unwrap()\n            .collect::<Vec<_>>();\n        graph\n            .link_prediction_ids(0, 256, 10.0, false, 10, &None)\n            .unwrap()\n            .collect::<Vec<_>>();\n    }\n\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_graph_filter",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "assert!(graph\n        .filter(\n            Some(graph.get_node_names()),\n            graph\n                .get_node_type_names()\n                .ok()\n                .map(|ntn| ntn.into_iter().map(Option::Some).collect()),\n            graph\n                .get_edge_type_names()\n                .map(|etn| etn.into_iter().map(Option::Some).collect()),\n            Some(1000.0),\n            Some(10.0),\n            verbose,\n        )\n        .is_err());\n    let _ = graph.filter(\n        Some(graph.get_node_names()),\n        graph\n            .get_node_type_names()\n            .ok()\n            .map(|ntn| ntn.into_iter().map(Option::Some).collect()),\n        graph\n            .get_edge_type_names()\n            .map(|etn| etn.into_iter().map(Option::Some).collect()),\n        graph.get_min_edge_weight().ok(),\n        graph.get_max_edge_weight().ok(),\n        verbose,\n    );\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_edgelist_generation",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "_verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "let _clique = graph.get_clique_edge_names(\n        None,\n        None,\n        Some(false),\n        None,\n        // limit to compute the clique for at most the first 3 nodes\n        // because it's really expensive computationally.\n        Some(\n            graph\n                .get_node_names()\n                .iter()\n                .take(3)\n                .cloned()\n                .collect::<HashSet<String>>(),\n        ),\n    );\n    warn!(\"Running edge lists generator tests.\");\n    if graph.get_nodes_number() > 1 {\n        let _bipartite = graph.get_bipartite_edge_names(\n            None,\n            Some(\n                [graph.get_unchecked_node_name_from_node_id(0)]\n                    .iter()\n                    .cloned()\n                    .collect::<HashSet<String>>(),\n            ),\n            Some(\n                [graph.get_unchecked_node_name_from_node_id(1)]\n                    .iter()\n                    .cloned()\n                    .collect::<HashSet<String>>(),\n            ),\n            None,\n            None,\n        )?;\n        let _star = graph.get_star_edges(\n            graph.get_unchecked_node_name_from_node_id(0),\n            Some(false),\n            Some(\n                [graph.get_unchecked_node_name_from_node_id(1)]\n                    .iter()\n                    .cloned()\n                    .collect::<HashSet<String>>(),\n            ),\n            None,\n        )?;\n        let _star = graph.get_star_edge_names(\n            graph.get_unchecked_node_name_from_node_id(0),\n            Some(false),\n            Some(\n                [graph.get_unchecked_node_name_from_node_id(1)]\n                    .iter()\n                    .cloned()\n                    .collect::<HashSet<String>>(),\n            ),\n            None,\n        )?;\n    }\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_nodelabel_holdouts",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "_verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "for use_stratification in [true, false].iter() {\n        if *use_stratification\n            && (graph.has_multilabel_node_types() || graph.get_minimum_node_types_number() < 2)\n            || graph.get_nodes_number() - graph.get_unknown_node_types_number() < 2\n            || !graph.has_node_types()\n        {\n            assert!(graph\n                .node_label_holdout(0.8, *use_stratification, 42)\n                .is_err());\n            continue;\n        }\n\n        let (train, test) = graph.node_label_holdout(0.8, *use_stratification, 42)?;\n        let remerged = &mut (&train | &test)?;\n        assert_eq!(remerged.node_types, graph.node_types);\n        assert!(\n            remerged.contains(graph)?,\n            \"The re-merged holdouts does not contain the original graph.\"\n        );\n        assert!(\n            graph.contains(remerged)?,\n            \"The re-merged holdouts does not contain the original graph.\"\n        );\n        assert!(\n            train.node_types.as_ref().map_or(false, |train_nts| {\n                test.node_types.as_ref().map_or(false, |test_nts| {\n                    train_nts.ids.iter().zip(test_nts.ids.iter()).all(\n                        |(train_node_type, test_node_type)| {\n                            !(train_node_type.is_some() && test_node_type.is_some())\n                        },\n                    )\n                })\n            }),\n            \"The train and test node-label graphs are overlapping!\"\n        );\n    }\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_edgelabel_holdouts",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "_verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "for use_stratification in [true, false].iter() {\n        if *use_stratification && graph.get_minimum_edge_types_number() < 2\n            || graph.get_directed_edges_number() - graph.get_unknown_edge_types_number() < 2\n            || !graph.has_edge_types()\n        {\n            assert!(graph\n                .edge_label_holdout(0.8, *use_stratification, 42)\n                .is_err());\n            continue;\n        }\n        let (train, test) = graph.edge_label_holdout(0.8, *use_stratification, 42)?;\n        assert!(\n            train.edge_types.as_ref().map_or(false, |train_nts| {\n                test.edge_types.as_ref().map_or(false, |test_nts| {\n                    train_nts.ids.iter().zip(test_nts.ids.iter()).all(\n                        |(train_edge_type, test_edge_type)| {\n                            !(train_edge_type.is_some() && test_edge_type.is_some())\n                        },\n                    )\n                })\n            }),\n            \"The train and test edge-label graphs are overlapping!\"\n        );\n    }\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_graph_removes",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "{\n        let without_edge_types = graph.remove(\n            None, None, None, None, None, None, None, None, false, false, true, false, false,\n            verbose,\n        );\n        if let Some(we) = &without_edge_types.ok() {\n            validate_vocabularies(we);\n            assert_eq!(we.has_edge_types(), false);\n            assert_eq!(we.has_edge_weights(), graph.has_edge_weights());\n            assert_eq!(we.node_types, graph.node_types);\n            assert_eq!(\n                we.get_unique_edges_number(),\n                graph.get_unique_edges_number(),\n                concat!(\n                    \"Number of unique edges does not match in graph without edge types.\\n\",\n                    \"The report of the original graph is \\n{:?}\\n\",\n                    \"The report of the graph without edge types is \\n{:?}\",\n                ),\n                graph.textual_report(false),\n                we.textual_report(false),\n            );\n            assert_eq!(\n                we.get_unique_selfloop_number(),\n                graph.get_unique_selfloop_number(),\n                \"Number of unique self loops does not match in graph without edge types.\"\n            );\n            assert_eq!(we.nodes, graph.nodes);\n        }\n    }\n    {\n        let without_node_types = graph.remove(\n            None, None, None, None, None, None, None, None, false, true, false, false, false,\n            verbose,\n        );\n        if let Some(wn) = &without_node_types.ok() {\n            validate_vocabularies(wn);\n            assert_eq!(wn.has_node_types(), false);\n            assert_eq!(\n                wn.weights,\n                graph.weights,\n                concat!(\n                    \"We expected the weights not to change when removig node types.\",\n                    \"\\nThe report of the original graph is {:?}.\",\n                    \"\\nThe report of the filtered graph is {:?}.\"\n                ),\n                graph.textual_report(false),\n                wn.textual_report(false)\n            );\n            assert_eq!(wn.has_selfloops(), graph.has_selfloops());\n            assert_eq!(wn.nodes, graph.nodes);\n        }\n    }\n    {\n        let without_weights = graph.remove(\n            None, None, None, None, None, None, None, None, true, false, false, false, false,\n            verbose,\n        );\n        if let Some(ww) = &without_weights.ok() {\n            validate_vocabularies(ww);\n            assert_eq!(ww.has_edge_weights(), false);\n            assert_eq!(ww.node_types, graph.node_types);\n            assert_eq!(ww.has_selfloops(), graph.has_selfloops());\n            assert_eq!(ww.nodes, graph.nodes);\n        }\n    }\n\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_clone_and_setters",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "_verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "let mut clone = graph.clone();\n    clone = clone.set_all_edge_types(\"TEST_SET_ALL_EDGE_TYPES\")?;\n    clone = clone.set_all_node_types(\"TEST_SET_ALL_NODE_TYPES\")?;\n\n    assert_eq!(\n        clone.get_edge_types_number(),\n        1,\n        \"Number of edge types of the graph is not 1.\"\n    );\n    assert_eq!(\n        clone.get_unchecked_edge_count_from_edge_type_id(Some(0)),\n        graph.get_directed_edges_number(),\n        \"Number of edges with the unique edge type does not match number of edges in the graph.\"\n    );\n\n    assert_eq!(\n        clone.get_node_types_number(),\n        1,\n        \"Number of node types of the graph is not 1.\"\n    );\n    assert_eq!(\n        clone.get_unchecked_node_count_from_node_type_id(Some(0)),\n        graph.get_nodes_number(),\n        \"Number of nodes with the unique node type does not match number of nodes in the graph.\"\n    );\n\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "test_graph_remapping",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "assert!(\n        graph.are_nodes_remappable(&graph),\n        \"Graph always should be remappable to itself.\"\n    );\n    assert!(\n        graph.remap(&graph, verbose).is_ok(),\n        \"Graph always should be remappable to itself.\"\n    );\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [
            "Executes near-complete test of all functions for the given graph."
        ],
        "modifiers": "",
        "name": "_default_test_suite",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "warn!(\"Starting default test suite.\");\n    let _ = test_graph_properties(graph, verbose);\n\n    warn!(\"Testing SkipGram / CBOW / GloVe preprocessing.\");\n    let _ = test_embiggen_preprocessing(graph, verbose);\n\n    warn!(\"Testing subgraph generation.\");\n    let _ = test_subgraph_generation(graph, verbose);\n\n    warn!(\"Testing clone and setters.\");\n    let _ = test_clone_and_setters(graph, verbose);\n\n    warn!(\"Testing edge-label holdouts tests.\");\n    let _ = test_edgelabel_holdouts(graph, verbose);\n\n    warn!(\"Testing writing out graph to file.\");\n    //let _ = test_dump_graph(graph, verbose);\n\n    warn!(\"Testing generic filtering mechanism.\");\n    let _ = test_graph_filter(graph, verbose);\n\n    warn!(\"Testing the spanning arborescences.\");\n    let _ = test_spanning_arborescence_bader(graph, verbose);\n\n    warn!(\"Running node-label holdouts tests.\");\n    let _ = test_nodelabel_holdouts(graph, verbose);\n\n    warn!(\"Running remove components tests.\");\n    let _ = test_remove_components(graph, verbose);\n\n    warn!(\"Testing removes.\");\n    let _ = test_graph_removes(graph, verbose);\n\n    warn!(\"Testing negative edges generation.\");\n    let _ = test_negative_edges_generation(graph, verbose);\n\n    warn!(\"Executing edge holdouts tests.\");\n    let _ = test_edge_holdouts(graph, verbose);\n\n    warn!(\"Testing k-fold holdouts.\");\n    let _ = test_kfold(graph, verbose);\n\n    warn!(\"Testing edge lists generation.\");\n    let _ = test_edgelist_generation(graph, verbose);\n\n    warn!(\"Testing graph remapping.\");\n    let _ = test_graph_remapping(graph, verbose);\n\n    warn!(\"Testing random walks.\");\n    let _ = test_random_walks(graph, verbose);\n\n    Ok(())"
    },
    {
        "file": "test_utilities.rs",
        "doc": [
            "Executes near-complete test of all functions for the given graph."
        ],
        "modifiers": "pub",
        "name": "default_test_suite",
        "args": [
            [
                "graph",
                "&mut Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "warn!(\"Starting default test suite.\");\n    let _ = _default_test_suite(graph, verbose);\n    warn!(\"Starting default test suite with speedups enabled.\");\n    graph.enable(true, true, true, None)?;\n    let _ = _default_test_suite(graph, verbose);\n    Ok(())"
    },
    {
        "file": "modifiers.rs",
        "struct": "Graph",
        "doc": [
            "Enable extra perks that buys you time as you accept to spend more memory.",
            "",
            "# Arguments",
            "* `vector_sources`: bool - Whether to cache sources into a vector for faster walks.",
            "* `vector_destinations`: bool - Whether to cache destinations into a vector for faster walks.",
            "* `vector_cumulative_node_degrees`: bool - Whether to cache cumulative_node_degrees into a vector for faster walks.",
            "* `cache_size`: Option<f64> - percentage of nodes destinations to cache. This cannot be used with the vector destinations."
        ],
        "modifiers": "pub",
        "name": "enable",
        "args": [
            [
                "self",
                "&mut self"
            ],
            [
                "vector_sources",
                "bool"
            ],
            [
                "vector_destinations",
                "bool"
            ],
            [
                "vector_cumulative_node_degrees",
                "bool"
            ],
            [
                "cache_size",
                "Option<f64>"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "if vector_destinations {\n            if self.destinations.is_none() {\n                self.destinations = Some(self.get_destinations(true));\n            }\n        } else {\n            self.destinations = None;\n        }\n        if vector_sources {\n            if self.sources.is_none() {\n                self.sources = Some(self.get_sources(true));\n            }\n        } else {\n            self.sources = None;\n        }\n        if vector_cumulative_node_degrees {\n            if self.cumulative_node_degrees.is_none() {\n                self.cumulative_node_degrees = Some(self.get_cumulative_node_degrees());\n            }\n        } else {\n            self.cumulative_node_degrees = None;\n        }\n        if let Some(cs) = cache_size {\n            if vector_destinations {\n                return Err(\"You cannot use cache if you enable the destinations vector\".to_owned());\n            }\n            if cs <= 0.0 || cs >= 1.0 {\n                return Err(\"Cache size must be between strictly 0 and 1, otherwise just enable the destinations vector.\".to_owned());\n            }\n            let cached_nodes_number: NodeT = (self.get_nodes_number() as f64 * cs) as NodeT;\n            if cached_nodes_number == 0 || cached_nodes_number == self.get_nodes_number() {\n                return Err(\"Required cached nodes number cannot be 0 or all the nodes.\".to_owned());\n            }\n            self.cached_destinations = Some(\n                self.get_top_k_central_node_ids(cached_nodes_number)\n                    .par_iter()\n                    .map(|node_id| {\n                        (\n                            *node_id,\n                            self.iter_unchecked_neighbour_node_ids_from_source_node_id(*node_id)\n                                .collect::<Vec<NodeT>>(),\n                        )\n                    })\n                    .collect::<HashMap<NodeT, Vec<NodeT>>>(),\n            );\n        } else {\n            self.cached_destinations = None;\n        }\n        Ok(())"
    },
    {
        "file": "modifiers.rs",
        "struct": "Graph",
        "doc": [
            "Disable all extra perks, reducing memory impact but incresing time requirements."
        ],
        "modifiers": "pub",
        "name": "disable_all",
        "args": [
            [
                "self",
                "&mut self"
            ]
        ],
        "body": "self.destinations = None;\n        self.sources = None;\n        self.cumulative_node_degrees = None;\n        self.cached_destinations = None;"
    },
    {
        "file": "node_file_writer.rs",
        "struct": "NodeFileWriter",
        "impl_doc": [
            "Structure that saves the writer specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* writer: CSVFileWriter - The common writer for readin and writing a csv.",
            "* nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
            "* nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
            "* node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* node_types_separator: String - Separator to split the node types."
        ],
        "doc": [
            "Return new NodeFileWriter object.",
            "",
            "# Arguments",
            "",
            "* path: String - Path where to store/load the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "new",
        "generics": "S: Into<String>",
        "args": [
            [
                "path",
                "S"
            ]
        ],
        "return_type": "NodeFileWriter",
        "body": "NodeFileWriter {\n            writer: CSVFileWriter::new(path),\n            nodes_column: \"id\".to_string(),\n            nodes_column_number: 0,\n            node_types_column: \"category\".to_string(),\n            node_types_column_number: 1,\n            node_types_separator: \"\".to_string(),\n        }"
    },
    {
        "file": "node_file_writer.rs",
        "struct": "NodeFileWriter",
        "impl_doc": [
            "Structure that saves the writer specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* writer: CSVFileWriter - The common writer for readin and writing a csv.",
            "* nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
            "* nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
            "* node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* node_types_separator: String - Separator to split the node types."
        ],
        "doc": [
            "Set the column of the nodes.",
            "",
            "# Arguments",
            "",
            "* nodes_column: Option<String> - The nodes column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_nodes_column",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "nodes_column",
                "Option<S>"
            ]
        ],
        "return_type": "NodeFileWriter",
        "body": "if let Some(column) = nodes_column {\n            self.nodes_column = column.into();\n        }\n        self"
    },
    {
        "file": "node_file_writer.rs",
        "struct": "NodeFileWriter",
        "impl_doc": [
            "Structure that saves the writer specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* writer: CSVFileWriter - The common writer for readin and writing a csv.",
            "* nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
            "* nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
            "* node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* node_types_separator: String - Separator to split the node types."
        ],
        "doc": [
            "Set the column of the nodes.",
            "",
            "# Arguments",
            "",
            "* node_types_column: Option<String> - The node types column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_node_types_column",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "nodes_type_column",
                "Option<S>"
            ]
        ],
        "return_type": "NodeFileWriter",
        "body": "if let Some(column) = nodes_type_column {\n            self.node_types_column = column.into();\n        }\n        self"
    },
    {
        "file": "node_file_writer.rs",
        "struct": "NodeFileWriter",
        "impl_doc": [
            "Structure that saves the writer specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* writer: CSVFileWriter - The common writer for readin and writing a csv.",
            "* nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
            "* nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
            "* node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* node_types_separator: String - Separator to split the node types."
        ],
        "doc": [
            "Set the column_number of the nodes.",
            "",
            "# Arguments",
            "",
            "* nodes_column_number: Option<usize> - The nodes column_number to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_nodes_column_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "nodes_column_number",
                "Option<usize>"
            ]
        ],
        "return_type": "NodeFileWriter",
        "body": "if let Some(column) = nodes_column_number {\n            self.nodes_column_number = column;\n        }\n        self"
    },
    {
        "file": "node_file_writer.rs",
        "struct": "NodeFileWriter",
        "impl_doc": [
            "Structure that saves the writer specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* writer: CSVFileWriter - The common writer for readin and writing a csv.",
            "* nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
            "* nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
            "* node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* node_types_separator: String - Separator to split the node types."
        ],
        "doc": [
            "Set the column_number of the nodes.",
            "",
            "# Arguments",
            "",
            "* node_types_column_number: Option<usize> - The node types column_number to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_node_types_column_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "node_types_column_number",
                "Option<usize>"
            ]
        ],
        "return_type": "NodeFileWriter",
        "body": "if let Some(v) = node_types_column_number {\n            self.node_types_column_number = v;\n        }\n        self"
    },
    {
        "file": "node_file_writer.rs",
        "struct": "NodeFileWriter",
        "impl_doc": [
            "Structure that saves the writer specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* writer: CSVFileWriter - The common writer for readin and writing a csv.",
            "* nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
            "* nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
            "* node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* node_types_separator: String - Separator to split the node types."
        ],
        "doc": [
            "Set the verbose.",
            "",
            "# Arguments",
            "",
            "* `verbose`: Option<bool> - Whether to show the loading bar or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_verbose",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "verbose",
                "Option<bool>"
            ]
        ],
        "return_type": "NodeFileWriter",
        "body": "if let Some(v) = verbose {\n            self.writer.verbose = v;\n        }\n        self"
    },
    {
        "file": "node_file_writer.rs",
        "struct": "NodeFileWriter",
        "impl_doc": [
            "Structure that saves the writer specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* writer: CSVFileWriter - The common writer for readin and writing a csv.",
            "* nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
            "* nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
            "* node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* node_types_separator: String - Separator to split the node types."
        ],
        "doc": [
            "Set the separator.",
            "",
            "# Arguments",
            "",
            "* separator: Option<String> - The separator to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_separator",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "separator",
                "Option<S>"
            ]
        ],
        "return_type": "NodeFileWriter",
        "body": "if let Some(v) = separator {\n            self.writer.separator = v.into();\n        }\n        self"
    },
    {
        "file": "node_file_writer.rs",
        "struct": "NodeFileWriter",
        "impl_doc": [
            "Structure that saves the writer specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* writer: CSVFileWriter - The common writer for readin and writing a csv.",
            "* nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
            "* nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
            "* node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* node_types_separator: String - Separator to split the node types."
        ],
        "doc": [
            "Set the header.",
            "",
            "# Arguments",
            "",
            "* header: Option<bool> - Whether to write out an header or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_header",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "header",
                "Option<bool>"
            ]
        ],
        "return_type": "NodeFileWriter",
        "body": "if let Some(v) = header {\n            self.writer.header = v;\n        }\n        self"
    },
    {
        "file": "node_file_writer.rs",
        "struct": "NodeFileWriter",
        "impl_doc": [
            "Structure that saves the writer specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* writer: CSVFileWriter - The common writer for readin and writing a csv.",
            "* nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.",
            "* nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.",
            "* node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* node_types_separator: String - Separator to split the node types."
        ],
        "doc": [
            "Write nodes to file.",
            "",
            "# Arguments",
            "",
            "* `graph`: &Graph, reference to graph to use."
        ],
        "modifiers": "pub",
        "name": "dump",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "graph",
                "&Graph"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "// build the header\n        let mut header = vec![(self.nodes_column.clone(), self.nodes_column_number)];\n\n        if graph.has_node_types() {\n            header.push((\n                self.node_types_column.clone(),\n                self.node_types_column_number,\n            ));\n        }\n\n        let number_of_columns = 1 + header.iter().map(|(_, i)| i).max().unwrap();\n\n        self.writer.write_lines(\n            graph.get_nodes_number() as usize,\n            compose_lines(number_of_columns, header),\n            (0..graph.get_nodes_number()).map(|node_id| {\n                let mut line = vec![(\n                    graph.nodes.unchecked_translate(node_id),\n                    self.nodes_column_number,\n                )];\n\n                if graph.has_node_types() {\n                    line.push((\n                        match graph.get_node_type_name_from_node_id(node_id).unwrap() {\n                            Some(values) => values.join(&self.node_types_separator),\n                            None => \"\".to_string(),\n                        },\n                        self.node_types_column_number,\n                    ));\n                }\n                compose_lines(number_of_columns, line)\n            }),\n        )"
    },
    {
        "file": "iter_queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "* `iter_(.+?)_from_(.+)`",
            "* `iter_unchecked_(.+?)_from_(.+)`",
            "* `par_iter_(.+?)_from_(.+)`",
            "* `par_iter_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns range of the edge ids of edges starting from the given source node.",
            "",
            "# Arguments",
            "",
            "* `src`: NodeT - Source node of the edge.",
            ""
        ],
        "modifiers": "pub",
        "name": "iter_unchecked_edge_ids_from_source_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ]
        ],
        "return_type": "std::ops::Range<usize>",
        "body": "let (min_edge_id, max_edge_id) =\n            self.get_unchecked_minmax_edge_ids_from_source_node_id(src);\n        min_edge_id as usize..max_edge_id as usize"
    },
    {
        "file": "iter_queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "* `iter_(.+?)_from_(.+)`",
            "* `iter_unchecked_(.+?)_from_(.+)`",
            "* `par_iter_(.+?)_from_(.+)`",
            "* `par_iter_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns range of the edge ids of edges starting from the given source node.",
            "",
            "# Arguments",
            "",
            "* `src`: NodeT - Source node of the edge.",
            ""
        ],
        "modifiers": "pub",
        "name": "par_iter_unchecked_edge_ids_from_source_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = NodeT> + '_",
        "body": "self.iter_unchecked_edge_ids_from_source_node_id(src)\n            .into_par_iter()\n            .map(|node_id| node_id as NodeT)"
    },
    {
        "file": "iter_queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "* `iter_(.+?)_from_(.+)`",
            "* `iter_unchecked_(.+?)_from_(.+)`",
            "* `par_iter_(.+?)_from_(.+)`",
            "* `par_iter_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns range of multigraph minimum and maximum edge ids with same source and destination nodes and different edge type.",
            "",
            "# Arguments",
            "",
            "* `src`: NodeT - Source node of the edge.",
            "* `dst`: NodeT -  Destination node of the edge.",
            ""
        ],
        "modifiers": "pub",
        "name": "iter_unchecked_edge_ids_from_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "impl Iterator<Item = EdgeT>",
        "body": "let (min_edge_id, max_edge_id) = self.get_unchecked_minmax_edge_ids_from_node_ids(src, dst);\n        min_edge_id..max_edge_id"
    },
    {
        "file": "iter_queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "* `iter_(.+?)_from_(.+)`",
            "* `iter_unchecked_(.+?)_from_(.+)`",
            "* `par_iter_(.+?)_from_(.+)`",
            "* `par_iter_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return iterator over NodeT of destinations of the given node src.",
            "",
            "# Arguments",
            "* `src`: NodeT - The node whose neighbours are to be retrieved.",
            ""
        ],
        "modifiers": "pub",
        "name": "iter_unchecked_neighbour_node_ids_from_source_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ]
        ],
        "return_type": "Box<dyn Iterator<Item = NodeT> + '_>",
        "body": "match &self.destinations {\n            Some(dsts) => Box::new(\n                dsts[self.iter_unchecked_edge_ids_from_source_node_id(src)]\n                    .iter()\n                    .cloned(),\n            ),\n            None => Box::new(\n                self.edges\n                    .iter_in_range(self.encode_edge(src, 0)..self.encode_edge(src + 1, 0))\n                    .map(move |edge| self.decode_edge(edge).1),\n            ),\n        }"
    },
    {
        "file": "iter_queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "* `iter_(.+?)_from_(.+)`",
            "* `iter_unchecked_(.+?)_from_(.+)`",
            "* `par_iter_(.+?)_from_(.+)`",
            "* `par_iter_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return iterator over NodeT of destinations of the given node src.",
            "",
            "# Arguments",
            "* `src`: NodeT - The node whose neighbour names are to be retrieved.",
            ""
        ],
        "modifiers": "pub",
        "name": "iter_unchecked_neighbour_node_names_from_source_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ]
        ],
        "return_type": "impl Iterator<Item = String> + '_",
        "body": "self.iter_unchecked_neighbour_node_ids_from_source_node_id(src)\n            .map(move |dst| self.get_unchecked_node_name_from_node_id(dst))"
    },
    {
        "file": "iter_queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "* `iter_(.+?)_from_(.+)`",
            "* `iter_unchecked_(.+?)_from_(.+)`",
            "* `par_iter_(.+?)_from_(.+)`",
            "* `par_iter_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns option of range of multigraph minimum and maximum edge ids with same source and destination nodes and different edge type.",
            "",
            "# Arguments",
            "",
            "* `src`: NodeT - Source node id of the edge.",
            "* `dst`: NodeT -  Destination node id of the edge.",
            ""
        ],
        "modifiers": "pub",
        "name": "iter_edge_ids_from_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "Result<impl Iterator<Item = EdgeT>, String>",
        "body": "let (min_edge_id, max_edge_id) = self.get_minmax_edge_ids_from_node_ids(src, dst)?;\n        Ok(min_edge_id..max_edge_id)"
    },
    {
        "file": "tarjan.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Tarjan algorithm"
        ],
        "doc": [
            "Returns list of nodes of the various strongly connected components.",
            "",
            "This is an implementation of Tarjan algorithm.",
            ""
        ],
        "modifiers": "pub",
        "name": "strongly_connected_components",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Vec<HashSet<NodeT>>",
        "body": "let mut indexed_mask: Vec<bool> = vec![false; self.get_nodes_number() as usize];\n        let mut stacked_mask: Vec<bool> = vec![false; self.get_nodes_number() as usize];\n        let mut low_indices: Vec<NodeT> = vec![0; self.get_nodes_number() as usize];\n        let mut indices: Vec<NodeT> = vec![0; self.get_nodes_number() as usize];\n        let mut components_stack: Vec<NodeT> = Vec::new();\n        let mut components: Vec<HashSet<NodeT>> = Vec::new();\n        let mut common_index = 0;\n        let mut recurse: bool;\n        for node in self.iter_node_ids() {\n            if !indexed_mask[node as usize] {\n                let mut to_visit: Vec<(NodeT, usize)> = vec![(node, 0)];\n                while !to_visit.is_empty() {\n                    let (src, i) = to_visit.pop().unwrap();\n                    if !indexed_mask[src as usize] {\n                        low_indices[src as usize] = common_index;\n                        indices[src as usize] = common_index;\n                        indexed_mask[src as usize] = true;\n                        stacked_mask[src as usize] = true;\n                        common_index += 1;\n                        components_stack.push(src);\n                    }\n                    recurse = false;\n                    let (_min, _max) = self.get_unchecked_minmax_edge_ids_from_source_node_id(src);\n                    // Consider successors of source node\n                    for (j, dst) in ((_min + i as EdgeT).._max)\n                        .map(|edge_id| self.get_unchecked_destination_node_id_from_edge_id(edge_id))\n                        .enumerate()\n                    {\n                        if !indexed_mask[dst as usize] {\n                            // Successor w has not yet been visited; recurse on it\n                            to_visit.push((src, i + j + 1));\n                            to_visit.push((dst, 0));\n                            recurse = true;\n                            break;\n                        } else if stacked_mask[dst as usize] {\n                            // Successor w is in stack S and hence in the current SCC\n                            // If w is not on stack, then (v, w) is an edge pointing to an SCC already found and must be ignored\n                            // Note: The next line may look odd - but is correct.\n                            // It says w.index not w.lowlink; that is deliberate and from the original paper\n                            low_indices[src as usize] =\n                                min(low_indices[src as usize], indices[dst as usize]);\n                        }\n                    }\n\n                    if recurse {\n                        continue;\n                    }\n\n                    // If source is a root node, pop the stack and generate an SCC\n                    if low_indices[src as usize] == indices[src as usize] {\n                        // start a new strongly connected component\n                        let mut new_component: HashSet<NodeT> = HashSet::new();\n                        loop {\n                            let dst = components_stack.pop().unwrap();\n                            stacked_mask[dst as usize] = false;\n                            new_component.insert(dst);\n                            if dst == src {\n                                break;\n                            }\n                        }\n                        components.push(new_component);\n                    }\n\n                    if !to_visit.is_empty() {\n                        let (root, _) = to_visit.last().unwrap();\n                        low_indices[*root as usize] =\n                            min(low_indices[*root as usize], low_indices[src as usize]);\n                    }\n                }\n            }\n        }\n        components"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns option with the weight of the given edge id.",
            "",
            "This method will raise a panic if the given edge ID is higher than",
            "the number of edges in the graph. Additionally, it will simply",
            "return None if there are no graph weights.",
            "",
            "# Arguments",
            "* `edge_id`: EdgeT - The edge whose edge weight is to be returned."
        ],
        "modifiers": "pub",
        "name": "get_unchecked_edge_weight_from_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Option<WeightT>",
        "body": "self.weights.as_ref().map(|ws| ws[edge_id as usize])"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns node id from given node name raising a panic if used unproperly.",
            "",
            "# Arguments",
            "* `node_name`: &str - The node name whose node ID is to be returned."
        ],
        "modifiers": "pub",
        "name": "get_unchecked_node_id_from_node_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "NodeT",
        "body": "*self.nodes.get(node_name).unwrap()"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return edge type ID corresponding to the given edge type name.",
            "",
            "# Arguments",
            "* `edge_type_name`: &str - The edge type name whose edge type ID is to be returned."
        ],
        "modifiers": "pub",
        "name": "get_unchecked_edge_type_id_from_edge_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type_name",
                "&str"
            ]
        ],
        "return_type": "Option<EdgeTypeT>",
        "body": "self.edge_types\n            .as_ref()\n            .and_then(|ets| ets.get(edge_type_name).copied())"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return edge type ID corresponding to the given edge type name",
            "raising panic if edge type ID does not exists in current graph.",
            "",
            "# Arguments",
            "* `edge_type_id`: Option<EdgeTypeT> - The edge type naIDme whose edge type name is to be returned."
        ],
        "modifiers": "pub",
        "name": "get_unchecked_edge_type_name_from_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type_id",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "Option<String>",
        "body": "match (&self.edge_types, edge_type_id) {\n            (Some(ets), Some(et)) => Some(ets.unchecked_translate(et)),\n            _ => None,\n        }"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return number of edges of the given edge type without checks.",
            "",
            "# Arguments",
            "* `edge_type`: Option<EdgeTypeT> - The edge type to retrieve count of."
        ],
        "modifiers": "pub",
        "name": "get_unchecked_edge_count_from_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "EdgeT",
        "body": "match (&self.edge_types, edge_type) {\n            (Some(ets), None) => ets.get_unknown_count(),\n            (Some(ets), Some(et)) => ets.counts[et as usize],\n            _ => unreachable!(\"The current graph instance does not have edge types!\"),\n        }"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return number of nodes of the given node type without checks.",
            "",
            "# Arguments",
            "* node_type: Option<NodeTypeT> - The node type to retrieve count of."
        ],
        "modifiers": "pub(crate)",
        "name": "get_unchecked_node_count_from_node_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type",
                "Option<NodeTypeT>"
            ]
        ],
        "return_type": "NodeT",
        "body": "match (&self.node_types, node_type) {\n            (Some(nts), None) => nts.get_unknown_count(),\n            (Some(nts), Some(nt)) => nts.counts[nt as usize],\n            _ => unreachable!(\"The current graph instance does not have node types!\"),\n        }"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return (subsampled) vector of destinations of given node.",
            "",
            "If the max neighbours parameter is given, and is smaller than the",
            "number of the neighbours of the given node, the subsampling",
            "mechanism is given.",
            "",
            "# Arguments",
            "`node`: NodeT - Node whose neighbours are to return.",
            "`random_state`: u64 - Random state to subsample neighbours.",
            "`max_neighbours`: Option<NodeT> - Optionally number of neighbours to consider."
        ],
        "modifiers": "pub(crate)",
        "name": "get_unchecked_destination_node_ids_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "max_neighbours",
                "Option<NodeT>"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "let (min_edge_id, max_edge_id, destinations, _) =\n            self.get_node_edges_and_destinations(max_neighbours, random_state, node);\n        self.get_destinations_slice(min_edge_id, max_edge_id, node, &destinations)\n            .to_owned()"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return edge ID without any checks for given tuple of nodes and edge type.",
            "",
            "This method will cause a panic if used improperly when it is not certain",
            "that the edge exists.",
            "",
            "# Arguments",
            "* `src`: NodeT - Source node of the edge.",
            "* `dst`: NodeT - Destination node of the edge.",
            "* `edge_type`: Option<EdgeTypeT> - Edge Type of the edge."
        ],
        "modifiers": "pub",
        "name": "get_unchecked_edge_id_from_node_ids_and_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "edge_type",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.edge_types.as_ref().map_or_else(\n            || self.get_unchecked_edge_id_from_node_ids(src, dst),\n            |ets| {\n                self.iter_unchecked_edge_ids_from_node_ids(src, dst)\n                    // The vectors of the edge types can only have one element.\n                    .find(|edge_id| ets.ids[*edge_id as usize] == edge_type)\n                    .unwrap()\n            },\n        )"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return range of outbound edges IDs for all the edges bewteen the given",
            "source and destination nodes.",
            "This operation is meaningfull only in a multigraph.",
            "",
            "# Arguments",
            "",
            "* `src`: NodeT - Source node.",
            "* `dst`: NodeT - Destination node.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_unchecked_minmax_edge_ids_from_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "(EdgeT, EdgeT)",
        "body": "(\n            self.get_unchecked_edge_id_from_node_ids(src, dst),\n            self.get_unchecked_edge_id_from_node_ids(src, dst + 1),\n        )"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return the number of edges between the given source and destination nodes.",
            "",
            "This might be thought as the degree of an edge in a multigraph.",
            "On non-multigraph this trivially return 1 on existing edges and 0 on",
            "the non-existing ones.",
            "",
            "# Arguments",
            "",
            "* `src`: NodeT - Source node.",
            "* `dst`: NodeT - Destination node.",
            ""
        ],
        "modifiers": "pub(crate)",
        "name": "get_unchecked_edge_degree_from_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "EdgeT",
        "body": "let (min_edge_id, max_edge_id) = self.get_unchecked_minmax_edge_ids_from_node_ids(src, dst);\n        max_edge_id - min_edge_id"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns node IDs corresponding to given edge ID.",
            "",
            "The method will panic if the given edge ID does not exists in the",
            "current graph instance.",
            "",
            "# Arguments",
            "* `edge_id`: EdgeT - The edge ID whose source and destination node IDs are to e retrieved.",
            "",
            "# Example",
            "To retrieve the source and destination node IDs of a given edge ID you can use the following:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let edge_id = 0;",
            "let (src, dst) = graph.get_unchecked_node_ids_from_edge_id(edge_id);",
            "println!(\"The edge with ID {} has source node ID {} and destination node ID {}.\", edge_id, src, dst);",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_unchecked_node_ids_from_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "(NodeT, NodeT)",
        "body": "if let (Some(sources), Some(destinations)) = (&self.sources, &self.destinations) {\n            return (sources[edge_id as usize], destinations[edge_id as usize]);\n        }\n        self.decode_edge(self.edges.unchecked_select(edge_id))"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns node IDs corresponding to given edge ID.",
            "",
            "# Arguments",
            "* `edge_id`: EdgeT - The edge ID whose source and destination node IDs are to e retrieved.",
            "",
            "# Example",
            "To retrieve the source and destination node IDs of a given edge ID you can use the following:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(graph.get_node_ids_from_edge_id(0).is_ok());",
            "assert!(graph.get_node_ids_from_edge_id(10000000000).is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_node_ids_from_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Result<(NodeT, NodeT), String>",
        "body": "self.validate_edge_id(edge_id)\n            .map(|edge_id| self.get_unchecked_node_ids_from_edge_id(edge_id))"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns edge ID corresponding to given source and destination node IDs.",
            "",
            "The method will panic if the given source and destination node IDs do",
            "not correspond to an edge in this graph instance.",
            "",
            "# Arguments",
            "* `src`: NodeT - The source node ID.",
            "* `dst`: NodeT - The destination node ID.",
            "",
            "# Example",
            "To retrieve the edge ID curresponding to the given source and destination node IDs you can use the following:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "let src = 0;",
            "let dst = 1;",
            "let edge_id = graph.get_unchecked_edge_id_from_node_ids(src, dst);",
            "println!(\"The source node ID {} and destination node ID {} corrrespond to the edge with ID {}.\", src, dst, edge_id);",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_unchecked_edge_id_from_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.edges.unchecked_rank(self.encode_edge(src, dst)) as EdgeT"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns edge ID corresponding to given source and destination node IDs.",
            "",
            "# Arguments",
            "* `src`: NodeT - The source node ID.",
            "* `dst`: NodeT - The destination node ID.",
            "",
            "# Example",
            "To retrieve the edge ID curresponding to the given source and destination node IDs you can use the following:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "assert!(graph.get_edge_id_from_node_ids(0, 1).is_ok());",
            "assert!(graph.get_edge_id_from_node_ids(0, 100000000).is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_edge_id_from_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "Result<EdgeT, String>",
        "body": "match self\n            .edges\n            .rank(self.encode_edge(src, dst))\n            .map(|value| value as EdgeT) {\n                Some(edge_id) => Ok(edge_id),\n                None => Err(format!(\"The edge composed by the source node {} and destination node {} does not exist in this graph.\", src, dst))\n            }"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns edge ID corresponding to given source and destination node IDs.",
            "",
            "# Arguments",
            "* `source_id`: NodeT - The source node ID.",
            "",
            "# Example",
            "To retrieve the edge ID curresponding to the given source and destination node IDs you can use the following:",
            "",
            "```rust",
            "# let graph_with_singletons = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "# let graph_without_singletons = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "assert!(",
            "graph_without_singletons.iter_node_ids()",
            ".all(|node_id|",
            "graph_without_singletons.get_unchecked_unique_source_node_id(node_id) == node_id)",
            ");",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_unchecked_unique_source_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "source_id",
                "NodeT"
            ]
        ],
        "return_type": "NodeT",
        "body": "// If there are no singletons or trap nodes in the graph\n        self.unique_sources.as_ref().map_or(\n            // We can directly return the provided source id.\n            source_id,\n            |x|\n                // Otherwise we need to retrieve the nodes corresponding to the given source ID\n                x.unchecked_select(source_id as u64) as NodeT,\n        )"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return the src, dst, edge type of a given edge ID.",
            "",
            "This method will raise a panic when an improper configuration is used.",
            "",
            "# Arguments",
            "* `edge_id`: EdgeT - The edge ID whose source, destination and edge type are to be retrieved.",
            "",
            "# Example",
            "In order to retrieve a given edge ID informations, you can use the following:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let edge_id = 0;",
            "let (src, dst, edge_type) = graph.get_unchecked_node_ids_and_edge_type_id_from_edge_id(edge_id);",
            "println!(\"The edge with ID {} has source node ID {}, destination node ID {} and edge type ID {:?}\", edge_id, src, dst, edge_type);",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_unchecked_node_ids_and_edge_type_id_from_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "(NodeT, NodeT, Option<EdgeTypeT>)",
        "body": "let (src, dst) = self.get_unchecked_node_ids_from_edge_id(edge_id);\n        (\n            src,\n            dst,\n            self.get_unchecked_edge_type_id_from_edge_id(edge_id),\n        )"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return the src, dst, edge type of a given edge ID.",
            "",
            "# Arguments",
            "* `edge_id`: EdgeT - The edge ID whose source, destination and edge type are to be retrieved.",
            "",
            "# Example",
            "In order to retrieve a given edge ID informations, you can use the following:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(graph.get_node_ids_and_edge_type_id_from_edge_id(0).is_ok());",
            "assert!(graph.get_node_ids_and_edge_type_id_from_edge_id(10000000000).is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_node_ids_and_edge_type_id_from_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Result<(NodeT, NodeT, Option<EdgeTypeT>), String>",
        "body": "self.validate_edge_id(edge_id)\n            .map(|edge_id| self.get_unchecked_node_ids_and_edge_type_id_from_edge_id(edge_id))"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return the src, dst, edge type and weight of a given edge ID.",
            "",
            "This method will raise a panic when an improper configuration is used.",
            "",
            "# Arguments",
            "* `edge_id`: EdgeT - The edge ID whose source, destination, edge type and weight are to be retrieved.",
            "",
            "# Example",
            "In order to retrieve a given edge ID informations, you can use the following:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let edge_id = 0;",
            "let (src, dst, edge_type, weight) = graph.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(edge_id);",
            "println!(\"The edge with ID {} has source node ID {}, destination node ID {}, edge type ID {:?} and weight {:?}.\", edge_id, src, dst, edge_type, weight);",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "(NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>)",
        "body": "let (src, dst, edge_type) =\n            self.get_unchecked_node_ids_and_edge_type_id_from_edge_id(edge_id);\n        (\n            src,\n            dst,\n            edge_type,\n            self.get_unchecked_edge_weight_from_edge_id(edge_id),\n        )"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return the src, dst, edge type and weight of a given edge ID.",
            "",
            "# Arguments",
            "* `edge_id`: EdgeT - The edge ID whose source, destination, edge type and weight are to be retrieved.",
            "",
            "# Example",
            "In order to retrieve a given edge ID informations, you can use the following:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(0).is_ok());",
            "assert!(graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(10000000000).is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Result<(NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>), String>",
        "body": "self.validate_edge_id(edge_id).map(|edge_id| {\n            self.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(edge_id)\n        })"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return vector with top k central node Ids.",
            "",
            "If the k passed is bigger than the number of nodes this method will return",
            "all the nodes in the graph.",
            "",
            "# Arguments",
            "",
            "* `k`: NodeT - Number of central nodes to extract.",
            "TODO: This can be refactored to run faster!"
        ],
        "modifiers": "pub",
        "name": "get_top_k_central_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "k",
                "NodeT"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "let k = k.min(self.get_nodes_number());\n        let mut nodes_degrees: Vec<(NodeT, NodeT)> = (0..self.get_nodes_number())\n            .map(|node_id| {\n                (\n                    self.get_unchecked_node_degree_from_node_id(node_id),\n                    node_id,\n                )\n            })\n            .collect();\n        nodes_degrees.par_sort_unstable();\n        nodes_degrees.reverse();\n        nodes_degrees[0..k as usize]\n            .iter()\n            .map(|(_, node_id)| *node_id)\n            .collect()"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns the number of outbound neighbours of given node.",
            "",
            "The method will panic if the given node id is higher than the number of",
            "nodes in the graph.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - Integer ID of the node.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_unchecked_node_degree_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "NodeT",
        "body": "let (min_edge_id, max_edge_id) =\n            self.get_unchecked_minmax_edge_ids_from_source_node_id(node_id);\n        (max_edge_id - min_edge_id) as NodeT"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns the number of outbound neighbours of given node.",
            "",
            "# Arguments",
            "* `node_id`: NodeT - Integer ID of the node.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_node_degree_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "self.validate_node_id(node_id)\n            .map(|node_id| self.get_unchecked_node_degree_from_node_id(node_id))"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return vector with top k central node names.",
            "",
            "# Arguments",
            "",
            "* `k`: NodeT - Number of central nodes to extract."
        ],
        "modifiers": "pub",
        "name": "get_top_k_central_node_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "k",
                "NodeT"
            ]
        ],
        "return_type": "Vec<String>",
        "body": "self.get_top_k_central_node_ids(k)\n            .into_iter()\n            .map(|node_id| self.get_unchecked_node_name_from_node_id(node_id))\n            .collect()"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns option with vector of node types of given node.",
            "",
            "This method will panic if the given node ID is greater than",
            "the number of nodes in the graph.",
            "Furthermore, if the graph does NOT have node types, it will NOT",
            "return neither an error or a panic.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - node whose node type is to be returned.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The node type id of node {} is {:?}\", 0, graph.get_unchecked_node_type_id_from_node_id(0));",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "get_unchecked_node_type_id_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Option<Vec<NodeTypeT>>",
        "body": "self.node_types\n            .as_ref()\n            .and_then(|nts| nts.ids[node_id as usize].clone())"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns node type of given node.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - node whose node type is to be returned.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The node type id of node {} is {:?}\", 0, graph.get_node_type_id_from_node_id(0));",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "get_node_type_id_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<Option<Vec<NodeTypeT>>, String>",
        "body": "self.must_have_node_types()?;\n        self.validate_node_id(node_id)\n            .map(|node_id| self.get_unchecked_node_type_id_from_node_id(node_id))"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns edge type of given edge.",
            "",
            "This method will panic if the given edge ID is greater than",
            "the number of edges in the graph.",
            "Furthermore, if the graph does NOT have edge types, it will NOT",
            "return neither an error or a panic.",
            "",
            "# Arguments",
            "",
            "* `edge_id`: EdgeT - edge whose edge type is to be returned.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert_eq!(graph.get_unchecked_edge_type_id_from_edge_id(0), Some(0));",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_unchecked_edge_type_id_from_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Option<EdgeTypeT>",
        "body": "self.edge_types\n            .as_ref()\n            .and_then(|ets| ets.ids[edge_id as usize])"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns edge type of given edge.",
            "",
            "# Arguments",
            "",
            "* `edge_id`: EdgeT - edge whose edge type is to be returned.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "# let graph_without_edge_types = graph::test_utilities::load_ppi(true, false, true, true, false, false).unwrap();",
            "assert_eq!(graph.get_edge_type_id_from_edge_id(0).unwrap(), Some(0));",
            "assert!(graph_without_edge_types.get_edge_type_id_from_edge_id(0).is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_edge_type_id_from_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Result<Option<EdgeTypeT>, String>",
        "body": "self.must_have_edge_types()?;\n        self.validate_edge_id(edge_id)\n            .map(|edge_id| self.get_unchecked_edge_type_id_from_edge_id(edge_id))"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns result of option with the node type of the given node id.",
            "",
            "# Arguments",
            "* `node_id`: NodeT - The node ID whose node types are to be returned."
        ],
        "modifiers": "pub",
        "name": "get_node_type_name_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<Option<Vec<String>>, String>",
        "body": "self.must_have_node_types()?;\n        Ok(self\n            .get_node_type_id_from_node_id(node_id)?\n            .and_then(|node_type_ids| {\n                // This unwrap cannot fail because it is surely a vector\n                // of node type IDs from the current graph instance.\n                self.get_node_type_names_from_node_type_ids(node_type_ids)\n                    .ok()\n            }))"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns option with the edge type of the given edge id.",
            "",
            "# Arguments",
            "* `edge_id`: EdgeT - The edge ID whose edge type is to be returned."
        ],
        "modifiers": "pub",
        "name": "get_edge_type_name_from_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Result<Option<String>, String>",
        "body": "self.get_edge_type_id_from_edge_id(edge_id)?\n            .map_or(Ok(None), |x| {\n                Ok(Some(self.get_edge_type_name_from_edge_type_id(x)?))\n            })"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return edge type name of given edge type.",
            "",
            "# Arguments",
            "* `edge_type_id`: EdgeTypeT - Id of the edge type."
        ],
        "modifiers": "pub",
        "name": "get_edge_type_name_from_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type_id",
                "EdgeTypeT"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "self.must_have_edge_types()?;\n        self.edge_types.as_ref().map(\n            |ets| ets.translate(edge_type_id),\n        ).unwrap()"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns weight of the given edge id.",
            "",
            "# Arguments",
            "* `edge_id`: EdgeT - The edge ID whose weight is to be returned.",
            "",
            "# Example",
            "To get the weight of a given `edge_id` you can run:",
            "```rust",
            "# let weighted_graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "# let unweighted_graph = graph::test_utilities::load_ppi(true, true, false, true, false, false).unwrap();",
            "let edge_id = 0;",
            "let unexistent_edge_id = 123456789;",
            "assert!(weighted_graph.get_edge_weight_from_edge_id(edge_id).is_ok());",
            "assert!(weighted_graph.get_edge_weight_from_edge_id(unexistent_edge_id).is_err());",
            "assert!(unweighted_graph.get_edge_weight_from_edge_id(edge_id).is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_edge_weight_from_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "self.must_have_edge_weights()?;\n        self.weights.as_ref().map(\n            |weights| weights.get(edge_id as usize).map_or(\n                Err(format!(\n                    \"The given edge_id {} is higher than the number of available directed edges {}.\",\n                    edge_id,\n                    self.get_directed_edges_number()\n                )),\n                |value| Ok(*value)\n            )\n        ).unwrap()"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns weight of the given node ids.",
            "",
            "# Arguments",
            "* `src`: NodeT - The node ID of the source node.",
            "* `dst`: NodeT - The node ID of the destination node.",
            "",
            "# Example",
            "To get the weight of a given `src` and `dst` you can run:",
            "```rust",
            "# let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "let src = 0;",
            "let dst = 1;",
            "assert!(weighted_graph.get_edge_weight_from_node_ids(src, dst).is_ok());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_edge_weight_from_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "self.get_edge_weight_from_edge_id(self.get_edge_id_from_node_ids(src, dst)?)"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns weight of the given node ids and edge type.",
            "",
            "# Arguments",
            "* `src`: NodeT - The node ID of the source node.",
            "* `dst`: NodeT - The node ID of the destination node.",
            "* `edge_type`: Option<EdgeTypeT> - The edge type ID of the edge.",
            "",
            "# Example",
            "To get the weight of a given `src` and `dst` and `edge_type` you can run:",
            "```rust",
            "# let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "let src = 0;",
            "let dst = 1;",
            "let edge_type = Some(0);",
            "assert!(weighted_graph.get_edge_weight_from_node_ids_and_edge_type_id(src, dst, edge_type).is_ok());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_edge_weight_from_node_ids_and_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "edge_type",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "self.get_edge_weight_from_edge_id(\n            self.get_edge_id_from_node_ids_and_edge_type_id(src, dst, edge_type)?,\n        )"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns weight of the given node names and edge type.",
            "",
            "# Arguments",
            "* `src`: &str - The node name of the source node.",
            "* `dst`: &str - The node name of the destination node.",
            "* `edge_type`: Option<&String> - The edge type name of the edge.",
            "",
            "# Example",
            "To get the weight of a given `src` and `dst` and `edge_type` you can run:",
            "```rust",
            "# let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "let src = \"ENSP00000000233\";",
            "let dst = \"ENSP00000432568\";",
            "let edge_type = Some(\"red\".to_string());",
            "assert!(weighted_graph.get_edge_weight_from_node_names_and_edge_type_name(src, dst, edge_type.as_ref()).is_ok());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_edge_weight_from_node_names_and_edge_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "&str"
            ],
            [
                "dst",
                "&str"
            ],
            [
                "edge_type",
                "Option<&String>"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "self.get_edge_weight_from_edge_id(\n            self.get_edge_id_from_node_names_and_edge_type_name(src, dst, edge_type)?,\n        )"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns weight of the given node names.",
            "",
            "# Arguments",
            "* `src_name`: &str - The node name of the source node.",
            "* `dst_name`: &str - The node name of the destination node.",
            "",
            "# Example",
            "To get the weight of a given `src_name` and `dst_name` you can run:",
            "```rust",
            "# let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "let src_name = \"ENSP00000000233\";",
            "let dst_name = \"ENSP00000432568\";",
            "assert!(weighted_graph.get_edge_weight_from_node_names(src_name, dst_name).is_ok());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_edge_weight_from_node_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src_name",
                "&str"
            ],
            [
                "dst_name",
                "&str"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "self.get_edge_weight_from_edge_id(self.get_edge_id_from_node_names(src_name, dst_name)?)"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns result with the node name.",
            "",
            "# Arguments",
            "* `node_id`: NodeT - The node ID whose name is to be returned.",
            "",
            "# Example",
            "To get the name of a node you can use:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert_eq!(graph.get_unchecked_node_name_from_node_id(0), \"ENSG00000004059\".to_string());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_unchecked_node_name_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "String",
        "body": "self.nodes.unchecked_translate(node_id)"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns result with the node name.",
            "",
            "# Arguments",
            "* `node_id`: NodeT - The node ID whose name is to be returned.",
            "",
            "# Example",
            "To get the name of a node you can use:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(graph.get_node_name_from_node_id(0).is_ok());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_node_name_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "self.validate_node_id(node_id)\n            .map(|node_id| self.get_unchecked_node_name_from_node_id(node_id))"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns result with the node id.",
            "",
            "# Arguments",
            "* `node_name`: &str - The node name whose node ID is to be returned."
        ],
        "modifiers": "pub",
        "name": "get_node_id_from_node_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "match self.nodes.get(node_name) {\n            Some(node_id) => Ok(*node_id),\n            None => Err(format!(\n                \"Given node name {} is not available in current graph.\",\n                node_name\n            )),\n        }"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return node type ID for the given node name if available.",
            "",
            "# Arguments",
            "",
            "* `node_name`: &str - Name of the node.",
            "",
            "# Example",
            "To get the node type ID for a given node name you can run:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let node_name = \"ENSP00000000233\";",
            "println!(\"The node type ID of node {} is {:?}.\", node_name, graph.get_node_type_id_from_node_name(node_name).unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_node_type_id_from_node_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "Result<Option<Vec<NodeTypeT>>, String>",
        "body": "self.get_node_type_id_from_node_id(self.get_node_id_from_node_name(node_name)?)"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return node type name for the given node name if available.",
            "",
            "# Arguments",
            "",
            "* `node_name`: &str - Name of the node.",
            "",
            "# Example",
            "To get the node type name for a given node name you can run:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let node_name = \"ENSP00000000233\";",
            "println!(\"The node type of node {} is {:?}\", node_name, graph.get_node_type_name_from_node_name(node_name).unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_node_type_name_from_node_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "Result<Option<Vec<String>>, String>",
        "body": "self.get_node_type_name_from_node_id(self.get_node_id_from_node_name(node_name)?)"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return number of edges with given edge type ID.",
            "",
            "If None is given as an edge type ID, the unknown edge type IDs",
            "will be returned.",
            "",
            "# Arguments",
            "* `edge_type_id`: Option<EdgeTypeT> - The edge type ID to count the edges of.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_edge_count_from_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type_id",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "Result<EdgeT, String>",
        "body": "self.must_have_edge_types()?;\n        if let Some(et) = &edge_type_id {\n            if self.get_edge_types_number() <= *et {\n                return Err(format!(\n                    \"Given edge type ID {} is bigger than number of edge types in the graph {}.\",\n                    self.get_edge_types_number(),\n                    et\n                ));\n            }\n        }\n        Ok(self.get_unchecked_edge_count_from_edge_type_id(edge_type_id))"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return edge type ID curresponding to given edge type name.",
            "",
            "If None is given as an edge type ID, None is returned.",
            "",
            "# Arguments",
            "* `edge_type_name`: Option<&str> - The edge type name whose ID is to be returned.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_edge_type_id_from_edge_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type_name",
                "Option<&str>"
            ]
        ],
        "return_type": "Result<Option<EdgeTypeT>, String>",
        "body": "match (&self.edge_types, edge_type_name) {\n            (None, _) => Err(\"Current graph does not have edge types.\".to_owned()),\n            (Some(_), None) => Ok(None),\n            (Some(ets), Some(etn)) => match ets.get(etn) {\n                Some(edge_type_id) => Ok(Some(*edge_type_id)),\n                None => Err(format!(\n                    \"Given edge type name {} is not available in current graph.\",\n                    etn\n                )),\n            },\n        }"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return number of edges with given edge type name.",
            "",
            "If None is given as an edge type name, the unknown edge types",
            "will be returned.",
            "",
            "# Arguments",
            "* `edge_type_name`: Option<&str> - The edge type name to count the edges of.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_edge_count_from_edge_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type_name",
                "Option<&str>"
            ]
        ],
        "return_type": "Result<EdgeT, String>",
        "body": "self.get_edge_count_from_edge_type_id(\n            self.get_edge_type_id_from_edge_type_name(edge_type_name)?,\n        )"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return node type ID curresponding to given node type name.",
            "",
            "If None is given as an node type ID, None is returned.",
            "",
            "# Arguments",
            "* `node_type_name`: &str - The node type name whose ID is to be returned.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_node_type_id_from_node_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type_name",
                "&str"
            ]
        ],
        "return_type": "Result<NodeTypeT, String>",
        "body": "self.must_have_node_types()?;\n        self.node_types\n            .as_ref()\n            .map(|nts| {\n                nts.get(node_type_name).map_or_else(\n                    || {\n                        Err(format!(\n                    \"The given node type name {} does not exists in the current graph instance.\",\n                    node_type_name\n                ))\n                    },\n                    |node_type_id| Ok(*node_type_id),\n                )\n            })\n            .unwrap()"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return number of nodes with given node type ID.",
            "",
            "If None is given as an node type ID, the unknown node types",
            "will be returned.",
            "",
            "# Arguments",
            "* `node_type_id`: Option<NodeTypeT> - The node type ID to count the nodes of.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_node_count_from_node_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type_id",
                "Option<NodeTypeT>"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "self.validate_node_type_id(node_type_id)\n            .map(|node_type_id| self.get_unchecked_node_count_from_node_type_id(node_type_id))"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return number of nodes with given node type name.",
            "",
            "If None is given as an node type name, the unknown node types",
            "will be returned.",
            "",
            "# Arguments",
            "* `node_type_name`: Option<&str> - The node type name to count the nodes of.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_node_count_from_node_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type_name",
                "Option<&str>"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "self.get_node_count_from_node_type_id(\n            node_type_name.map_or(Ok::<_, String>(None), |ntn| {\n                Ok(Some(self.get_node_type_id_from_node_type_name(ntn)?))\n            })?,\n        )"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns the destination of given edge id without making any boundary check.",
            "",
            "# Arguments",
            "",
            "* `edge_id`: EdgeT - The edge ID whose destination is to be retrieved."
        ],
        "modifiers": "pub(crate)",
        "name": "get_unchecked_destination_node_id_from_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.destinations.as_ref().map_or_else(\n            || self.get_unchecked_node_ids_from_edge_id(edge_id).1,\n            |dsts| dsts[edge_id as usize],\n        )"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Returns the destination of given edge id.",
            "",
            "# Arguments",
            "",
            "* `edge_id`: EdgeT - The edge ID whose destination is to be retrieved."
        ],
        "modifiers": "pub",
        "name": "get_destination_node_id_from_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "self.validate_edge_id(edge_id)\n            .map(|edge_id| self.get_unchecked_destination_node_id_from_edge_id(edge_id))"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return vector of destinations for the given source node ID.",
            "",
            "# Arguments",
            "",
            "* `node_id`: NodeT - Node ID whose neighbours are to be retrieved.",
            "",
            "# Example",
            "To retrieve the neighbours of a given node `src` you can use:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "# let node_id = 0;",
            "println!(\"The neighbours of the node {} are {:?}.\", node_id, graph.get_neighbour_node_ids_from_node_id(node_id).unwrap());",
            "let unavailable_node = 2349765432;",
            "assert!(graph.get_neighbour_node_ids_from_node_id(unavailable_node).is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_neighbour_node_ids_from_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<Vec<NodeT>, String>",
        "body": "self.validate_node_id(node_id).map(|node_id| {\n            self.iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)\n                .collect()\n        })"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return vector of destinations for the given source node name.",
            "",
            "# Arguments",
            "",
            "* `node_name`: &str - Node ID whose neighbours are to be retrieved.",
            "",
            "# Example",
            "To retrieve the neighbours of a given node `src` you can use:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let node_name = \"ENSP00000000233\";",
            "println!(\"The neighbours of the node {} are {:?}.\", node_name, graph.get_neighbour_node_ids_from_node_name(node_name).unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_neighbour_node_ids_from_node_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "Result<Vec<NodeT>, String>",
        "body": "self.get_neighbour_node_ids_from_node_id(self.get_node_id_from_node_name(node_name)?)"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return vector of destination names for the given source node name.",
            "",
            "# Arguments",
            "",
            "* `node_name`: &str - Node name whose neighbours are to be retrieved.",
            "",
            "# Example",
            "To retrieve the neighbours of a given node `src` you can use:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let node_name = \"ENSP00000000233\";",
            "println!(\"The neighbours of the node {} are {:?}.\", node_name, graph.get_neighbour_node_names_from_node_name(node_name).unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_neighbour_node_names_from_node_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_name",
                "&str"
            ]
        ],
        "return_type": "Result<Vec<String>, String>",
        "body": "Ok(self\n            .iter_unchecked_neighbour_node_names_from_source_node_id(\n                self.get_node_id_from_node_name(node_name)?,\n            )\n            .collect())"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return range of outbound edges IDs for all the edges bewteen the given",
            "source and destination nodes.",
            "This operation is meaningfull only in a multigraph.",
            "",
            "# Arguments",
            "",
            "* `src`: NodeT - Source node.",
            "* `dst`: NodeT - Destination node.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_minmax_edge_ids_from_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "Result<(EdgeT, EdgeT), String>",
        "body": "Ok((\n            self.get_edge_id_from_node_ids(src, dst)?,\n            self.get_unchecked_edge_id_from_node_ids(src, dst + 1),\n        ))"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return edge ID for given tuple of nodes and edge type.",
            "",
            "This method will return an error if the graph does not contain the",
            "requested edge with edge type.",
            "",
            "# Arguments",
            "* `src`: NodeT - Source node of the edge.",
            "* `dst`: NodeT - Destination node of the edge.",
            "* `edge_type`: Option<EdgeTypeT> - Edge Type of the edge.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_edge_id_from_node_ids_and_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "edge_type",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "Result<EdgeT, String>",
        "body": "self.edge_types\n            .as_ref()\n            .map_or_else(\n                || self.get_edge_id_from_node_ids(src, dst).ok(),\n                |ets| {\n                    self.iter_edge_ids_from_node_ids(src, dst)\n                        .ok()\n                        .and_then(|mut edge_ids| {\n                            edge_ids.find(|edge_id| ets.ids[*edge_id as usize] == edge_type)\n                        })\n                },\n            )\n            .ok_or_else(|| {\n                format!(\n                    concat!(\n                    \"The current graph instance does not contain the required edge composed of \",\n                    \"source node ID {}, destination node ID {} and edge ID {:?}.\"\n                ),\n                    src, dst, edge_type\n                )\n            })"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return edge ID for given tuple of node names.",
            "",
            "This method will return an error if the graph does not contain the",
            "requested edge with edge type.",
            "",
            "# Arguments",
            "* `src_name`: &str - Source node name of the edge.",
            "* `dst_name`: &str - Destination node name of the edge.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_edge_id_from_node_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src_name",
                "&str"
            ],
            [
                "dst_name",
                "&str"
            ]
        ],
        "return_type": "Result<EdgeT, String>",
        "body": "match (self.nodes.get(src_name), self.nodes.get(dst_name)) {\n            (Some(src), Some(dst)) => self.get_edge_id_from_node_ids(*src, *dst).ok(),\n            _ => None,\n        }\n        .ok_or_else(|| {\n            format!(\n                concat!(\n                    \"The current graph instance does not contain the required edge composed of \",\n                    \"source node name {} and destination node name {}.\"\n                ),\n                src_name, dst_name\n            )\n        })"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return edge ID for given tuple of node names and edge type name.",
            "",
            "This method will return an error if the graph does not contain the",
            "requested edge with edge type.",
            "",
            "# Arguments",
            "* `src_name`: &str - Source node name of the edge.",
            "* `dst_name`: &str - Destination node name of the edge.",
            "* `edge_type_name`: Option<&String> - Edge type name.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_edge_id_from_node_names_and_edge_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src_name",
                "&str"
            ],
            [
                "dst_name",
                "&str"
            ],
            [
                "edge_type_name",
                "Option<&String>"
            ]
        ],
        "return_type": "Result<EdgeT, String>",
        "body": "match (self.nodes.get(src_name), self.nodes.get(dst_name)) {\n            (Some(src), Some(dst)) => self\n                .get_edge_id_from_node_ids_and_edge_type_id(\n                    *src,\n                    *dst,\n                    self.get_edge_type_id_from_edge_type_name(edge_type_name.map(|x| x.as_str()))?,\n                )\n                .ok(),\n            _ => None,\n        }\n        .ok_or_else(|| {\n            format!(\n                concat!(\n                    \"The current graph instance does not contain the required edge composed of \",\n                    \"source node name {}, destination node name {} and edge name {:?}.\"\n                ),\n                src_name, dst_name, edge_type_name\n            )\n        })"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return translated edge types from string to internal edge ID.",
            "",
            "# Arguments",
            "* `edge_type_names`: Vec<Option<String>> - Vector of edge types to be converted."
        ],
        "modifiers": "pub",
        "name": "get_edge_type_ids_from_edge_type_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type_names",
                "Vec<Option<String>>"
            ]
        ],
        "return_type": "Result<Vec<Option<EdgeTypeT>>, String>",
        "body": "edge_type_names\n            .iter()\n            .map(|edge_type_name| match edge_type_name {\n                None => Ok(None),\n                Some(edge_type_name) => {\n                    self.get_edge_type_id_from_edge_type_name(Some(edge_type_name))\n                }\n            })\n            .collect::<Result<Vec<Option<EdgeTypeT>>, String>>()"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return translated node types from string to internal node ID.",
            "",
            "# Arguments",
            "",
            "* `node_type_names`: Vec<Option<String>> - Vector of node types to be converted."
        ],
        "modifiers": "pub",
        "name": "get_node_type_ids_from_node_type_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type_names",
                "Vec<Option<String>>"
            ]
        ],
        "return_type": "Result<Vec<Option<NodeTypeT>>, String>",
        "body": "self.must_have_node_types()?;\n        node_type_names\n            .iter()\n            .map(|node_type_name| match node_type_name {\n                None => Ok(None),\n                Some(node_type_name) => self\n                    .get_node_type_id_from_node_type_name(node_type_name)\n                    .map(Some),\n            })\n            .collect::<Result<Vec<Option<NodeTypeT>>, String>>()"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return range of outbound edges IDs which have as source the given Node.",
            "",
            "The method will panic if the given source node ID is higher than",
            "the number of nodes in the graph.",
            "",
            "# Arguments",
            "",
            "* `src`: NodeT - Node for which we need to compute the cumulative_node_degrees range.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_unchecked_minmax_edge_ids_from_source_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ]
        ],
        "return_type": "(EdgeT, EdgeT)",
        "body": "match &self.cumulative_node_degrees {\n            Some(cumulative_node_degrees) => {\n                let min_edge_id = if src == 0 {\n                    0\n                } else {\n                    cumulative_node_degrees[src as usize - 1]\n                };\n                (min_edge_id, cumulative_node_degrees[src as usize])\n            }\n            None => {\n                let min_edge_id: EdgeT = self.get_unchecked_edge_id_from_node_ids(src, 0);\n                (\n                    min_edge_id,\n                    match &self.cached_destinations {\n                        Some(cds) => match cds.get(&src) {\n                            Some(destinations) => destinations.len() as EdgeT + min_edge_id,\n                            None => self.get_unchecked_edge_id_from_node_ids(src + 1, 0),\n                        },\n                        None => self.get_unchecked_edge_id_from_node_ids(src + 1, 0),\n                    },\n                )\n            }\n        }"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return range of outbound edges IDs which have as source the given Node.",
            "",
            "# Arguments",
            "",
            "* `src`: NodeT - Node for which we need to compute the cumulative_node_degrees range.",
            ""
        ],
        "modifiers": "pub",
        "name": "get_minmax_edge_ids_from_source_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ]
        ],
        "return_type": "Result<(EdgeT, EdgeT), String>",
        "body": "self.validate_node_id(src)\n            .map(|src| self.get_unchecked_minmax_edge_ids_from_source_node_id(src))"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return node type name of given node type.",
            "",
            "There is no need for a unchecked version since we will have to map",
            "on the note_types anyway.",
            "",
            "# Arguments",
            "* `node_type_id`: NodeTypeT - Id of the node type."
        ],
        "modifiers": "pub",
        "name": "get_node_type_name_from_node_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type_id",
                "NodeTypeT"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "self.must_have_node_types()?;\n        self.node_types\n            .as_ref()\n            .map(|nts| nts.translate(node_type_id))\n            .unwrap()"
    },
    {
        "file": "queries.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Queries",
            "The naming convention we follow is:",
            "* `get_(.+?)_from_(.+)`",
            "* `get_unchecked_(.+?)_from_(.+)`"
        ],
        "doc": [
            "Return node type name of given node type.",
            "",
            "# Arguments",
            "* `node_type_ids`: Vec<NodeTypeT> - Id of the node type."
        ],
        "modifiers": "pub",
        "name": "get_node_type_names_from_node_type_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type_ids",
                "Vec<NodeTypeT>"
            ]
        ],
        "return_type": "Result<Vec<String>, String>",
        "body": "self.must_have_node_types()?;\n        self.node_types\n            .as_ref()\n            .map(|nts| nts.translate_vector(node_type_ids))\n            .unwrap()"
    },
    {
        "file": "filters.rs",
        "struct": "Graph",
        "doc": [
            "Return graph filtered by given weights range.",
            "",
            "# Arguments",
            "",
            "* `node_names`: Option<Vec<String>> - The node names to keep.",
            "* `node_types`: Option<Vec<Option<String>>> - The node types to keep.",
            "* `edge_types`: Option<Vec<Option<String>>> - The edge types to keep.",
            "* `min_weight`: Option<WeightT> - Minimum weight to use to filter edges.",
            "* `max_weight`: Option<WeightT> - Maximum weight to use to filter edges.",
            "* `verbose`: bool - Whether to show the loading bar.",
            ""
        ],
        "modifiers": "pub",
        "name": "filter",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_names",
                "Option<Vec<String>>"
            ],
            [
                "node_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "edge_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "min_weight",
                "Option<WeightT>"
            ],
            [
                "max_weight",
                "Option<WeightT>"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "if let (Some(min_w), Some(max_w)) = (min_weight, max_weight) {\n            if min_w >= max_w {\n                return Err(format!(\n                    \"The given minimum weight ({}) is greater or equal than the given maximum weight ({})!\",\n                    min_w, max_w\n                ));\n            }\n        }\n\n        let pb = get_loading_bar(\n            verbose,\n            format!(\"Building filtered {}\", self.name).as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n\n        let node_ids = self.get_filter_bitmap(node_names, node_types)?;\n        let edge_types_ids = edge_types.map_or(Ok::<_, String>(None), |ets| {\n            Ok(Some(self.get_edge_type_ids_from_edge_type_names(ets)?))\n        });\n        let edge_types_ids = edge_types_ids?;\n\n        Graph::build_graph(\n            self.iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)\n                .progress_with(pb)\n                .filter_map(|(_, src, dst, edge_type, weight)| {\n                    if let Some(nis) = &node_ids {\n                        if !nis.contains(src) || !nis.contains(dst) {\n                            return None;\n                        }\n                    }\n                    if let (Some(_min), Some(w)) = (min_weight, weight) {\n                        if _min > w {\n                            return None;\n                        }\n                    }\n                    if let (Some(_max), Some(w)) = (max_weight, weight) {\n                        if w >= _max {\n                            return None;\n                        }\n                    }\n                    if let Some(ets) = &edge_types_ids {\n                        if !ets.contains(&edge_type) {\n                            return None;\n                        }\n                    }\n                    Some(Ok((src, dst, edge_type, weight)))\n                }),\n            self.get_directed_edges_number() as usize,\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.directed,\n            true,\n            self.name.clone(),\n            false,\n            self.has_edge_types(),\n            self.has_edge_weights(),\n            true,\n            true,\n            true,\n        )"
    },
    {
        "file": "types.rs",
        "doc": [
            "Type used to index the Nodes.",
            "Type used to index the Node Types.",
            "Type used to index the Edges.",
            "Type used to index the Edge Types.",
            "Type used for the weights of the edges.",
            "Type used for the parameters of the walk such as the return weight (p),",
            "and the explore weight (q).",
            "Type used to save contexts used for Skipgram and CBOW.",
            "Type used to save a group of words indices.",
            "Type used to save the frequencies of words",
            "Triple of edge data",
            "Quadruple of edge data",
            "Quadrule of string edge data",
            "Trait used for the Vocabulary class.",
            "It represent an unsigned integer that can be converted to and from usize.",
            "This allows us to save memory using indicies of smaller size than u64",
            "and it has no effects on performance because it's optimized away during",
            "compilaton.",
            "create the type from a usize"
        ],
        "modifiers": "",
        "name": "from_usize",
        "args": [
            [
                "v",
                "usize"
            ]
        ],
        "return_type": "Self;\n    /// create an usize frm the type\n    fn to_usize(v: Self) -> usize;\n}\n\n/// Automatically implement the methods needed to convert from and to usize\n/// for the given numerical type.\nmacro_rules! impl_to_from_usize",
        "body": "($($ty:ty)*) => {\n        $(\n            impl ToFromUsize for $ty {\n                #[inline(always)]\n                fn from_usize(v: usize) -> $ty {\n                    v as $ty\n                }\n                #[inline(always)]\n                fn to_usize(v: $ty) -> usize {\n                    v as usize\n                }\n            }\n        )*\n    }"
    },
    {
        "file": "types.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "new",
        "args": [
            [
                "val",
                "T"
            ]
        ],
        "return_type": "ClonableRwLock<T>",
        "body": "ClonableRwLock {\n            value: RwLock::new(val),\n        }"
    },
    {
        "file": "types.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "read",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "RwLockReadGuard<T>",
        "body": "self.value.read().unwrap()"
    },
    {
        "file": "types.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "write",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "RwLockWriteGuard<T>",
        "body": "self.value.write().unwrap()"
    },
    {
        "file": "types.rs",
        "doc": [],
        "modifiers": "",
        "name": "clone",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "ClonableRwLock<T>",
        "body": "ClonableRwLock {\n            value: RwLock::new(self.read().clone()),\n        }"
    },
    {
        "file": "validators.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Validators",
            "The naming convention we follow is:",
            "* `validate_(.+)`",
            "* `must_have_(.+)`"
        ],
        "doc": [
            "Validates provided node ID.",
            "",
            "# Arguments",
            "* `node_id`: NodeT - node ID to validate.",
            "",
            "# Example",
            "In order to validate a given node ID, you can use the following:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(graph.validate_node_id(0).is_ok());",
            "assert!(graph.validate_node_id(100000000).is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "validate_node_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_id",
                "NodeT"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "if node_id >= self.get_nodes_number() {\n            return Err(format!(\n                \"The given node id ({}) is higher than the number of nodes within the graph ({}).\",\n                node_id,\n                self.get_nodes_number()\n            ));\n        }\n        Ok(node_id)"
    },
    {
        "file": "validators.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Validators",
            "The naming convention we follow is:",
            "* `validate_(.+)`",
            "* `must_have_(.+)`"
        ],
        "doc": [
            "Validates provided edge ID.",
            "",
            "# Arguments",
            "* `edge_id`: EdgeT - Edge ID to validate.",
            "",
            "# Example",
            "In order to validate a given edge ID, you can use the following:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(graph.validate_edge_id(0).is_ok());",
            "assert!(graph.validate_edge_id(10000000000).is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "validate_edge_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_id",
                "EdgeT"
            ]
        ],
        "return_type": "Result<EdgeT, String>",
        "body": "if edge_id >= self.get_directed_edges_number() {\n            return Err(format!(\n                \"The given edge id ({}) is higher than the number of edges within the graph ({}).\",\n                edge_id,\n                self.get_directed_edges_number()\n            ));\n        }\n        Ok(edge_id)"
    },
    {
        "file": "validators.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Validators",
            "The naming convention we follow is:",
            "* `validate_(.+)`",
            "* `must_have_(.+)`"
        ],
        "doc": [
            "Validates provided node type ID.",
            "",
            "# Arguments",
            "* `node_type_id`: Option<NodeTypeT> - Node type ID to validate.",
            "",
            "# Example",
            "In order to validate a given node type ID, you can use the following:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(graph.validate_node_type_id(Some(0)).is_ok());",
            "assert!(graph.validate_node_type_id(Some(1000)).is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "validate_node_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_type_id",
                "Option<NodeTypeT>"
            ]
        ],
        "return_type": "Result<Option<NodeTypeT>, String>",
        "body": "self.must_have_node_types()?;\n        if let Some(nti) = node_type_id {\n            if self.get_node_types_number() <= nti {\n                return Err(format!(\n                    \"Given node type ID {:?} is bigger than number of node types in the graph {}.\",\n                    nti,\n                    self.get_node_types_number()\n                ));\n            }\n        }\n        Ok(node_type_id)"
    },
    {
        "file": "validators.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Validators",
            "The naming convention we follow is:",
            "* `validate_(.+)`",
            "* `must_have_(.+)`"
        ],
        "doc": [
            "Validates provided edge type ID.",
            "",
            "# Arguments",
            "* `edge_type_id`: Option<EdgeTypeT> - edge type ID to validate.",
            "",
            "# Example",
            "In order to validate a given edge type ID, you can use the following:",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(graph.validate_edge_type_id(Some(0)).is_ok());",
            "assert!(graph.validate_edge_type_id(Some(1000)).is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "validate_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_type_id",
                "Option<EdgeTypeT>"
            ]
        ],
        "return_type": "Result<Option<EdgeTypeT>, String>",
        "body": "self.must_have_edge_types()?;\n        if let Some(eti) = edge_type_id{\n            if self.get_edge_types_number() <= eti {\n                return Err(format!(\n                    \"Given edge type ID {:?} is bigger than number of edge types in the graph {}.\",\n                    eti,\n                    self.get_edge_types_number()\n                ));\n            }\n        }\n        Ok(edge_type_id)"
    },
    {
        "file": "validators.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Validators",
            "The naming convention we follow is:",
            "* `validate_(.+)`",
            "* `must_have_(.+)`"
        ],
        "doc": [
            "Raises an error if the graph does not have node types.",
            "",
            "# Example",
            "In order to validate a graph instance, you can use:",
            "",
            "```rust",
            "# let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "# let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "assert!(graph_with_node_types.must_have_node_types().is_ok());",
            "assert!(graph_without_node_types.must_have_node_types().is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "must_have_node_types",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "if !self.has_node_types() {\n            return Err(\"The current graph instance does not have node types.\".to_string());\n        }\n        Ok(())"
    },
    {
        "file": "validators.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Validators",
            "The naming convention we follow is:",
            "* `validate_(.+)`",
            "* `must_have_(.+)`"
        ],
        "doc": [
            "Raises an error if the graph does not have edge types.",
            "",
            "# Example",
            "In order to validate a graph instance, you can use:",
            "",
            "```rust",
            "# let graph_with_edge_types = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "# let graph_without_edge_types = graph::test_utilities::load_ppi(false, false, true, true, false, false).unwrap();",
            "assert!(graph_with_edge_types.must_have_edge_types().is_ok());",
            "assert!(graph_without_edge_types.must_have_edge_types().is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "must_have_edge_types",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "if !self.has_edge_types() {\n            return Err(\"The current graph instance does not have edge types.\".to_string());\n        }\n        Ok(())"
    },
    {
        "file": "validators.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Validators",
            "The naming convention we follow is:",
            "* `validate_(.+)`",
            "* `must_have_(.+)`"
        ],
        "doc": [
            "Raises an error if the graph does not have edge types.",
            "",
            "# Example",
            "In order to validate a graph instance, you can use:",
            "",
            "```rust",
            "# let undirecte_graph = graph::test_utilities::load_ppi(false, false, false, false, false, false).unwrap();",
            "# let directed_graph = graph::test_utilities::load_ppi(false, false, true, true, false, false).unwrap();",
            "assert!(undirecte_graph.must_be_undirected().is_ok());",
            "assert!(directed_graph.must_be_undirected().is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "must_be_undirected",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "if self.is_directed() {\n            return Err(\"The current graph instance is not undirected.\".to_string());\n        }\n        Ok(())"
    },
    {
        "file": "validators.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Validators",
            "The naming convention we follow is:",
            "* `validate_(.+)`",
            "* `must_have_(.+)`"
        ],
        "doc": [
            "Raises an error if the graph does not have edge types.",
            "",
            "# Example",
            "In order to validate a graph instance, you can use:",
            "",
            "```rust",
            "# let multigraph = graph::test_utilities::load_ppi(false, true, false, false, false, false).unwrap();",
            "# let homogeneous = graph::test_utilities::load_ppi(false, false, false, false, false, false).unwrap();",
            "assert!(multigraph.must_be_multigraph().is_ok());",
            "assert!(homogeneous.must_be_multigraph().is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "must_be_multigraph",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "if !self.is_multigraph() {\n            return Err(\"The current graph instance is not a multigraph.\".to_string());\n        }\n        Ok(())"
    },
    {
        "file": "validators.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Validators",
            "The naming convention we follow is:",
            "* `validate_(.+)`",
            "* `must_have_(.+)`"
        ],
        "doc": [
            "Raises an error if the graph does not have weights.",
            "",
            "# Example",
            "In order to validate a graph instance, you can use:",
            "",
            "```rust",
            "# let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false).unwrap();",
            "# let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false).unwrap();",
            "assert!(graph_with_weights.must_have_edge_weights().is_ok());",
            "assert!(graph_without_weights.must_have_edge_weights().is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "must_have_edge_weights",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "if !self.has_edge_weights() {\n            return Err(\"The current graph instance does not have weights.\".to_string());\n        }\n        Ok(())"
    },
    {
        "file": "validators.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Validators",
            "The naming convention we follow is:",
            "* `validate_(.+)`",
            "* `must_have_(.+)`"
        ],
        "doc": [
            "Raises an error if the graph does not have any edge.",
            "",
            "# Example",
            "In order to validate a graph instance, you can use:",
            "",
            "```rust",
            "# let graph_with_edges = graph::test_utilities::load_ppi(false, false, true, true, false, false).unwrap();",
            "# let graph_without_edges = graph::test_utilities::load_empty_graph(false);",
            "assert!(graph_with_edges.must_have_edges().is_ok());",
            "assert!(graph_without_edges.must_have_edges().is_err());",
            "```"
        ],
        "modifiers": "pub",
        "name": "must_have_edges",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "if !self.has_edges() {\n            return Err(\"The current graph instance does not have any edge.\".to_string());\n        }\n        Ok(())"
    },
    {
        "file": "metrics.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Properties and measurements of the graph"
        ],
        "doc": [
            "Returns product of degrees of given nodes.",
            "",
            "# Arguments",
            "",
            "* `one`: NodeT - Integer ID of the first node.",
            "* `two`: NodeT - Integer ID of the second node.",
            "=",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The degrees_product between 0 and 1 is {}\", graph.degrees_product(0, 1).unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "degrees_product",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "one",
                "NodeT"
            ],
            [
                "two",
                "NodeT"
            ]
        ],
        "return_type": "Result<usize, String>",
        "body": "if one >= self.get_nodes_number() || two >= self.get_nodes_number() {\n            return Err(format!(\n                concat!(\n                    \"One or more of the given nodes indices ({}, {}) are \",\n                    \"biggen than the number of nodes present in the graph ({}).\"\n                ),\n                one,\n                two,\n                self.get_nodes_number()\n            ));\n        }\n        Ok(self.get_unchecked_node_degree_from_node_id(one) as usize\n            * self.get_unchecked_node_degree_from_node_id(two) as usize)"
    },
    {
        "file": "metrics.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Properties and measurements of the graph"
        ],
        "doc": [
            "Returns the Jaccard index for the two given nodes.",
            "",
            "# Arguments",
            "",
            "* `one`: NodeT - Integer ID of the first node.",
            "* `two`: NodeT - Integer ID of the second node.",
            "",
            "# References",
            "[D. Liben-Nowell, J. Kleinberg.",
            "The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The Jaccard Index between node 1 and node 2 is {}\", graph.jaccard_index(1, 2).unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "jaccard_index",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "one",
                "NodeT"
            ],
            [
                "two",
                "NodeT"
            ]
        ],
        "return_type": "Result<f64, String>",
        "body": "if one >= self.get_nodes_number() || two >= self.get_nodes_number() {\n            return Err(format!(\n                concat!(\n                    \"One or more of the given nodes indices ({}, {}) are \",\n                    \"biggen than the number of nodes present in the graph ({}).\"\n                ),\n                one,\n                two,\n                self.get_nodes_number()\n            ));\n        }\n\n        if self.is_trap_node_from_node_id(one).unwrap()\n            || self.is_trap_node_from_node_id(two).unwrap()\n        {\n            return Ok(0.0f64);\n        }\n\n        let one_neighbors: HashSet<NodeT> = self.iter_unchecked_neighbour_node_ids_from_source_node_id(one).collect();\n        let two_neighbors: HashSet<NodeT> = self.iter_unchecked_neighbour_node_ids_from_source_node_id(two).collect();\n        let intersections: HashSet<NodeT> = one_neighbors\n            .intersection(&two_neighbors)\n            .cloned()\n            .collect();\n\n        Ok(intersections.len() as f64 / (one_neighbors.len() + two_neighbors.len()) as f64)"
    },
    {
        "file": "metrics.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Properties and measurements of the graph"
        ],
        "doc": [
            "Returns the Adamic/Adar Index for the given pair of nodes.",
            "",
            "# Arguments",
            "",
            "* `one`: NodeT - Integer ID of the first node.",
            "* `two`: NodeT - Integer ID of the second node.",
            "",
            "# Implementation details",
            "Since the Adamic/Adar Index is only defined for graph not containing",
            "node traps (nodes without any outbound edge) and must support all kind",
            "of graphs, the sinks node are excluded from",
            "the computation because they would result in an infinity.",
            "",
            "# References",
            "[D. Liben-Nowell, J. Kleinberg.",
            "The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The Adamic/Adar Index between node 1 and node 2 is {}\", graph.adamic_adar_index(1, 2).unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "adamic_adar_index",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "one",
                "NodeT"
            ],
            [
                "two",
                "NodeT"
            ]
        ],
        "return_type": "Result<f64, String>",
        "body": "if self.is_trap_node_from_node_id(one)? || self.is_trap_node_from_node_id(two)? {\n            return Ok(0.0f64);\n        }\n\n        let one_neighbors: HashSet<NodeT> = self.iter_unchecked_neighbour_node_ids_from_source_node_id(one).collect();\n        let two_neighbors: HashSet<NodeT> = self.iter_unchecked_neighbour_node_ids_from_source_node_id(two).collect();\n        let intersections: HashSet<NodeT> = one_neighbors\n            .intersection(&two_neighbors)\n            .cloned()\n            .collect();\n\n        Ok(intersections\n            .par_iter()\n            .filter(|node| !self.is_trap_node_from_node_id(**node).unwrap())\n            .map(|node| 1.0 / (self.get_unchecked_node_degree_from_node_id(*node) as f64).ln())\n            .sum())"
    },
    {
        "file": "metrics.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Properties and measurements of the graph"
        ],
        "doc": [
            "Returns the Resource Allocation Index for the given pair of nodes.",
            "",
            "# Arguments",
            "",
            "* `one`: NodeT - Integer ID of the first node.",
            "* `two`: NodeT - Integer ID of the second node.",
            "",
            "# References",
            "[T. Zhou, L. Lu, Y.-C. Zhang.",
            "Predicting missing links via local information.",
            "Eur. Phys. J. B 71 (2009) 623.](http://arxiv.org/pdf/0901.0553.pdf)",
            "",
            "# Implementation details",
            "Since the Resource Allocation Index is only defined for graph not",
            "containing node traps (nodes without any outbound edge) and",
            "must support all kind of graphs, the sinks node are excluded from",
            "the computation because they would result in an infinity.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The Resource Allocation Index between node 1 and node 2 is {}\", graph.resource_allocation_index(1, 2).unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "resource_allocation_index",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "one",
                "NodeT"
            ],
            [
                "two",
                "NodeT"
            ]
        ],
        "return_type": "Result<f64, String>",
        "body": "if self.is_trap_node_from_node_id(one)? || self.is_trap_node_from_node_id(two)? {\n            return Ok(0.0f64);\n        }\n\n        let one_neighbors: HashSet<NodeT> = self.iter_unchecked_neighbour_node_ids_from_source_node_id(one).collect();\n        let two_neighbors: HashSet<NodeT> = self.iter_unchecked_neighbour_node_ids_from_source_node_id(two).collect();\n        let intersections: HashSet<NodeT> = one_neighbors\n            .intersection(&two_neighbors)\n            .cloned()\n            .collect();\n\n        Ok(intersections\n            .par_iter()\n            .filter(|node| !self.is_trap_node_from_node_id(**node).unwrap())\n            .map(|node| 1.0 / self.get_unchecked_node_degree_from_node_id(*node) as f64)\n            .sum())"
    },
    {
        "file": "remove.rs",
        "struct": "Graph",
        "impl_doc": [
            "# remove."
        ],
        "doc": [
            "Returns a **NEW** Graph that does not have the required attributes.",
            "",
            "# Arguments",
            "* `allow_nodes_set`: Option<HashSet<String>> - Optional set of nodes names to keep.",
            "* `deny_nodes_set`: Option<HashSet<String>> - Optional set of nodes names to remove.",
            "* `allow_node_types_set`: Option<HashSet<String>> - Optional set of node type names to keep.",
            "* `deny_node_types_set`: Option<HashSet<String>> - Optional set of node type names to remove.",
            "* `allow_edge_set`: Option<HashSet<EdgeT>> - Optional set of numeric edge IDs to keep.",
            "* `deny_edge_set`: Option<HashSet<EdgeT>> - Optional set of numeric edge IDs to remove.",
            "* `allow_edge_types_set`: Option<HashSet<String>> - Optional set of edge type names to keep.",
            "* `deny_edge_types_set`: Option<HashSet<String>> - Optional set of edge type names to remove.",
            "* `weights`: bool - Whether to remove the weights.",
            "* `node_types`: bool - Whether to remove the node types.",
            "* `edge_types`: bool - Whether to remove the edge types.",
            "* `singletons`: bool - Whether to remove the singleton nodes.",
            "* `selfloops`: bool - Whether to remove edges with self-loops.",
            "* `verbose`: bool - Whether to show a loading bar while building the graph.",
            "",
            "## Implementation details",
            "",
            "### How the collapse of multigraphs is handled",
            "We keep only the first edge when a multigraph is collapsed while removing",
            "the edge types, in the order provided when first reading from the CSV file.",
            "",
            "### Generation of new singleton nodes when removeping edges",
            "Some of the remove operations allowed in this method might lead to the",
            "generation of new singleton nodes that will not be handled within this",
            "function call even if you provide the flag singletons to true, but you",
            "will need to call the method again if you want to get reed of also those",
            "newly created singleton nodes.",
            ""
        ],
        "modifiers": "pub",
        "name": "remove",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "allow_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "deny_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "allow_node_types_set",
                "Option<HashSet<String>>"
            ],
            [
                "deny_node_types_set",
                "Option<HashSet<String>>"
            ],
            [
                "allow_edge_set",
                "Option<HashSet<EdgeT>>"
            ],
            [
                "deny_edge_set",
                "Option<HashSet<EdgeT>>"
            ],
            [
                "allow_edge_types_set",
                "Option<HashSet<String>>"
            ],
            [
                "deny_edge_types_set",
                "Option<HashSet<String>>"
            ],
            [
                "weights",
                "bool"
            ],
            [
                "node_types",
                "bool"
            ],
            [
                "edge_types",
                "bool"
            ],
            [
                "singletons",
                "bool"
            ],
            [
                "selfloops",
                "bool"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "let pb_edges = get_loading_bar(\n            verbose,\n            format!(\n                \"Building edges of graph {} without required attributes\",\n                self.name\n            )\n            .as_ref(),\n            self.get_directed_edges_number() as usize,\n        );\n        let pb_nodes = get_loading_bar(\n            verbose,\n            format!(\n                \"Building nodes of graph {} without required attributes\",\n                self.name\n            )\n            .as_ref(),\n            self.get_nodes_number() as usize,\n        );\n\n        Graph::from_string_sorted(\n            self.iter_edge_node_names_and_edge_type_name_and_edge_weight(true)\n                .progress_with(pb_edges)\n                .filter_map(\n                    |(edge_id, _, src_name, _, dst_name, _, edge_type, weight)| {\n                        // If an allow edge set was provided\n                        if let Some(aes) = &allow_edge_set {\n                            // We check that the current edge ID is within the edge set.\n                            if !aes.contains(&edge_id) {\n                                return None;\n                            }\n                        }\n                        // If selfloops need to be filtered out.\n                        if selfloops && src_name == dst_name {\n                            return None;\n                        }\n                        // If a deny edge set was provided\n                        if let Some(des) = &deny_edge_set {\n                            // We check that the current edge ID is NOT within the edge set.\n                            if des.contains(&edge_id) {\n                                return None;\n                            }\n                        }\n                        // If an allow nodes set was provided\n                        if let Some(ans) = &allow_nodes_set {\n                            // We check that the current source or destination node name is within the edge set.\n                            if !ans.contains(&src_name) || !ans.contains(&dst_name) {\n                                return None;\n                            }\n                        }\n                        // If a deny nodes set was provided\n                        if let Some(dns) = &deny_nodes_set {\n                            // We check that the current source or destination node name is NOT within the edge set.\n                            if dns.contains(&src_name) || dns.contains(&dst_name) {\n                                return None;\n                            }\n                        }\n                        // If the allow edge types set was provided\n                        if let (Some(aets), Some(et)) = (&allow_edge_types_set, &edge_type) {\n                            // We check that the current edge type name is within the edge type set.\n                            if !aets.contains(et) {\n                                return None;\n                            }\n                        }\n                        // If the deny edge types set was provided\n                        if let (Some(dets), Some(et)) = (&deny_edge_types_set, &edge_type) {\n                            // We check that the current edge type name is NOT within the edge type set.\n                            if dets.contains(et) {\n                                return None;\n                            }\n                        }\n\n                        if allow_node_types_set.is_some() || deny_node_types_set.is_some() {\n                            let src_node_type = self.get_unchecked_node_type_id_from_node_id(\n                                self.get_unchecked_node_id_from_node_name(&src_name),\n                            );\n                            let dst_node_type = self.get_unchecked_node_type_id_from_node_id(\n                                self.get_unchecked_node_id_from_node_name(&dst_name),\n                            );\n                            // If the graph has node types\n                            if let (Some(src_nt), Some(dst_nt)) = (src_node_type, dst_node_type) {\n                                let node_type_names = self\n                                    .get_node_type_names_from_node_type_ids(\n                                        src_nt.into_iter().chain(dst_nt.into_iter()).collect(),\n                                    )\n                                    .unwrap();\n                                // If the allow node types set was provided\n                                if let Some(ants) = &allow_node_types_set {\n                                    // We check that the current node type name is NOT within the node type set.\n                                    if node_type_names\n                                        .iter()\n                                        .any(|node_type_name| !ants.contains(node_type_name))\n                                    {\n                                        return None;\n                                    }\n                                }\n                                // If the deny node types set was provided\n                                if let Some(dnts) = &deny_node_types_set {\n                                    // We check that the current node type name is NOT within the node type set.\n                                    if node_type_names\n                                        .iter()\n                                        .any(|node_type_name| dnts.contains(node_type_name))\n                                    {\n                                        return None;\n                                    }\n                                }\n                            }\n                        }\n\n                        Some(Ok((\n                            src_name,\n                            dst_name,\n                            match edge_types {\n                                false => edge_type,\n                                true => None,\n                            },\n                            match weights {\n                                false => weight,\n                                true => None,\n                            },\n                        )))\n                    },\n                ),\n            Some(self.iter_nodes().progress_with(pb_nodes).filter_map(\n                |(node_id, node_name, _, node_type_names)| {\n                    if singletons && self.is_singleton_from_node_name(&node_name).unwrap() {\n                        return None;\n                    }\n                    // If singletons and selfloops need to be removed.\n                    // We need to check all the destinations of the node if they are equal\n                    // with the source node, as in multigraphs there may be multiple selfloops of different\n                    // node types.\n                    if singletons\n                        && selfloops\n                        && self.is_singleton_with_selfloops_from_node_id(node_id)\n                    {\n                        return None;\n                    }\n                    if let Some(ans) = &allow_nodes_set {\n                        if !ans.contains(&node_name) {\n                            return None;\n                        }\n                    }\n                    if let Some(dns) = &deny_nodes_set {\n                        if dns.contains(&node_name) {\n                            return None;\n                        }\n                    }\n                    if let (Some(ants), Some(nts)) = (&allow_node_types_set, &node_type_names) {\n                        // We check that the current node type name is NOT within the node type set.\n                        if nts\n                            .iter()\n                            .any(|node_type_name| !ants.contains(node_type_name))\n                        {\n                            return None;\n                        }\n                    }\n                    if let (Some(dnts), Some(nts)) = (&deny_node_types_set, &node_type_names) {\n                        // We check that the current node type name is NOT within the node type set.\n                        if nts\n                            .iter()\n                            .any(|node_type_name| dnts.contains(node_type_name))\n                        {\n                            return None;\n                        }\n                    }\n                    Some(Ok((\n                        node_name,\n                        match node_types {\n                            false => node_type_names,\n                            true => None,\n                        },\n                    )))\n                },\n            )),\n            self.directed,\n            true,\n            false,\n            true,\n            true,\n            true,\n            self.get_directed_edges_number() as usize, // Approximation of expected edges number.\n            self.get_nodes_number(),                   // Approximation of expected nodes number.\n            false,\n            false,\n            false,\n            false,\n            self.has_node_types() && !node_types,\n            self.has_edge_types() && !edge_types,\n            self.has_edge_weights() && !weights,\n            // TODO: This may be made more precise!\n            true,\n            self.has_selfloops() && !selfloops,\n            true,\n            self.get_name(),\n        )"
    },
    {
        "file": "remove.rs",
        "struct": "Graph",
        "impl_doc": [
            "# remove."
        ],
        "doc": [
            "remove all the components that are not connected to interesting",
            "nodes and edges.",
            "",
            "# Arguments",
            "* `node_names`: Option<Vec<String>> - The name of the nodes of which components to keep.",
            "* `node_types`: Option<Vec<Option<String>>> - The types of the nodes of which components to keep.",
            "* `edge_types`: Option<Vec<Option<String>>> - The types of the edges of which components to keep.",
            "* `minimum_component_size`: Option<NodeT> - Optional, Minimum size of the components to keep.",
            "* `top_k_components`: Option<NodeT> - Optional, number of components to keep sorted by number of nodes.",
            "* `verbose`: bool - Whether to show the loading bar."
        ],
        "modifiers": "pub",
        "name": "remove_components",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_names",
                "Option<Vec<String>>"
            ],
            [
                "node_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "edge_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "minimum_component_size",
                "Option<NodeT>"
            ],
            [
                "top_k_components",
                "Option<NodeT>"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "let mut keep_components = RoaringBitmap::new();\n        let components_vector = self.get_node_connected_component_ids(verbose);\n\n        // Extend the components so the include the given node Ids and node types.\n        if let Some(node_ids) = self.get_filter_bitmap(node_names, node_types)? {\n            keep_components.extend(\n                node_ids\n                    .iter()\n                    .map(|node_id| components_vector[node_id as usize]),\n            );\n        }\n\n        // Extend the components to keep those that include the given edge types.\n        if let Some(ets) = edge_types {\n            let edge_types_ids: HashSet<Option<EdgeTypeT>> = self\n                .get_edge_type_ids_from_edge_type_names(ets)?\n                .into_iter()\n                .collect();\n\n            let pb = get_loading_bar(\n                verbose,\n                &format!(\n                    \"Computing which components are to keep for the graph {}\",\n                    &self.name\n                ),\n                self.get_directed_edges_number() as usize,\n            );\n\n            self.iter_edge_node_ids_and_edge_type_id(self.directed)\n                .progress_with(pb)\n                .for_each(|(_, src, dst, edge_type)| {\n                    if edge_types_ids.contains(&edge_type) {\n                        keep_components.insert(components_vector[src as usize]);\n                        keep_components.insert(components_vector[dst as usize]);\n                    }\n                });\n        }\n\n        // Create the components counter\n        let component_counts: Vec<(NodeT, NodeT)> =\n            Counter::init(components_vector.clone()).most_common_ordered();\n\n        // Insert the top k biggest components components\n        if let Some(tkc) = top_k_components {\n            for (i, (component_id, _)) in component_counts.iter().enumerate() {\n                if i < tkc as usize {\n                    keep_components.insert(*component_id);\n                }\n            }\n        }\n\n        // Remove components smaller than the given amount\n        if let Some(mcs) = &minimum_component_size {\n            component_counts\n                .iter()\n                .for_each(|(component, component_size)| {\n                    if *component_size < *mcs {\n                        keep_components.remove(*component);\n                    }\n                });\n        }\n\n        let pb = get_loading_bar(\n            verbose,\n            &format!(\n                \"Building edge list with only required components {}\",\n                &self.name\n            ),\n            self.get_directed_edges_number() as usize,\n        );\n        let pb_nodes = get_loading_bar(\n            verbose,\n            &format!(\n                \"Building node list with only required components {}\",\n                &self.name\n            ),\n            self.get_nodes_number() as usize,\n        );\n\n        let min_component_size = keep_components\n            .iter()\n            .map(|component_id| component_counts[component_id as usize].1)\n            .min();\n\n        Graph::from_string_sorted(\n            self.iter_edge_node_names_and_edge_type_name_and_edge_weight(true)\n                .progress_with(pb)\n                .filter_map(\n                    |(_, src, src_name, _, dst_name, _, edge_type_name, weight)| {\n                        // we just check src because dst is trivially in the same component as src\n                        match keep_components.contains(components_vector[src as usize]) {\n                            true => Some(Ok((src_name, dst_name, edge_type_name, weight))),\n                            false => None,\n                        }\n                    },\n                ),\n            Some(self.iter_nodes().progress_with(pb_nodes).filter_map(\n                |(node_id, node_name, _, node_type_names)| {\n                    match keep_components.contains(components_vector[node_id as usize]) {\n                        true => Some(Ok((node_name, node_type_names))),\n                        false => None,\n                    }\n                },\n            )),\n            self.directed,\n            true,\n            false,\n            true,\n            true,\n            true,\n            self.get_directed_edges_number() as usize, // Approximation of expected edges number.\n            self.get_nodes_number(),                   // Approximation of expected nodes number.\n            false,\n            false,\n            false,\n            false,\n            self.has_node_types(),\n            self.has_edge_types(),\n            self.has_edge_weights(),\n            min_component_size.as_ref().map_or(true, |mcs| *mcs <= 1),\n            self.has_singletons_with_selfloops()\n                && min_component_size.as_ref().map_or(true, |mcs| *mcs <= 1),\n            self.has_trap_nodes(),\n            self.get_name(),\n        )"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Return new EdgeFileWriter object.",
            "",
            "# Arguments",
            "",
            "* path: String - Path where to store/load the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "new",
        "generics": "S: Into<String>",
        "args": [
            [
                "path",
                "S"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "EdgeFileWriter {\n            writer: CSVFileWriter::new(path),\n            sources_column: \"subject\".to_string(),\n            sources_column_number: 0,\n            destinations_column: \"object\".to_string(),\n            destinations_column_number: 1,\n            edge_types_column: \"label\".to_string(),\n            edge_types_column_number: 2,\n            weights_column: \"weight\".to_string(),\n            weights_column_number: 3,\n            numeric_node_ids: false,\n            directed: None,\n        }"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column of the source nodes.",
            "",
            "# Arguments",
            "",
            "* sources_column: Option<String> - The source nodes column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_sources_column",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "sources_column",
                "Option<S>"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "if let Some(column) = sources_column {\n            self.sources_column = column.into();\n        }\n        self"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column of the source nodes.",
            "",
            "# Arguments",
            "",
            "* sources_column_number: Option<String> - The source nodes column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_sources_column_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "sources_column_number",
                "Option<usize>"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "if let Some(column_number) = sources_column_number {\n            self.sources_column_number = column_number;\n        }\n        self"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column of the nodes.",
            "",
            "# Arguments",
            "",
            "* destinations_column: Option<String> - The node types column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_destinations_column",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "destinations_column",
                "Option<S>"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "if let Some(column) = destinations_column {\n            self.destinations_column = column.into();\n        }\n        self"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column of the nodes.",
            "",
            "# Arguments",
            "",
            "* destinations_column_number: Option<String> - The node types column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_destinations_column_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "destinations_column_number",
                "Option<usize>"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "if let Some(column_number) = destinations_column_number {\n            self.destinations_column_number = column_number;\n        }\n        self"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column of the nodes.",
            "",
            "# Arguments",
            "",
            "* edge_types_column: Option<String> - The node types column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_edge_types_column",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "edge_type_column",
                "Option<S>"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "if let Some(column) = edge_type_column {\n            self.edge_types_column = column.into();\n        }\n        self"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column of the nodes.",
            "",
            "# Arguments",
            "",
            "* edge_types_column_number: Option<usize> - The node types column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_edge_types_column_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "edge_type_column_number",
                "Option<usize>"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "if let Some(column_number) = edge_type_column_number {\n            self.edge_types_column_number = column_number;\n        }\n        self"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column of the nodes.",
            "",
            "# Arguments",
            "",
            "* weights_column: Option<String> - The node types column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_weights_column",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "weights_column",
                "Option<S>"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "if let Some(column) = weights_column {\n            self.weights_column = column.into();\n        }\n        self"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the column of the nodes.",
            "",
            "# Arguments",
            "",
            "* weights_column_number: Option<usize> - The node types column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_weights_column_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "weights_column_number",
                "Option<usize>"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "if let Some(column_number) = weights_column_number {\n            self.weights_column_number = column_number;\n        }\n        self"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the verbose.",
            "",
            "# Arguments",
            "",
            "* `verbose`: Option<bool> - Whether to show the loading bar or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_verbose",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "verbose",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "if let Some(v) = verbose {\n            self.writer.verbose = v;\n        }\n        self"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the numeric_id.",
            "",
            "# Arguments",
            "",
            "* numeric_id: Option<bool> - Whether to convert numeric Ids to Node Id.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_numeric_node_ids",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "numeric_node_ids",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "if let Some(nni) = numeric_node_ids {\n            self.numeric_node_ids = nni;\n        }\n        self"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the separator.",
            "",
            "# Arguments",
            "",
            "* separator: Option<String> - The separator to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_separator",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "separator",
                "Option<S>"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "if let Some(v) = separator {\n            self.writer.separator = v.into();\n        }\n        self"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the header.",
            "",
            "# Arguments",
            "",
            "* header: Option<bool> - Whether to write out an header or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_header",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "header",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "if let Some(v) = header {\n            self.writer.header = v;\n        }\n        self"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Set the directed.",
            "",
            "# Arguments",
            "",
            "* `directed`: Option<bool> - Whether to write out the graph as directed or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_directed",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "directed",
                "Option<bool>"
            ]
        ],
        "return_type": "EdgeFileWriter",
        "body": "self.directed = directed;\n        self"
    },
    {
        "file": "edge_file_writer.rs",
        "struct": "EdgeFileWriter",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes"
        ],
        "doc": [
            "Write edge file.",
            "",
            "# Arguments",
            "",
            "* `graph`: &Graph - the graph to write out."
        ],
        "modifiers": "pub",
        "name": "dump",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "graph",
                "&Graph"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "let directed: bool = self.directed.unwrap_or_else(|| graph.is_directed());\n        // build the header\n        let mut header = vec![\n            (self.sources_column.clone(), self.sources_column_number),\n            (\n                self.destinations_column.clone(),\n                self.destinations_column_number,\n            ),\n        ];\n\n        if graph.has_edge_types() {\n            header.push((\n                self.edge_types_column.clone(),\n                self.edge_types_column_number,\n            ));\n        }\n\n        if graph.has_edge_weights() {\n            header.push((self.weights_column.clone(), self.weights_column_number));\n        }\n\n        let number_of_columns = 1 + header.iter().map(|(_, i)| i).max().unwrap();\n\n        self.writer.write_lines(\n            graph.get_directed_edges_number() as usize,\n            compose_lines(number_of_columns, header),\n            graph.iter_edge_node_ids_and_edge_type_id_and_edge_weight(directed).map(\n                |(_, src, dst, edge_type, weight)| {\n                    let mut line = vec![\n                        (\n                            match self.numeric_node_ids {\n                                true => src.to_string(),\n                                false => graph.nodes.unchecked_translate(src),\n                            },\n                            self.sources_column_number,\n                        ),\n                        (\n                            match self.numeric_node_ids {\n                                true => dst.to_string(),\n                                false => graph.nodes.unchecked_translate(dst),\n                            },\n                            self.destinations_column_number,\n                        ),\n                    ];\n\n                    if let Some(ets) = &graph.edge_types {\n                        line.push((\n                            edge_type.map_or(\"\".to_string(), |et| ets.unchecked_translate(et)),\n                            self.edge_types_column_number,\n                        ));\n                    }\n\n                    if let Some(w) = weight {\n                        line.push((w.to_string(), self.weights_column_number));\n                    }\n\n                    compose_lines(number_of_columns, line)\n                },\n            ),\n        )"
    },
    {
        "file": "setters.rs",
        "struct": "Graph",
        "doc": [
            "Set the name of the graph.",
            "",
            "# Arguments",
            "",
            "* `name`: String - Name of the graph."
        ],
        "modifiers": "pub",
        "name": "set_name",
        "args": [
            [
                "self",
                "&mut self"
            ],
            [
                "name",
                "String"
            ]
        ],
        "body": "self.invalidate_report();\n        self.name = name;"
    },
    {
        "file": "setters.rs",
        "struct": "Graph",
        "doc": [
            "Invalidate the cache for the textual report.",
            "This should be called as the first line of every methods that either get",
            "a mutable reference to self or get ownership of self."
        ],
        "modifiers": "pub(crate)",
        "name": "invalidate_report",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "body": "*self.cached_report.write() = None;"
    },
    {
        "file": "setters.rs",
        "struct": "Graph",
        "doc": [
            "Replace all edge types (if present) and set all the edge to edge_type.",
            "",
            "# Arguments",
            "* `edge_type`: S - The edge type to assing to all the edges."
        ],
        "modifiers": "pub",
        "name": "set_all_edge_types",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "edge_type",
                "S"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "self.invalidate_report();\n        let mut vocabulary = Vocabulary::default();\n        vocabulary.insert(edge_type.into())?;\n        vocabulary.build_reverse_mapping()?;\n        let edge_types = EdgeTypeVocabulary::from_structs(\n            vec![Some(0); self.get_directed_edges_number() as usize],\n            vocabulary,\n        );\n        self.edge_types = Some(edge_types);\n        Ok(self)"
    },
    {
        "file": "setters.rs",
        "struct": "Graph",
        "doc": [
            "Replace all node types (if present) and set all the node to node_type.",
            "",
            "# Arguments",
            "* `node_type`: S - The node type to assing to all the nodes."
        ],
        "modifiers": "pub",
        "name": "set_all_node_types",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "node_type",
                "S"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "self.invalidate_report();\n        let mut vocabulary = Vocabulary::default();\n        vocabulary.insert(node_type.into())?;\n        vocabulary.build_reverse_mapping()?;\n        let node_types = NodeTypeVocabulary::from_structs(\n            vec![Some(vec![0]); self.get_nodes_number() as usize],\n            Some(vocabulary),\n        );\n        self.node_types = node_types;\n        Ok(self)"
    },
    {
        "file": "walks.rs",
        "doc": [],
        "modifiers": "",
        "name": "update_return_weight_transition",
        "args": [
            [
                "transition",
                "&mut Vec<WeightT>"
            ],
            [
                "destinations",
                "&[NodeT]"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "return_weight",
                "ParamsT"
            ],
            [
                "has_selfloop",
                "bool"
            ]
        ],
        "body": "if let Ok(mut i) = destinations.binary_search(&src) {\n        let mut j = i;\n        while j > 0 && destinations[j] == src {\n            transition[j] *= return_weight;\n            j -= 1;\n        }\n        i += 1;\n        while i < destinations.len() && destinations[i] == src {\n            transition[i] *= return_weight;\n            i += 1;\n        }\n    }\n\n    if src != dst && has_selfloop {\n        if let Ok(mut i) = destinations.binary_search(&dst) {\n            let mut j = i;\n            while j > 0 && destinations[j] == dst {\n                transition[j] *= return_weight;\n                j -= 1;\n            }\n            i += 1;\n            while i < destinations.len() && destinations[i] == dst {\n                transition[i] *= return_weight;\n                i += 1;\n            }\n        }\n    }"
    },
    {
        "file": "walks.rs",
        "doc": [],
        "modifiers": "",
        "name": "rust_update_explore_weight_transition",
        "args": [
            [
                "transition",
                "&mut Vec<WeightT>"
            ],
            [
                "destinations",
                "&[NodeT]"
            ],
            [
                "previous_destinations",
                "&[NodeT]"
            ],
            [
                "explore_weight",
                "ParamsT"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "body": "let mut i = 0;\n    let mut j = 0;\n    let mut v1: NodeT;\n    let mut v2: NodeT;\n    //############################################################\n    //# Handling of the Q parameter: the explore coefficient     #\n    //############################################################\n    // This coefficient increases the probability of switching\n    // to nodes not locally seen.\n    while i < destinations.len() && j < previous_destinations.len() {\n        v1 = destinations[i];\n        v2 = previous_destinations[j];\n        if v1 <= v2 {\n            let is_less = v1 < v2;\n            if is_less && v1 != src && v1 != dst {\n                transition[i] *= explore_weight;\n            }\n            j += !is_less as usize;\n            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    for k in i..destinations.len() {\n        v1 = destinations[k];\n        transition[k] *= 1.0 + (v1 != src && v1 != dst) as u64 as WeightT * (explore_weight - 1.0);\n    }"
    },
    {
        "file": "walks.rs",
        "doc": [],
        "modifiers": "",
        "name": "rust_update_return_explore_weight_transition",
        "args": [
            [
                "transition",
                "&mut Vec<WeightT>"
            ],
            [
                "destinations",
                "&[NodeT]"
            ],
            [
                "previous_destinations",
                "&[NodeT]"
            ],
            [
                "return_weight",
                "ParamsT"
            ],
            [
                "explore_weight",
                "ParamsT"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "body": "let mut i = 0;\n    let mut j = 0;\n    let mut v1: NodeT;\n    let mut v2: NodeT;\n    //############################################################\n    //# Handling of the Q parameter: the explore coefficient     #\n    //############################################################\n    // This coefficient increases the probability of switching\n    // to nodes not locally seen.\n    while i < destinations.len() && j < previous_destinations.len() {\n        v1 = destinations[i];\n        v2 = previous_destinations[j];\n        if v1 == src || v1 == dst {\n            transition[i] *= return_weight;\n            i += 1;\n            continue;\n        }\n        if v1 <= v2 {\n            let is_less = v1 < v2;\n            if is_less {\n                transition[i] *= explore_weight;\n            }\n            j += !is_less as usize;\n            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    for k in i..destinations.len() {\n        v1 = destinations[k];\n        if v1 == src || v1 == dst {\n            transition[k] *= return_weight;\n        } else {\n            transition[k] *= explore_weight;\n        }\n    }"
    },
    {
        "file": "walks.rs",
        "doc": [],
        "modifiers": "",
        "name": "update_explore_weight_transition",
        "args": [
            [
                "transition",
                "&mut Vec<WeightT>"
            ],
            [
                "destinations",
                "&[NodeT]"
            ],
            [
                "previous_destinations",
                "&[NodeT]"
            ],
            [
                "explore_weight",
                "ParamsT"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "body": "#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n    {\n        if is_x86_feature_detected!(\"avx2\") {\n            unsafe {\n                c_update_explore_weight_transition(\n                    transition.as_ptr(),\n                    destinations.as_ptr(),\n                    destinations.len() as u32,\n                    previous_destinations.as_ptr(),\n                    previous_destinations.len() as u32,\n                    explore_weight,\n                    src,\n                    dst,\n                );\n            }\n            return;\n        }\n    }\n    rust_update_explore_weight_transition(\n        transition,\n        destinations,\n        previous_destinations,\n        explore_weight,\n        src,\n        dst,\n    );"
    },
    {
        "file": "walks.rs",
        "doc": [],
        "modifiers": "",
        "name": "update_return_explore_weight_transition",
        "args": [
            [
                "transition",
                "&mut Vec<WeightT>"
            ],
            [
                "destinations",
                "&[NodeT]"
            ],
            [
                "previous_destinations",
                "&[NodeT]"
            ],
            [
                "return_weight",
                "ParamsT"
            ],
            [
                "explore_weight",
                "ParamsT"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "body": "#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n    {\n        if is_x86_feature_detected!(\"avx2\") {\n            unsafe {\n                c_update_return_explore_weight_transition(\n                    transition.as_ptr(),\n                    destinations.as_ptr(),\n                    destinations.len() as u32,\n                    previous_destinations.as_ptr(),\n                    previous_destinations.len() as u32,\n                    explore_weight,\n                    return_weight,\n                    src,\n                    dst,\n                );\n            }\n            return;\n        }\n    }\n    rust_update_return_explore_weight_transition(\n        transition,\n        destinations,\n        previous_destinations,\n        return_weight,\n        explore_weight,\n        src,\n        dst,\n    );"
    },
    {
        "file": "walks.rs",
        "doc": [],
        "modifiers": "",
        "name": "test_update_explore_weight_transition",
        "args": [],
        "body": "let destinations = vec![\n            1, 2, 3, 4, 4, 4, 5, 6, 100, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101,\n            101, 101, 101, 101,\n        ];\n        let previous_destinations = vec![2, 4, 4, 4];\n        let mut transitions = (0..destinations.len())\n            .map(|_| 1.0)\n            .collect::<Vec<WeightT>>();\n        update_explore_weight_transition(\n            &mut transitions,\n            &destinations,\n            &previous_destinations,\n            2.0,\n            6,\n            100,\n        );\n        assert_eq!(\n            transitions,\n            vec![\n                2.0, 1.0, 2.0, 1.0, 1.0, 1.0, 2.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0,\n                2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0\n            ]\n        )"
    },
    {
        "file": "walks.rs",
        "doc": [],
        "modifiers": "",
        "name": "test_update_return_explore_weight_transition",
        "args": [],
        "body": "let destinations = vec![1, 2, 3, 4, 4, 4, 5, 6, 100];\n        let previous_destinations = vec![2, 4, 4, 4];\n        let mut transitions = (0..destinations.len())\n            .map(|_| 1.0)\n            .collect::<Vec<WeightT>>();\n        update_return_explore_weight_transition(\n            &mut transitions,\n            &destinations,\n            &previous_destinations,\n            3.0,\n            2.0,\n            6,\n            100,\n        );\n        assert_eq!(\n            transitions,\n            vec![2.0, 1.0, 2.0, 1.0, 1.0, 1.0, 2.0, 3.0, 3.0]\n        )"
    },
    {
        "file": "walks.rs",
        "doc": [],
        "modifiers": "",
        "name": "test_update_return_weight_transition",
        "args": [],
        "body": "let destinations = vec![1, 2, 3, 4, 4, 4, 5, 6, 100];\n        let mut transitions = (0..destinations.len())\n            .map(|_| 1.0)\n            .collect::<Vec<WeightT>>();\n        update_return_weight_transition(&mut transitions, &destinations, 6, 2, 2.0, true);\n        assert_eq!(\n            transitions,\n            vec![1.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, 2.0, 1.0]\n        )"
    },
    {
        "file": "walks.rs",
        "struct": "Graph",
        "doc": [
            "Return the base weighted transitions.",
            "",
            "# Arguments",
            "",
            "* `min_edge_id`: EdgeT - The minimum edge id.",
            "* `max_edge_id`: EdgeT - The maximum edge id.",
            ""
        ],
        "modifiers": "",
        "name": "get_edge_weighted_transitions",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "min_edge_id",
                "EdgeT"
            ],
            [
                "max_edge_id",
                "EdgeT"
            ],
            [
                "probabilistic_indices",
                "&Option<Vec<u64>>"
            ]
        ],
        "return_type": "Vec<WeightT>",
        "body": "match &probabilistic_indices {\n            Some(indices) => match &self.weights {\n                Some(ws) => indices\n                    .iter()\n                    .map(|edge_id| ws[*edge_id as usize])\n                    .collect(),\n                // Otherwise we return an uniform vector.\n                None => vec![1.0; indices.len()],\n            },\n            None => match &self.weights {\n                Some(ws) => ws[(min_edge_id as usize)..(max_edge_id as usize)].to_vec(),\n                // Otherwise we return an uniform vector.\n                None => vec![1.0; (max_edge_id - min_edge_id) as usize],\n            },\n        }"
    },
    {
        "file": "walks.rs",
        "struct": "Graph",
        "doc": [
            "Updates the the transitions probability score for the change of the node type.",
            "",
            "Specifically, we multiply the transition score by the given `change_node_type_weight`",
            "when the node type changes.",
            "",
            "# Arguments",
            "",
            "* `node`: NodeT - Source node.",
            "* `transition`: &mut Vec<WeightT> - Vector of transitions to update.",
            "* `destinations`: impl Iterator<Item = NodeT> - Iterator of the destinations.",
            "* `change_node_type_weight`: ParamsT - The weight to multiply the transition by if there is a change of node type.",
            ""
        ],
        "modifiers": "",
        "name": "update_node_transition",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "transition",
                "&mut Vec<WeightT>"
            ],
            [
                "destinations",
                "impl Iterator<Item = NodeT>"
            ],
            [
                "change_node_type_weight",
                "ParamsT"
            ]
        ],
        "body": "//############################################################\n        //# Handling of the change node type parameter               #\n        //############################################################\n\n        if not_one(change_node_type_weight) {\n            // If the node types were given:\n            if let Some(nt) = &self.node_types {\n                // if the destination node type matches the neighbour\n                // destination node type (we are not changing the node type)\n                // we weigth using the provided change_node_type_weight weight.\n\n                transition\n                    .iter_mut()\n                    .zip(destinations)\n                    .for_each(|(transition_value, dst)| {\n                        if nt.ids[node as usize] != nt.ids[dst as usize] {\n                            *transition_value *= change_node_type_weight\n                        }\n                    });\n            }\n        }"
    },
    {
        "file": "walks.rs",
        "struct": "Graph",
        "doc": [
            "Return the node transition weights and the related node and edges.",
            "",
            "# Arguments",
            "",
            "* `node`: NodeT, the previous node from which to compute the transitions, if this is bigger that the number of nodes it will panic.",
            "* `walk_weights`: WalkWeights, the weights for the weighted random walks.",
            ""
        ],
        "modifiers": "",
        "name": "get_node_transition",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "walk_weights",
                "&WalkWeights"
            ],
            [
                "min_edge_id",
                "EdgeT"
            ],
            [
                "max_edge_id",
                "EdgeT"
            ],
            [
                "destinations",
                "&[NodeT]"
            ],
            [
                "probabilistic_indices",
                "&Option<Vec<u64>>"
            ]
        ],
        "return_type": "Vec<WeightT>",
        "body": "// Retrieve the data to compute the update transition\n        let mut transition =\n            self.get_edge_weighted_transitions(min_edge_id, max_edge_id, probabilistic_indices);\n\n        // Compute the transition weights relative to the node weights.\n        self.update_node_transition(\n            node,\n            &mut transition,\n            destinations.iter().cloned(),\n            walk_weights.change_node_type_weight,\n        );\n\n        transition"
    },
    {
        "file": "walks.rs",
        "struct": "Graph",
        "doc": [
            "Return the edge transition weights and the related node and edges.",
            "",
            "# Arguments",
            "",
            "* `edge`: EdgeT - the previous edge from which to compute the transitions.",
            "* `weights`: WalkWeights - Weights to use for the weighted walk."
        ],
        "modifiers": "",
        "name": "get_edge_transition",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "edge_id",
                "EdgeT"
            ],
            [
                "walk_weights",
                "&WalkWeights"
            ],
            [
                "min_edge_id",
                "EdgeT"
            ],
            [
                "max_edge_id",
                "EdgeT"
            ],
            [
                "destinations",
                "&[NodeT]"
            ],
            [
                "previous_destinations",
                "&[NodeT]"
            ],
            [
                "probabilistic_indices",
                "&Option<Vec<u64>>"
            ],
            [
                "has_selfloop",
                "bool"
            ]
        ],
        "return_type": "(Vec<WeightT>, EdgeT)",
        "body": "let mut transition =\n            self.get_edge_weighted_transitions(min_edge_id, max_edge_id, probabilistic_indices);\n\n        // Compute the transition weights relative to the node weights.\n        self.update_node_transition(\n            dst,\n            &mut transition,\n            destinations.iter().cloned(),\n            walk_weights.change_node_type_weight,\n        );\n\n        //############################################################\n        //# Handling of the change edge type parameter               #\n        //############################################################\n\n        // If the edge types were given:\n        if not_one(walk_weights.change_edge_type_weight) {\n            if let Some(ets) = &self.edge_types {\n                //# If the neighbour edge type matches the previous\n                //# edge type (we are not changing the edge type)\n                //# we weigth using the provided change_edge_type_weight weight.\n                let this_type: Option<EdgeTypeT> = ets.ids[edge_id as usize];\n                transition\n                    .iter_mut()\n                    .zip(min_edge_id..max_edge_id)\n                    .for_each(|(transition_value, edge_id)| {\n                        if this_type == ets.ids[edge_id as usize] {\n                            *transition_value /= walk_weights.change_edge_type_weight\n                        }\n                    });\n            }\n        }\n\n        //###############################################################\n        //# Handling of the P & Q parameters: the node2vec coefficients #\n        //###############################################################\n        match (\n            not_one(walk_weights.return_weight),\n            not_one(walk_weights.explore_weight),\n        ) {\n            (false, false) => {}\n            (false, true) => {\n                update_explore_weight_transition(\n                    &mut transition,\n                    destinations,\n                    previous_destinations,\n                    walk_weights.explore_weight,\n                    src,\n                    dst,\n                );\n            }\n            (true, false) => {\n                update_return_weight_transition(\n                    &mut transition,\n                    destinations,\n                    src,\n                    dst,\n                    walk_weights.return_weight,\n                    has_selfloop,\n                );\n            }\n            (true, true) => {\n                update_return_explore_weight_transition(\n                    &mut transition,\n                    destinations,\n                    previous_destinations,\n                    walk_weights.return_weight,\n                    walk_weights.explore_weight,\n                    src,\n                    dst,\n                );\n            }\n        }\n\n        (transition, min_edge_id)"
    },
    {
        "file": "walks.rs",
        "struct": "Graph",
        "doc": [
            "Return new sampled node with the transition edge used.",
            "",
            "# Arguments",
            "",
            "* `node`: NodeT, the previous node from which to compute the transitions.",
            "* `random_state`: u64, the random_state to use for extracting the node.",
            ""
        ],
        "modifiers": "",
        "name": "extract_uniform_node",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ]
        ],
        "return_type": "NodeT",
        "body": "let (min_edge, max_edge) = self.get_unchecked_minmax_edge_ids_from_source_node_id(node);\n        let sampled_offset = sample_uniform((max_edge - min_edge) as u64, random_state);\n\n        match self\n            .cached_destinations\n            .as_ref()\n            .and_then(|cds| cds.get(&node))\n        {\n            Some(dsts) => dsts[sampled_offset],\n            None => self\n                .get_unchecked_destination_node_id_from_edge_id(min_edge + sampled_offset as EdgeT),\n        }"
    },
    {
        "file": "walks.rs",
        "struct": "Graph",
        "doc": [
            "Return new sampled node with the transition edge used.",
            "",
            "# Arguments",
            "",
            "* `node`: NodeT, the previous node from which to compute the transitions.",
            "* `random_state`: usize, the random_state to use for extracting the node.",
            "* `walk_weights`: WalkWeights, the weights for the weighted random walks."
        ],
        "modifiers": "",
        "name": "extract_node",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "walk_weights",
                "&WalkWeights"
            ],
            [
                "min_edge_id",
                "EdgeT"
            ],
            [
                "max_edge_id",
                "EdgeT"
            ],
            [
                "destinations",
                "&[NodeT]"
            ],
            [
                "probabilistic_indices",
                "&Option<Vec<u64>>"
            ]
        ],
        "return_type": "(NodeT, EdgeT)",
        "body": "let mut weights = self.get_node_transition(\n            node,\n            walk_weights,\n            min_edge_id,\n            max_edge_id,\n            destinations,\n            probabilistic_indices,\n        );\n        let sampled_offset = sample(&mut weights, random_state);\n        let edge_id = match probabilistic_indices {\n            Some(inds) => inds[sampled_offset],\n            None => min_edge_id + sampled_offset as EdgeT,\n        };\n\n        let destination = match self\n            .cached_destinations\n            .as_ref()\n            .and_then(|cds| cds.get(&node))\n        {\n            Some(dsts) => dsts[sampled_offset],\n            None => self.get_unchecked_destination_node_id_from_edge_id(edge_id),\n        };\n        (destination, edge_id)"
    },
    {
        "file": "walks.rs",
        "struct": "Graph",
        "doc": [
            "Return new random edge with given weights.",
            "",
            "# Arguments",
            "",
            "* `src`: NodeT - Current source node id.",
            "* `dst`: NodeT - Current destination node id.",
            "* `edge`: EdgeT - Current edge id.",
            "* `random_state`: NodeT - The random state to use to sample the next edge id.",
            "* `walk_weights`: &WalkWeights - Struct with the weights to use to update the transitions.",
            "* `min_edge_id`: EdgeT - Minimum edge id to sample for given destination node id.",
            "* `max_edge_id`: EdgeT - Maximum edge id to sample for given destination node id.",
            "* `destinations`: &[NodeT] - Current destinations slice.",
            "* `previous_destinations`: &[NodeT] - Previous destination slice.",
            "* `probabilistic_indices`: &Option<Vec<u64>> - Probabilistic indices, used when max neighbours is provided.",
            ""
        ],
        "modifiers": "",
        "name": "extract_edge",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "edge",
                "EdgeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "walk_weights",
                "&WalkWeights"
            ],
            [
                "min_edge_id",
                "EdgeT"
            ],
            [
                "max_edge_id",
                "EdgeT"
            ],
            [
                "destinations",
                "&[NodeT]"
            ],
            [
                "previous_destinations",
                "&[NodeT]"
            ],
            [
                "probabilistic_indices",
                "&Option<Vec<u64>>"
            ]
        ],
        "return_type": "(NodeT, EdgeT)",
        "body": "let (mut weights, min_edge_id) = self.get_edge_transition(\n            src,\n            dst,\n            edge,\n            walk_weights,\n            min_edge_id,\n            max_edge_id,\n            destinations,\n            previous_destinations,\n            probabilistic_indices,\n            self.has_selfloops(),\n        );\n        let sampled_offset = sample(&mut weights, random_state as u64);\n        let edge_id = match probabilistic_indices {\n            Some(inds) => inds[sampled_offset],\n            None => min_edge_id + sampled_offset as EdgeT,\n        };\n        let destination = match self\n            .cached_destinations\n            .as_ref()\n            .and_then(|cds| cds.get(&dst))\n        {\n            Some(dsts) => dsts[sampled_offset],\n            None => self.get_unchecked_destination_node_id_from_edge_id(edge_id),\n        };\n        (destination, edge_id)"
    },
    {
        "file": "walks.rs",
        "struct": "Graph",
        "doc": [
            "Return vector of walks run on each non-trap node of the graph.",
            "",
            "# Arguments",
            "",
            "* `quantity`: NodeT - Number of random walk to compute.",
            "* `parameters`: &'a WalksParameters - the weighted walks parameters.",
            ""
        ],
        "modifiers": "pub",
        "name": "iter_random_walks",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "quantity",
                "NodeT"
            ],
            [
                "parameters",
                "&'a WalksParameters"
            ]
        ],
        "return_type": "Result<impl IndexedParallelIterator<Item = Vec<NodeT>> + 'a, String>",
        "body": "self.must_have_edges()?;\n        let factor = 0xDEAD;\n        let random_state = splitmix64(parameters.random_state.wrapping_mul(factor) as u64);\n        self.iter_walk(\n            quantity,\n            move |index| {\n                let local_index = index % quantity;\n                let random_source_id =\n                    splitmix64(random_state + local_index.wrapping_mul(factor) as u64) as NodeT;\n                (\n                    splitmix64(random_state + index.wrapping_mul(factor) as u64),\n                    self.get_unchecked_unique_source_node_id(\n                        random_source_id % self.get_unique_source_nodes_number(),\n                    ),\n                )\n            },\n            parameters,\n        )"
    },
    {
        "file": "walks.rs",
        "struct": "Graph",
        "doc": [
            "Return vector of walks run on a random subset of the not trap nodes.",
            "",
            "# Arguments",
            "",
            "* `parameters`: &'a WalksParameters - the weighted walks parameters.",
            ""
        ],
        "modifiers": "pub",
        "name": "iter_complete_walks",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "parameters",
                "&'a WalksParameters"
            ]
        ],
        "return_type": "Result<impl IndexedParallelIterator<Item = Vec<NodeT>> + 'a, String>",
        "body": "self.must_have_edges()?;\n        let factor = 0xDEAD;\n        let random_state = splitmix64(parameters.random_state.wrapping_mul(factor) as u64);\n        self.iter_walk(\n            self.get_unique_source_nodes_number(),\n            move |index| {\n                (\n                    splitmix64(random_state + index.wrapping_mul(factor) as u64),\n                    self.get_unchecked_unique_source_node_id(\n                        index as NodeT % self.get_unique_source_nodes_number(),\n                    ),\n                )\n            },\n            parameters,\n        )"
    },
    {
        "file": "walks.rs",
        "struct": "Graph",
        "doc": [
            "Returns vector of walks.",
            "",
            "# Arguments",
            "",
            "* `parameters`: WalksParameters - the weighted walks parameters.",
            ""
        ],
        "modifiers": "",
        "name": "iter_walk",
        "generics": "'a",
        "args": [
            [
                "self",
                "&'a self"
            ],
            [
                "quantity",
                "NodeT"
            ],
            [
                "to_node",
                "impl Fn(NodeT) -> (u64, NodeT) + Sync + Send + 'a"
            ],
            [
                "parameters",
                "&'a WalksParameters"
            ]
        ],
        "return_type": "Result<impl IndexedParallelIterator<Item = Vec<NodeT>> + 'a, String>",
        "body": "if self.directed {\n            return Err(\"Not supporting directed walks as of now.\".to_owned());\n        }\n\n        // Validate if given parameters are compatible with current graph.\n        parameters.validate(&self)?;\n\n        let total_iterations = quantity * parameters.iterations;\n        info!(\"Starting random walk.\");\n\n        // If the graph does not have any weights and the parameters\n        // for the walks are all equal to 1, we can use the first-order\n        // random walk algorithm.\n        let use_uniform = !self.has_edge_weights() && parameters.is_first_order_walk();\n\n        let walks = (0..total_iterations).into_par_iter().map(move |index| {\n            let (random_state, node) = to_node(index);\n            let mut walk = match use_uniform {\n                true => self.uniform_walk(\n                    node,\n                    random_state,\n                    parameters.single_walk_parameters.walk_length,\n                ),\n                false => self.single_walk(node, random_state, &parameters.single_walk_parameters),\n            };\n\n            if let Some(dense_node_mapping) = &parameters.dense_node_mapping {\n                walk.iter_mut()\n                    .for_each(|node| *node = *dense_node_mapping.get(node).unwrap());\n            }\n            walk\n        });\n\n        Ok(walks)"
    },
    {
        "file": "walks.rs",
        "struct": "Graph",
        "doc": [
            "Returns single walk from given node.",
            "",
            "This method assumes that there are no traps in the graph.",
            "",
            "# Arguments",
            "",
            "* node: NodeT - Node from where to start the random walks.",
            "* `random_state`: usize, the random_state to use for extracting the nodes and edges.",
            "* `parameters`: SingleWalkParameters - Parameters for the single walk.",
            ""
        ],
        "modifiers": "",
        "name": "single_walk",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "parameters",
                "&SingleWalkParameters"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "let (min_edge_id, max_edge_id, destinations, indices) =\n            self.get_node_edges_and_destinations(parameters.max_neighbours, random_state, node);\n        let (dst, edge) = self.extract_node(\n            node,\n            random_state,\n            &parameters.weights,\n            min_edge_id,\n            max_edge_id,\n            self.get_destinations_slice(min_edge_id, max_edge_id, node, &destinations),\n            &indices,\n        );\n\n        let mut result = Vec::with_capacity(parameters.walk_length as usize);\n        result.push(node);\n        result.push(dst);\n        // We iterate two times before because we need to parse the two initial nodes\n\n        let mut previous_min_edge_id = min_edge_id;\n        let mut previous_max_edge_id = max_edge_id;\n        let mut previous_destinations = destinations;\n        let mut previous_src = node;\n        let mut previous_dst = dst;\n        let mut previous_edge = edge;\n\n        for i in 2..parameters.walk_length {\n            let (min_edge_id, max_edge_id, destinations, indices) = self\n                .get_node_edges_and_destinations(\n                    parameters.max_neighbours,\n                    random_state + i,\n                    previous_dst,\n                );\n            let (dst, edge) = self.extract_edge(\n                previous_src,\n                previous_dst,\n                previous_edge,\n                random_state + i,\n                &parameters.weights,\n                min_edge_id,\n                max_edge_id,\n                self.get_destinations_slice(min_edge_id, max_edge_id, previous_dst, &destinations),\n                self.get_destinations_slice(\n                    previous_min_edge_id,\n                    previous_max_edge_id,\n                    previous_src,\n                    &previous_destinations,\n                ),\n                &indices,\n            );\n\n            previous_min_edge_id = min_edge_id;\n            previous_max_edge_id = max_edge_id;\n            previous_destinations = destinations;\n            previous_src = previous_dst;\n            previous_dst = dst;\n            previous_edge = edge;\n            result.push(dst);\n        }\n\n        result"
    },
    {
        "file": "walks.rs",
        "struct": "Graph",
        "doc": [
            "Returns single walk from given node.",
            "",
            "This method assumes that there are no traps in the graph.",
            "",
            "# Arguments",
            "",
            "* node: NodeT - Node from where to start the random walks.",
            "* `random_state`: usize - the random_state to use for extracting the nodes and edges.",
            "* `walk_length`: u64 - Length of the random walk.",
            ""
        ],
        "modifiers": "",
        "name": "uniform_walk",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node",
                "NodeT"
            ],
            [
                "random_state",
                "u64"
            ],
            [
                "walk_length",
                "u64"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "// We iterate one time before because we need to parse the initial node.\n        (0..1)\n            .map(move |_| node)\n            .chain((1..walk_length).scan(node, move |node, iteration| {\n                *node = self.extract_uniform_node(*node, random_state + iteration);\n                Some(*node)\n            }))\n            .collect()"
    },
    {
        "file": "compression.rs",
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "encode_edge",
        "args": [
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ],
            [
                "node_bits",
                "u8"
            ]
        ],
        "return_type": "EdgeT",
        "body": "((src as EdgeT) << node_bits) | dst as EdgeT"
    },
    {
        "file": "compression.rs",
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "encode_max_edge",
        "args": [
            [
                "node",
                "NodeT"
            ],
            [
                "node_bits",
                "u8"
            ]
        ],
        "return_type": "EdgeT",
        "body": "((node as EdgeT) << node_bits) | node as EdgeT"
    },
    {
        "file": "compression.rs",
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "decode_edge",
        "args": [
            [
                "edge",
                "u64"
            ],
            [
                "node_bits",
                "u8"
            ],
            [
                "node_bit_mask",
                "u64"
            ]
        ],
        "return_type": "(NodeT, NodeT)",
        "body": "(\n        (edge >> node_bits) as NodeT,\n        (edge & node_bit_mask) as NodeT,\n    )"
    },
    {
        "file": "compression.rs",
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "get_node_bits",
        "args": [
            [
                "top_node",
                "NodeT"
            ]
        ],
        "return_type": "u8",
        "body": "(1.0 + top_node as f64).log2().ceil() as u8"
    },
    {
        "file": "compression.rs",
        "struct": "Graph",
        "doc": [
            "Return edge value corresponding to given node IDs.",
            "",
            "# Arguments",
            "* `src`: NodeT - The source node ID.",
            "* `dst`: NodeT - The destination node ID."
        ],
        "modifiers": "pub",
        "name": "encode_edge",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "src",
                "NodeT"
            ],
            [
                "dst",
                "NodeT"
            ]
        ],
        "return_type": "u64",
        "body": "encode_edge(src, dst, self.node_bits)"
    },
    {
        "file": "compression.rs",
        "struct": "Graph",
        "doc": [
            "Returns source and destination nodes corresponding to given edge ID.",
            "",
            "# Arguments",
            "* `edge`: u64 - The edge value to decode."
        ],
        "modifiers": "pub",
        "name": "decode_edge",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge",
                "u64"
            ]
        ],
        "return_type": "(NodeT, NodeT)",
        "body": "decode_edge(edge, self.node_bits, self.node_bit_mask)"
    },
    {
        "file": "compression.rs",
        "struct": "Graph",
        "doc": [
            "Return maximum encodable edge number."
        ],
        "modifiers": "pub",
        "name": "get_max_encodable_edge_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "encode_max_edge(\n            self.get_nodes_number(),\n            get_node_bits(self.get_nodes_number()),\n        )"
    },
    {
        "file": "edge_lists.rs",
        "struct": "Graph",
        "doc": [
            "Return vector of tuple of Node IDs that form the edges of the required bipartite graph.",
            "",
            "# Arguments",
            "* `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.",
            "* `first_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the first set of nodes of the graph.",
            "* `second_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the second set of nodes of the graph.",
            "* `first_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the first set of nodes of the graph.",
            "* `second_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the second set of nodes of the graph."
        ],
        "modifiers": "pub",
        "name": "get_bipartite_edges",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "removed_existing_edges",
                "Option<bool>"
            ],
            [
                "first_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "second_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "first_node_types_set",
                "Option<HashSet<String>>"
            ],
            [
                "second_node_types_set",
                "Option<HashSet<String>>"
            ]
        ],
        "return_type": "Result<Vec<Vec<NodeT>>, String>",
        "body": "let removed_existing_edges_unwrapped = removed_existing_edges.unwrap_or(true);\n        let (first_nodes, second_nodes): (Vec<NodeT>, Vec<NodeT>) = [\n            (first_nodes_set, first_node_types_set),\n            (second_nodes_set, second_node_types_set),\n        ]\n        .iter()\n        .map(|(node_set, node_type_set)| {\n            self.iter_nodes()\n                .filter_map(|(node_id, node_name, _, node_type)| {\n                    if let Some(ans) = &node_set {\n                        if !ans.contains(&node_name) {\n                            return None;\n                        }\n                    }\n                    if let (Some(ants), Some(nt)) = (&node_type_set, &node_type) {\n                        if nt\n                            .iter()\n                            .any(|node_type_name| !ants.contains(node_type_name))\n                        {\n                            return None;\n                        }\n                    }\n                    Some(node_id)\n                })\n                .collect::<Vec<NodeT>>()\n        })\n        .collect_tuple()\n        .unwrap();\n\n        if first_nodes.is_empty() {\n            return Err(\"The first nodes set of required bipartite graph is empty!\".to_owned());\n        }\n\n        if second_nodes.is_empty() {\n            return Err(\"The second nodes set of required bipartite graph is empty!\".to_owned());\n        }\n\n        if first_nodes\n            .par_iter()\n            .any(|src| second_nodes.binary_search(src).is_ok())\n        {\n            return Err(\n                \"The giving node sets of the required bipartite graph have shared nodes.\"\n                    .to_owned(),\n            );\n        }\n\n        Ok(first_nodes\n            .par_iter()\n            .flat_map(|src| {\n                second_nodes\n                    .iter()\n                    .filter_map(|dst| {\n                        if removed_existing_edges_unwrapped\n                            && self.has_edge_from_node_ids(*src, *dst)\n                        {\n                            return None;\n                        }\n                        Some(vec![*src, *dst])\n                    })\n                    .collect::<Vec<Vec<NodeT>>>()\n            })\n            .collect())"
    },
    {
        "file": "edge_lists.rs",
        "struct": "Graph",
        "doc": [
            "Return vector of tuple of Node IDs that form the edges of the required bipartite graph.",
            "",
            "# Arguments",
            "* `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.",
            "* `first_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the first set of nodes of the graph.",
            "* `second_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the second set of nodes of the graph.",
            "* `first_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the first set of nodes of the graph.",
            "* `second_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the second set of nodes of the graph."
        ],
        "modifiers": "pub",
        "name": "get_bipartite_edge_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "removed_existing_edges",
                "Option<bool>"
            ],
            [
                "first_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "second_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "first_node_types_set",
                "Option<HashSet<String>>"
            ],
            [
                "second_node_types_set",
                "Option<HashSet<String>>"
            ]
        ],
        "return_type": "Result<Vec<Vec<String>>, String>",
        "body": "Ok(self\n            .get_bipartite_edges(\n                removed_existing_edges,\n                first_nodes_set,\n                second_nodes_set,\n                first_node_types_set,\n                second_node_types_set,\n            )?\n            .iter()\n            .map(|nodes| {\n                nodes\n                    .iter()\n                    .map(|node| self.get_unchecked_node_name_from_node_id(*node))\n                    .collect::<Vec<String>>()\n            })\n            .collect::<Vec<Vec<String>>>())"
    },
    {
        "file": "edge_lists.rs",
        "struct": "Graph",
        "doc": [
            "Return vector of tuple of Node IDs that form the edges of the required star.",
            "",
            "# Arguments",
            "* `central_node`: String - Name of the node to use as center of the star.",
            "* `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.",
            "* `star_points_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the set of star points.",
            "* `star_points_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the set of star points."
        ],
        "modifiers": "pub",
        "name": "get_star_edges",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "central_node",
                "String"
            ],
            [
                "removed_existing_edges",
                "Option<bool>"
            ],
            [
                "star_points_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "star_points_node_types_set",
                "Option<HashSet<String>>"
            ]
        ],
        "return_type": "Result<Vec<Vec<NodeT>>, String>",
        "body": "self.get_bipartite_edges(\n            removed_existing_edges,\n            Some(vec![central_node].into_iter().collect::<HashSet<String>>()),\n            star_points_nodes_set,\n            None,\n            star_points_node_types_set,\n        )"
    },
    {
        "file": "edge_lists.rs",
        "struct": "Graph",
        "doc": [
            "Return vector of tuple of Node names that form the edges of the required star.",
            "",
            "# Arguments",
            "* `central_node`: String - Name of the node to use as center of the star.",
            "* `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.",
            "* `star_points_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the set of star points.",
            "* `star_points_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the set of star points."
        ],
        "modifiers": "pub",
        "name": "get_star_edge_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "central_node",
                "String"
            ],
            [
                "removed_existing_edges",
                "Option<bool>"
            ],
            [
                "star_points_nodes_set",
                "Option<HashSet<String>>"
            ],
            [
                "star_points_node_types_set",
                "Option<HashSet<String>>"
            ]
        ],
        "return_type": "Result<Vec<Vec<String>>, String>",
        "body": "self.get_bipartite_edge_names(\n            removed_existing_edges,\n            Some(vec![central_node].into_iter().collect::<HashSet<String>>()),\n            star_points_nodes_set,\n            None,\n            star_points_node_types_set,\n        )"
    },
    {
        "file": "edge_lists.rs",
        "struct": "Graph",
        "doc": [
            "Return vector of tuple of Node IDs that form the edges of the required clique.",
            "",
            "# Arguments",
            "* `directed`: Option<bool> - Whether to return the edges as directed or undirected. By default, equal to the graph.",
            "* `allow_selfloops`: Option<bool> - Whether to allow self-loops in the clique. By default, equal to the graph.",
            "* `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.",
            "* `allow_node_type_set`: Option<HashSet<String>> - Node types to include in the clique.",
            "* `allow_node_set`: Option<HashSet<String>> - Nodes to include i the clique."
        ],
        "modifiers": "pub",
        "name": "get_clique_edges",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "Option<bool>"
            ],
            [
                "allow_selfloops",
                "Option<bool>"
            ],
            [
                "removed_existing_edges",
                "Option<bool>"
            ],
            [
                "allow_node_type_set",
                "Option<HashSet<String>>"
            ],
            [
                "allow_node_set",
                "Option<HashSet<String>>"
            ]
        ],
        "return_type": "Vec<Vec<NodeT>>",
        "body": "let directed_unwrapped = directed.unwrap_or(self.directed);\n        let allow_selfloops_unwrapped = allow_selfloops.unwrap_or_else(|| self.has_selfloops());\n        let removed_existing_edges_unwrapped = removed_existing_edges.unwrap_or(true);\n        let nodes: Vec<NodeT> = self\n            .iter_nodes()\n            .filter_map(|(node_id, node_name, _, node_type)| {\n                if let (Some(ants), Some(nt)) = (&allow_node_type_set, &node_type) {\n                    if nt\n                        .iter()\n                        .any(|node_type_name| !ants.contains(node_type_name))\n                    {\n                        return None;\n                    }\n                }\n                if let Some(ans) = &allow_node_set {\n                    if !ans.contains(&node_name) {\n                        return None;\n                    }\n                }\n                Some(node_id)\n            })\n            .collect();\n\n        nodes\n            .par_iter()\n            .flat_map(|src| {\n                nodes\n                    .iter()\n                    .filter_map(|dst| {\n                        if !allow_selfloops_unwrapped && src == dst {\n                            return None;\n                        }\n                        if !directed_unwrapped && src > dst {\n                            return None;\n                        }\n                        if removed_existing_edges_unwrapped\n                            && self.has_edge_from_node_ids(*src, *dst)\n                        {\n                            return None;\n                        }\n                        Some(vec![*src, *dst])\n                    })\n                    .collect::<Vec<Vec<NodeT>>>()\n            })\n            .collect()"
    },
    {
        "file": "edge_lists.rs",
        "struct": "Graph",
        "doc": [
            "Return vector of tuple of Node names that form the edges of the required clique.",
            "",
            "# Arguments",
            "* `directed`: Option<bool> - Whether to return the edges as directed or undirected. By default, equal to the graph.",
            "* `allow_selfloops`: Option<bool> - Whether to allow self-loops in the clique. By default, equal to the graph.",
            "* `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.",
            "* `allow_node_type_set`: Option<HashSet<String>> - Node types to include in the clique.",
            "* `allow_node_set`: Option<HashSet<String>> - Nodes to include i the clique."
        ],
        "modifiers": "pub",
        "name": "get_clique_edge_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "Option<bool>"
            ],
            [
                "allow_selfloops",
                "Option<bool>"
            ],
            [
                "removed_existing_edges",
                "Option<bool>"
            ],
            [
                "allow_node_type_set",
                "Option<HashSet<String>>"
            ],
            [
                "allow_node_set",
                "Option<HashSet<String>>"
            ]
        ],
        "return_type": "Vec<Vec<String>>",
        "body": "self.get_clique_edges(\n            directed,\n            allow_selfloops,\n            removed_existing_edges,\n            allow_node_type_set,\n            allow_node_set,\n        )\n        .iter()\n        .map(|nodes| {\n            nodes\n                .iter()\n                .map(|node| self.get_unchecked_node_name_from_node_id(*node))\n                .collect::<Vec<String>>()\n        })\n        .collect::<Vec<Vec<String>>>()"
    },
    {
        "file": "report.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Human readable report of the properties of the graph"
        ],
        "doc": [
            "Returns report relative to the graph metrics",
            "",
            "The report includes a few useful metrics like:",
            "",
            "* degrees_median: the median degree of the nodes.",
            "* degrees_mean: the mean degree of the nodes.",
            "* degrees_mode: the mode degree of the nodes.",
            "* min_degree: the max degree of the nodes.",
            "* max_degree: the min degree of the nodes.",
            "* nodes_number: the number of nodes in the graph.",
            "* edges_number: the number of edges in the graph.",
            "* unique_node_types_number: the number of different node types in the graph.",
            "* unique_edge_types_number: the number of different edge types in the graph.",
            "* traps_rate: probability to end up in a trap when starting into any given node.",
            "* selfloops_rate: pecentage of edges that are selfloops.",
            "* bidirectional_rate: rate of edges that are bidirectional.",
            "",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "graph.report();",
            "```"
        ],
        "modifiers": "pub",
        "name": "report",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "DefaultHashMap<&str, String>",
        "body": "let mut report: DefaultHashMap<&str, String> = DefaultHashMap::new();\n\n        if self.has_nodes() {\n            report.insert(\"density\", self.get_density().unwrap().to_string());\n            report.insert(\n                \"min_degree\",\n                self.get_min_node_degree().unwrap().to_string(),\n            );\n            report.insert(\n                \"max_degree\",\n                self.get_max_node_degree().unwrap().to_string(),\n            );\n            report.insert(\n                \"degree_mean\",\n                self.get_node_degrees_mean().unwrap().to_string(),\n            );\n        }\n\n        if self.has_edges() {\n            report.insert(\n                \"selfloops_rate\",\n                self.get_selfloop_nodes_rate().unwrap().to_string(),\n            );\n        }\n\n        report.insert(\"name\", self.name.clone());\n        report.insert(\"nodes_number\", self.get_nodes_number().to_string());\n        report.insert(\"edges_number\", self.get_directed_edges_number().to_string());\n        report.insert(\n            \"undirected_edges_number\",\n            self.get_undirected_edges_number().to_string(),\n        );\n        report.insert(\"directed\", self.is_directed().to_string());\n        report.insert(\"has_edge_weights\", self.has_edge_weights().to_string());\n        report.insert(\"has_edge_types\", self.has_edge_types().to_string());\n        report.insert(\"has_node_types\", self.has_node_types().to_string());\n        report.insert(\"selfloops_number\", self.get_selfloop_nodes_number().to_string());\n        report.insert(\"singletons\", self.get_singleton_nodes_number().to_string());\n        report.insert(\n            \"unique_node_types_number\",\n            self.get_node_types_number().to_string(),\n        );\n        report.insert(\n            \"unique_edge_types_number\",\n            self.get_edge_types_number().to_string(),\n        );\n        report"
    },
    {
        "file": "report.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Human readable report of the properties of the graph"
        ],
        "doc": [],
        "modifiers": "",
        "name": "shared_components_number",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "nodes_components",
                "&[NodeT]"
            ],
            [
                "other",
                "&Graph"
            ]
        ],
        "return_type": "NodeT",
        "body": "other\n            .iter_nodes()\n            .filter_map(\n                |(_, node_name, _, _)| match self.get_node_id_from_node_name(&node_name) {\n                    Ok(node_id) => Some(nodes_components[node_id as usize]),\n                    Err(_) => None,\n                },\n            )\n            .unique()\n            .count() as NodeT"
    },
    {
        "file": "report.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Human readable report of the properties of the graph"
        ],
        "doc": [
            "Return number of distinct components that are merged by the other graph in current graph.bitvec",
            "",
            "# Arguments",
            "* `nodes_components`: &[NodeT] - Slice with the node components.",
            "* `other`: &Graph - Graph from where to extract the edge list."
        ],
        "modifiers": "",
        "name": "merged_components_number",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "nodes_components",
                "&[NodeT]"
            ],
            [
                "other",
                "&Graph"
            ]
        ],
        "return_type": "NodeT",
        "body": "other\n            .iter_edges(false)\n            .filter_map(|(_, _, src_name, _, dst_name)| {\n                match (\n                    self.get_node_id_from_node_name(&src_name),\n                    self.get_node_id_from_node_name(&dst_name),\n                ) {\n                    (Ok(src_id), Ok(dst_id)) => {\n                        let src_component_number = nodes_components[src_id as usize];\n                        let dst_component_number = nodes_components[dst_id as usize];\n                        match src_component_number == dst_component_number {\n                            true => None,\n                            false => Some(vec![src_component_number, dst_component_number]),\n                        }\n                    }\n                    _ => None,\n                }\n            })\n            .flatten()\n            .unique()\n            .count() as NodeT"
    },
    {
        "file": "report.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Human readable report of the properties of the graph"
        ],
        "doc": [
            "Return rendered textual report about the graph overlaps.",
            "",
            "# Arguments",
            "",
            "* `other`: &Graph - graph to create overlap report with.",
            "* `verbose`: bool - Whether to shor the loading bars."
        ],
        "modifiers": "pub",
        "name": "overlap_textual_report",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "other",
                "&Graph"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "// Checking if overlap is allowed\n        self.validate_operator_terms(other)?;\n        // Get overlapping nodes\n        let overlapping_nodes_number = self\n            .iter_nodes()\n            .filter(|(_, node_name, _, node_type)| {\n                other.has_node_from_node_name_and_node_type_name(node_name, node_type.clone())\n            })\n            .count();\n        // Get overlapping edges\n        let overlapping_edges_number = self\n            .par_iter_edge_node_names_and_edge_type_name(self.directed)\n            .filter(|(_, _, src_name, _, dst_name, _, edge_type_name)| {\n                other.has_edge_from_node_names_and_edge_type_name(\n                    src_name,\n                    dst_name,\n                    edge_type_name.as_ref(),\n                )\n            })\n            .count();\n        // Get number of overlapping components\n        let first_nodes_components = self.get_node_connected_component_ids(verbose);\n        let second_nodes_components = other.get_node_connected_component_ids(verbose);\n        let first_components_number = first_nodes_components.iter().unique().count() as NodeT;\n        let second_components_number = second_nodes_components.iter().unique().count() as NodeT;\n        let first_shared_components_number =\n            self.shared_components_number(&first_nodes_components, other);\n        let second_shared_components_number =\n            other.shared_components_number(&second_nodes_components, self);\n        // Get number of overlapping components\n        let first_merged_components_number =\n            self.merged_components_number(&first_nodes_components, other);\n        let second_merged_components_number =\n            other.merged_components_number(&second_nodes_components, self);\n\n        let first_edges = match self.directed {\n            true => self.get_directed_edges_number(),\n            false => self.get_undirected_edges_number(),\n        };\n        let second_edges = match other.directed {\n            true => other.get_directed_edges_number(),\n            false => other.get_undirected_edges_number(),\n        };\n        // Building up the report\n        Ok(format!(\n            concat!(\n                \"The graph {first_graph} and the graph {second_graph} share {nodes_number} nodes and {edges_number} edges. \",\n                \"By percent, {first_graph} shares {first_node_percentage:.2}% ({nodes_number} out of {first_nodes}) of its nodes and {first_edge_percentage:.2}% ({edges_number} out of {first_edges}) of its edges with {second_graph}. \",\n                \"{second_graph} shares {second_node_percentage:.2}% ({nodes_number} out of {second_nodes}) of its nodes and {second_edge_percentage:.2}% ({edges_number} out of {second_edges}) of its edges with {first_graph}. \",\n                \"Nodes from {first_graph} appear in {first_components_statement} components of {second_graph}{first_merged_components_statement}. \",\n                \"Similarly, nodes from {second_graph} appear in {second_components_statement} components of {first_graph}{second_merged_components_statement}. \",\n            ),\n            first_graph=self.get_name(),\n            second_graph=other.get_name(),\n            nodes_number=overlapping_nodes_number,\n            edges_number=overlapping_edges_number,\n            first_nodes=self.get_nodes_number(),\n            second_nodes=other.get_nodes_number(),\n            first_edges=first_edges,\n            second_edges=second_edges,\n            first_components_statement = match second_shared_components_number== second_components_number{\n                true=> \"all the\".to_owned(),\n                false => format!(\n                    \"{second_shared_components_number} of the {second_components_number}\",\n                    second_shared_components_number=second_shared_components_number,\n                    second_components_number=second_components_number\n                )\n            },\n            second_components_statement = match first_shared_components_number== first_components_number{\n                true=> \"all the\".to_owned(),\n                false => format!(\n                    \"{first_shared_components_number} of the {first_components_number}\",\n                    first_shared_components_number=first_shared_components_number,\n                    first_components_number=first_components_number\n                )\n            },\n            first_merged_components_statement = match second_components_number > 1 {\n                false=>\"\".to_owned(),\n                true=>format!(\n                    \": of these, {edges_number} connected by edges of {first_graph}\",\n                    first_graph=self.name,\n                    edges_number= match second_merged_components_number {\n                        d if d==0=>\"none are\".to_owned(),\n                        d if d==1=>\"one is\".to_owned(),\n                        d if d==second_components_number=>\"all components are\".to_owned(),\n                        _ => format!(\"{} components are\", second_merged_components_number)\n                    })\n                },\n            second_merged_components_statement = match first_components_number > 1 {\n                false=>\"\".to_owned(),\n                true=>format!(\n                    \": of these, {edges_number} connected by edges of {second_graph}\",\n                    second_graph=other.name,\n                    edges_number= match first_merged_components_number {\n                        d if d==0=>\"none are\".to_owned(),\n                        d if d==1=>\"one is\".to_owned(),\n                        d if d==first_components_number=>\"all components are\".to_owned(),\n                        _ => format!(\"{} components are\", first_merged_components_number)\n                    })\n                },\n            first_node_percentage=100.0*(overlapping_nodes_number as f64 / self.get_nodes_number() as f64),\n            second_node_percentage=100.0*(overlapping_nodes_number as f64 / other.get_nodes_number() as f64),\n            first_edge_percentage=100.0*(overlapping_edges_number as f64 / first_edges as f64),\n            second_edge_percentage=100.0*(overlapping_edges_number as f64 / second_edges as f64),\n        ))"
    },
    {
        "file": "report.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Human readable report of the properties of the graph"
        ],
        "doc": [],
        "modifiers": "",
        "name": "format_list",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "list",
                "&[String]"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "if list.is_empty() {\n            return Err(\"Cannot format a list with no elements.\".to_owned());\n        }\n        if list.len() == 1 {\n            return Ok(list.first().unwrap().clone());\n        }\n        let all_minus_last: String = list[0..list.len() - 1].join(\", \");\n        Ok(format!(\n            \"{all_minus_last} and {last}\",\n            all_minus_last = all_minus_last,\n            last = list.last().unwrap()\n        ))"
    },
    {
        "file": "report.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Human readable report of the properties of the graph"
        ],
        "doc": [
            "Return formatted node list.",
            "",
            "# Arguments",
            "* `node_list`: &[NodeT] - list of nodes to be formatted."
        ],
        "modifiers": "",
        "name": "format_node_list",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_list",
                "&[NodeT]"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "self.format_list(\n            node_list\n                .iter()\n                .map(|node_id| {\n                    format!(\n                        \"{node_name} (degree {node_degree})\",\n                        node_name = self.get_unchecked_node_name_from_node_id(*node_id),\n                        node_degree = self.get_unchecked_node_degree_from_node_id(*node_id)\n                    )\n                })\n                .collect::<Vec<String>>()\n                .as_slice(),\n        )"
    },
    {
        "file": "report.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Human readable report of the properties of the graph"
        ],
        "doc": [
            "Return formatted node type list.",
            "",
            "# Arguments",
            "* `node_types_list`: &[NodeT] - list of nodes to be formatted."
        ],
        "modifiers": "",
        "name": "format_node_type_list",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "node_types_list",
                "&[(NodeTypeT, usize)]"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "self.format_list(\n            node_types_list\n                .iter()\n                .map(|(node_type_id, number)| {\n                    format!(\n                        \"{node_type} (nodes number {node_degree})\",\n                        node_type = self\n                            .get_node_type_name_from_node_type_id(*node_type_id)\n                            .unwrap(),\n                        node_degree = number\n                    )\n                })\n                .collect::<Vec<String>>()\n                .as_slice(),\n        )"
    },
    {
        "file": "report.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Human readable report of the properties of the graph"
        ],
        "doc": [
            "Return formatted edge type list.",
            "",
            "# Arguments",
            "* `edge_types_list`: &[edgeT] - list of edges to be formatted."
        ],
        "modifiers": "",
        "name": "format_edge_type_list",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "edge_types_list",
                "&[(EdgeTypeT, usize)]"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "self.format_list(\n            edge_types_list\n                .iter()\n                .map(|(edge_type_id, _)| {\n                    self.get_edge_type_name_from_edge_type_id(*edge_type_id)\n                        .unwrap()\n                })\n                .collect::<Vec<String>>()\n                .as_slice(),\n        )"
    },
    {
        "file": "report.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Human readable report of the properties of the graph"
        ],
        "doc": [
            "Return rendered textual report of the graph.",
            "",
            "# Arguments",
            "* `verbose`: bool - Whether to show loading bar."
        ],
        "modifiers": "pub",
        "name": "textual_report",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "{\n            let ptr = self.cached_report.read();\n            if let Some(report) = &*ptr {\n                return Ok(report.clone());\n            }\n        }\n\n        if !self.has_nodes() {\n            return Ok(format!(\"The graph {} is empty.\", self.get_name()));\n        }\n\n        let mut ptr = self.cached_report.write();\n        // THis is not a duplicate of above because we need to\n        // check if another thread already filled the cache\n        if let Some(report) = &*ptr {\n            return Ok(report.clone());\n        }\n\n        let (connected_components_number, minimum_connected_component, maximum_connected_component) =\n            self.get_connected_components_number(verbose);\n\n        let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        let hash = hasher.finish();\n\n        *ptr = Some(format!(\n            concat!(\n                \"The {direction} {graph_type} {name} has {nodes_number} nodes{node_types}{singletons} and {edges_number} {weighted} edges{edge_types}, of which {selfloops}{selfloops_multigraph_connector}{multigraph_edges}. \",\n                \"The graph is {quantized_density} as it has a density of {density:.5} and {connected_components}. \",\n                \"The graph median node degree is {median_node_degree}, the mean node degree is {mean_node_degree:.2}, and the node degree mode is {mode_node_degree}. \",\n                \"The top {most_common_nodes_number} most central nodes are {central_nodes}. \",\n                \"The hash of the graph is {hash:08x}.\"\n            ),\n            hash = hash,\n            direction = match self.directed {\n                true=> \"directed\",\n                false => \"undirected\"\n            }.to_owned(),\n            graph_type = match self.is_multigraph() {\n                true=> \"multigraph\",\n                false => \"graph\"\n            }.to_owned(),\n            name = self.name,\n            nodes_number = self.get_nodes_number(),\n            edges_number = self.get_edges_number(),\n            weighted = match self.has_edge_weights(){\n                true=> \"weighted\",\n                false=> \"unweighted\"\n            }.to_owned(),\n            selfloops = match self.has_selfloops() {\n                true => format!(\"{} are self-loops\", self.get_selfloop_nodes_number()),\n                false => \"none are self-loops\".to_owned()\n            },\n            selfloops_multigraph_connector = match self.is_multigraph() {\n                true => \" and \".to_owned(),\n                false => \"\".to_owned()\n            },\n            multigraph_edges = match self.is_multigraph() {\n                true=>match self.get_multigraph_edges_number()>0 {\n                    true => format!(\"{} are parallel\", self.get_multigraph_edges_number()),\n                    false => \"none are parallel\".to_owned()\n                },\n                false=>\"\".to_owned()\n            },\n            node_types= match self.get_node_types_number() {\n                ntn if ntn==1 => format!(\n                    \" with a single node type: {node_type}\",\n                    node_type={\n                        let node_types = self.get_node_type_counter()?;\n                        self.format_node_type_list(node_types.most_common().as_slice())?\n                    }\n                ),\n                ntn if ntn > 1 => format!(\n                    \" with {node_types_number} different {multilabel}node types: {most_common_node_types}{unknown_node_types}.\",\n                    node_types_number=ntn,\n                    multilabel=match self.has_multilabel_node_types(){\n                        true=>\"multi-label \",\n                        false=>\"\"\n                    },\n                    most_common_node_types={\n                        let node_types = self.get_node_type_counter()?;\n                        let most_common = node_types.most_common();\n                        match most_common.len()>5 {\n                            true=>format!(\" the 5 most common are {}\", self.format_node_type_list(most_common[0..5].as_ref())?),\n                            false=>self.format_node_type_list(most_common.as_slice())?\n                        }\n                    },\n                    unknown_node_types={\n                        match self.has_unknown_node_types(){\n                            true=>{\n                                let unknown_nodes_number=self.get_unknown_node_types_number();\n                                let percentage = 100.0*(unknown_nodes_number as f64 / self.get_nodes_number() as f64);\n                                format!(\" and there are {} unknown node types ({:.2}%)\", unknown_nodes_number, percentage)\n                            },\n                            false=>\"\".to_owned()\n                        }\n                    }\n                ),\n                _ => \"\".to_owned()\n            },\n            singletons = match self.has_singletons() {\n                true => format!(\n                    \" There are {singleton_number} singleton nodes{selfloop_singleton},\", \n                    singleton_number=self.get_singleton_nodes_number(),\n                    selfloop_singleton=match self.has_singletons_with_selfloops(){\n                        true=>format!(\" ({} have self-loops)\", match self.get_singleton_nodes_number()==self.get_singleton_nodes_with_selfloops_number(){\n                            true=>\"all\".to_owned(),\n                            false=>format!(\"{} of these\", self.get_singleton_nodes_with_selfloops_number())\n                        }),\n                        false=>\"\".to_owned()\n                    }\n                ),\n                false => \"\".to_owned()\n            },\n            edge_types= match self.get_edge_types_number() {\n                etn if etn==1 => format!(\n                    \" with a single edge type: {edge_type}\",\n                    edge_type={\n                        let edge_types = self.get_edge_type_counter()?;\n                        self.format_edge_type_list(edge_types.most_common().as_slice())?\n                    }\n                ),\n                etn if etn > 1 => format!(\n                    \" with {edge_types_number} different edge types: {most_common_edge_types}{unknown_edge_types}\",\n                    edge_types_number=etn,\n                    most_common_edge_types={\n                        let edge_types = self.get_edge_type_counter()?;\n                        let most_common = edge_types.most_common();\n                        match most_common.len()>5 {\n                            true=>format!(\" the 5 most common are {}\", self.format_edge_type_list(most_common[0..5].as_ref())?),\n                            false=>self.format_edge_type_list(most_common.as_slice())?\n                        }\n                    },\n                    unknown_edge_types={\n                        match self.has_unknown_edge_types(){\n                            true=>{\n                                let unknown_edges_number=self.get_unknown_edge_types_number();\n                                let percentage = 100.0*(unknown_edges_number as f64 / self.get_directed_edges_number() as f64);\n                                format!(\". There are {} unknown edge types ({:.2}%).\", unknown_edges_number, percentage)\n                            },\n                            false=>\"\".to_owned()\n                        }\n                    }\n                ),\n                _ => \"\".to_owned()\n            },\n            quantized_density = match self.get_density().unwrap() {\n                d if d < 0.0001 => \"extremely sparse\".to_owned(),\n                d if d < 0.001 => \"quite sparse\".to_owned(),\n                d if d < 0.01 => \"sparse\".to_owned(),\n                d if d < 0.1 => \"dense\".to_owned(),\n                d if d < 0.5 => \"quite dense\".to_owned(),\n                d if (d - 1.0).abs() < f64::EPSILON => \"complete\".to_owned(),\n                d if d <= 1.0 => \"extremely dense\".to_owned(),\n                d => unreachable!(format!(\"Unreacheable density case {}\", d))\n            },\n            density=self.get_density().unwrap(),\n            connected_components=match connected_components_number> 1{\n                true=>format!(\n                    \"has {components_number} connected components, where the component with most nodes has {maximum_connected_component} and the component with the least nodes has {minimum_connected_component}\",\n                    components_number=connected_components_number,\n                    maximum_connected_component=match maximum_connected_component==1{\n                        true=>\"a single node\".to_owned(),\n                        false=>format!(\"{} nodes\", maximum_connected_component)\n                    },\n                    minimum_connected_component=match minimum_connected_component==1{\n                        true=>\"a single node\".to_owned(),\n                        false=>format!(\"{} nodes\", minimum_connected_component)\n                    }\n                ),\n                false=>\"is connected, as it has a single component\".to_owned()\n            },\n            median_node_degree=self.get_node_degrees_median().unwrap(),\n            mean_node_degree=self.get_node_degrees_mean().unwrap(),\n            mode_node_degree=self.get_node_degrees_mode().unwrap(),\n            most_common_nodes_number=std::cmp::min(5, self.get_nodes_number()),\n            central_nodes = self.format_node_list(self.get_top_k_central_node_ids(std::cmp::min(5, self.get_nodes_number())).as_slice())?\n        ));\n\n        Ok(ptr.clone().unwrap())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number a triple with (number of components, number of nodes of the smallest component, number of nodes of the biggest component )",
            "",
            "# Arguments",
            "",
            "* `verbose`: bool - Whether to show a loading bar or not."
        ],
        "modifiers": "pub",
        "name": "get_connected_components_number",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "(NodeT, NodeT, NodeT)",
        "body": "info!(\"Computing connected components number.\");\n        if self.directed {\n            let (_, _, components_number, min_component_size, max_component_size) =\n                self.spanning_arborescence_kruskal(verbose);\n            (components_number, min_component_size, max_component_size)\n        } else {\n            info!(\"Executing undirected parallel version of connected components.\");\n            let (_, components_number, min_component_size, max_component_size) =\n                self.connected_components(verbose).unwrap();\n            (components_number, min_component_size, max_component_size)\n        }"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of singleton nodes within the graph.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The graph contains {} singleton nodes\", graph.get_singleton_nodes_number());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_singleton_nodes_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.get_nodes_number() - self.get_not_singleton_nodes_number()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of singleton nodes with self-loops within the graph.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The graph contains {} singleton nodes with self-loops\", graph.get_singleton_nodes_with_selfloops_number());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_singleton_nodes_with_selfloops_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.singleton_nodes_with_selfloops_number"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of not singleton nodes within the graph.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The graph contains {} not singleton nodes\", graph.get_not_singleton_nodes_number());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_not_singleton_nodes_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.not_singleton_nodes_number"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns density of the graph.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The graph density is {}\", graph.get_density().unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_density",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<f64, String>",
        "body": "if !self.has_nodes() {\n            return Err(\"The density of an empty graph is undefined.\".to_string());\n        }\n        if !self.has_edges() {\n            return Ok(0.0);\n        }\n        let nodes_number = self.get_nodes_number() as EdgeT;\n        let total_nodes_number = nodes_number\n            * match self.has_selfloops() {\n                true => nodes_number,\n                false => nodes_number - 1,\n            };\n        Ok(self.unique_edges_number as f64 / total_nodes_number as f64)"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns the traps rate of the graph.",
            "",
            "THIS IS EXPERIMENTAL AND MUST BE PROVEN!",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The Graph rate is {}\", graph.get_trap_nodes_rate());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_trap_nodes_rate",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "f64",
        "body": "self.par_iter_node_ids()\n            .map(|node| {\n                if !self.is_trap_node_from_node_id(node).unwrap() {\n                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(node)\n                        .map(|dst| self.is_trap_node_from_node_id(dst).unwrap() as usize as f64)\n                        .sum::<f64>()\n                        / self.get_unchecked_node_degree_from_node_id(node) as f64\n                } else {\n                    1.0\n                }\n            })\n            .sum::<f64>()\n            / self.get_nodes_number() as f64"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns mean node degree of the graph.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The mean node degree of the graph is  {}\", graph.get_node_degrees_mean().unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_node_degrees_mean",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<f64, String>",
        "body": "if !self.has_nodes() {\n            return Err(\n                \"The mean of the node degrees is not defined on an empty graph\".to_string(),\n            );\n        }\n        Ok(self.get_directed_edges_number() as f64 / self.get_nodes_number() as f64)"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of undirected edges of the graph.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of undirected edges of the graph is  {}\", graph.get_undirected_edges_number());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_undirected_edges_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "(self.get_directed_edges_number() - self.get_selfloop_nodes_number()) / 2\n            + self.get_selfloop_nodes_number()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of undirected edges of the graph.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of unique undirected edges of the graph is  {}\", graph.get_unique_undirected_edges_number());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_unique_undirected_edges_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "(self.unique_edges_number - self.get_unique_selfloop_number() as EdgeT) / 2\n            + self.get_unique_selfloop_number() as EdgeT"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of edges of the graph.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of edges of the graph is  {}\", graph.get_edges_number());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_edges_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "match self.directed {\n            true => self.get_directed_edges_number(),\n            false => self.get_undirected_edges_number(),\n        }"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of unique edges of the graph.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of edges of the graph is  {}\", graph.get_unique_edges_number());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_unique_edges_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "match self.directed {\n            true => self.get_unique_directed_edges_number(),\n            false => self.get_unique_undirected_edges_number(),\n        }"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns median node degree of the graph",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The median node degree of the graph is  {}\", graph.get_node_degrees_median().unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_node_degrees_median",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "if !self.has_nodes() {\n            return Err(\n                \"The median of the node degrees is not defined on an empty graph\".to_string(),\n            );\n        }\n        let mut degrees = self.get_node_degrees();\n        degrees.par_sort_unstable();\n        Ok(degrees[(self.get_nodes_number() / 2) as usize])"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns maximum node degree of the graph.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The maximum node degree of the graph is  {}\", graph.get_max_node_degree().unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_max_node_degree",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "self.get_node_degrees().into_iter().max().ok_or_else(|| {\n            \"The maximum node degree of a graph with no nodes is not defined.\".to_string()\n        })"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns minimum node degree of the graph.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The minimum node degree of the graph is  {}\", graph.get_min_node_degree().unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_min_node_degree",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "self.get_node_degrees().into_iter().min().ok_or_else(|| {\n            \"The minimum node degree of a graph with no nodes is not defined.\".to_string()\n        })"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns mode node degree of the graph.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The mode node degree of the graph is  {}\", graph.get_node_degrees_mode().unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_node_degrees_mode",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<NodeT, String>",
        "body": "if !self.has_nodes() {\n            return Err(\n                \"The mode of the node degrees is not defined on an empty graph\".to_string(),\n            );\n        }\n        let counter: Counter<NodeT, usize> = Counter::init(self.iter_node_degrees());\n        Ok(*counter\n            .iter()\n            .max_by_key(|&(_, count)| count)\n            .map(|(degree, _)| degree)\n            .unwrap())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of self-loops, including also those in eventual multi-edges.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of self-loops in the graph is  {}\", graph.get_selfloop_nodes_number());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_selfloop_nodes_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.selfloop_number"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of unique self-loops, excluding those in eventual multi-edges.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of unique self-loops in the graph is  {}\", graph.get_unique_selfloop_number());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_unique_selfloop_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.unique_selfloop_number"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns rate of self-loops.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The rate of self-loops in the graph is  {}\", graph.get_selfloop_nodes_rate().unwrap());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_selfloop_nodes_rate",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<f64, String>",
        "body": "if !self.has_edges() {\n            return Err(\"The self-loops rate is not defined for graphs without edges.\".to_string());\n        }\n        Ok(self.get_selfloop_nodes_number() as f64 / self.get_directed_edges_number() as f64)"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return name of the graph.",
            "",
            "# Example",
            "To the retrieve the name of the current graph instance selfloop_number can use:",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert_eq!(graph.get_name(), \"STRING PPI\".to_string());",
            "println!(\"The name of the current graph is {}.\", graph.get_name());",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "get_name",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "String",
        "body": "self.name.clone()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return the number of traps (nodes without any outgoing edges that are not singletons)",
            "This also includes nodes with only a self-loops, therefore singletons with",
            "only a self-loops are not considered traps because you could make a walk on them.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"There are {} trap nodes in the current graph.\", graph.get_trap_nodes_number());",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "get_trap_nodes_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "(self.get_not_singleton_nodes_number() + self.get_singleton_nodes_with_selfloops_number()\n            - self.get_unique_source_nodes_number()) as EdgeT"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return vector of the non-unique source nodes.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "get_sources",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "self.par_iter_source_node_ids(directed).collect()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return vector of the non-unique source nodes names.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "get_source_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Vec<String>",
        "body": "self.par_iter_source_node_ids(directed)\n            .map(|src| self.get_unchecked_node_name_from_node_id(src))\n            .collect()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return vector on the (non unique) destination nodes of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "get_destinations",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "self.par_iter_destination_node_ids(directed).collect()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return vector of the non-unique destination nodes names.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "get_destination_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Vec<String>",
        "body": "self.par_iter_destination_node_ids(directed)\n            .map(|dst| self.get_unchecked_node_name_from_node_id(dst))\n            .collect()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return vector with the sorted nodes names."
        ],
        "modifiers": "pub",
        "name": "get_node_names",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Vec<String>",
        "body": "self.nodes.reverse_map.clone()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return vector with the sorted nodes Ids."
        ],
        "modifiers": "pub",
        "name": "get_nodes",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "self.iter_node_ids().collect()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return the edge types of the edges."
        ],
        "modifiers": "pub",
        "name": "get_edge_types",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<Vec<Option<EdgeTypeT>>, String>",
        "body": "self.must_have_edge_types()?;\n        Ok(self.edge_types.as_ref().map(|ets| ets.ids.clone()).unwrap())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return the edge types names."
        ],
        "modifiers": "pub",
        "name": "get_edge_type_names",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Option<Vec<String>>",
        "body": "self.edge_types\n            .as_ref()\n            .map(|ets| ets.vocabulary.reverse_map.clone())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return the weights of the graph edges.",
            "",
            "# Example",
            "To get an the graph weights you can use:",
            "```rust",
            "# let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false).unwrap();",
            "# let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false).unwrap();",
            "assert!(graph_with_weights.get_edge_weights().is_ok());",
            "assert!(graph_without_weights.get_edge_weights().is_err());",
            "println!(\"The graph weights are {:?}.\", graph_with_weights.get_edge_weights());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_edge_weights",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<Vec<WeightT>, String>",
        "body": "self.must_have_edge_weights()?;\n        Ok(self.weights.clone().unwrap())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return the minimum weight, if graph has weights.",
            "",
            "# Example",
            "To get the minimum edge weight you can use:",
            "```rust",
            "# let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false).unwrap();",
            "# let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false).unwrap();",
            "assert!(graph_with_weights.get_min_edge_weight().is_ok());",
            "assert!(graph_without_weights.get_min_edge_weight().is_err());",
            "println!(\"The graph minimum weight is {:?}.\", graph_with_weights.get_min_edge_weight());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_min_edge_weight",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "Ok(self\n            .par_iter_edge_weights()?\n            .reduce(|| f32::INFINITY, |a, b| a.min(b)))"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return the maximum weight, if graph has weights.",
            "",
            "# Example",
            "To get the maximum edge weight you can use:",
            "```rust",
            "# let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false).unwrap();",
            "# let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false).unwrap();",
            "assert!(graph_with_weights.get_max_edge_weight().is_ok());",
            "assert!(graph_without_weights.get_max_edge_weight().is_err());",
            "println!(\"The graph maximum weight is {:?}.\", graph_with_weights.get_max_edge_weight());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_max_edge_weight",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<WeightT, String>",
        "body": "Ok(self\n            .par_iter_edge_weights()?\n            .reduce(|| f32::NEG_INFINITY, |a, b| a.max(b)))"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return the node types of the graph nodes.",
            "",
            "# Example",
            "To retrieve the node type IDs of the graph nodes you can use:",
            "```rust",
            "# let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "# let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "assert!(graph_with_node_types.get_node_type_ids().is_ok());",
            "assert!(graph_without_node_types.get_node_type_ids().is_err());",
            "println!(\"The graph node types are {:?}\", graph_with_node_types.get_node_type_ids());",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "get_node_type_ids",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<Vec<Option<Vec<NodeTypeT>>>, String>",
        "body": "self.must_have_node_types()?;\n        Ok(self.node_types.as_ref().map(|nts| nts.ids.clone()).unwrap())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return the node types names.",
            "",
            "# Example",
            "To retrieve the node type names of the graph nodes you can use:",
            "```rust",
            "# let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "# let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false).unwrap();",
            "assert!(graph_with_node_types.get_node_type_names().is_ok());",
            "assert!(graph_without_node_types.get_node_type_names().is_err());",
            "println!(\"The graph node types are {:?}\", graph_with_node_types.get_node_type_names());",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "get_node_type_names",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<Vec<String>, String>",
        "body": "self.must_have_node_types()?;\n        Ok(self\n            .node_types\n            .as_ref()\n            .map(|nts| nts.vocabulary.reverse_map.clone())\n            .unwrap())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return number of the unique edges in the graph."
        ],
        "modifiers": "pub",
        "name": "get_unique_directed_edges_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.unique_edges_number"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return the nodes mapping."
        ],
        "modifiers": "pub",
        "name": "get_nodes_mapping",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "HashMap<String, NodeT>",
        "body": "self.nodes.map.clone()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return vector with the sorted edge Ids.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "get_edges",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Vec<Vec<NodeT>>",
        "body": "self.par_iter_edge_ids(directed)\n            .map(|(_, src, dst)| vec![src, dst])\n            .collect()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return vector with the sorted edge names.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "get_edge_node_names",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Vec<(String, String)>",
        "body": "self.par_iter_edges(directed)\n            .map(|(_, _, src_name, _, dst_name)| (src_name, dst_name))\n            .collect()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of unknown node types."
        ],
        "modifiers": "pub",
        "name": "get_unknown_node_types_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.node_types\n            .as_ref()\n            .map_or(0, |nt| nt.get_unknown_count())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns minimum number of node types."
        ],
        "modifiers": "pub",
        "name": "get_minimum_node_types_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.node_types\n            .as_ref()\n            .map_or(0, |et| et.min_node_type_count())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of unknown edge types."
        ],
        "modifiers": "pub",
        "name": "get_unknown_edge_types_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.edge_types\n            .as_ref()\n            .map_or(0, |et| et.get_unknown_count())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns minimum number of edge types."
        ],
        "modifiers": "pub",
        "name": "get_minimum_edge_types_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.edge_types\n            .as_ref()\n            .map_or(0, |et| et.min_edge_type_count())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of nodes in the graph."
        ],
        "modifiers": "pub",
        "name": "get_nodes_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.nodes.len() as NodeT"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return a vector with the components each node belongs to.",
            "",
            "E.g. If we have two components `[0, 2, 3]` and `[1, 4, 5]` the result will look like",
            "`[0, 1, 0, 0, 1, 1]`",
            "",
            "# Arguments",
            "* `verbose`: bool - Whether to show the loading bar."
        ],
        "modifiers": "pub",
        "name": "get_node_connected_component_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "match self.directed {\n            true => self.spanning_arborescence_kruskal(verbose).1,\n            false => self.connected_components(verbose).unwrap().0,\n        }"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of directed edges in the graph."
        ],
        "modifiers": "pub",
        "name": "get_directed_edges_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.edges.len() as EdgeT"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of edge types in the graph."
        ],
        "modifiers": "pub",
        "name": "get_edge_types_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeTypeT",
        "body": "self.edge_types\n            .as_ref()\n            .map_or(0, |ets| ets.len() as EdgeTypeT)"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of node types in the graph."
        ],
        "modifiers": "pub",
        "name": "get_node_types_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "NodeTypeT",
        "body": "self.node_types\n            .as_ref()\n            .map_or(0, |nts| nts.len() as NodeTypeT)"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns the degree of every node in the graph."
        ],
        "modifiers": "pub",
        "name": "get_node_degrees",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "self.iter_node_degrees().collect()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return set of nodes that are not singletons."
        ],
        "modifiers": "pub",
        "name": "get_not_singletons_node_ids",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Vec<NodeT>",
        "body": "self.iter_non_singleton_node_ids().collect()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return mapping from instance not trap nodes to dense nodes."
        ],
        "modifiers": "pub",
        "name": "get_dense_nodes_mapping",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "HashMap<NodeT, NodeT>",
        "body": "self.iter_non_singleton_node_ids()\n            .enumerate()\n            .map(|(i, node)| (node as NodeT, i as NodeT))\n            .collect()"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return number of edges that have multigraph syblings."
        ],
        "modifiers": "pub",
        "name": "get_multigraph_edges_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.get_directed_edges_number() - self.unique_edges_number"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Return vector with node cumulative_node_degrees, that is the comulative node degree."
        ],
        "modifiers": "pub",
        "name": "get_cumulative_node_degrees",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Vec<EdgeT>",
        "body": "self.cumulative_node_degrees.as_ref().map_or_else(\n            || {\n                self.par_iter_node_ids()\n                    .map(|src| self.get_unchecked_edge_id_from_node_ids(src + 1, 0))\n                    .collect()\n            },\n            |cumulative_node_degrees| cumulative_node_degrees.clone(),\n        )"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns number of the source nodes.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "println!(\"The number of sources of the graph (not trap nodes) is {}\", graph.get_unique_source_nodes_number());",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_unique_source_nodes_number",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.unique_sources\n            .as_ref()\n            .map_or(self.get_nodes_number(), |x| x.len() as NodeT)"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns edge type counts.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "for (edge_type_id, count) in graph.get_edge_type_counter().unwrap().iter() {",
            "println!(\"edge type id {}: count: {}\", edge_type_id, count);",
            "}",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_edge_type_counter",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<Counter<EdgeTypeT, usize>, String>",
        "body": "self.must_have_edge_types()?;\n        Ok(self\n            .edge_types\n            .as_ref()\n            .map(|ets| Counter::init(ets.ids.iter().filter_map(|edge_type| *edge_type)))\n            .unwrap())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns edge type counts hashmap.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "for (edge_type_id, count) in graph.get_edge_type_counts_hashmap().unwrap().iter() {",
            "println!(\"edge type id {}: count: {}\", edge_type_id, count);",
            "}",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_edge_type_counts_hashmap",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<HashMap<EdgeTypeT, usize>, String>",
        "body": "Ok(self.get_edge_type_counter()?.into_map())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns node type counts.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "for (node_type_id, count) in graph.get_node_type_counter().unwrap().iter() {",
            "println!(\"node type id {}: count: {}\", node_type_id, count);",
            "}",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_node_type_counter",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<Counter<NodeTypeT, usize>, String>",
        "body": "self.must_have_node_types()?;\n        Ok(self\n            .node_types\n            .as_ref()\n            .map(|nts| {\n                Counter::init(\n                    nts.ids\n                        .iter()\n                        .filter_map(|node_type| node_type.clone())\n                        .flatten(),\n                )\n            })\n            .unwrap())"
    },
    {
        "file": "getters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `get_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `get_unchecked_(.+)`"
        ],
        "doc": [
            "Returns node type counts hashmap.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "for (node_type_id, count) in graph.get_node_type_counts_hashmap().unwrap().iter() {",
            "println!(\"node type id {}: count: {}\", node_type_id, count);",
            "}",
            "```"
        ],
        "modifiers": "pub",
        "name": "get_node_type_counts_hashmap",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<HashMap<EdgeTypeT, usize>, String>",
        "body": "Ok(self.get_node_type_counter()?.into_map())"
    },
    {
        "file": "vocabulary.rs",
        "doc": [],
        "modifiers": "pub",
        "name": "default",
        "args": [],
        "return_type": "Vocabulary<IndexT>",
        "body": "Vocabulary {\n            map: HashMap::new(),\n            reverse_map: Vec::new(),\n            numeric_ids: false,\n        }"
    },
    {
        "file": "vocabulary.rs",
        "doc": [],
        "modifiers": "",
        "name": "normalize_value",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "value",
                "&str"
            ]
        ],
        "return_type": "Result<(String, IndexT), String>",
        "body": "Ok(if self.numeric_ids {\n            let parsed_value = match value.parse::<usize>() {\n                Ok(val) => Ok(val),\n                Err(_) => Err(format!(\n                    \"The given ID `{}` is not a numeric positive integer.\",\n                    value\n                )),\n            }?;\n\n            let string_parsed_value = parsed_value.to_string();\n\n            // Check that there are no extra zeros or separators in the number\n            // E.g. 000 is not supported since it will be traduced to 0\n            if value != string_parsed_value {\n                return Err(format!(\n                    concat!(\n                        \"The given ID is numeric but is not symmetric.\\n\",\n                        \"Specifically, {} != {} where the first value is the user's one \",\n                        \"and the second one is the result of parsing the value as an \",\n                        \" integer and casting back to string.\"\n                    ),\n                    value, string_parsed_value\n                ));\n            }\n\n            (string_parsed_value, IndexT::from_usize(parsed_value))\n        } else {\n            (value.to_string(), IndexT::from_usize(self.map.len()))\n        })"
    },
    {
        "file": "vocabulary.rs",
        "doc": [
            "Returns id of given value inserted.",
            "",
            "# Arguments",
            "",
            "* `value`: String - The value to be inserted."
        ],
        "modifiers": "pub(crate)",
        "name": "unchecked_insert",
        "args": [
            [
                "self",
                "&mut self"
            ],
            [
                "value",
                "String"
            ]
        ],
        "return_type": "IndexT",
        "body": "let current_length = self.map.len();\n        let numeric_ids = self.numeric_ids;\n        *self.map.entry(value).or_insert_with_key(|value| {\n            IndexT::from_usize(if numeric_ids {\n                value.parse::<usize>().unwrap()\n            } else {\n                current_length\n            })\n        })"
    },
    {
        "file": "vocabulary.rs",
        "doc": [
            "Returns id of given value inserted.",
            "",
            "# Arguments",
            "",
            "* `value`: String - The value to be inserted."
        ],
        "modifiers": "pub(crate)",
        "name": "insert",
        "generics": "S: AsRef<str>",
        "args": [
            [
                "self",
                "&mut self"
            ],
            [
                "value",
                "S"
            ]
        ],
        "return_type": "Result<IndexT, String>",
        "body": "let value = value.as_ref();\n\n        if value.is_empty() {\n            return Err(\"The value given to the vocabulary was empty\".to_string());\n        }\n\n        let (normalized_value, index) = self.normalize_value(value)?;\n\n        Ok(*self.map.entry(normalized_value).or_insert(index))"
    },
    {
        "file": "vocabulary.rs",
        "doc": [
            "Compute the reverse mapping vector for fast decoding"
        ],
        "modifiers": "pub",
        "name": "build_reverse_mapping",
        "args": [
            [
                "self",
                "&mut self"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "if !self.reverse_map.is_empty() {\n            panic!(\"Build reverse mapping called multiple times!\");\n        }\n        self.reverse_map = vec![\"\".to_string(); self.map.len()];\n        for (k, v) in self.map.iter() {\n            if *v >= IndexT::from_usize(self.map.len()) {\n                return Err(format!(\n                    concat!(\n                        \"The given set of values is not dense. Found the tuple k:{} v:{} \",\n                        \"which has index bigger than the number of elements in the map {}.\"\n                    ),\n                    k,\n                    v,\n                    self.map.len()\n                ));\n            }\n            let i = IndexT::to_usize(*v);\n            if !self.reverse_map[i].is_empty() {\n                return Err(format!(\n                    concat!(\n                        \"During the building of the reverse mapping, \",\n                        \"one of the elements of the reverse mapping was attempted \",\n                        \"to be assigned multiple times. This means that in the map \",\n                        \"there are multiple nodes with the same id.\\n\",\n                        \"In the past this was caused by improper handling of numeric \",\n                        \"node id.\\n\",\n                        \"In this case, the value is {} and its index is {}.\"\n                    ),\n                    k, i\n                ));\n            }\n            self.reverse_map[i] = k.clone();\n        }\n        Ok(())"
    },
    {
        "file": "vocabulary.rs",
        "doc": [
            "Returns whether the value is empty or not."
        ],
        "modifiers": "pub",
        "name": "is_empty",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.map.is_empty()"
    },
    {
        "file": "vocabulary.rs",
        "doc": [
            "Returns string name of given id.",
            "",
            "# Arguments",
            "",
            "* `id`: IndexT - Id to be translated."
        ],
        "modifiers": "pub",
        "name": "unchecked_translate",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "id",
                "IndexT"
            ]
        ],
        "return_type": "String",
        "body": "self.reverse_map[IndexT::to_usize(id)].clone()"
    },
    {
        "file": "vocabulary.rs",
        "doc": [
            "Returns option with string name of given id.",
            "",
            "# Arguments",
            "",
            "* `id`: IndexT - Id to be translated."
        ],
        "modifiers": "pub",
        "name": "translate",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "id",
                "IndexT"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "match self.reverse_map.get(IndexT::to_usize(id)) {\n            Some(name) => Ok(name.clone()),\n            None => Err(\"The requested ID is not available in current dictionary.\".to_string()),\n        }"
    },
    {
        "file": "vocabulary.rs",
        "doc": [
            "Return the id of given key.",
            "",
            "# Arguments",
            "",
            "* `key`: &str - the key whose Id is to be retrieved."
        ],
        "modifiers": "pub",
        "name": "get",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "key",
                "&str"
            ]
        ],
        "return_type": "Option<&IndexT>",
        "body": "self.map.get(key)"
    },
    {
        "file": "vocabulary.rs",
        "doc": [
            "Return vector of keys of the map."
        ],
        "modifiers": "pub",
        "name": "keys",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Vec<String>",
        "body": "self.map.keys().cloned().collect()"
    },
    {
        "file": "vocabulary.rs",
        "doc": [
            "Return boolean representing if given key is present.",
            "",
            "# Arguments",
            "",
            "* `key`: &str - the key to check existance of."
        ],
        "modifiers": "pub",
        "name": "contains_key",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "key",
                "&str"
            ]
        ],
        "return_type": "bool",
        "body": "self.map.contains_key(key)"
    },
    {
        "file": "vocabulary.rs",
        "doc": [
            "Return length of the vocabulary."
        ],
        "modifiers": "pub",
        "name": "len",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "usize",
        "body": "self.map.len()"
    },
    {
        "file": "vocabulary.rs",
        "doc": [
            "Set whether to load IDs as numeric.",
            "",
            "# Arguments",
            "* numeric_ids: bool - Whether to load the IDs as numeric",
            ""
        ],
        "modifiers": "pub",
        "name": "set_numeric_ids",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "numeric_ids",
                "bool"
            ]
        ],
        "return_type": "Vocabulary<IndexT>",
        "body": "self.numeric_ids = numeric_ids;\n        self"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [],
        "modifiers": "",
        "name": "compute_hash",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "u64",
        "body": "let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        hasher.finish()"
    },
    {
        "file": "node_type_vocabulary.rs",
        "doc": [],
        "modifiers": "",
        "name": "eq",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "other",
                "&Self"
            ]
        ],
        "return_type": "bool",
        "body": "self.compute_hash() == other.compute_hash()"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [],
        "modifiers": "pub",
        "name": "default",
        "args": [],
        "return_type": "NodeTypeVocabulary",
        "body": "NodeTypeVocabulary {\n            ids: Vec::new(),\n            vocabulary: Vocabulary::default(),\n            counts: Vec::new(),\n            unknown_count: NodeT::from_usize(0),\n            multilabel: false,\n        }"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [],
        "modifiers": "pub",
        "name": "from_structs",
        "args": [
            [
                "ids",
                "Vec<Option<Vec<NodeTypeT>>>"
            ],
            [
                "vocabulary",
                "Option<Vocabulary<NodeTypeT>>"
            ]
        ],
        "return_type": "Option<NodeTypeVocabulary>",
        "body": "match vocabulary {\n            Some(vocab) => {\n                let multilabel = ids\n                    .iter()\n                    .any(|node_types| node_types.as_ref().map_or(false, |nts| nts.len() > 1));\n                let mut vocabvec = NodeTypeVocabulary {\n                    ids,\n                    vocabulary: vocab,\n                    counts: Vec::new(),\n                    unknown_count: NodeT::from_usize(0),\n                    multilabel,\n                };\n                vocabvec.build_counts();\n                Some(vocabvec)\n            }\n            None => None,\n        }"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [],
        "modifiers": "pub",
        "name": "build_counts",
        "args": [
            [
                "self",
                "&mut self"
            ]
        ],
        "body": "let mut counts = vec![NodeT::from_usize(0); self.vocabulary.len()];\n        for index in self.ids.iter() {\n            match index {\n                Some(values) => {\n                    values.iter().for_each(|value| {\n                        counts[NodeTypeT::to_usize(*value)] += NodeT::from_usize(1)\n                    });\n                }\n                None => self.unknown_count += NodeT::from_usize(1),\n            }\n        }\n        self.counts = counts;"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [],
        "modifiers": "pub",
        "name": "build_reverse_mapping",
        "args": [
            [
                "self",
                "&mut self"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "self.vocabulary.build_reverse_mapping()"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [
            "Returns ids of given values inserted.",
            "",
            "# Arguments",
            "",
            "* `maybe_values`: Option<Vec<S>> - The values to be inserted."
        ],
        "modifiers": "pub",
        "name": "insert_values",
        "generics": "S: AsRef<str> + std::fmt::Debug",
        "args": [
            [
                "self",
                "&mut self"
            ],
            [
                "maybe_values",
                "Option<Vec<S>>"
            ]
        ],
        "return_type": "Result<Option<Vec<NodeTypeT>>, String>",
        "body": "Ok(match maybe_values {\n            Some(values) => {\n                // Check if there is at least one node type\n                if values.is_empty() {\n                    return Err(\"The given node types vector is empty.\".to_owned());\n                }\n                // Retrieve the ID\n                let mut ids = values\n                    .iter()\n                    .map(|value| self.vocabulary.insert(value.as_ref()))\n                    .collect::<Result<Vec<NodeTypeT>, String>>()?;\n                // Sort the slice\n                ids.sort_unstable();\n\n                // check for duplicates\n                if ids[..ids.len() - 1]\n                    .iter()\n                    .zip(ids[1..].iter())\n                    .any(|(a, b)| a == b)\n                {\n                    return Err(format!(\n                        concat!(\n                            \"Node with duplicated node types was provided.\\n\",\n                            \"Specifically the node types vector of the node is {:?} \",\n                        ),\n                        values\n                    ));\n                }\n                self.multilabel = self.multilabel || ids.len() > 1;\n                // Push the sorted IDs\n                self.ids.push(Some(ids.clone()));\n                Some(ids)\n            }\n            None => {\n                self.ids.push(None);\n                None\n            }\n        })"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [
            "Returns whether the vocabulary is empty or not."
        ],
        "modifiers": "pub",
        "name": "is_empty",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.vocabulary.is_empty()"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [
            "Returns whether the node types are multi-label or not."
        ],
        "modifiers": "pub",
        "name": "is_multilabel",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.multilabel"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [
            "Returns number of minimum node-count."
        ],
        "modifiers": "pub",
        "name": "min_node_type_count",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "NodeT",
        "body": "*self.counts.iter().min().unwrap_or(&0)"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [
            "Returns number of unknown nodes."
        ],
        "modifiers": "pub",
        "name": "get_unknown_count",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "NodeT",
        "body": "self.unknown_count"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [
            "Returns string name of given id.",
            "",
            "# Arguments",
            "",
            "* `id`: NodeTypeT - Node Type ID to be translated."
        ],
        "modifiers": "pub",
        "name": "unchecked_translate",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "id",
                "NodeTypeT"
            ]
        ],
        "return_type": "String",
        "body": "self.vocabulary.unchecked_translate(id)"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [
            "Returns string name of given id.",
            "",
            "# Arguments",
            "",
            "* `id`: NodeTypeT - Node Type ID to be translated."
        ],
        "modifiers": "pub",
        "name": "translate",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "id",
                "NodeTypeT"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "self.vocabulary.translate(id)"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [
            "Returns string name of given id.",
            "",
            "# Arguments",
            "",
            "* `ids`: Vec<NodeTypeT> - Node Type IDs to be translated."
        ],
        "modifiers": "pub",
        "name": "translate_vector",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "ids",
                "Vec<NodeTypeT>"
            ]
        ],
        "return_type": "Result<Vec<String>, String>",
        "body": "ids.into_iter().map(|id| self.translate(id)).collect()"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [
            "Return the id of given key.",
            "",
            "# Arguments",
            "",
            "* `key`: &str - the key whose Id is to be retrieved."
        ],
        "modifiers": "pub",
        "name": "get",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "key",
                "&str"
            ]
        ],
        "return_type": "Option<&NodeTypeT>",
        "body": "self.vocabulary.get(key)"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [
            "Return vector of keys of the map."
        ],
        "modifiers": "pub",
        "name": "keys",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Vec<String>",
        "body": "self.vocabulary.keys()"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [
            "Return length of the vocabulary."
        ],
        "modifiers": "pub",
        "name": "len",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "usize",
        "body": "self.counts.len()"
    },
    {
        "file": "node_type_vocabulary.rs",
        "struct": "NodeTypeVocabulary",
        "doc": [
            "Set whether to load IDs as numeric.",
            "",
            "# Arguments",
            "* numeric_ids: bool - Whether to load the IDs as numeric",
            ""
        ],
        "modifiers": "pub",
        "name": "set_numeric_ids",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "numeric_ids",
                "bool"
            ]
        ],
        "return_type": "NodeTypeVocabulary",
        "body": "self.vocabulary = self.vocabulary.set_numeric_ids(numeric_ids);\n        self"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Return new NodeFileReader object.",
            "",
            "# Arguments",
            "",
            "* reader: CSVFileParameters - Path where to store/load the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "new",
        "generics": "S: Into<String>",
        "args": [
            [
                "path",
                "S"
            ]
        ],
        "return_type": "Result<NodeFileReader, String>",
        "body": "Ok(NodeFileReader {\n            reader: CSVFileReader::new(path, \"node list\".to_owned())?,\n            default_node_type: None,\n            nodes_column_number: None,\n            node_types_separator: None,\n            node_types_column_number: None,\n            numeric_node_ids: false,\n            numeric_node_type_ids: false,\n            skip_node_types_if_unavailable: false,\n            might_have_singletons: true,\n        })"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the column of the nodes.",
            "",
            "# Arguments",
            "",
            "* nodes_column: Option<String> - The nodes column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_nodes_column",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "nodes_column",
                "Option<S>"
            ]
        ],
        "return_type": "Result<NodeFileReader, String>",
        "body": "if let Some(column) = nodes_column {\n            let column = column.into();\n            if column.is_empty() {\n                return Err(\"The given node column is empty.\".to_owned());\n            }\n            self.nodes_column_number = Some(self.reader.get_column_number(column)?);\n        }\n        Ok(self)"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the column_number of the nodes.",
            "",
            "# Arguments",
            "",
            "* nodes_column_number: Option<usize> - The nodes column_number to use for the file.",
            "t"
        ],
        "modifiers": "pub",
        "name": "set_nodes_column_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "nodes_column_number",
                "Option<usize>"
            ]
        ],
        "return_type": "NodeFileReader",
        "body": "self.nodes_column_number = nodes_column_number;\n        self"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the name of the graph to be loaded.",
            "",
            "# Arguments",
            "",
            "* graph_name: String - The name of the graph to be loaded.",
            ""
        ],
        "modifiers": "pub(crate)",
        "name": "set_graph_name",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "graph_name",
                "String"
            ]
        ],
        "return_type": "NodeFileReader",
        "body": "self.reader.graph_name = graph_name;\n        self"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the column of the nodes.",
            "",
            "# Arguments",
            "",
            "* node_types_column: Option<String> - The node types column to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_node_types_column",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "nodes_type_column",
                "Option<S>"
            ]
        ],
        "return_type": "Result<NodeFileReader, String>",
        "body": "if let Some(column) = nodes_type_column {\n            let column = column.into();\n            if column.is_empty() {\n                return Err(\"The given node types column is empty.\".to_owned());\n            }\n            match self.reader.get_column_number(column) {\n                Ok(ecn) => {\n                    self.node_types_column_number = Some(ecn);\n                }\n                Err(e) => {\n                    if !self.skip_node_types_if_unavailable {\n                        return Err(e);\n                    }\n                }\n            }\n        }\n        Ok(self)"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the column_number of the nodes.",
            "",
            "# Arguments",
            "",
            "* node_types_column_number: Option<usize> - The node types column_number to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_node_types_column_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "node_types_column_number",
                "Option<usize>"
            ]
        ],
        "return_type": "NodeFileReader",
        "body": "self.node_types_column_number = node_types_column_number;\n        self"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set whether to automatically skip node_types if they are not avaitable instead of raising an exception.",
            "",
            "# Arguments",
            "",
            "* skip_node_types_if_unavailable: Option<bool> - Whether to skip node_types if they are not available.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_skip_node_types_if_unavailable",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "skip_node_types_if_unavailable",
                "Option<bool>"
            ]
        ],
        "return_type": "Result<NodeFileReader, String>",
        "body": "if let Some(skip) = skip_node_types_if_unavailable {\n            self.skip_node_types_if_unavailable = skip;\n        }\n        Ok(self)"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set whether you pinky promise that this graph has singletons or not.",
            "",
            "# Arguments",
            "",
            "* `might_have_singletons`: Option<bool> - Whether this graph has singletons.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_might_have_singletons",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "might_have_singletons",
                "Option<bool>"
            ]
        ],
        "return_type": "Result<NodeFileReader, String>",
        "body": "if let Some(skip) = might_have_singletons {\n            self.might_have_singletons = skip;\n        }\n        Ok(self)"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the comment symbol to use to skip the lines.",
            "",
            "# Arguments",
            "",
            "* comment_symbol: Option<String> - if the reader should ignore or not duplicated edges.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_comment_symbol",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "comment_symbol",
                "Option<String>"
            ]
        ],
        "return_type": "Result<NodeFileReader, String>",
        "body": "if let Some(cs) = comment_symbol {\n            if cs.is_empty() {\n                return Err(\"The given comment symbol is empty.\".to_string());\n            }\n            self.reader.comment_symbol = Some(cs);\n        }\n        Ok(self)"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the default node type.",
            "",
            "# Arguments",
            "",
            "* default_node_type: Option<String> - The node type to use when node type is missing.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_default_node_type",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "default_node_type",
                "Option<S>"
            ]
        ],
        "return_type": "NodeFileReader",
        "body": "self.default_node_type = default_node_type.map(|val| val.into());\n        self"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the verbose.",
            "",
            "# Arguments",
            "",
            "* `verbose`: Option<bool> - Whether to show the loading bar or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_verbose",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "verbose",
                "Option<bool>"
            ]
        ],
        "return_type": "NodeFileReader",
        "body": "if let Some(v) = verbose {\n            self.reader.verbose = v;\n        }\n        self"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the numeric_id.",
            "",
            "# Arguments",
            "",
            "* numeric_node_type_ids: Option<bool> - Whether to convert numeric node type Ids to Node Type Ids.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_numeric_node_type_ids",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "numeric_node_type_ids",
                "Option<bool>"
            ]
        ],
        "return_type": "NodeFileReader",
        "body": "if let Some(nnti) = numeric_node_type_ids {\n            self.numeric_node_type_ids = nnti;\n        }\n        self"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the numeric_id.",
            "",
            "# Arguments",
            "",
            "* numeric_node_ids: Option<bool> - Whether to convert numeric node type Ids to Node Type Ids.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_numeric_node_ids",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "numeric_node_ids",
                "Option<bool>"
            ]
        ],
        "return_type": "NodeFileReader",
        "body": "if let Some(nni) = numeric_node_ids {\n            self.numeric_node_ids = nni;\n        }\n        self"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the ignore_duplicates.",
            "",
            "# Arguments",
            "",
            "* ignore_duplicates: Option<bool> - Whether to ignore detected duplicates or raise exception.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_ignore_duplicates",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "ignore_duplicates",
                "Option<bool>"
            ]
        ],
        "return_type": "NodeFileReader",
        "body": "if let Some(v) = ignore_duplicates {\n            self.reader.ignore_duplicates = v;\n        }\n        self"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the separator.",
            "",
            "# Arguments",
            "",
            "* separator: Option<String> - The separator to use for the file.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_separator",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "separator",
                "Option<S>"
            ]
        ],
        "return_type": "Result<NodeFileReader, String>",
        "body": "if let Some(sep) = separator {\n            let sep = sep.into();\n            if sep.is_empty() {\n                return Err(\"The separator cannot be empty.\".to_owned());\n            }\n            self.reader.separator = sep;\n        }\n        Ok(self)"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the node types separator.",
            "",
            "In the following example we show a column of node IDs and",
            "a column of node types.",
            "",
            "```bash",
            "node_id_columns node_types",
            "node_A node_type_1|node_type_2",
            "node_B node_type_2",
            "```",
            "",
            "# Arguments",
            "",
            "* node_types_separator: Option<String> - The separator to use for the node types column.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_node_types_separator",
        "generics": "S: Into<String>",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "node_types_separator",
                "Option<S>"
            ]
        ],
        "return_type": "Result<NodeFileReader, String>",
        "body": "if let Some(sep) = node_types_separator {\n            let sep = sep.into();\n            if sep.is_empty() {\n                return Err(\"The node type separator cannot be empty.\".to_owned());\n            }\n            self.node_types_separator = Some(sep);\n        }\n        Ok(self)"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the header.",
            "",
            "# Arguments",
            "",
            "* header: Option<bool> - Whether to expect an header or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_header",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "header",
                "Option<bool>"
            ]
        ],
        "return_type": "NodeFileReader",
        "body": "if let Some(v) = header {\n            self.reader.header = v;\n        }\n        self"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set number of rows to be skipped when starting to read file.",
            "",
            "# Arguments",
            "",
            "* rows_to_skip: Option<bool> - Whether to show the loading bar or not.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_rows_to_skip",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "rows_to_skip",
                "Option<usize>"
            ]
        ],
        "return_type": "NodeFileReader",
        "body": "if let Some(v) = rows_to_skip {\n            self.reader.rows_to_skip = v;\n        }\n        self"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Set the maximum number of rows to load from the file",
            "",
            "# Arguments",
            "",
            "* max_rows_number: Option<u64> - The edge type to use when edge type is missing.",
            ""
        ],
        "modifiers": "pub",
        "name": "set_max_rows_number",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "max_rows_number",
                "Option<u64>"
            ]
        ],
        "return_type": "NodeFileReader",
        "body": "self.reader.max_rows_number = max_rows_number;\n        self"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Return boolean representing if the node types exist."
        ],
        "modifiers": "pub",
        "name": "has_node_types",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.default_node_type.is_some() || self.node_types_column_number.is_some()"
    },
    {
        "file": "node_file_reader.rs",
        "struct": "NodeFileReader",
        "impl_doc": [
            "Structure that saves the reader specific to writing and reading a nodes csv file.",
            "",
            "# Attributes",
            "* reader: CSVFile - The common reader for reading and writing a csv.",
            "* default_node_type: Option<String> - The node type to use if a node has node type or its node type is \"\".",
            "* nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.",
            "* node_types_separator: Option<String> - Separator to split the node types.",
            "* node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.",
            "* numeric_node_ids: bool - Whether to load the node IDs as numeric.",
            "* numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.",
            "* skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.",
            ""
        ],
        "doc": [
            "Return iterator of the lines of the node file."
        ],
        "modifiers": "pub",
        "name": "read_lines",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>> + '_, String>",
        "body": "// Validating that at least a column was given.\n        if [self.nodes_column_number, self.node_types_column_number]\n            .iter()\n            .all(|val| val.is_none())\n        {\n            return Err(\"Neither nodes ID column or node types column were given!\".to_string());\n        }\n\n        // Check that the two columns do not have the same value.\n        if self.nodes_column_number == self.node_types_column_number {\n            return Err(\"The node column is the same as the node type one.\".to_string());\n        }\n\n        // Retrieve the expected maximum number of columns.\n        let expected_number_of_elements = self.reader.get_elements_per_line()?;\n\n        // Check that the two columns do not have a value higher than the maximum amount.\n        for column in [self.nodes_column_number, self.node_types_column_number]\n            .iter()\n            .filter_map(|maybe_column| *maybe_column)\n        {\n            if column >= expected_number_of_elements {\n                return Err(format!(\n                    concat!(\n                        \"A column number passed was {} but \",\n                        \"the first parsable line has {} values.\"\n                    ),\n                    column, expected_number_of_elements\n                ));\n            }\n        }\n\n        Ok(self\n            .reader\n            .read_lines()?\n            .enumerate()\n            .map(move |(line_number, values)| match values {\n                Ok(vals) => {\n                    let node_name = match self.nodes_column_number {\n                        Some(column) => match vals[column].to_owned() {\n                            Some(node_name) => node_name,\n                            None => {\n                                return Err(\n                                    \"One of the provided node IDs is empty or None.\".to_owned()\n                                )\n                            }\n                        },\n                        None => line_number.to_string(),\n                    };\n                    let maybe_node_types_string = match self.node_types_column_number {\n                        Some(column) => match vals[column].to_owned() {\n                            Some(node_type) => Some(node_type),\n                            None => self.default_node_type.clone(),\n                        },\n                        None => self.default_node_type.clone(),\n                    };\n\n                    // Split given node types using the provided node type separator.\n                    let node_types = match maybe_node_types_string {\n                        Some(string) => match &self.node_types_separator {\n                            Some(sep) => Some(string.split(sep).map(String::from).collect()),\n                            None => Some(vec![string]),\n                        },\n                        None => None,\n                    };\n\n                    // Return tuple with string and list of node types\n                    Ok((node_name, node_types))\n                }\n                Err(e) => Err(e),\n            }))"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [],
        "modifiers": "",
        "name": "compute_hash",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "u64",
        "body": "let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        hasher.finish()"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "doc": [],
        "modifiers": "",
        "name": "eq",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "other",
                "&Self"
            ]
        ],
        "return_type": "bool",
        "body": "self.compute_hash() == other.compute_hash()"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [],
        "modifiers": "pub",
        "name": "default",
        "args": [],
        "return_type": "EdgeTypeVocabulary",
        "body": "EdgeTypeVocabulary {\n            ids: Vec::new(),\n            vocabulary: Vocabulary::default(),\n            counts: Vec::new(),\n            unknown_count: EdgeT::from_usize(0),\n        }"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [],
        "modifiers": "pub",
        "name": "from_structs",
        "args": [
            [
                "ids",
                "Vec<Option<EdgeTypeT>>"
            ],
            [
                "vocabulary",
                "Vocabulary<EdgeTypeT>"
            ]
        ],
        "return_type": "EdgeTypeVocabulary",
        "body": "let mut vocabvec = EdgeTypeVocabulary {\n            ids,\n            vocabulary,\n            counts: Vec::new(),\n            unknown_count: EdgeT::from_usize(0),\n        };\n\n        vocabvec.build_counts();\n\n        vocabvec"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [],
        "modifiers": "pub",
        "name": "from_option_structs",
        "args": [
            [
                "ids",
                "Option<Vec<Option<EdgeTypeT>>>"
            ],
            [
                "vocabulary",
                "Option<Vocabulary<EdgeTypeT>>"
            ]
        ],
        "return_type": "Option<EdgeTypeVocabulary>",
        "body": "if let (Some(ids), Some(vocabulary)) = (ids, vocabulary) {\n            Some(EdgeTypeVocabulary::from_structs(ids, vocabulary))\n        } else {\n            None\n        }"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [],
        "modifiers": "pub",
        "name": "build_counts",
        "args": [
            [
                "self",
                "&mut self"
            ]
        ],
        "body": "self.counts = vec![EdgeT::from_usize(0); self.vocabulary.len()];\n        for index in self.ids.iter() {\n            match index {\n                Some(value) => {\n                    self.counts[*value as usize] += 1;\n                }\n                None => self.unknown_count += EdgeT::from_usize(1),\n            }\n        }"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [
            "Returns whether the value is empty or not."
        ],
        "modifiers": "pub",
        "name": "is_empty",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.vocabulary.is_empty()"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [
            "Returns string name of given id.",
            "",
            "# Arguments",
            "",
            "* `id`: EdgeTypeT - Id to be translated."
        ],
        "modifiers": "pub",
        "name": "unchecked_translate",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "id",
                "EdgeTypeT"
            ]
        ],
        "return_type": "String",
        "body": "self.vocabulary.unchecked_translate(id)"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [
            "Returns string name of given id.",
            "",
            "# Arguments",
            "",
            "* `id`: EdgeTypeT - Id to be translated."
        ],
        "modifiers": "pub",
        "name": "translate",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "id",
                "EdgeTypeT"
            ]
        ],
        "return_type": "Result<String, String>",
        "body": "self.vocabulary.translate(id)"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [
            "Return the id of given key.",
            "",
            "# Arguments",
            "",
            "* `key`: &str - the key whose Id is to be retrieved."
        ],
        "modifiers": "pub",
        "name": "get",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "key",
                "&str"
            ]
        ],
        "return_type": "Option<&EdgeTypeT>",
        "body": "self.vocabulary.get(key)"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [
            "Return vector of keys of the map."
        ],
        "modifiers": "pub",
        "name": "keys",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Vec<String>",
        "body": "self.vocabulary.keys()"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [
            "Return length of the vocabulary."
        ],
        "modifiers": "pub",
        "name": "len",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "usize",
        "body": "self.counts.len()"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [
            "Set whether to load IDs as numeric.",
            "",
            "# Arguments",
            "* numeric_ids: bool - Whether to load the IDs as numeric",
            ""
        ],
        "modifiers": "pub",
        "name": "set_numeric_ids",
        "args": [
            [
                "self",
                "mut self"
            ],
            [
                "numeric_ids",
                "bool"
            ]
        ],
        "return_type": "EdgeTypeVocabulary",
        "body": "self.vocabulary = self.vocabulary.set_numeric_ids(numeric_ids);\n        self"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [
            "Returns number of unknown edges."
        ],
        "modifiers": "pub",
        "name": "get_unknown_count",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "self.unknown_count"
    },
    {
        "file": "edge_type_vocabulary.rs",
        "struct": "EdgeTypeVocabulary",
        "doc": [
            "Returns number of minimum edge-count."
        ],
        "modifiers": "pub",
        "name": "min_edge_type_count",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "EdgeT",
        "body": "*self.counts.iter().min().unwrap_or(&0)"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the node of the graph."
        ],
        "modifiers": "pub",
        "name": "iter_node_ids",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "impl Iterator<Item = NodeT> + '_",
        "body": "0..self.get_nodes_number()"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the node of the graph."
        ],
        "modifiers": "pub",
        "name": "par_iter_node_ids",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = NodeT> + '_",
        "body": "(0..self.get_nodes_number()).into_par_iter()"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the node degrees of the graph."
        ],
        "modifiers": "pub",
        "name": "iter_node_degrees",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "impl Iterator<Item = NodeT> + '_",
        "body": "self.iter_node_ids()\n            .map(move |node| self.get_unchecked_node_degree_from_node_id(node))"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the node degrees of the graph."
        ],
        "modifiers": "pub",
        "name": "par_iter_node_degrees",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = NodeT> + '_",
        "body": "self.par_iter_node_ids()\n            .map(move |node| self.get_unchecked_node_degree_from_node_id(node))"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the non-singleton nodes of the graph.",
            "",
            "Note that this includes also the singleton with self-loops and",
            "the trap nodes within this iterator. Only true singleton nodes,",
            "that is, nodes without any edge (both inbound and outbound) are",
            "included.",
            "",
            "Since the following requires to be boxed, we cannot create the",
            "parallel version of this iterator.",
            ""
        ],
        "modifiers": "pub",
        "name": "iter_non_singleton_node_ids",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Box<dyn Iterator<Item = NodeT> + '_>",
        "body": "match self.not_singleton_nodes.as_ref() {\n            Some(nsns) => Box::new(nsns.iter_ones().map(|node_id| node_id as NodeT)),\n            _ => Box::new(self.iter_node_ids()),\n        }"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the singleton nodes of the graph."
        ],
        "modifiers": "pub",
        "name": "iter_singleton_node_ids",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Box<dyn Iterator<Item = NodeT> + '_>",
        "body": "match self.not_singleton_nodes.as_ref() {\n            Some(nsns) => Box::new(nsns.iter_zeros().map(|node_id| node_id as NodeT)),\n            _ => Box::new(::std::iter::empty()),\n        }"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the singleton with selfloops nodes of the graph."
        ],
        "modifiers": "pub",
        "name": "iter_singleton_with_selfloops_node_ids",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Box<dyn Iterator<Item = NodeT> + '_>",
        "body": "match self.singleton_nodes_with_selfloops.as_ref() {\n            Some(nsns) => Box::new(nsns.iter()),\n            _ => Box::new(::std::iter::empty()),\n        }"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the (non unique) source nodes of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "iter_source_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<Item = NodeT> + '_",
        "body": "self.iter_edge_ids(directed).map(move |(_, src, _)| src)"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges' weights.",
            "",
            "# Example",
            "To get an iterator over the edges weights you can use:",
            "```rust",
            "# let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false).unwrap();",
            "# let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false).unwrap();",
            "assert!(graph_with_weights.iter_edge_weights().is_ok());",
            "assert!(graph_without_weights.iter_edge_weights().is_err());",
            "println!(\"The graph weights are {:?}.\", graph_with_weights.iter_edge_weights().unwrap().collect::<Vec<_>>());",
            "```"
        ],
        "modifiers": "pub",
        "name": "iter_edge_weights",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<impl Iterator<Item = WeightT> + '_, String>",
        "body": "self.must_have_edge_weights()?;\n        Ok(self.weights.as_ref().map(|ws| ws.iter().cloned()).unwrap())"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return parallel iterator on the edges' weights.",
            "",
            "# Example",
            "To get an iterator over the edges weights you can use:",
            "```rust",
            "# use rayon::iter::ParallelIterator;",
            "# let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false).unwrap();",
            "# let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false).unwrap();",
            "assert!(graph_with_weights.iter_edge_weights().is_ok());",
            "assert!(graph_without_weights.iter_edge_weights().is_err());",
            "println!(\"The graph weights are {:?}.\", graph_with_weights.par_iter_edge_weights().unwrap().collect::<Vec<_>>());",
            "```"
        ],
        "modifiers": "pub",
        "name": "par_iter_edge_weights",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Result<impl ParallelIterator<Item = WeightT> + '_, String>",
        "body": "self.must_have_edge_weights()?;\n        Ok(self\n            .weights\n            .as_ref()\n            .map(|ws| ws.par_iter().cloned())\n            .unwrap())"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return parallel iterator on the (non unique) source nodes of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "par_iter_source_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = NodeT> + '_",
        "body": "self.par_iter_edge_ids(directed).map(move |(_, src, _)| src)"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the (non unique) destination nodes of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "iter_destination_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<Item = NodeT> + '_",
        "body": "self.iter_edge_ids(directed).map(move |(_, _, dst)| dst)"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return parallel iterator on the (non unique) destination nodes of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "par_iter_destination_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = NodeT> + '_",
        "body": "self.par_iter_edge_ids(directed).map(move |(_, _, dst)| dst)"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the node of the graph."
        ],
        "modifiers": "pub",
        "name": "iter_node_ids_and_node_type_ids",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "impl Iterator<Item = (NodeT, Option<Vec<NodeTypeT>>)> + '_",
        "body": "self.iter_node_ids().map(move |node_id| {\n            (\n                node_id,\n                self.get_unchecked_node_type_id_from_node_id(node_id),\n            )\n        })"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the node of the graph."
        ],
        "modifiers": "pub",
        "name": "par_iter_node_ids_and_node_type_ids",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = (NodeT, Option<Vec<NodeTypeT>>)> + '_",
        "body": "self.par_iter_node_ids().map(move |node_id| {\n            (\n                node_id,\n                self.get_unchecked_node_type_id_from_node_id(node_id),\n            )\n        })"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the node of the graph as Strings."
        ],
        "modifiers": "pub",
        "name": "iter_nodes",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "impl Iterator<Item = (NodeT, String, Option<Vec<NodeTypeT>>, Option<Vec<String>>)> + '_",
        "body": "self.iter_node_ids_and_node_type_ids()\n            .map(move |(node_id, node_types)| {\n                (\n                    node_id,\n                    self.nodes.unchecked_translate(node_id),\n                    node_types,\n                    self.get_node_type_name_from_node_id(node_id)\n                        .unwrap_or(None),\n                )\n            })"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "iter_edge_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Box<dyn Iterator<Item = (EdgeT, NodeT, NodeT)> + '_>",
        "body": "if self.sources.is_some() && self.destinations.is_some() {\n            return Box::new(\n                (0..self.get_directed_edges_number()).filter_map(move |edge_id| {\n                    let (src, dst) = self.get_unchecked_node_ids_from_edge_id(edge_id);\n                    if !directed && src > dst {\n                        return None;\n                    }\n                    Some((edge_id, src, dst))\n                }),\n            );\n        }\n        Box::new(\n            self.edges\n                .iter()\n                .enumerate()\n                .filter_map(move |(edge_id, edge)| {\n                    let (src, dst) = self.decode_edge(edge);\n                    if !directed && src > dst {\n                        return None;\n                    }\n                    Some((edge_id as EdgeT, src, dst))\n                }),\n        )"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "iter_edges",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<Item = (EdgeT, NodeT, String, NodeT, String)> + '_",
        "body": "self.iter_edge_ids(directed)\n            .map(move |(edge_id, src, dst)| {\n                (\n                    edge_id,\n                    src,\n                    self.get_unchecked_node_name_from_node_id(src),\n                    dst,\n                    self.get_unchecked_node_name_from_node_id(dst),\n                )\n            })"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "par_iter_edge_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = (EdgeT, NodeT, NodeT)> + '_",
        "body": "self.edges\n            .par_enumerate()\n            .filter_map(move |(edge_id, edge)| {\n                let (src, dst) = self.decode_edge(edge);\n                if !directed && src > dst {\n                    return None;\n                }\n                Some((edge_id as EdgeT, src, dst))\n            })"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "par_iter_edges",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = (EdgeT, NodeT, String, NodeT, String)> + '_",
        "body": "self.par_iter_edge_ids(directed)\n            .map(move |(edge_id, src, dst)| {\n                (\n                    edge_id,\n                    src,\n                    self.get_unchecked_node_name_from_node_id(src),\n                    dst,\n                    self.get_unchecked_node_name_from_node_id(dst),\n                )\n            })"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "iter_edge_node_ids_and_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>)> + '_",
        "body": "self.iter_edge_ids(directed)\n            .map(move |(edge_id, src, dst)| {\n                (\n                    edge_id,\n                    src,\n                    dst,\n                    self.get_unchecked_edge_type_id_from_edge_id(edge_id),\n                )\n            })"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "iter_edge_node_names_and_edge_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<\n        Item = (\n            EdgeT,\n            NodeT,\n            String,\n            NodeT,\n            String,\n            Option<EdgeTypeT>,\n            Option<String>,\n        ),\n    > + '_",
        "body": "self.iter_edges(directed)\n            .map(move |(edge_id, src, src_name, dst, dst_name)| {\n                let edge_type_id = self.get_unchecked_edge_type_id_from_edge_id(edge_id);\n                (\n                    edge_id,\n                    src,\n                    src_name,\n                    dst,\n                    dst_name,\n                    edge_type_id,\n                    self.get_unchecked_edge_type_name_from_edge_type_id(edge_type_id),\n                )\n            })"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges of the graph with the ids and string name.",
            "The result is (edge_id, src, src_name, dst, dst_name, edge_type, edge_type_name)",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "par_iter_edge_node_names_and_edge_type_name",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<\n        Item = (\n            EdgeT,\n            NodeT,\n            String,\n            NodeT,\n            String,\n            Option<EdgeTypeT>,\n            Option<String>,\n        ),\n    > + '_",
        "body": "self.par_iter_edges(directed)\n            .map(move |(edge_id, src, src_name, dst, dst_name)| {\n                let edge_type_id = self.get_unchecked_edge_type_id_from_edge_id(edge_id);\n                (\n                    edge_id,\n                    src,\n                    src_name,\n                    dst,\n                    dst_name,\n                    edge_type_id,\n                    self.get_unchecked_edge_type_name_from_edge_type_id(edge_type_id),\n                )\n            })"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "par_iter_edge_node_ids_and_edge_type_id",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>)> + '_",
        "body": "self.par_iter_edge_ids(directed)\n            .map(move |(edge_id, src, dst)| {\n                (\n                    edge_id,\n                    src,\n                    dst,\n                    self.get_unchecked_edge_type_id_from_edge_id(edge_id),\n                )\n            })"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "par_iter_edge_node_names_and_edge_type_name_and_edge_weight",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<\n        Item = (\n            EdgeT,\n            NodeT,\n            String,\n            NodeT,\n            String,\n            Option<EdgeTypeT>,\n            Option<String>,\n            Option<WeightT>,\n        ),\n    > + '_",
        "body": "self.par_iter_edge_node_names_and_edge_type_name(directed).map(\n            move |(edge_id, src, src_name, dst, dst_name, edge_type, edge_type_name)| {\n                (\n                    edge_id,\n                    src,\n                    src_name,\n                    dst,\n                    dst_name,\n                    edge_type,\n                    edge_type_name,\n                    self.get_unchecked_edge_weight_from_edge_id(edge_id),\n                )\n            },\n        )"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "iter_edge_node_names_and_edge_type_name_and_edge_weight",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<\n        Item = (\n            EdgeT,\n            NodeT,\n            String,\n            NodeT,\n            String,\n            Option<EdgeTypeT>,\n            Option<String>,\n            Option<WeightT>,\n        ),\n    > + '_",
        "body": "self.iter_edge_node_names_and_edge_type_name(directed).map(\n            move |(edge_id, src, src_name, dst, dst_name, edge_type, edge_type_name)| {\n                (\n                    edge_id,\n                    src,\n                    src_name,\n                    dst,\n                    dst_name,\n                    edge_type,\n                    edge_type_name,\n                    self.get_unchecked_edge_weight_from_edge_id(edge_id),\n                )\n            },\n        )"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "par_iter_edge_node_ids_and_edge_type_id_and_edge_weight",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl ParallelIterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>)> + '_",
        "body": "self.par_iter_edge_node_ids_and_edge_type_id(directed)\n            .map(move |(edge_id, src, dst, edge_type)| {\n                (\n                    edge_id,\n                    src,\n                    dst,\n                    edge_type,\n                    self.get_unchecked_edge_weight_from_edge_id(edge_id),\n                )\n            })"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges of the graph with the string name.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "iter_edge_node_ids_and_edge_type_id_and_edge_weight",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "impl Iterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>)> + '_",
        "body": "self.iter_edge_node_ids_and_edge_type_id(directed)\n            .map(move |(edge_id, src, dst, edge_type)| {\n                (\n                    edge_id,\n                    src,\n                    dst,\n                    edge_type,\n                    self.get_unchecked_edge_weight_from_edge_id(edge_id),\n                )\n            })"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the edges of the graph.",
            "",
            "# Arguments",
            "* `directed`: bool - Whether to filter out the undirected edges."
        ],
        "modifiers": "pub",
        "name": "iter_unique_edge_node_ids",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "directed",
                "bool"
            ]
        ],
        "return_type": "Box<dyn Iterator<Item = (NodeT, NodeT)> + '_>",
        "body": "if self.sources.is_some() && self.destinations.is_some() {\n            return Box::new(\n                (0..self.get_directed_edges_number()).filter_map(move |edge_id| {\n                    let (src, dst) = self.get_unchecked_node_ids_from_edge_id(edge_id);\n                    if edge_id > 0 {\n                        let (last_src, last_dst) =\n                            self.get_unchecked_node_ids_from_edge_id(edge_id - 1);\n                        if last_src == src && last_dst == dst {\n                            return None;\n                        }\n                    }\n                    if !directed && src > dst {\n                        return None;\n                    }\n                    Some((src, dst))\n                }),\n            );\n        }\n        Box::new(self.edges.iter_uniques().filter_map(move |edge| {\n            let (src, dst) = self.decode_edge(edge);\n            if !directed && src > dst {\n                return None;\n            }\n            Some((src, dst))\n        }))"
    },
    {
        "file": "iters.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Iterators",
            "The naming convention for the iterators is:",
            "If the method has the `par_` prefix then it should return a parallel iterator.",
            "By default all the methods retruns both the ids and the name of the item and",
            "if the method has the suffix `_ids` then it will returns **only** the ids.",
            "Therefore, the naming convetions are:",
            "* `iter_(.+)`",
            "* `iter_unchecked_(.+)`",
            "* `par_iter_(.+)`",
            "* `par_iter_unchecked_(.+)`"
        ],
        "doc": [
            "Return iterator on the unique sources of the graph."
        ],
        "modifiers": "pub",
        "name": "iter_unique_source_node_ids",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "Box<dyn Iterator<Item = NodeT> + '_>",
        "body": "if let Some(x) = &self.unique_sources {\n            return Box::new(x.iter().map(|source| source as NodeT));\n        }\n        Box::new(self.iter_node_ids())"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "Return if the graph has any nodes.",
            "",
            "# Example",
            "To check if the graph has nodes you can use:",
            "```rust",
            "# let graph_with_nodes = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "# let empty_graph = graph::test_utilities::load_empty_graph(false);",
            "assert!(graph_with_nodes.has_nodes());",
            "assert!(!empty_graph.has_nodes());",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "has_nodes",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_nodes_number() > 0"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "Return if the graph has any edges.",
            "",
            "# Example",
            "To check if the current graph has edges you can use:",
            "```rust",
            "# let graph_with_edges = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "# let empty_graph = graph::test_utilities::load_empty_graph(false);",
            "assert!(graph_with_edges.has_edges());",
            "assert!(!empty_graph.has_edges());",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "has_edges",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_edges_number() > 0"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "if graph.has_trap_nodes(){",
            "println!(\"There are {} trap nodes in the current graph.\", graph.get_trap_nodes_number());",
            "} else {",
            "println!(\"There are no trap nodes in the current graph.\");",
            "}",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "has_trap_nodes",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_trap_nodes_number() > 0"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "Returns boolean representing if graph is directed.",
            "",
            "# Example",
            "```rust",
            "let directed_string_ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(directed_string_ppi.is_directed());",
            "let undirected_string_ppi = graph::test_utilities::load_ppi(true, true, true, false, false, false).unwrap();",
            "assert!(!undirected_string_ppi.is_directed());",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "is_directed",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.directed"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "Returns boolean representing whether graph has weights.",
            "",
            "# Example",
            "```rust",
            "let weights_string_ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(weights_string_ppi.has_edge_weights());",
            "let unweights_string_ppi = graph::test_utilities::load_ppi(true, true, false, true, false, false).unwrap();",
            "assert!(!unweights_string_ppi.has_edge_weights());",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "has_edge_weights",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.weights.is_some()"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "Returns boolean representing whether graph has edge types.",
            "",
            "# Example",
            "```rust",
            "let string_ppi_with_edge_types = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(string_ppi_with_edge_types.has_edge_types());",
            "let string_ppi_without_edge_types = graph::test_utilities::load_ppi(true, false, true, true, false, false).unwrap();",
            "assert!(!string_ppi_without_edge_types.has_edge_types());",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "has_edge_types",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.edge_types.is_some()"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "Returns boolean representing if graph has self-loops.",
            "",
            "# Example",
            "```rust",
            "let string_ppi_with_selfloops = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "assert!(string_ppi_with_selfloops.has_selfloops());",
            "let string_ppi_without_selfloops = graph::test_utilities::load_ppi(true, false, true, true, false, true).unwrap();",
            "assert!(!string_ppi_without_selfloops.has_selfloops());",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "has_selfloops",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.selfloop_number > 0"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "Returns boolean representing if graph has singletons.",
            "",
            "# Example",
            "```rust",
            "# let graph_with_singletons = graph::test_utilities::load_ppi(true, true, true, false, false, false).unwrap();",
            "assert!(graph_with_singletons.has_singletons());",
            "let graph_without_singletons = graph_with_singletons.remove(",
            "None, None, None, None, None, None, None, None, false, false, true, true, false, false,",
            ").unwrap();",
            "assert!(!graph_without_singletons.has_singletons());",
            "```"
        ],
        "modifiers": "pub",
        "name": "has_singletons",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_singleton_nodes_number() > 0"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "Returns boolean representing if graph has singletons."
        ],
        "modifiers": "pub",
        "name": "has_singletons_with_selfloops",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_singleton_nodes_with_selfloops_number() > 0"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "Returns boolean representing if graph has node types."
        ],
        "modifiers": "pub",
        "name": "has_node_types",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.node_types.is_some()"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "Returns boolean representing if graph has multilabel node types."
        ],
        "modifiers": "pub",
        "name": "has_multilabel_node_types",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.node_types\n            .as_ref()\n            .map_or(false, |nt| nt.is_multilabel())"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "Returns whether there are unknown node types."
        ],
        "modifiers": "pub",
        "name": "has_unknown_node_types",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_unknown_node_types_number() > 0"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "Returns whether there are unknown edge types."
        ],
        "modifiers": "pub",
        "name": "has_unknown_edge_types",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_unknown_edge_types_number() > 0"
    },
    {
        "file": "getters_boolean.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Getters",
            "The naming convention we follow is:",
            "* `has_(.+)`",
            "* `is_(.+)`",
            "The naming convention for unchecked methods follows:",
            "* `has_unchecked_(.+)`",
            "* `is_unchecked_(.+)`."
        ],
        "doc": [
            "Return if there are multiple edges between two nodes"
        ],
        "modifiers": "pub",
        "name": "is_multigraph",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "bool",
        "body": "self.get_multigraph_edges_number() > 0"
    },
    {
        "file": "from_csv.rs",
        "struct": "Graph",
        "doc": [
            "Return graph renderized from given files.",
            "",
            "# Arguments",
            "",
            "* `edge_file_reader`: EdgeFileReader - Reader of the edge file.",
            "* `node_file_reader`: Option<NodeFileReader> - Reader of the node file.",
            "* `directed`: bool - Whether the graph is to be read as directed or undirected.",
            "* `directed_edge_list`: bool - Whether to read the edge list as directed.",
            "* `edges_number`: usize - Number of edges of the graph.",
            "* `nodes_number`: NodeT - Number of the nodes of the graph.",
            "* `name`: S - Name of the graph.",
            ""
        ],
        "modifiers": "pub",
        "name": "from_sorted_csv",
        "generics": "S: Clone + Into<String>",
        "args": [
            [
                "edge_file_reader",
                "EdgeFileReader"
            ],
            [
                "node_file_reader",
                "Option<NodeFileReader>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ],
            [
                "edges_number",
                "usize"
            ],
            [
                "nodes_number",
                "NodeT"
            ],
            [
                "name",
                "S"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "edge_file_reader = edge_file_reader.set_graph_name(name.clone().into());\n        node_file_reader = node_file_reader.map(|nfr| nfr.set_graph_name(name.clone().into()));\n        Graph::from_string_sorted(\n            edge_file_reader.read_lines()?,\n            node_file_reader\n                .as_ref()\n                .map_or(Ok::<_, String>(None), |nfr| Ok(Some(nfr.read_lines()?)))?,\n            directed,\n            directed_edge_list,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.ignore_duplicates),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.csv_is_correct),\n            edge_file_reader.reader.ignore_duplicates,\n            edge_file_reader.reader.csv_is_correct,\n            edges_number,\n            nodes_number,\n            edge_file_reader.numeric_edge_type_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_ids),\n            edge_file_reader.numeric_node_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_type_ids),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.has_node_types()),\n            edge_file_reader.has_edge_types(),\n            edge_file_reader.has_edge_weights(),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.might_have_singletons),\n            edge_file_reader.might_have_singletons_with_selfloops,\n            edge_file_reader.might_have_trap_nodes,\n            name,\n        )"
    },
    {
        "file": "from_csv.rs",
        "struct": "Graph",
        "doc": [
            "Return graph renderized from given files.",
            "",
            "# Arguments",
            "",
            "* `edge_file_reader`: EdgeFileReader - Reader of the edge file.",
            "* `node_file_reader`: Option<NodeFileReader> - Reader of the node file.",
            "* `directed`: bool - Whether the graph is to be read as directed or undirected.",
            "* `directed_edge_list`: bool - Whether to read the edge list as directed.",
            "* `name`: S - The name for the graph."
        ],
        "modifiers": "pub",
        "name": "from_unsorted_csv",
        "generics": "S: Clone + Into<String>",
        "args": [
            [
                "edge_file_reader",
                "EdgeFileReader"
            ],
            [
                "node_file_reader",
                "Option<NodeFileReader>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ],
            [
                "name",
                "S"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "edge_file_reader = edge_file_reader.set_graph_name(name.clone().into());\n        node_file_reader = node_file_reader.map(|nfr| nfr.set_graph_name(name.clone().into()));\n        Graph::from_string_unsorted(\n            edge_file_reader.read_lines()?,\n            node_file_reader\n                .as_ref()\n                .map_or(Ok::<_, String>(None), |nfr| Ok(Some(nfr.read_lines()?)))?,\n            directed,\n            directed_edge_list,\n            name,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.ignore_duplicates),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.reader.csv_is_correct),\n            edge_file_reader.reader.ignore_duplicates,\n            edge_file_reader.reader.csv_is_correct,\n            edge_file_reader.reader.verbose,\n            edge_file_reader.numeric_edge_type_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_ids),\n            edge_file_reader.numeric_node_ids,\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.numeric_node_type_ids),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.has_node_types()),\n            edge_file_reader.has_edge_types(),\n            edge_file_reader.has_edge_weights(),\n            node_file_reader\n                .as_ref()\n                .map_or(false, |nfr| nfr.might_have_singletons),\n            edge_file_reader.might_have_singletons_with_selfloops,\n            edge_file_reader.might_have_trap_nodes,\n        )"
    },
    {
        "file": "hash.rs",
        "doc": [
            "Hashing floats is usually a bad idea",
            "But we want to know if any weight changed significantly",
            "THUS we will hash only the order of magnitude and the",
            "first few bits of the mantissa.",
            "",
            "This should be an hash which is kinda robust to float erros."
        ],
        "modifiers": "",
        "name": "hash_float",
        "generics": "H: Hasher",
        "args": [
            [
                "x",
                "f32"
            ],
            [
                "state",
                "&mut H"
            ]
        ],
        "body": "// basically we are converting the float to a u32 and\n    // clear out the lower bits of the mantissa.\n    let mut hack = u32::from_le_bytes(x.to_le_bytes());\n\n    // Clear the lower bits of the mantissa\n    //        seeeeeeeemmmmmmmmmmmmmmmmmmmmmmm\n    hack &= 0b11111111111111111111000000000000;\n\n    state.write_u32(hack);"
    },
    {
        "file": "hash.rs",
        "struct": "Graph",
        "doc": [],
        "modifiers": "pub",
        "name": "compute_hash",
        "args": [
            [
                "self",
                "&self"
            ]
        ],
        "return_type": "u64",
        "body": "let mut hasher = DefaultHasher::new();\n        self.hash(&mut hasher);\n        hasher.finish()"
    },
    {
        "file": "hash.rs",
        "doc": [],
        "modifiers": "",
        "name": "eq",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "other",
                "&Self"
            ]
        ],
        "return_type": "bool",
        "body": "self.compute_hash() == other.compute_hash()"
    },
    {
        "file": "hash.rs",
        "doc": [],
        "modifiers": "",
        "name": "hash",
        "generics": "H: Hasher",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "state",
                "&mut H"
            ]
        ],
        "body": "// These fields are fundamentals\n        self.directed.hash(state);\n        self.nodes.hash(state);\n        self.edges.hash(state);\n\n        if let Some(ws) = &self.weights {\n            for w in ws {\n                hash_float(*w, state);\n            }\n        }\n\n        if let Some(nt) = &self.node_types {\n            nt.hash(state);\n        }\n\n        if let Some(et) = &self.edge_types {\n            et.hash(state);\n        }\n\n        // These fields are derivative from the other ones and thus not needed.\n        // self.unique_sources.hash(state);\n        // self.node_bits.hash(state);\n        // self.node_bit_mask.hash(state);\n        // self.unique_selfloop_number.hash(state);\n        // self.selfloop_number.hash(state);\n        // self.not_singleton_nodes_number.hash(state);\n        // self.singleton_nodes_with_selfloops_number.hash(state);\n        // self.unique_edges_number.hash(state);\n\n        // These fields are not meaningfull to hash imho\n        // self.name.hash(state);\n        // self.singleton_nodes_with_selfloops_number.hash(state);\n        // self.sources.hash(state);\n        // self.cumulative_node_degrees.hash(state);\n        // self.cached_destinations.hash(state);\n        // self.embedding.hash(state);"
    },
    {
        "file": "hash.rs",
        "doc": [],
        "modifiers": "",
        "name": "hash",
        "generics": "H: Hasher",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "state",
                "&mut H"
            ]
        ],
        "body": "// The hashmap is not hashable, so we convert it to a\n        // sorted array of tuples.\n\n        let mut vector: Vec<(&String, &IndexT)> = self.map.iter().collect();\n        vector.sort();\n        vector.hash(state);\n\n        self.reverse_map.hash(state);\n        self.numeric_ids.hash(state);"
    },
    {
        "file": "hash.rs",
        "doc": [],
        "modifiers": "",
        "name": "hash",
        "generics": "H: Hasher",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "state",
                "&mut H"
            ]
        ],
        "body": "self.ids.hash(state);\n        self.vocabulary.hash(state);\n        self.counts.hash(state);"
    },
    {
        "file": "hash.rs",
        "doc": [],
        "modifiers": "",
        "name": "hash",
        "generics": "H: Hasher",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "state",
                "&mut H"
            ]
        ],
        "body": "self.ids.hash(state);\n        self.vocabulary.hash(state);\n        self.counts.hash(state);"
    },
    {
        "file": "constructors.rs",
        "doc": [
            "Take a vector and make it a None if its empty, Some(vector) otherwise"
        ],
        "modifiers": "",
        "name": "check_numeric_ids_compatibility",
        "args": [
            [
                "has_nodes_list",
                "bool"
            ],
            [
                "numeric_node_ids",
                "bool"
            ],
            [
                "numeric_edge_node_ids",
                "bool"
            ]
        ],
        "return_type": "Result<(), String>",
        "body": "if has_nodes_list && numeric_node_ids && !numeric_edge_node_ids {\n        return Err(concat!(\n            \"You are trying to load a numeric node list and a non numeric edge list.\\n\",\n            \"This is a problem because an edge composed of two nodes (e.g. \\\"2, 8\\\") is \",\n            \"not necessarily mapped internally to the same node ids of the node list.\\n\",\n            \"Possibily you want to also enable the parameter for the numeric edge node ids.\"\n        )\n        .to_string());\n    }\n    Ok(())"
    },
    {
        "file": "constructors.rs",
        "doc": [
            "Returns iterator of nodes handling the node IDs.",
            "",
            "# Arguments",
            "",
            "nodes_iter: impl Iterator<Item = Result<(String, Option<Vec<String>>), String>> + 'a,",
            "Iterator over the node list.",
            "ignore_duplicated_nodes: bool,",
            "Whether to just ignore the duplicated node types.",
            "node_list_is_correct: bool,",
            "Parameter to pinky promise that the node list is correct.",
            "If you provide a broken node list to this method while promising",
            "that the node list is correct, be prepared to deal with the fallout.",
            "This parameter is mainly meant to be used internally when creating",
            "graphs that CANNOT BE BROKEN by design. If you use this parameter",
            "from any of the bindings, be SURE that the node list is actually",
            "correct.",
            "We assume that any provided node list is broken until disproved.",
            "nodes: &'b mut Vocabulary<NodeT>,",
            "Vocabulary of the nodes to be populated."
        ],
        "modifiers": "pub(crate)",
        "name": "parse_node_ids",
        "generics": "'a, 'b",
        "args": [
            [
                "nodes_iter",
                "impl Iterator<Item = Result<(String, Option<Vec<String>>), String>> + 'a"
            ],
            [
                "ignore_duplicated_nodes",
                "bool"
            ],
            [
                "node_list_is_correct",
                "bool"
            ],
            [
                "nodes",
                "&'b mut Vocabulary<NodeT>"
            ]
        ],
        "return_type": "impl Iterator<Item = Result<(NodeT, Option<Vec<String>>), String>> + 'a\nwhere\n    'b: 'a,",
        "body": "nodes_iter.filter_map(move |row| {\n        row.map_or_else(|err| Some(Err(err)), |(node_name, node_type)| {\n            if node_list_is_correct {\n                Some(Ok((nodes.unchecked_insert(node_name), node_type)))\n            } else {\n                if node_name.is_empty() {\n                    return Some(Err(\"Found an empty node name. Node names cannot be empty.\".to_owned()));\n                }\n                if nodes.contains_key(&node_name){\n                    if ignore_duplicated_nodes {\n                        return None;\n                    }\n                    return Some(Err(format!(\n                        concat!(\n                            \"The node {node_name} appears multiple times in the node list.\\n\",\n                            \"The node type of the row is {node_type:?}.\\n\",\n                            \"The library does not currently support multiple node types for a single node.\"\n                        ),\n                        node_name = node_name,\n                        node_type = node_type\n                    )));\n                }\n                Some(nodes.insert(node_name).map(|node_id| (node_id, node_type)))\n            }\n        })\n    })"
    },
    {
        "file": "constructors.rs",
        "doc": [
            "Returns iterator of nodes handling the node type IDs."
        ],
        "modifiers": "pub(crate)",
        "name": "parse_node_type_ids",
        "generics": "'a, 'b",
        "args": [
            [
                "nodes_iter",
                "impl Iterator<Item = Result<(NodeT, Option<Vec<String>>), String>> + 'a"
            ],
            [
                "node_types_vocabulary",
                "&'b mut NodeTypeVocabulary"
            ]
        ],
        "return_type": "impl Iterator<Item = Result<(NodeT, Option<Vec<NodeTypeT>>), String>> + 'a\nwhere\n    'b: 'a,",
        "body": "nodes_iter.map(move |row| match row {\n        Ok((node_id, node_types)) => {\n            Ok((node_id, node_types_vocabulary.insert_values(node_types)?))\n        }\n        Err(e) => Err(e),\n    })"
    },
    {
        "file": "constructors.rs",
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "parse_edges_node_ids",
        "generics": "'a, 'b",
        "args": [
            [
                "edges_iterator",
                "impl Iterator<Item = Result<StringQuadruple, String>> + 'a"
            ],
            [
                "edge_list_is_correct",
                "bool"
            ],
            [
                "nodes",
                "&'b mut Vocabulary<NodeT>"
            ]
        ],
        "return_type": "impl Iterator<Item = Result<(NodeT, NodeT, Option<String>, Option<WeightT>), String>> + 'a\nwhere\n    'b: 'a,",
        "body": "let empty_nodes_mapping = nodes.is_empty();\n    edges_iterator.map(move |row: Result<StringQuadruple, String>| match row {\n        Ok((src_name, dst_name, edge_type, weight)) => {\n            let node_ids = [src_name, dst_name]\n                .iter()\n                .map(|node_name| {\n                    // the source and destination nodes must either be\n                    //  - both numeric node ids\n                    //      - if the node list was provided\n                    //          - The nodes must be less than the max nodes\n                    //      - if the node list was not provided\n                    //          - the nodes must be added to the node list which should be numeric.\n                    //  - if the edge node ids are not numeric\n                    //      - if the node list was provided\n                    //          - the nodes must be added to the node list.\n                    //      - if the node list was no provided\n                    //          - the nodes must be added to the node list.\n                    if empty_nodes_mapping {\n                        if edge_list_is_correct {\n                            Ok(nodes.unchecked_insert(node_name.to_owned()))\n                        } else {\n                            nodes.insert(node_name.to_owned())\n                        }\n                    } else if let Some(node_id) = nodes.get(&node_name) {\n                        Ok(*node_id)\n                    } else {\n                        Err(format!(\n                            concat!(\n                                \"In the edge list was found the node {} \",\n                                \"which is not present in the given node list.\"\n                            ),\n                            node_name\n                        ))\n                    }\n                })\n                .collect::<Result<Vec<NodeT>, String>>()?;\n            Ok((node_ids[0], node_ids[1], edge_type, weight))\n        }\n        Err(e) => Err(e),\n    })"
    },
    {
        "file": "constructors.rs",
        "doc": [
            "Returns iterator of edges handling the edge type IDs."
        ],
        "modifiers": "pub(crate)",
        "name": "parse_edge_type_ids_vocabulary",
        "generics": "'a, 'b",
        "args": [
            [
                "edges_iter",
                "impl Iterator<Item = Result<(NodeT, NodeT, Option<String>, Option<WeightT>), String>>\n        + 'a"
            ],
            [
                "edge_types",
                "&'b mut Vocabulary<EdgeTypeT>"
            ]
        ],
        "return_type": "impl Iterator<Item = Result<Quadruple, String>> + 'a\nwhere\n    'b: 'a,",
        "body": "edges_iter.map(move |row| match row {\n        Ok((src, dst, edge_type, weight)) => {\n            let edge_type_id = match edge_type {\n                Some(et) => Some(edge_types.insert(et)?),\n                None => None,\n            };\n            Ok((src, dst, edge_type_id, weight))\n        }\n        Err(e) => Err(e),\n    })"
    },
    {
        "file": "constructors.rs",
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "parse_sorted_edges",
        "generics": "'a",
        "args": [
            [
                "edges_iter",
                "impl Iterator<Item = Result<Quadruple, String>> + 'a"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ]
        ],
        "return_type": "Box<dyn Iterator<Item = Result<Quadruple, String>> + 'a>",
        "body": "if directed || directed_edge_list {\n        return Box::new(edges_iter);\n    }\n    let mut sorting_tmp: BTreeMap<Triple, Option<WeightT>> = BTreeMap::new();\n    Box::new(edges_iter\n        .map(Some)\n        .chain(vec![None])\n        .flat_map(move |maybe_row| match maybe_row {\n            Some(row) => {\n                let mut results: Vec<Result<Quadruple, String>> = Vec::with_capacity(1);\n                let result = match row {\n                    Ok((src, dst, edge_type, weight)) => {\n                        if !directed && src < dst {\n                            sorting_tmp.insert((dst, src, edge_type), weight);\n                        }\n                        while !sorting_tmp.is_empty()\n                            && *sorting_tmp.first_key_value().unwrap().0 < (src, dst, edge_type)\n                        {\n                            let ((smaller_src, smaller_dst, smaller_edge_type), smaller_weight) =\n                                sorting_tmp.pop_first().unwrap();\n                            results.push(Ok((\n                                smaller_src,\n                                smaller_dst,\n                                smaller_edge_type,\n                                smaller_weight,\n                            )));\n                        }\n                        Ok((src, dst, edge_type, weight))\n                    }\n                    Err(e) => Err(e),\n                };\n                results.push(result);\n                results\n            }\n            None => sorting_tmp\n                .iter()\n                .map(|((src, dst, edge_type), weight)| Ok((*src, *dst, *edge_type, *weight)))\n                .collect::<Vec<_>>(),\n        }))"
    },
    {
        "file": "constructors.rs",
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "parse_unsorted_quadruples",
        "args": [
            [
                "edges",
                "Vec<Quadruple>"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "(usize, impl Iterator<Item = Result<Quadruple, String>>)",
        "body": "info!(\"Sorting edges.\");\n    edges.par_sort_by(|(src1, dst1, edt1, _), (src2, dst2, edt2, _)| {\n        (*src1, *dst1, *edt1).cmp(&(*src2, *dst2, *edt2))\n    });\n\n    let edges_number = edges.len();\n    let pb = get_loading_bar(verbose, \"Building sorted graph\", edges_number);\n\n    (\n        edges_number,\n        edges.into_iter().progress_with(pb).map(Result::Ok),\n    )"
    },
    {
        "file": "constructors.rs",
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "parse_integer_unsorted_edges",
        "generics": "'a",
        "args": [
            [
                "edges_iter",
                "impl Iterator<Item = Result<(NodeT, NodeT, Option<NodeTypeT>, Option<WeightT>), String>>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(usize, impl Iterator<Item = Result<Quadruple, String>> + 'a), String>",
        "body": "let edge_quadruples: Vec<Quadruple> = edges_iter\n        .flat_map(|tuple| match tuple {\n            Ok((src, dst, edt, weight)) => {\n                if !directed && src != dst && !directed_edge_list {\n                    vec![Ok((src, dst, edt, weight)), Ok((dst, src, edt, weight))]\n                } else {\n                    vec![Ok((src, dst, edt, weight))]\n                }\n            }\n            Err(e) => vec![Err(e)],\n        })\n        .collect::<Result<Vec<Quadruple>, String>>()?;\n\n    Ok(parse_unsorted_quadruples(edge_quadruples, verbose))"
    },
    {
        "file": "constructors.rs",
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "parse_string_unsorted_edges",
        "generics": "'a",
        "args": [
            [
                "// This parameter does not NEED a lifetime because it does NOT survive the function call\n    edges_iter",
                "impl Iterator<Item = Result<StringQuadruple, String>>"
            ],
            [
                "nodes",
                "Vocabulary<NodeT>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ],
            [
                "edge_list_is_correct",
                "bool"
            ],
            [
                "has_edge_types",
                "bool"
            ],
            [
                "verbose",
                "bool"
            ],
            [
                "numeric_edge_type_ids",
                "bool"
            ]
        ],
        "return_type": "Result<\n    (\n        usize,\n        impl Iterator<Item = Result<Quadruple, String>> + 'a,\n        Vocabulary<NodeT>,\n        Option<Vocabulary<EdgeTypeT>>,\n    ),\n    String,\n>",
        "body": "let mut edge_types_vocabulary = if has_edge_types {\n        Some(Vocabulary::default().set_numeric_ids(numeric_edge_type_ids))\n    } else {\n        None\n    };\n    let (edges_number, edges_iter) = {\n        let edges_iter = parse_edges_node_ids(edges_iter, edge_list_is_correct, &mut nodes);\n        let edges_iter: Box<dyn Iterator<Item = Result<Quadruple, String>>> =\n            if let Some(ets) = &mut edge_types_vocabulary {\n                Box::new(parse_edge_type_ids_vocabulary(edges_iter, ets))\n            } else {\n                Box::new(edges_iter.map_ok(|(src, dst, _, weight)| (src, dst, None, weight)))\n            };\n        let edge_quadruples: Vec<Quadruple> = edges_iter\n            .flat_map(|tuple| match tuple {\n                Ok((src, dst, edt, weight)) => {\n                    if !directed && src != dst && !directed_edge_list {\n                        vec![Ok((src, dst, edt, weight)), Ok((dst, src, edt, weight))]\n                    } else {\n                        vec![Ok((src, dst, edt, weight))]\n                    }\n                }\n                Err(e) => vec![Err(e)],\n            })\n            .collect::<Result<Vec<Quadruple>, String>>()?;\n\n        parse_unsorted_quadruples(edge_quadruples, verbose)\n    };\n    info!(\"Building nodes reverse mapping.\");\n    nodes.build_reverse_mapping()?;\n    if let Some(ets) = &mut edge_types_vocabulary {\n        info!(\"Building edge types reverse mapping.\");\n        ets.build_reverse_mapping()?;\n    }\n    Ok((edges_number, edges_iter, nodes, edge_types_vocabulary))"
    },
    {
        "file": "constructors.rs",
        "doc": [
            "TODO! add computation of minimum node degree",
            "TODO! add computation of minimum edge weight",
            "TODO! add computation of maximum node degree",
            "TODO! add computation of maximum edge weight",
            "TODO! add docstring"
        ],
        "modifiers": "pub(crate)",
        "name": "build_edges",
        "args": [
            [
                "edges_iter",
                "impl Iterator<Item = Result<Quadruple, String>>"
            ],
            [
                "edges_number",
                "usize"
            ],
            [
                "nodes_number",
                "NodeT"
            ],
            [
                "ignore_duplicated_edges",
                "bool"
            ],
            [
                "has_edge_weights",
                "bool"
            ],
            [
                "has_edge_types",
                "bool"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "edge_list_is_correct",
                "bool"
            ]
        ],
        "return_type": "Result<\n    (\n        EliasFano,\n        Option<EliasFano>,\n        Option<Vec<Option<EdgeTypeT>>>,\n        Option<Vec<WeightT>>,\n        EdgeT,\n        EdgeT,\n        NodeT,\n        NodeT,\n        NodeT,\n        u8,\n        u64,\n        Option<BitVec<Lsb0, u8>>,\n        Option<RoaringBitmap>,\n    ),\n    String,\n>",
        "body": "info!(\"Started building of EliasFano edges data structure.\");\n    let node_bits = get_node_bits(nodes_number);\n    let node_bit_mask = (1 << node_bits) - 1;\n    let mut edges: EliasFano =\n        EliasFano::new(encode_max_edge(nodes_number, node_bits), edges_number)?;\n\n    // The graph might still contain duplicated edges, therefore the provided edges\n    // number is a maximal value.\n    let mut edge_type_ids: Option<Vec<Option<EdgeTypeT>>> = if has_edge_types {\n        Some(Vec::with_capacity(edges_number))\n    } else {\n        None\n    };\n\n    let mut weights: Option<Vec<WeightT>> = if has_edge_weights {\n        Some(Vec::with_capacity(edges_number))\n    } else {\n        None\n    };\n\n    // The unique sources variable is equal to the set of nodes of the graph when\n    // there are no singletons and the graph is undirected. Otherwise, if there is\n    // a singleton node, that must not appear in this set.\n    // We will use this set during the random walks and other graph algorithms\n    // in order to obtain the nth source node. For this reason we cannot\n    // use a bitvec here, since we need to execute an unchecked select when the\n    // object is not equal to the set of the nodes to remap the nth source node\n    // to the nth unique source node, excluding the eventual; singleton nodes.\n    // Similarly, in directed graphs, only a subset of the nodes might be a\n    // source as there might be traps.\n    // In the case of directed graphs, we have additionally the might have trap nodes\n    // parameter which allows to specify whether the graph is known to contain\n    // trap nodes. The parameter only makes sense in directed graphs.\n    // Since we expect that the average use case (when we arew not dealing with pathological graphs)\n    // the following set should be relatively dense, when we know that the set of unique\n    // sources will be needed but it will be equal to the nodes with edges set, we compute it\n    // afterwards. This is because it is known that an Elias Fano data structure\n    // uses more than twice the memory required by a bitvec to memorize a set of\n    // dense values.\n    let mut unique_sources: Option<EliasFano> =\n        if directed && (might_have_trap_nodes || might_have_singletons) {\n            Some(EliasFano::new(nodes_number as u64, nodes_number as usize)?)\n        } else {\n            None\n        };\n    // When the graph is either undirected or directed without trap nodes, the unique sources set and the\n    // nodes with edges set are equal one another.\n    // We need to compute the following set when it is not trivial, that is when\n    // either the graph is undirected and there are no singletons or alternatively\n    // when the graph is directed and there are neither trap nodes nor singletons.\n    // Additionally, since we need this support data structure when computing the\n    // number of singletons with selfloops, we need to create it also when it has\n    // been specified that there might be singletons with selfloops.\n    let mut not_singleton_nodes: Option<_> =\n        if (might_have_singletons || might_have_singletons_with_selfloops) && nodes_number > 0 {\n            Some(bitvec![Lsb0, u8; 0; nodes_number as usize])\n        } else {\n            None\n        };\n\n    // Last source inserted\n    let mut last_src: NodeT = 0;\n    let mut last_dst: NodeT = 0;\n    let mut last_edge_type: Option<EdgeTypeT> = None;\n    let mut unique_edges_number: EdgeT = 0;\n    let mut unique_selfloop_number: NodeT = 0;\n    let mut selfloop_number: EdgeT = 0;\n    let mut forward_undirected_edges_counter: EdgeT = 0;\n    let mut backward_undirected_edges_counter: EdgeT = 0;\n    let mut not_singleton_node_number: NodeT =\n        if might_have_singletons || might_have_singletons_with_selfloops {\n            0\n        } else {\n            nodes_number\n        };\n    // This bitvec should be really sparse ON SANE GRAPHS\n    // so we use a roaring bitvec to save memory.\n    let mut singleton_nodes_with_selfloops = if might_have_singletons_with_selfloops {\n        Some(RoaringBitmap::new())\n    } else {\n        None\n    };\n\n    let mut first = true;\n    for value in edges_iter {\n        let (src, dst, edge_type, weight) = value?;\n        let different_src = last_src != src || first;\n        let different_dst = last_dst != dst || first;\n        let selfloop = src == dst;\n        let different_edge_type = last_edge_type != edge_type || first;\n        if !(different_src || different_dst || different_edge_type) {\n            if ignore_duplicated_edges {\n                continue;\n            } else {\n                return Err(\"A duplicated edge was found while building the graph.\".to_owned());\n            }\n        }\n\n        if let Some(ets) = &mut edge_type_ids {\n            ets.push(edge_type);\n        }\n        match (&mut weights, weight) {\n            (Some(ws), Some(w)) => {\n                validate_weight(w)?;\n                ws.push(w);\n                Ok(())\n            }\n            (None, Some(_)) => Err(concat!(\n                \"A non-None weight was provided but no weights are expected \",\n                \"because the has_edge_weights flag has been set to false.\"\n            )),\n            (Some(_), None) => Err(concat!(\n                \"A None weight was found.\\n\",\n                \"This might mean you have either provided a None weight to the edge list or \",\n                \"you may have an empty weight in your edge list file.\\n\",\n                \"If you intend to load this edge list WITHOUT weights, do not provide the \",\n                \"edge weights colum or column number.\\n\",\n                \"If you intend to load this edge with its weight, add a default weight.\"\n            )),\n            _ => Ok(()),\n        }?;\n\n        if !directed && !edge_list_is_correct {\n            match src.cmp(&dst) {\n                Ordering::Greater => {\n                    // We retrieve the edge id of the forward edge, the one going from\n                    // dst to src.\n                    let maybe_edge_id = edges.rank(encode_edge(dst, src, node_bits));\n                    // Now we need to find, starting from edge id, if the edge types are given,\n                    // the correct edge id: if we are in a multi-graph the edge may be the same\n                    // but have multiple edge types and hence be reported multiple times.\n                    let maybe_edge_id = maybe_edge_id.and_then(|min_edge_id| {\n                        edge_type_ids.as_ref().map_or(Some(min_edge_id), |ets| {\n                            (min_edge_id\n                                ..edges.unchecked_rank(encode_edge(dst, src + 1, node_bits)))\n                                .find(|edge_id| ets[*edge_id as usize] == edge_type)\n                        })\n                    });\n                    // Finally now we need to check if the weights of the two edges, if given\n                    // are actually equal.\n                    let has_unbalanced_undirected_edge = maybe_edge_id.map_or(true, |edge_id| {\n                        weights.as_ref().map_or(false, |ws| {\n                            (ws[edge_id as usize] - weight.unwrap()).abs() >= f32::EPSILON\n                        })\n                    });\n                    if has_unbalanced_undirected_edge {\n                        return Err(concat!(\n                            \"You are trying to load an undirected \",\n                            \"graph using the directed edge list \",\n                            \"paremeter that requires for ALL edges to \",\n                            \"be fully defined in both directions.\\n\",\n                            \"The edge list you have provided does not \",\n                            \"provide the edges in both directions.\",\n                        )\n                        .to_string());\n                    }\n                    backward_undirected_edges_counter += 1\n                }\n                Ordering::Less => forward_undirected_edges_counter += 1,\n                Ordering::Equal => {}\n            }\n        }\n        last_edge_type = edge_type;\n        edges.unchecked_push(encode_edge(src, dst, node_bits));\n        if selfloop {\n            selfloop_number += 1;\n        }\n        if different_src || different_dst {\n            if let Some(nwe) = &mut not_singleton_nodes {\n                for node in &[src, dst] {\n                    unsafe {\n                        let mut ptr = nwe.get_unchecked_mut(*node as usize);\n                        if !*ptr {\n                            *ptr = true;\n                            if !selfloop || singleton_nodes_with_selfloops.is_none() {\n                                not_singleton_node_number += 1;\n                            } else {\n                                if let Some(bitmap) = &mut singleton_nodes_with_selfloops {\n                                    bitmap.insert(*node);\n                                }\n                                break;\n                            }\n                        } else if !selfloop\n                            && singleton_nodes_with_selfloops\n                                .as_mut()\n                                .map_or(false, |bitmap| bitmap.remove(*node))\n                        {\n                            not_singleton_node_number += 1;\n                        }\n                    }\n                }\n            }\n            unique_edges_number += 1;\n            if selfloop {\n                unique_selfloop_number += 1;\n            }\n            if different_src {\n                if let Some(us) = &mut unique_sources {\n                    us.unchecked_push(src as u64);\n                }\n            }\n        }\n        last_src = src;\n        last_dst = dst;\n        first = false;\n    }\n\n    if forward_undirected_edges_counter != backward_undirected_edges_counter {\n        return Err(concat!(\n            \"You are trying to load an undirected graph \",\n            \"from a directed edge list but the edge list is not \",\n            \"complete.\"\n        )\n        .to_owned());\n    }\n\n    if let Some(ws) = &weights {\n        if edges.len() != ws.len() {\n            panic!(\n                \"The number of weights {} does not match the number of edges {}.\",\n                ws.len(),\n                edges.len()\n            );\n        }\n        if ws.is_empty() {\n            weights = None;\n        }\n    }\n\n    if let Some(ets) = &edge_type_ids {\n        if edges.len() != ets.len() {\n            panic!(\n                \"The number of edge types {} does not match the number of edges {}.\",\n                ets.len(),\n                edges.len()\n            );\n        }\n\n        if ets.is_empty() {\n            edge_type_ids = None;\n        }\n    }\n\n    if not_singleton_node_number > nodes_number {\n        panic!(\n            \"There is an error in the constructor, the not singleton  node number '{}' is bigger than node number '{}'\",\n            not_singleton_node_number, nodes_number\n        );\n    }\n\n    let singleton_nodes_with_selfloops_number = singleton_nodes_with_selfloops\n        .as_ref()\n        .map_or(0, |bitmap| bitmap.len() as NodeT);\n\n    // While on internal methods nodes_number is always exact, the user may\n    // provide a wrong value for nodes_number when loading a sorted csv.\n    // If this happens, it might cause a slow down in the walk and other\n    // currently unforseen consequences.\n    if nodes_number == not_singleton_node_number + singleton_nodes_with_selfloops_number {\n        unique_sources = None;\n    }\n\n    // When we have computed the nodes with edges set but we have left None\n    // the unique sources elias fano, this is done to avoid using extra memory\n    // for no reason. We need to create the elias fano object starting from the\n    // nodes with edges now to normalize the returned values.\n    if might_have_singletons\n        && unique_sources.is_none()\n        && nodes_number != not_singleton_node_number + singleton_nodes_with_selfloops_number\n    {\n        unique_sources = not_singleton_nodes\n            .as_ref()\n            .map_or(Ok::<_, String>(None), |nsns| {\n                Ok(Some(EliasFano::from_iter(\n                    nsns.iter_ones().into_iter().map(|x| x as u64),\n                    nodes_number as u64,\n                    not_singleton_node_number as usize\n                        + singleton_nodes_with_selfloops_number as usize,\n                )?))\n            })?;\n    }\n\n    if !directed\n        && unique_sources\n            .as_ref()\n            .map_or(false, |x| not_singleton_node_number > x.len() as NodeT)\n    {\n        panic!(\n            \"There is an error in the constructor, the not singleton node number '{}' is bigger than the len of unique sources which is '{}'\",\n            not_singleton_node_number, unique_sources.unwrap().len()\n        );\n    }\n\n    Ok((\n        edges,\n        unique_sources,\n        edge_type_ids,\n        weights,\n        unique_edges_number,\n        selfloop_number,\n        unique_selfloop_number,\n        not_singleton_node_number,\n        singleton_nodes_with_selfloops_number,\n        node_bits,\n        node_bit_mask,\n        not_singleton_nodes,\n        singleton_nodes_with_selfloops,\n    ))"
    },
    {
        "file": "constructors.rs",
        "doc": [],
        "modifiers": "",
        "name": "parse_nodes",
        "args": [
            [
                "nodes_iterator",
                "Option<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>>>"
            ],
            [
                "ignore_duplicated_nodes",
                "bool"
            ],
            [
                "node_list_is_correct",
                "bool"
            ],
            [
                "numeric_node_ids",
                "bool"
            ],
            [
                "numeric_node_types_ids",
                "bool"
            ],
            [
                "numeric_edge_node_ids",
                "bool"
            ],
            [
                "has_node_types",
                "bool"
            ]
        ],
        "return_type": "Result<(Vocabulary<NodeT>, Option<NodeTypeVocabulary>), String>",
        "body": "let mut nodes = Vocabulary::default()\n        .set_numeric_ids(numeric_node_ids || numeric_edge_node_ids && nodes_iterator.is_none());\n\n    let node_types = if let Some(ni) = nodes_iterator {\n        // TODO: the following can likely be dealt with in a better way.\n        let node_iterator = parse_node_ids(\n            ni,\n            ignore_duplicated_nodes,\n            node_list_is_correct,\n            &mut nodes,\n        );\n        // In the case there is a node types we need to add its proper iterator.\n        if has_node_types {\n            let mut node_types =\n                NodeTypeVocabulary::default().set_numeric_ids(numeric_node_types_ids);\n            for row in parse_node_type_ids(node_iterator, &mut node_types) {\n                row?;\n            }\n            node_types.build_reverse_mapping()?;\n            node_types.build_counts();\n\n            if node_types.is_empty() {\n                Ok(None)\n            } else {\n                Ok::<_, String>(Some(node_types))\n            }\n        } else {\n            for row in node_iterator {\n                row?;\n            }\n            Ok::<_, String>(None)\n        }?\n    } else {\n        None\n    };\n\n    Ok((nodes, node_types))"
    },
    {
        "file": "constructors.rs",
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "parse_string_edges",
        "args": [
            [
                "edges_iter",
                "impl Iterator<Item = Result<StringQuadruple, String>>"
            ],
            [
                "edges_number",
                "usize"
            ],
            [
                "nodes_number",
                "NodeT"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "nodes",
                "Vocabulary<NodeT>"
            ],
            [
                "numeric_edge_type_ids",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ],
            [
                "edge_list_is_correct",
                "bool"
            ],
            [
                "ignore_duplicated_edges",
                "bool"
            ],
            [
                "has_edge_types",
                "bool"
            ],
            [
                "has_edge_weights",
                "bool"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ]
        ],
        "return_type": "ParsedStringEdgesType",
        "body": "let mut edge_types_vocabulary: Vocabulary<EdgeTypeT> =\n        Vocabulary::default().set_numeric_ids(numeric_edge_type_ids);\n\n    // This is not equivalent to nodes_iterator.is_some() because the iterator\n    // could also be empty, this is a corner-case that might happen when over-filtering\n    // or fuzzing or loading an empty file with improper configurations.\n    // There might be singletons if the user has told us that there might be singletons\n    // and the node list is not empty. If the node list is empty, then it is not possible\n    // to have singletons.\n    let might_have_singletons = !nodes.is_empty() && might_have_singletons;\n    // If the graph is undirected there cannot be trap nodes\n    let might_have_trap_nodes = directed && might_have_trap_nodes;\n\n    let edges_iter = parse_sorted_edges(\n        parse_edge_type_ids_vocabulary(\n            parse_edges_node_ids(edges_iter, edge_list_is_correct, &mut nodes),\n            &mut edge_types_vocabulary,\n        ),\n        directed,\n        directed_edge_list,\n    );\n\n    let (\n        edges,\n        unique_sources,\n        edge_type_ids,\n        weights,\n        unique_edges_number,\n        selfloop_number,\n        unique_selfloop_number,\n        not_singleton_nodes_number,\n        singleton_nodes_with_selfloops_number,\n        node_bits,\n        node_bit_mask,\n        not_singleton_nodes,\n        singleton_nodes_with_selfloops,\n    ) = build_edges(\n        edges_iter,\n        edges_number,\n        nodes_number,\n        ignore_duplicated_edges,\n        has_edge_weights,\n        has_edge_types,\n        might_have_singletons,\n        might_have_singletons_with_selfloops,\n        might_have_trap_nodes,\n        directed,\n        edge_list_is_correct,\n    )?;\n\n    nodes.build_reverse_mapping()?;\n    edge_types_vocabulary.build_reverse_mapping()?;\n    let edge_types =\n        EdgeTypeVocabulary::from_option_structs(edge_type_ids, optionify!(edge_types_vocabulary));\n\n    Ok((\n        edges,\n        unique_sources,\n        nodes,\n        edge_types,\n        weights,\n        unique_edges_number,\n        selfloop_number,\n        unique_selfloop_number,\n        not_singleton_nodes_number,\n        singleton_nodes_with_selfloops_number,\n        node_bit_mask,\n        node_bits,\n        not_singleton_nodes,\n        singleton_nodes_with_selfloops,\n    ))"
    },
    {
        "file": "constructors.rs",
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "parse_integer_edges",
        "args": [
            [
                "edges_iter",
                "impl Iterator<Item = Result<Quadruple, String>>"
            ],
            [
                "edges_number",
                "usize"
            ],
            [
                "nodes_number",
                "NodeT"
            ],
            [
                "edge_types_vocabulary",
                "Option<Vocabulary<EdgeTypeT>>"
            ],
            [
                "ignore_duplicated_edges",
                "bool"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "edge_list_is_correct",
                "bool"
            ],
            [
                "has_edge_types",
                "bool"
            ],
            [
                "has_edge_weights",
                "bool"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ]
        ],
        "return_type": "Result<\n    (\n        EliasFano,\n        Option<EliasFano>,\n        Option<EdgeTypeVocabulary>,\n        Option<Vec<WeightT>>,\n        EdgeT,\n        EdgeT,\n        NodeT,\n        NodeT,\n        NodeT,\n        u64,\n        u8,\n        Option<BitVec<Lsb0, u8>>,\n        Option<RoaringBitmap>,\n    ),\n    String,\n>",
        "body": "let (\n        edges,\n        unique_sources,\n        edge_type_ids,\n        weights,\n        unique_edges_number,\n        selfloop_number,\n        unique_selfloop_number,\n        not_singleton_nodes_number,\n        singleton_nodes_with_selfloops_number,\n        node_bits,\n        node_bit_mask,\n        not_singleton_nodes,\n        singleton_nodes_with_selfloops,\n    ) = build_edges(\n        edges_iter,\n        edges_number,\n        nodes_number,\n        ignore_duplicated_edges,\n        has_edge_weights,\n        has_edge_types,\n        might_have_singletons,\n        might_have_singletons_with_selfloops,\n        might_have_trap_nodes,\n        directed,\n        edge_list_is_correct,\n    )?;\n\n    let edge_types = EdgeTypeVocabulary::from_option_structs(edge_type_ids, edge_types_vocabulary);\n\n    Ok((\n        edges,\n        unique_sources,\n        edge_types,\n        weights,\n        unique_edges_number,\n        selfloop_number,\n        unique_selfloop_number,\n        not_singleton_nodes_number,\n        singleton_nodes_with_selfloops_number,\n        node_bit_mask,\n        node_bits,\n        not_singleton_nodes,\n        singleton_nodes_with_selfloops,\n    ))"
    },
    {
        "file": "constructors.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Graph Constructors"
        ],
        "doc": [],
        "modifiers": "pub(crate)",
        "name": "build_graph",
        "generics": "S: Into<String>",
        "args": [
            [
                "edges_iter",
                "impl Iterator<Item = Result<Quadruple, String>>"
            ],
            [
                "edges_number",
                "usize"
            ],
            [
                "nodes",
                "Vocabulary<NodeT>"
            ],
            [
                "node_types",
                "Option<NodeTypeVocabulary>"
            ],
            [
                "edge_types_vocabulary",
                "Option<Vocabulary<EdgeTypeT>>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "edge_list_is_correct",
                "bool"
            ],
            [
                "name",
                "S"
            ],
            [
                "ignore_duplicated_edges",
                "bool"
            ],
            [
                "has_edge_types",
                "bool"
            ],
            [
                "has_edge_weights",
                "bool"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "let (\n            edges,\n            unique_sources,\n            edge_types,\n            weights,\n            unique_edges_number,\n            selfloop_number,\n            unique_selfloop_number,\n            not_singleton_nodes_number,\n            singleton_nodes_with_selfloops_number,\n            node_bit_mask,\n            node_bits,\n            not_singleton_nodes,\n            singleton_nodes_with_selfloops,\n        ) = parse_integer_edges(\n            edges_iter,\n            edges_number,\n            nodes.len() as NodeT,\n            edge_types_vocabulary,\n            ignore_duplicated_edges,\n            directed,\n            edge_list_is_correct,\n            has_edge_types,\n            has_edge_weights,\n            might_have_singletons,\n            might_have_singletons_with_selfloops,\n            might_have_trap_nodes,\n        )?;\n\n        Ok(Graph::new(\n            directed,\n            unique_selfloop_number,\n            selfloop_number,\n            not_singleton_nodes_number,\n            singleton_nodes_with_selfloops_number,\n            unique_edges_number,\n            edges,\n            unique_sources,\n            nodes,\n            node_bit_mask,\n            node_bits,\n            edge_types,\n            name,\n            weights,\n            node_types,\n            not_singleton_nodes,\n            singleton_nodes_with_selfloops,\n        ))"
    },
    {
        "file": "constructors.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Graph Constructors"
        ],
        "doc": [
            "Create new Graph object from unsorted source.",
            "",
            "# Arguments",
            "",
            "TODO: UPDATE THE DOCSTRING!",
            "",
            "* `edges_iterator`: impl Iterator<Item = Result<StringQuadruple, String>> - Iterator of the edges.",
            "* `nodes_iterator`: Option<impl Iterator<Item = Result<(String, Option<String>), String>>> -Iterator of the nodes.",
            "* `directed`: bool - Wether the graph should be directed or undirected.",
            "* `ignore_duplicated_nodes`: bool - Wether to ignore duplicated nodes or to raise a proper exception.",
            "* `ignore_duplicated_edges`: bool - Wether to ignore duplicated edges or to raise a proper exception.",
            "* `skip_selfloops`: bool - Wether to skip self loops while reading the the edges iterator."
        ],
        "modifiers": "pub",
        "name": "from_string_unsorted",
        "generics": "S: Into<String>",
        "args": [
            [
                "edges_iterator",
                "impl Iterator<Item = Result<StringQuadruple, String>>"
            ],
            [
                "nodes_iterator",
                "Option<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>>>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ],
            [
                "name",
                "S"
            ],
            [
                "ignore_duplicated_nodes",
                "bool"
            ],
            [
                "node_list_is_correct",
                "bool"
            ],
            [
                "ignore_duplicated_edges",
                "bool"
            ],
            [
                "edge_list_is_correct",
                "bool"
            ],
            [
                "verbose",
                "bool"
            ],
            [
                "numeric_edge_type_ids",
                "bool"
            ],
            [
                "numeric_node_ids",
                "bool"
            ],
            [
                "numeric_edge_node_ids",
                "bool"
            ],
            [
                "numeric_node_types_ids",
                "bool"
            ],
            [
                "has_node_types",
                "bool"
            ],
            [
                "has_edge_types",
                "bool"
            ],
            [
                "has_edge_weights",
                "bool"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "check_numeric_ids_compatibility(\n            nodes_iterator.is_some(),\n            numeric_node_ids,\n            numeric_edge_node_ids,\n        )?;\n\n        let (nodes, node_types) = parse_nodes(\n            nodes_iterator,\n            ignore_duplicated_nodes,\n            node_list_is_correct,\n            numeric_node_ids,\n            numeric_node_types_ids,\n            numeric_edge_node_ids,\n            has_node_types,\n        )?;\n\n        // This is not equivalent to nodes_iterator.is_some() because the iterator\n        // could also be empty, this is a corner-case that might happen when over-filtering\n        // or fuzzing or loading an empty file with improper configurations.\n        // There might be singletons if the user has told us that there might be singletons\n        // and the node list is not empty. If the node list is empty, then it is not possible\n        // to have singletons.\n        let might_have_singletons = !nodes.is_empty() && might_have_singletons;\n        // If the graph is undirected there cannot be trap nodes\n        let might_have_trap_nodes = directed && might_have_trap_nodes;\n\n        info!(\"Parse unsorted edges.\");\n        let (edges_number, edges_iterator, nodes, edge_types_vocabulary) =\n            parse_string_unsorted_edges(\n                edges_iterator,\n                nodes,\n                directed,\n                directed_edge_list,\n                edge_list_is_correct,\n                has_edge_types,\n                verbose,\n                numeric_edge_type_ids,\n            )?;\n\n        Graph::build_graph(\n            edges_iterator,\n            edges_number,\n            nodes,\n            node_types,\n            edge_types_vocabulary,\n            directed,\n            edge_list_is_correct || !directed_edge_list,\n            name,\n            ignore_duplicated_edges,\n            has_edge_types,\n            has_edge_weights,\n            might_have_singletons,\n            might_have_singletons_with_selfloops,\n            might_have_trap_nodes,\n        )"
    },
    {
        "file": "constructors.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Graph Constructors"
        ],
        "doc": [
            "Create new Graph object from unsorted source.",
            "",
            "# Arguments",
            "",
            "* `edges_iterator`: impl Iterator<Item = Result<StringQuadruple, String>> - Iterator of the edges.",
            "* `nodes_iterator`: Option<impl Iterator<Item = Result<(String, Option<String>), String>>> - Iterator of the nodes.",
            "* `directed`: bool - Wether the graph should be directed or undirected.",
            "* `ignore_duplicated_nodes`: bool - Wether to ignore duplicated nodes or to raise a proper exception.",
            "* `ignore_duplicated_edges`: bool - Wether to ignore duplicated edges or to raise a proper exception.",
            "* `skip_selfloops`: bool - Wether to skip self loops while reading the the edges iterator."
        ],
        "modifiers": "pub",
        "name": "from_integer_unsorted",
        "args": [
            [
                "edges_iterator",
                "impl Iterator<\n            Item = Result<(NodeT, NodeT, Option<NodeTypeT>, Option<WeightT>), String>,\n        >"
            ],
            [
                "nodes",
                "Vocabulary<NodeT>"
            ],
            [
                "node_types",
                "Option<NodeTypeVocabulary>"
            ],
            [
                "edge_types_vocabulary",
                "Option<Vocabulary<EdgeTypeT>>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "name",
                "String"
            ],
            [
                "ignore_duplicated_edges",
                "bool"
            ],
            [
                "has_edge_types",
                "bool"
            ],
            [
                "has_edge_weights",
                "bool"
            ],
            [
                "verbose",
                "bool"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "let (edges_number, edges_iterator) =\n            parse_integer_unsorted_edges(edges_iterator, directed, true, verbose)?;\n\n        Graph::build_graph(\n            edges_iterator,\n            edges_number,\n            nodes,\n            node_types,\n            edge_types_vocabulary,\n            directed,\n            true,\n            name,\n            ignore_duplicated_edges,\n            has_edge_types,\n            has_edge_weights,\n            might_have_singletons,\n            might_have_singletons_with_selfloops,\n            might_have_trap_nodes,\n        )"
    },
    {
        "file": "constructors.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Graph Constructors"
        ],
        "doc": [
            "Create new Graph object from sorted sources."
        ],
        "modifiers": "pub",
        "name": "from_string_sorted",
        "generics": "S: Into<String>",
        "args": [
            [
                "edges_iterator",
                "impl Iterator<Item = Result<StringQuadruple, String>>"
            ],
            [
                "nodes_iterator",
                "Option<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>>>"
            ],
            [
                "directed",
                "bool"
            ],
            [
                "directed_edge_list",
                "bool"
            ],
            [
                "ignore_duplicated_nodes",
                "bool"
            ],
            [
                "node_list_is_correct",
                "bool"
            ],
            [
                "ignore_duplicated_edges",
                "bool"
            ],
            [
                "edge_list_is_correct",
                "bool"
            ],
            [
                "edges_number",
                "usize"
            ],
            [
                "nodes_number",
                "NodeT"
            ],
            [
                "numeric_edge_type_ids",
                "bool"
            ],
            [
                "numeric_node_ids",
                "bool"
            ],
            [
                "numeric_edge_node_ids",
                "bool"
            ],
            [
                "numeric_node_types_ids",
                "bool"
            ],
            [
                "has_node_types",
                "bool"
            ],
            [
                "has_edge_types",
                "bool"
            ],
            [
                "has_edge_weights",
                "bool"
            ],
            [
                "might_have_singletons",
                "bool"
            ],
            [
                "might_have_singletons_with_selfloops",
                "bool"
            ],
            [
                "might_have_trap_nodes",
                "bool"
            ],
            [
                "name",
                "S"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "check_numeric_ids_compatibility(\n            nodes_iterator.is_some(),\n            numeric_node_ids,\n            numeric_edge_node_ids,\n        )?;\n        let (nodes, node_types) = parse_nodes(\n            nodes_iterator,\n            ignore_duplicated_nodes,\n            node_list_is_correct,\n            numeric_node_ids,\n            numeric_node_types_ids,\n            numeric_edge_node_ids,\n            has_node_types,\n        )?;\n\n        if !nodes.is_empty() {\n            nodes_number = nodes.len() as NodeT;\n        }\n\n        let (\n            edges,\n            unique_sources,\n            nodes,\n            edge_types,\n            weights,\n            unique_edges_number,\n            selfloop_number,\n            unique_selfloop_number,\n            not_singleton_nodes_number,\n            singleton_nodes_with_selfloops_number,\n            node_bit_mask,\n            node_bits,\n            not_singleton_nodes,\n            singleton_nodes_with_selfloops,\n        ) = parse_string_edges(\n            edges_iterator,\n            edges_number,\n            nodes_number,\n            directed,\n            nodes,\n            numeric_edge_type_ids,\n            directed_edge_list,\n            edge_list_is_correct,\n            ignore_duplicated_edges,\n            has_edge_types,\n            has_edge_weights,\n            might_have_singletons,\n            might_have_singletons_with_selfloops,\n            might_have_trap_nodes,\n        )?;\n\n        Ok(Graph::new(\n            directed,\n            unique_selfloop_number,\n            selfloop_number,\n            not_singleton_nodes_number,\n            singleton_nodes_with_selfloops_number,\n            unique_edges_number,\n            edges,\n            unique_sources,\n            nodes,\n            node_bit_mask,\n            node_bits,\n            edge_types,\n            name,\n            weights,\n            node_types,\n            not_singleton_nodes,\n            singleton_nodes_with_selfloops,\n        ))"
    },
    {
        "file": "holdouts.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Holdouts."
        ],
        "doc": [
            "Returns Graph with given amount of negative edges as positive edges.",
            "",
            "The graph generated may be used as a testing negatives partition to be",
            "fed into the argument \"graph_to_avoid\" of the link_prediction or the",
            "skipgrams algorithm.",
            "",
            "",
            "# Arguments",
            "",
            "* `random_state`: EdgeT - random_state to use to reproduce negative edge set.",
            "* `negatives_number`: EdgeT - Number of negatives edges to include.",
            "* `seed_graph`: Option<&Graph> - Optional graph to use to filter the negative edges. The negative edges generated when this variable is provided will always have a node within this graph.",
            "* `only_from_same_component`: bool - Whether to sample negative edges only from nodes that are from the same component.",
            "* `verbose`: bool - Whether to show the loading bar.",
            ""
        ],
        "modifiers": "pub",
        "name": "sample_negatives",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "EdgeT"
            ],
            [
                "negatives_number",
                "EdgeT"
            ],
            [
                "seed_graph",
                "Option<&Graph>"
            ],
            [
                "only_from_same_component",
                "bool"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "if negatives_number == 0 {\n            return Err(String::from(\"The number of negatives cannot be zero.\"));\n        }\n        let seed_nodes: Option<RoaringBitmap> = if let Some(sg) = &seed_graph {\n            if !self.overlaps(&sg)? {\n                return Err(String::from(\n                    \"The given seed graph does not overlap with the current graph instance.\",\n                ));\n            }\n            Some(\n                sg.iter_nodes()\n                    .map(|(_, node_name, _, _)| {\n                        self.get_unchecked_node_id_from_node_name(&node_name)\n                    })\n                    .collect::<RoaringBitmap>(),\n            )\n        } else {\n            None\n        };\n        // In a complete directed graph allowing selfloops with N nodes there are N^2\n        // edges. In a complete directed graph without selfloops there are N*(N-1) edges.\n        // We can rewrite the first formula as (N*(N-1)) + N.\n        //\n        // In a complete undirected graph allowing selfloops with N nodes there are\n        // (N*(N-1))/2 + N edges.\n\n        // Here we use unique edges number because on a multigraph the negative\n        // edges cannot have an edge type.\n        let nodes_number = self.get_nodes_number() as EdgeT;\n\n        // whether to sample negative edges only from the same connected component.\n        let (node_components, mut complete_edges_number) = if only_from_same_component {\n            let node_components = self.get_node_connected_component_ids(verbose);\n            let complete_edges_number: EdgeT = Counter::init(node_components.clone())\n                .into_iter()\n                .map(|(_, nodes_number): (_, &usize)| {\n                    let mut edge_number = (*nodes_number * (*nodes_number - 1)) as EdgeT;\n                    if !self.is_directed() {\n                        edge_number /= 2;\n                    }\n                    edge_number\n                })\n                .sum();\n            (Some(node_components), complete_edges_number)\n        } else {\n            let mut edge_number = nodes_number * (nodes_number - 1);\n            if !self.is_directed() {\n                edge_number /= 2;\n            }\n            (None, edge_number)\n        };\n\n        // Here we compute the number of edges that a complete graph would have if it had the same number of nodes\n        // of the current graph. Moreover, the complete graph will have selfloops IFF the current graph has at\n        // least one of them.\n        if self.has_selfloops() {\n            complete_edges_number += nodes_number;\n        }\n\n        // Now we compute the maximum number of negative edges that we can actually generate\n        let max_negative_edges = complete_edges_number - self.get_unique_edges_number();\n\n        // We check that the number of requested negative edges is compatible with the\n        // current graph instance.\n        if negatives_number > max_negative_edges {\n            return Err(format!(\n                concat!(\n                    \"The requested negatives number {} is more than the \",\n                    \"number of negative edges that exist in the graph ({}).\"\n                ),\n                negatives_number, max_negative_edges\n            ));\n        }\n\n        // As the above check, it is not possible to generate some negative\n        // graphs when some conditions.\n        if negatives_number % 2 == 1 && !self.is_directed() && !self.has_selfloops() {\n            return Err(format!(\n                concat!(\n                    \"The requested negatives number {} is an odd number and \",\n                    \"the graph is neither directed nor has selfloops, so it is \",\n                    \"not possible to sample an odd number of edges.\"\n                ),\n                negatives_number\n            ));\n        }\n\n        let pb1 = get_loading_bar(\n            verbose,\n            \"Computing negative edges\",\n            negatives_number as usize,\n        );\n\n        // xorshift breaks if the random_state is zero\n        // so we initialize xor it with a constat\n        // to mitigate this problem\n        random_state ^= SEED_XOR as EdgeT;\n\n        let mut negative_edges_hashset = HashSet::with_capacity(negatives_number as usize);\n        let mut last_length = 0;\n        let mut sampling_round: usize = 0;\n\n        // randomly extract negative edges until we have the choosen number\n        while negative_edges_hashset.len() < negatives_number as usize {\n            // generate two random_states for reproducibility porpouses\n            let src_random_state = rand_u64(random_state);\n            let dst_random_state = rand_u64(src_random_state);\n            random_state = rand_u64(dst_random_state);\n\n            let tmp_tb = get_loading_bar(\n                verbose,\n                format!(\"Negatives sampling round {}\", sampling_round).as_ref(),\n                negatives_number as usize,\n            );\n            sampling_round += 1;\n\n            // generate the random edge-sources\n            let sampled_edge_ids = gen_random_vec(negatives_number as usize, src_random_state)\n                .into_par_iter()\n                .zip(gen_random_vec(negatives_number as usize, dst_random_state).into_par_iter())\n                // convert them to plain (src, dst)\n                .progress_with(tmp_tb)\n                .filter_map(|(src_seed, dst_seed)| {\n                    let src = sample_uniform(nodes_number as u64, src_seed as u64) as NodeT;\n                    let dst = sample_uniform(nodes_number as u64, dst_seed as u64) as NodeT;\n                    if !self.is_directed() && src > dst {\n                        return None;\n                    }\n\n                    if !self.has_selfloops() && src == dst {\n                        return None;\n                    }\n\n                    if let Some(sn) = &seed_nodes {\n                        if !sn.contains(src) && !sn.contains(dst) {\n                            return None;\n                        }\n                    }\n                    if let Some(ncs) = &node_components {\n                        if ncs[src as usize] != ncs[dst as usize] {\n                            return None;\n                        }\n                    }\n                    // If the edge is not a self-loop or the user allows self-loops and\n                    // the graph is directed or the edges are inserted in a way to avoid\n                    // inserting bidirectional edges.\n                    match self.has_edge_from_node_ids(src, dst) {\n                        true => None,\n                        false => Some(self.encode_edge(src, dst)),\n                    }\n                })\n                .collect::<Vec<EdgeT>>();\n\n            let pb3 = get_loading_bar(\n                verbose,\n                format!(\n                    \"Inserting negative graph edges (iteration {})\",\n                    sampling_round\n                )\n                .as_ref(),\n                negatives_number as usize,\n            );\n\n            for edge_id in sampled_edge_ids.iter().progress_with(pb3) {\n                if negative_edges_hashset.len() >= negatives_number as usize {\n                    break;\n                }\n                negative_edges_hashset.insert(*edge_id);\n            }\n\n            if sampling_round > 50000 {\n                panic!(\"Deadlock in sampling negatives!\");\n            }\n\n            pb1.inc((negative_edges_hashset.len() - last_length as usize) as u64);\n            last_length = negative_edges_hashset.len();\n        }\n\n        pb1.finish();\n\n        Graph::from_integer_unsorted(\n            negative_edges_hashset.into_iter().flat_map(|edge| {\n                let (src, dst) = self.decode_edge(edge);\n                if !self.is_directed() && src != dst {\n                    vec![Ok((src, dst, None, None)), Ok((dst, src, None, None))]\n                } else {\n                    vec![Ok((src, dst, None, None))]\n                }\n            }),\n            self.nodes.clone(),\n            self.node_types.clone(),\n            None,\n            self.directed,\n            format!(\"Negative {}\", self.name.clone()),\n            false,\n            false,\n            false,\n            verbose,\n            true,\n            self.has_selfloops(),\n            true,\n        )"
    },
    {
        "file": "holdouts.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Holdouts."
        ],
        "doc": [
            "Compute the training and validation elements number from the training rate"
        ],
        "modifiers": "",
        "name": "get_holdouts_elements_number",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "train_size",
                "f64"
            ],
            [
                "total_elements",
                "usize"
            ]
        ],
        "return_type": "Result<(usize, usize), String>",
        "body": "if train_size <= 0.0 || train_size >= 1.0 {\n            return Err(String::from(\"Train rate must be strictly between 0 and 1.\"));\n        }\n        if self.directed && self.get_directed_edges_number() == 1\n            || !self.directed && self.get_directed_edges_number() == 2\n        {\n            return Err(String::from(\n                \"The current graph instance has only one edge. You cannot build an holdout with one edge.\",\n            ));\n        }\n        let train_elements_number = (total_elements as f64 * train_size) as usize;\n        let valid_elements_number = total_elements - train_elements_number;\n\n        if train_elements_number == 0 || train_elements_number >= total_elements {\n            return Err(String::from(\n                \"The training set has 0 elements! Change the training rate.\",\n            ));\n        }\n        if valid_elements_number == 0 {\n            return Err(String::from(\n                \"The validation set has 0 elements! Change the training rate.\",\n            ));\n        }\n\n        Ok((train_elements_number, valid_elements_number))"
    },
    {
        "file": "holdouts.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Holdouts."
        ],
        "doc": [
            "Compute the training and validation edges number from the training rate"
        ],
        "modifiers": "",
        "name": "get_holdouts_edges_number",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "train_size",
                "f64"
            ],
            [
                "include_all_edge_types",
                "bool"
            ]
        ],
        "return_type": "Result<(EdgeT, EdgeT), String>",
        "body": "if self.directed && self.get_directed_edges_number() == 1\n            || !self.directed && self.get_directed_edges_number() == 2\n        {\n            return Err(String::from(\n                \"The current graph instance has only one edge. You cannot build an holdout with one edge.\",\n            ));\n        }\n        let total_edges_number = if include_all_edge_types {\n            self.unique_edges_number\n        } else {\n            self.get_directed_edges_number()\n        };\n\n        let (train_edges, test_edges) =\n            self.get_holdouts_elements_number(train_size, total_edges_number as usize)?;\n        Ok((train_edges as EdgeT, test_edges as EdgeT))"
    },
    {
        "file": "holdouts.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Holdouts."
        ],
        "doc": [],
        "modifiers": "",
        "name": "edge_holdout",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "EdgeT"
            ],
            [
                "valid_edges_number",
                "EdgeT"
            ],
            [
                "include_all_edge_types",
                "bool"
            ],
            [
                "user_condition",
                "impl Fn(EdgeT, NodeT, NodeT, Option<EdgeTypeT>) -> bool"
            ],
            [
                "verbose",
                "bool"
            ],
            [
                "train_graph_might_have_singletons",
                "bool"
            ],
            [
                "train_graph_might_have_singletons_with_selfloops",
                "bool"
            ]
        ],
        "return_type": "Result<(Graph, Graph), String>",
        "body": "let pb1 = get_loading_bar(\n            verbose,\n            \"Picking validation edges\",\n            valid_edges_number as usize,\n        );\n\n        // generate and shuffle the indices of the edges\n        let mut rng = SmallRng::seed_from_u64(random_state ^ SEED_XOR as EdgeT);\n        let mut edge_indices: Vec<EdgeT> = (0..self.get_directed_edges_number()).collect();\n        edge_indices.shuffle(&mut rng);\n\n        let mut valid_edges_bitmap = RoaringTreemap::new();\n        let mut last_length = 0;\n\n        for (edge_id, (src, dst, edge_type)) in edge_indices.into_iter().map(|edge_id| {\n            (\n                edge_id,\n                self.get_unchecked_node_ids_and_edge_type_id_from_edge_id(edge_id),\n            )\n        }) {\n            // If the graph is undirected and we have extracted an edge that is a\n            // simmetric one, we can skip this iteration.\n            if !self.directed && src > dst {\n                continue;\n            }\n\n            // We stop adding edges when we have reached the minimum amount.\n            if user_condition(edge_id, src, dst, edge_type) {\n                // Compute the forward edge ids that are required.\n                valid_edges_bitmap.extend(self.compute_edge_ids_vector(\n                    edge_id,\n                    src,\n                    dst,\n                    include_all_edge_types,\n                ));\n\n                // If the graph is undirected\n                if !self.directed {\n                    // we compute also the backward edge ids that are required.\n                    valid_edges_bitmap.extend(self.compute_edge_ids_vector(\n                        self.get_unchecked_edge_id_from_node_ids_and_edge_type_id(\n                            dst, src, edge_type,\n                        ),\n                        dst,\n                        src,\n                        include_all_edge_types,\n                    ));\n                }\n                pb1.inc(valid_edges_bitmap.len() - last_length);\n                last_length = valid_edges_bitmap.len();\n            }\n\n            // We stop the iteration when we found all the edges.\n            if valid_edges_bitmap.len() >= valid_edges_number {\n                break;\n            }\n        }\n\n        if valid_edges_bitmap.len() < valid_edges_number {\n            let actual_valid_edges_number = valid_edges_bitmap.len();\n            return Err(format!(\n                concat!(\n                    \"With the given configuration for the holdout, it is not possible to \",\n                    \"generate a validation set composed of {valid_edges_number} edges from the current graph.\\n\",\n                    \"The validation set can be composed of at most {actual_valid_edges_number} edges.\\n\"\n                ),\n                valid_edges_number=valid_edges_number,\n                actual_valid_edges_number=actual_valid_edges_number,\n            ));\n        }\n\n        // Creating the loading bar for the building of both the training and validation.\n        let pb_valid = get_loading_bar(\n            verbose,\n            \"Building the valid partition\",\n            valid_edges_bitmap.len() as usize,\n        );\n        let pb_train = get_loading_bar(\n            verbose,\n            \"Building the train partition\",\n            (self.get_directed_edges_number() - valid_edges_bitmap.len()) as usize,\n        );\n\n        Ok((\n            Graph::build_graph(\n                (0..self.get_directed_edges_number())\n                    .filter(|edge_id| !valid_edges_bitmap.contains(*edge_id))\n                    .progress_with(pb_train)\n                    .map(|edge_id| {\n                        Ok(self\n                            .get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(\n                                edge_id,\n                            ))\n                    }),\n                self.get_directed_edges_number() as usize - valid_edges_bitmap.len() as usize,\n                self.nodes.clone(),\n                self.node_types.clone(),\n                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n                self.directed,\n                true,\n                format!(\"{} training\", self.name.clone()),\n                true,\n                self.has_edge_types(),\n                self.has_edge_weights(),\n                train_graph_might_have_singletons,\n                train_graph_might_have_singletons_with_selfloops,\n                true,\n            )?,\n            Graph::build_graph(\n                valid_edges_bitmap\n                    .iter()\n                    .progress_with(pb_valid)\n                    .map(|edge_id| {\n                        Ok(self\n                            .get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(\n                                edge_id,\n                            ))\n                    }),\n                valid_edges_bitmap.len() as usize,\n                self.nodes.clone(),\n                self.node_types.clone(),\n                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n                self.directed,\n                true,\n                format!(\"{} testing\", self.name.clone()),\n                true,\n                self.has_edge_types(),\n                self.has_edge_weights(),\n                true,\n                self.has_selfloops(),\n                true,\n            )?,\n        ))"
    },
    {
        "file": "holdouts.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Holdouts."
        ],
        "doc": [
            "Returns holdout for training ML algorithms on the graph structure.",
            "",
            "The holdouts returned are a tuple of graphs. The first one, which",
            "is the training graph, is garanteed to have the same number of",
            "graph components as the initial graph. The second graph is the graph",
            "meant for testing or validation of the algorithm, and has no garantee",
            "to be connected. It will have at most (1-train_size) edges,",
            "as the bound of connectivity which is required for the training graph",
            "may lead to more edges being left into the training partition.",
            "",
            "In the option where a list of edge types has been provided, these",
            "edge types will be those put into the validation set.",
            "",
            "# Arguments",
            "",
            "* `random_state`: EdgeT - The random_state to use for the holdout,",
            "* `train_size`: f64 - Rate target to reserve for training.",
            "* `edge_types`: Option<Vec<Option<String>>> - Edge types to be selected for in the validation set.",
            "* `include_all_edge_types`: bool - Whether to include all the edges between two nodes.",
            "* `verbose`: bool - Whether to show the loading bar.",
            "",
            ""
        ],
        "modifiers": "pub",
        "name": "connected_holdout",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "EdgeT"
            ],
            [
                "train_size",
                "f64"
            ],
            [
                "edge_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "include_all_edge_types",
                "bool"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(Graph, Graph), String>",
        "body": "if train_size <= 0.0 || train_size >= 1.0 {\n            return Err(String::from(\"Train rate must be strictly between 0 and 1.\"));\n        }\n\n        let edge_type_ids = edge_types.map_or(Ok::<_, String>(None), |ets| {\n            Ok(Some(\n                self.get_edge_type_ids_from_edge_type_names(ets)?\n                    .into_iter()\n                    .collect::<HashSet<Option<EdgeTypeT>>>(),\n            ))\n        })?;\n\n        let tree = self\n            .random_spanning_arborescence_kruskal(random_state, &edge_type_ids, verbose)\n            .0;\n\n        let edge_factor = if self.is_directed() { 1 } else { 2 };\n        let train_edges_number = (self.get_directed_edges_number() as f64 * train_size) as usize;\n        let mut valid_edges_number =\n            (self.get_directed_edges_number() as f64 * (1.0 - train_size)) as EdgeT;\n\n        if let Some(etis) = &edge_type_ids {\n            let selected_edges_number: EdgeT = etis\n                .iter()\n                .map(|et| self.get_unchecked_edge_count_from_edge_type_id(*et) as EdgeT)\n                .sum();\n            valid_edges_number = (selected_edges_number as f64 * (1.0 - train_size)) as EdgeT;\n        }\n\n        if tree.len() * edge_factor > train_edges_number {\n            return Err(format!(\n                concat!(\n                    \"The given spanning tree of the graph contains {} edges \",\n                    \"that is more than the required training edges number {}.\\n\",\n                    \"This makes impossible to create a validation set using \",\n                    \"{} edges.\\nIf possible, you should increase the \",\n                    \"train_size parameter which is currently equal to \",\n                    \"{}.\\nThe deny map, by itself, is requiring at least \",\n                    \"a train rate of {}.\"\n                ),\n                tree.len() * edge_factor,\n                train_edges_number,\n                valid_edges_number,\n                train_size,\n                (tree.len() * edge_factor) as f64 / train_edges_number as f64\n            ));\n        }\n\n        self.edge_holdout(\n            random_state,\n            valid_edges_number,\n            include_all_edge_types,\n            |_, src, dst, edge_type| {\n                let is_in_tree = tree.contains(&(src, dst));\n                let singleton_selfloop = self.is_singleton_with_selfloops_from_node_id(src);\n                let correct_edge_type = edge_type_ids\n                    .as_ref()\n                    .map_or(true, |etis| etis.contains(&edge_type));\n                // The tree must not contain the provided edge ID\n                // And this is not a self-loop edge with degree 1\n                // And the edge type of the edge ID is within the provided edge type\n                !is_in_tree && !singleton_selfloop && correct_edge_type\n            },\n            verbose,\n            self.has_singletons(),\n            self.has_singletons_with_selfloops(),\n        )"
    },
    {
        "file": "holdouts.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Holdouts."
        ],
        "doc": [
            "Returns random holdout for training ML algorithms on the graph edges.",
            "",
            "The holdouts returned are a tuple of graphs. In neither holdouts the",
            "graph connectivity is necessarily preserved. To maintain that, use",
            "the method `connected_holdout`.",
            "",
            "# Arguments",
            "",
            "* `random_state`: EdgeT - The random_state to use for the holdout,",
            "* `train_size`: f64 - rate target to reserve for training",
            "* `include_all_edge_types`: bool - Whether to include all the edges between two nodes.",
            "* `edge_types`: Option<Vec<Option<String>>> - The edges to include in validation set.",
            "* `min_number_overlaps`: Option<EdgeT> - The minimum number of overlaps to include the edge into the validation set.",
            "* `verbose`: bool - Whether to show the loading bar.",
            ""
        ],
        "modifiers": "pub",
        "name": "random_holdout",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "EdgeT"
            ],
            [
                "train_size",
                "f64"
            ],
            [
                "include_all_edge_types",
                "bool"
            ],
            [
                "edge_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "min_number_overlaps",
                "Option<EdgeT>"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(Graph, Graph), String>",
        "body": "let (_, valid_edges_number) =\n            self.get_holdouts_edges_number(train_size, include_all_edge_types)?;\n        let edge_type_ids = edge_types.map_or(Ok::<_, String>(None), |ets| {\n            Ok(Some(\n                self.get_edge_type_ids_from_edge_type_names(ets)?\n                    .into_iter()\n                    .collect::<HashSet<Option<EdgeTypeT>>>(),\n            ))\n        })?;\n        if min_number_overlaps.is_some() {\n            self.must_be_multigraph()?;\n        }\n        self.edge_holdout(\n            random_state,\n            valid_edges_number,\n            include_all_edge_types,\n            |_, src, dst, edge_type| {\n                // If a list of edge types was provided and the edge type\n                // of the current edge is not within the provided list,\n                // we skip the current edge.\n                if !edge_type_ids\n                    .as_ref()\n                    .map_or(true, |etis| etis.contains(&edge_type))\n                {\n                    return false;\n                }\n                // If a minimum number of overlaps was provided and the current\n                // edge has not the required minimum amount of overlaps.\n                if let Some(mno) = min_number_overlaps {\n                    if self.get_unchecked_edge_degree_from_node_ids(src, dst) < mno {\n                        return false;\n                    }\n                }\n                // Otherwise we accept the provided edge for the validation set\n                true\n            },\n            verbose,\n            // Singletons may be generated during the holdouts process\n            true,\n            // Singletons with selfloops may be generated during the holdouts process only when there are selfloops in the graph\n            self.has_selfloops(),\n        )"
    },
    {
        "file": "holdouts.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Holdouts."
        ],
        "doc": [
            "Returns node-label holdout for training ML algorithms on the graph node labels.",
            "",
            "# Arguments",
            "* `train_size`: f64 - rate target to reserve for training,",
            "* `use_stratification`: bool - Whether to use node-label stratification,",
            "* `random_state`: EdgeT - The random_state to use for the holdout,",
            "",
            "# Example",
            "This example create an 80-20 split of the nodes in the graph",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let (train, test) = graph.node_label_holdout(0.8, true, 0xbad5eed).unwrap();",
            "```"
        ],
        "modifiers": "pub",
        "name": "node_label_holdout",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "train_size",
                "f64"
            ],
            [
                "use_stratification",
                "bool"
            ],
            [
                "random_state",
                "EdgeT"
            ]
        ],
        "return_type": "Result<(Graph, Graph), String>",
        "body": "self.must_have_node_types()?;\n        if use_stratification {\n            if self.has_multilabel_node_types() {\n                return Err(\"It is impossible to create a stratified holdout when the graph has multi-label node types.\".to_string());\n            }\n            if self.get_minimum_node_types_number() < 2 {\n                return Err(\"It is impossible to create a stratified holdout when the graph has node types with cardinality one.\".to_string());\n            }\n        }\n\n        // Compute the vectors with the indices of the nodes which node type matches\n        // therefore the expected shape is:\n        // (node_types_number, number of nodes of that node type)\n        let node_sets: Vec<Vec<NodeT>> = self\n            .node_types\n            .as_ref()\n            .map(|nts| {\n                if use_stratification {\n                    // Initialize the vectors for each node type\n                    let mut node_sets: Vec<Vec<NodeT>> =\n                        vec![Vec::new(); self.get_node_types_number() as usize];\n                    // itering over the indices and adding each node to the\n                    // vector of the corresponding node type.\n                    nts.ids.iter().enumerate().for_each(|(node_id, node_type)| {\n                        // if the node has a node_type\n                        if let Some(nt) = node_type {\n                            // Get the index of the correct node type vector.\n                            node_sets[nt[0] as usize].push(node_id as NodeT);\n                        };\n                    });\n\n                    node_sets\n                } else {\n                    // just compute a vector with a single vector of the indices\n                    //  of the nodes with node\n                    vec![nts\n                        .ids\n                        .iter()\n                        .enumerate()\n                        .filter_map(|(node_id, node_type)| {\n                            node_type.as_ref().map(|_| node_id as NodeT)\n                        })\n                        .collect()]\n                }\n            })\n            .unwrap();\n\n        // initialize the seed for a re-producible shuffle\n        let mut rnd = SmallRng::seed_from_u64(random_state ^ SEED_XOR as u64);\n\n        // Allocate the vectors for the nodes of each\n        let mut train_node_types = vec![None; self.get_nodes_number() as usize];\n        let mut test_node_types = vec![None; self.get_nodes_number() as usize];\n\n        for mut node_set in node_sets {\n            // Shuffle in a reproducible way the nodes of the current node_type\n            node_set.shuffle(&mut rnd);\n            // Compute how many of these nodes belongs to the training set\n            let (train_size, _) = self.get_holdouts_elements_number(train_size, node_set.len())?;\n            // add the nodes to the relative vectors\n            node_set[..train_size].iter().for_each(|node_id| {\n                train_node_types[*node_id as usize] =\n                    self.get_unchecked_node_type_id_from_node_id(*node_id)\n            });\n            node_set[train_size..].iter().for_each(|node_id| {\n                test_node_types[*node_id as usize] =\n                    self.get_unchecked_node_type_id_from_node_id(*node_id)\n            });\n        }\n\n        // Clone the current graph\n        // here we could manually initialize the clones so that we don't waste\n        // time and memory cloning the node_types which will be immediately\n        // overwrite. We argue that this should not be impactfull so we prefer\n        // to prioritze the simplicity of the code\n        let mut train_graph = self.clone();\n        let mut test_graph = self.clone();\n\n        // Replace the node_types with the one computes above\n        train_graph.node_types = NodeTypeVocabulary::from_structs(\n            train_node_types,\n            self.node_types.as_ref().map(|ntv| ntv.vocabulary.clone()),\n        );\n        test_graph.node_types = NodeTypeVocabulary::from_structs(\n            test_node_types,\n            self.node_types.as_ref().map(|ntv| ntv.vocabulary.clone()),\n        );\n\n        Ok((train_graph, test_graph))"
    },
    {
        "file": "holdouts.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Holdouts."
        ],
        "doc": [
            "Returns edge-label holdout for training ML algorithms on the graph edge labels.",
            "This is commonly used for edge type prediction tasks.",
            "",
            "This method returns two graphs, the train and the test one.",
            "The edges of the graph will be splitted in the train and test graphs according",
            "to the `train_size` argument.",
            "",
            "If stratification is enabled, the train and test will have the same ratios of",
            "edge types.",
            "",
            "# Arguments",
            "* `train_size`: f64 - rate target to reserve for training,",
            "* `use_stratification`: bool - Whether to use edge-label stratification,",
            "* `random_state`: EdgeT - The random_state to use for the holdout,",
            "",
            "# Example",
            "This example creates an 80-20 split of the edges mantaining the edge label ratios",
            "in train and test.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let (train, test) = graph.edge_label_holdout(0.8, true, 0xbad5eed).unwrap();",
            "```"
        ],
        "modifiers": "pub",
        "name": "edge_label_holdout",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "train_size",
                "f64"
            ],
            [
                "use_stratification",
                "bool"
            ],
            [
                "random_state",
                "EdgeT"
            ]
        ],
        "return_type": "Result<(Graph, Graph), String>",
        "body": "self.must_have_edge_types()?;\n        if use_stratification && self.get_minimum_edge_types_number() < 2 {\n            return Err(\"It is impossible to create a stratified holdout when the graph has edge types with cardinality one.\".to_string());\n        }\n\n        // Compute the vectors with the indices of the edges which edge type matches\n        // therefore the expected shape is:\n        // (edge_types_number, number of edges of that edge type)\n        let edge_sets: Vec<Vec<EdgeT>> = self\n            .edge_types\n            .as_ref()\n            .map(|nts| {\n                if use_stratification {\n                    // Initialize the vectors for each edge type\n                    let mut edge_sets: Vec<Vec<EdgeT>> =\n                        vec![Vec::new(); self.get_edge_types_number() as usize];\n                    // itering over the indices and adding each edge to the\n                    // vector of the corresponding edge type.\n                    nts.ids.iter().enumerate().for_each(|(edge_id, edge_type)| {\n                        // if the edge has a edge_type\n                        if let Some(et) = edge_type {\n                            // Get the index of the correct edge type vector.\n                            edge_sets[*et as usize].push(edge_id as EdgeT);\n                        };\n                    });\n\n                    edge_sets\n                } else {\n                    // just compute a vector with a single vector of the indices\n                    //  of the edges with edge\n                    vec![nts\n                        .ids\n                        .iter()\n                        .enumerate()\n                        .filter_map(|(edge_id, edge_type)| {\n                            edge_type.as_ref().map(|_| edge_id as EdgeT)\n                        })\n                        .collect()]\n                }\n            })\n            .unwrap();\n\n        // initialize the seed for a re-producible shuffle\n        let mut rnd = SmallRng::seed_from_u64(random_state ^ SEED_XOR as u64);\n\n        // Allocate the vectors for the edges of each\n        let mut train_edge_types = vec![None; self.get_directed_edges_number() as usize];\n        let mut test_edge_types = vec![None; self.get_directed_edges_number() as usize];\n\n        for mut edge_set in edge_sets {\n            // Shuffle in a reproducible way the edges of the current edge_type\n            edge_set.shuffle(&mut rnd);\n            // Compute how many of these edges belongs to the training set\n            let (train_size, _) = self.get_holdouts_elements_number(train_size, edge_set.len())?;\n            // add the edges to the relative vectors\n            edge_set[..train_size].iter().for_each(|edge_id| {\n                train_edge_types[*edge_id as usize] =\n                    self.get_unchecked_edge_type_id_from_edge_id(*edge_id)\n            });\n            edge_set[train_size..].iter().for_each(|edge_id| {\n                test_edge_types[*edge_id as usize] =\n                    self.get_unchecked_edge_type_id_from_edge_id(*edge_id)\n            });\n        }\n\n        // Clone the current graph\n        // here we could manually initialize the clones so that we don't waste\n        // time and memory cloning the edge_types which will be immediately\n        // overwrite. We argue that this should not be impactfull so we prefer\n        // to prioritze the simplicity of the code\n        let mut train_graph = self.clone();\n        let mut test_graph = self.clone();\n\n        // Replace the edge_types with the one computes above\n        train_graph.edge_types = Some(EdgeTypeVocabulary::from_structs(\n            train_edge_types,\n            self.edge_types\n                .as_ref()\n                .map(|etv| etv.vocabulary.clone())\n                .unwrap(),\n        ));\n        test_graph.edge_types = Some(EdgeTypeVocabulary::from_structs(\n            test_edge_types,\n            self.edge_types\n                .as_ref()\n                .map(|etv| etv.vocabulary.clone())\n                .unwrap(),\n        ));\n\n        Ok((train_graph, test_graph))"
    },
    {
        "file": "holdouts.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Holdouts."
        ],
        "doc": [
            "Returns subgraph with given number of nodes.",
            "",
            "**This method creates a subset of the graph starting from a random node",
            "sampled using given random_state and includes all neighbouring nodes until",
            "the required number of nodes is reached**. All the edges connecting any",
            "of the selected nodes are then inserted into this graph.",
            "",
            "This is meant to execute distributed node embeddings.",
            "It may also sample singleton nodes.",
            "",
            "# Arguments",
            "* `random_state`: usize - Random random_state to use.",
            "* `nodes_number`: NodeT - Number of nodes to extract.",
            "* `verbose`: bool - Whether to show the loading bar.",
            "",
            "# Example",
            "this generates a random subgraph with 1000 nodes.",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "let random_graph = graph.random_subgraph(0xbad5eed, 1000, true).unwrap();",
            "```",
            ""
        ],
        "modifiers": "pub",
        "name": "random_subgraph",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "random_state",
                "usize"
            ],
            [
                "nodes_number",
                "NodeT"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<Graph, String>",
        "body": "if nodes_number <= 1 {\n            return Err(String::from(\"Required nodes number must be more than 1.\"));\n        }\n        let not_singleton_nodes_number = self.get_not_singleton_nodes_number();\n        if nodes_number > not_singleton_nodes_number {\n            return Err(format!(\n                concat!(\n                    \"Required number of nodes ({}) is more than available \",\n                    \"number of nodes ({}) that have edges in current graph.\"\n                ),\n                nodes_number, not_singleton_nodes_number\n            ));\n        }\n\n        // Creating the loading bars\n        let pb1 = get_loading_bar(verbose, \"Sampling nodes subset\", nodes_number as usize);\n        let pb2 = get_loading_bar(verbose, \"Computing subgraph edges\", nodes_number as usize);\n        let pb3 = get_loading_bar(\n            verbose,\n            \"Building subgraph\",\n            self.get_directed_edges_number() as usize,\n        );\n\n        // Creating the random number generator\n        let mut rnd = SmallRng::seed_from_u64((random_state ^ SEED_XOR) as u64);\n\n        // Nodes indices\n        let mut nodes: Vec<NodeT> = (0..self.get_nodes_number()).collect();\n\n        // Shuffling the components using the given random_state.\n        nodes.shuffle(&mut rnd);\n\n        // Initializing stack and set of nodes\n        let mut unique_nodes = RoaringBitmap::new();\n        let mut stack: Vec<NodeT> = Vec::new();\n\n        // We iterate on the components\n        'outer: for node in nodes.iter() {\n            // If the current node is a trap there is no need to continue with the current loop.\n            if self.is_trap_node_from_node_id(*node).unwrap() {\n                continue;\n            }\n            stack.push(*node);\n            while !stack.is_empty() {\n                let src = stack.pop().unwrap();\n                for dst in self.iter_unchecked_neighbour_node_ids_from_source_node_id(src) {\n                    if !unique_nodes.contains(dst) && src != dst {\n                        stack.push(dst);\n                    }\n\n                    unique_nodes.insert(*node);\n                    unique_nodes.insert(dst);\n                    pb1.inc(2);\n\n                    // If we reach the desired number of unique nodes we can stop the iteration.\n                    if unique_nodes.len() as NodeT >= nodes_number {\n                        break 'outer;\n                    }\n                }\n            }\n        }\n\n        pb1.finish();\n\n        let edges_bitmap =\n            RoaringTreemap::from_iter(unique_nodes.iter().progress_with(pb2).flat_map(|src| {\n                let (min_edge_id, max_edge_id) =\n                    self.get_unchecked_minmax_edge_ids_from_source_node_id(src);\n                (min_edge_id..max_edge_id)\n                    .filter(|edge_id| {\n                        unique_nodes\n                            .contains(self.get_unchecked_destination_node_id_from_edge_id(*edge_id))\n                    })\n                    .collect::<Vec<EdgeT>>()\n            }));\n\n        Graph::build_graph(\n            edges_bitmap.iter().progress_with(pb3).map(|edge_id| {\n                Ok(self\n                    .get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(edge_id))\n            }),\n            edges_bitmap.len() as usize,\n            self.nodes.clone(),\n            self.node_types.clone(),\n            self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),\n            self.directed,\n            true,\n            format!(\"{} subgraph\", self.name.clone()),\n            false,\n            self.has_edge_types(),\n            self.has_edge_weights(),\n            true,\n            self.has_selfloops(),\n            true,\n        )"
    },
    {
        "file": "holdouts.rs",
        "struct": "Graph",
        "impl_doc": [
            "# Holdouts."
        ],
        "doc": [
            "Returns train and test graph following kfold validation scheme.",
            "",
            "The edges are splitted into k chunks. The k_index-th chunk is used to build",
            "the validation graph, all the other edges create the training graph.",
            "",
            "# Arguments",
            "* `k`: EdgeT - The number of folds.",
            "* `k_index`: u64 - Which fold to use for the validation.",
            "* `edge_types`: Option<Vec<Option<String>>> - Edge types to be selected when computing the folds (All the edge types not listed here will be always be used in the training set).",
            "* `random_state`: EdgeT - The random_state (seed) to use for the holdout,",
            "* `verbose`: bool - Whether to show the loading bar.",
            "",
            "# Example",
            "```rust",
            "# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false).unwrap();",
            "for i in 0..5 {",
            "let (train, test) = graph.kfold(5, i, None, 0xbad5eed, true).unwrap();",
            "// Run the training",
            "}",
            "```",
            "If We pass a vector of edge types, the K-fold will be executed only on the edges which match",
            "that type. All the other edges will always appear in the traning set.",
            ""
        ],
        "modifiers": "pub",
        "name": "kfold",
        "args": [
            [
                "self",
                "&self"
            ],
            [
                "k",
                "EdgeT"
            ],
            [
                "k_index",
                "u64"
            ],
            [
                "edge_types",
                "Option<Vec<Option<String>>>"
            ],
            [
                "random_state",
                "EdgeT"
            ],
            [
                "verbose",
                "bool"
            ]
        ],
        "return_type": "Result<(Graph, Graph), String>",
        "body": "if k == 1 {\n            return Err(String::from(\"Cannot do a k-fold with only one fold.\"));\n        }\n        if k_index >= k {\n            return Err(String::from(\n                \"The index of the k-fold must be strictly less than the number of folds.\",\n            ));\n        }\n\n        // If edge types is not None, to compute the chunks only use the edges\n        // of the chosen edge_types\n        let mut indices = if let Some(ets) = edge_types {\n            if ets.is_empty() {\n                return Err(String::from(\n                    \"Required edge types must be a non-empty list.\",\n                ));\n            }\n\n            let edge_type_ids = self\n                .get_edge_type_ids_from_edge_type_names(ets)?\n                .into_iter()\n                .collect::<HashSet<Option<EdgeTypeT>>>();\n\n            self.iter_edge_node_ids_and_edge_type_id(self.directed)\n                .filter_map(|(edge_id, _, _, edge_type)| {\n                    if !edge_type_ids.contains(&edge_type) {\n                        return None;\n                    }\n                    Some(edge_id)\n                })\n                .collect::<Vec<EdgeT>>()\n        } else {\n            self.iter_edge_ids(self.directed)\n                .map(|(edge_id, _, _)| edge_id)\n                .collect::<Vec<EdgeT>>()\n        };\n\n        if k >= indices.len() as EdgeT {\n            return Err(String::from(\n                \"Cannot do a number of k-fold greater than the number of available edges.\",\n            ));\n        }\n\n        // if the graph has 8 edges and k = 3\n        // we want the chunks sized to be:\n        // 3, 3, 2\n\n        // if the graph has 4 edges and k = 3\n        // we want the chunks sized to be:\n        // 2, 1, 1\n\n        // shuffle the indices\n        let mut rng = SmallRng::seed_from_u64(random_state ^ SEED_XOR as EdgeT);\n        indices.shuffle(&mut rng);\n        // Get the k_index-th chunk\n        let chunk_size = indices.len() as f64 / k as f64;\n        let start = (k_index as f64 * chunk_size).ceil() as EdgeT;\n        let end = std::cmp::min(\n            indices.len() as EdgeT,\n            (((k_index + 1) as f64) * chunk_size).ceil() as EdgeT,\n        );\n        let chunk =\n            RoaringTreemap::from_iter(indices[start as usize..end as usize].iter().cloned());\n        // Create the two graphs\n        self.edge_holdout(\n            random_state,\n            end - start,\n            false,\n            |edge_id, _, _, _| chunk.contains(edge_id),\n            verbose,\n            true,\n            self.has_selfloops(),\n        )"
    }
]