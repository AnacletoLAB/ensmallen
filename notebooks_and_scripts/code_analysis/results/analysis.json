{
    "operators.rs": {
        "imports": [
            "use super::*;",
            "use pyo3::class::basic::PyObjectProtocol;",
            "use pyo3::class::number::PyNumberProtocol;"
        ],
        "functions": [
            {
                "file": "operators.rs",
                "struct": "EnsmallenGraph",
                "trait": "PyNumberProtocol",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "__or__",
                "args": [
                    [
                        "lhs",
                        "EnsmallenGraph"
                    ],
                    [
                        "rhs",
                        "EnsmallenGraph"
                    ]
                ],
                "return_type": "PyResult<EnsmallenGraph>",
                "body": "Ok(EnsmallenGraph {\n            graph: pe!(&lhs.graph | &rhs.graph)?,\n        })"
            },
            {
                "file": "operators.rs",
                "struct": "EnsmallenGraph",
                "trait": "PyNumberProtocol",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "__sub__",
                "args": [
                    [
                        "lhs",
                        "EnsmallenGraph"
                    ],
                    [
                        "rhs",
                        "EnsmallenGraph"
                    ]
                ],
                "return_type": "PyResult<EnsmallenGraph>",
                "body": "Ok(EnsmallenGraph {\n            graph: pe!(&lhs.graph - &rhs.graph)?,\n        })"
            },
            {
                "file": "operators.rs",
                "struct": "EnsmallenGraph",
                "trait": "PyNumberProtocol",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "__and__",
                "args": [
                    [
                        "lhs",
                        "EnsmallenGraph"
                    ],
                    [
                        "rhs",
                        "EnsmallenGraph"
                    ]
                ],
                "return_type": "PyResult<EnsmallenGraph>",
                "body": "Ok(EnsmallenGraph {\n            graph: pe!(&lhs.graph & &rhs.graph)?,\n        })"
            },
            {
                "file": "operators.rs",
                "struct": "EnsmallenGraph",
                "trait": "PyNumberProtocol",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "__xor__",
                "args": [
                    [
                        "lhs",
                        "EnsmallenGraph"
                    ],
                    [
                        "rhs",
                        "EnsmallenGraph"
                    ]
                ],
                "return_type": "PyResult<EnsmallenGraph>",
                "body": "Ok(EnsmallenGraph {\n            graph: pe!(&lhs.graph ^ &rhs.graph)?,\n        })"
            },
            {
                "file": "operators.rs",
                "struct": "EnsmallenGraph",
                "trait": "PyObjectProtocol",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "__str__",
                "args": [
                    [
                        "self",
                        "&'p self"
                    ]
                ],
                "return_type": "PyResult<String>",
                "body": "pe!(self.graph.textual_report(true))"
            },
            {
                "file": "operators.rs",
                "struct": "EnsmallenGraph",
                "trait": "PyObjectProtocol",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "__repr__",
                "args": [
                    [
                        "self",
                        "&'p self"
                    ]
                ],
                "return_type": "PyResult<String>",
                "body": "self.__str__()"
            },
            {
                "file": "operators.rs",
                "struct": "EnsmallenGraph",
                "trait": "PyObjectProtocol",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "__hash__",
                "args": [
                    [
                        "self",
                        "&'p self"
                    ]
                ],
                "return_type": "PyResult<isize>",
                "body": "Ok(self.hash() as isize)"
            },
            {
                "file": "operators.rs",
                "struct": "EnsmallenGraph",
                "doc": [],
                "attrs": [],
                "modifiers": "",
                "name": "_repr_html_",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "PyResult<String>",
                "body": "Ok(format!(\n            r#\"<h4>{}</h4><p style=\"text-align: justify; text-justify: inter-word;\">{}</p>\"#,\n            self.graph.get_name(),\n            pe!(self.__repr__())?\n        ))"
            },
            {
                "file": "operators.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return true if given graph has any edge overlapping with current graph.",
                    "",
                    " Parameters",
                    " ----------------------------",
                    " graph: EnsmallenGraph,",
                    "     The graph to check against.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Boolean representing if any overlapping edge was found."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "overlaps",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "graph",
                        "&EnsmallenGraph"
                    ]
                ],
                "return_type": "PyResult<bool>",
                "body": "pe!(self.graph.overlaps(&graph.graph))"
            },
            {
                "file": "operators.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return true if given graph edges are all contained within current graph.",
                    "",
                    " Parameters",
                    " ----------------------------",
                    " graph: EnsmallenGraph,",
                    "     The graph to check against.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Boolean representing if graph contains completely the othe graph."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "contains",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "graph",
                        "&EnsmallenGraph"
                    ]
                ],
                "return_type": "PyResult<bool>",
                "body": "pe!(self.graph.contains(&graph.graph))"
            }
        ]
    },
    "trees.rs": {
        "imports": [
            "use super::*;",
            "use graph::NodeT;",
            "use numpy::PyArray2;"
        ],
        "functions": [
            {
                "file": "trees.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns set of edges forming the spanning tree of given graph.",
                    "",
                    " Parameters",
                    " ------------------------",
                    " verbose: bool = True,",
                    "     Wether to show a loading bar.",
                    "",
                    " Raises",
                    " ------------------------",
                    " ValueError,",
                    "     If the given graph is not undirected.",
                    "",
                    " Returns",
                    " ------------------------",
                    " Numpy array of tuples of NodeIds forming the spanning tree.",
                    "",
                    " References",
                    " ------------------------",
                    " This is the implementaiton of the algorithm presented in the paper",
                    " A Fast, Parallel Spanning Tree Algorithm for Symmetric Multiprocessors",
                    " by David A. Bader and Guojing Cong."
                ],
                "attrs": [
                    "#[text_signature = \"($self, verbose)\"]"
                ],
                "modifiers": "",
                "name": "spanning_arborescence",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "PyResult<Py<PyArray2<NodeT>>>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let (edges_number, iter) =\n            pe!(self.graph.spanning_arborescence(verbose.unwrap_or(true)))?;\n        let array = ThreadSafe {\n            t: PyArray2::new(py.python(), [edges_number, 2], false),\n        };\n        unsafe {\n            iter.enumerate().for_each(|(index, (src, dst))| {\n                *(array.t.uget_mut([index, 0])) = src;\n                *(array.t.uget_mut([index, 1])) = dst;\n            });\n        }\n        Ok(array.t.to_owned())"
            }
        ]
    },
    "preprocessing.rs": {
        "imports": [
            "use super::*;",
            "use graph::{",
            "use numpy::{PyArray, PyArray1, PyArray2};",
            "use pyo3::wrap_pyfunction;",
            "use rayon::prelude::*;",
            "use std::sync::atomic::{AtomicUsize, Ordering};",
            "use thread_safe::ThreadSafe;"
        ],
        "functions": [
            {
                "file": "preprocessing.rs",
                "doc": [],
                "attrs": [
                    "#[pymodule]"
                ],
                "modifiers": "",
                "name": "preprocessing",
                "args": [
                    [
                        "_py",
                        "Python"
                    ],
                    [
                        "m",
                        "&PyModule"
                    ]
                ],
                "return_type": "PyResult<()>",
                "body": "m.add_wrapped(wrap_pyfunction!(word2vec))?;\n    m.add_wrapped(wrap_pyfunction!(cooccurence_matrix))?;\n    Ok(())"
            },
            {
                "file": "preprocessing.rs",
                "doc": [
                    " Return training batches for Word2Vec models.",
                    "",
                    " The batch is composed of a tuple as the following:",
                    "",
                    " - (Contexts indices, central nodes indices): the tuple of nodes",
                    "",
                    " This does not provide any output value as the model uses NCE loss",
                    " and basically the central nodes that are fed as inputs work as the",
                    " outputs value.",
                    "",
                    " Arguments",
                    " ---------",
                    "",
                    " sequences: List[List[int]],",
                    "     the sequence of sequences of integers to preprocess.",
                    " window_size: int,",
                    "     Window size to consider for the sequences.",
                    ""
                ],
                "attrs": [
                    "#[pyfunction(py_kwargs = \"**\")]",
                    "#[text_signature = \"(sequences, window_size)\"]"
                ],
                "modifiers": "",
                "name": "word2vec",
                "args": [
                    [
                        "sequences",
                        "Vec<Vec<NodeT>>"
                    ],
                    [
                        "window_size",
                        "usize"
                    ]
                ],
                "return_type": "PyResult<(PyContexts, PyWords)>",
                "body": "let (contexts, words): (Vec<Vec<NodeT>>, Vec<NodeT>) =\n        pe!(rust_word2vec(sequences.into_par_iter(), window_size))?.unzip();\n    let gil = pyo3::Python::acquire_gil();\n    Ok((\n        to_nparray_2d!(gil, contexts, NodeT),\n        to_ndarray_1d!(gil, words, NodeT),\n    ))"
            },
            {
                "file": "preprocessing.rs",
                "doc": [
                    " Return triple with CSR representation of cooccurrence matrix.",
                    "",
                    " The first vector has the sources, the second vector the destinations",
                    " and the third one contains the min-max normalized frequencies.",
                    "",
                    " Arguments",
                    " ---------",
                    "",
                    " sequences: List[List[int]],",
                    "     the sequence of sequences of integers to preprocess.",
                    " window_size: int = 4,",
                    "     Window size to consider for the sequences.",
                    " verbose: bool = False,",
                    "     whether to show the progress bars.",
                    "     The default behaviour is false.",
                    ""
                ],
                "attrs": [
                    "#[pyfunction(py_kwargs = \"**\")]",
                    "#[text_signature = \"(sequences, *, window_size, verbose)\"]"
                ],
                "modifiers": "",
                "name": "cooccurence_matrix",
                "args": [
                    [
                        "sequences",
                        "Vec<Vec<NodeT>>"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<(PyWords, PyWords, PyFrequencies)>",
                "body": "let _ = ctrlc::set_handler(|| std::process::exit(2));\n    let gil = pyo3::Python::acquire_gil();\n    let kwargs = normalize_kwargs!(py_kwargs, gil.python());\n    pe!(validate_kwargs(kwargs, &[\"window_size\", \"verbose\"]))?;\n    let len = sequences.len();\n\n    let (number_of_elements, iter) = pe!(rust_cooccurence_matrix(\n        sequences.into_par_iter(),\n        extract_value!(kwargs, \"window_size\", usize).unwrap_or(3),\n        len,\n        extract_value!(kwargs, \"verbose\", bool).unwrap_or(true),\n    ))?;\n\n    let srcs = PyArray1::new(gil.python(), [number_of_elements], false);\n    let dsts = PyArray1::new(gil.python(), [number_of_elements], false);\n    let frequencies = PyArray1::new(gil.python(), [number_of_elements], false);\n\n    iter.enumerate().for_each(|(i, (src, dst, freq))| {\n        unsafe{\n            *srcs.uget_mut(i) = src;\n            *dsts.uget_mut(i) = dst;\n            *frequencies.uget_mut(i) = freq;\n        }\n    });\n    \n    Ok((\n        srcs.to_owned(), dsts.to_owned(), frequencies.to_owned()\n    ))"
            },
            {
                "file": "preprocessing.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return cooccurence matrix-based triples of words, contexts and frequencies.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " walk_length: int,",
                    "     Maximal length of the random walk.",
                    "     On graphs without traps, all walks have this length.",
                    " window_size: int = 4,",
                    "     Size of the window for local contexts.",
                    " iterations: int = 1,",
                    "     Number of cycles on the graphs to execute.",
                    " return_weight: float = 1.0,",
                    "     Weight on the probability of returning to node coming from",
                    "     Having this higher tends the walks to be",
                    "     more like a Breadth-First Search.",
                    "     Having this very high  (> 2) makes search very local.",
                    "     Equal to the inverse of p in the Node2Vec paper.",
                    " explore_weight: float = 1.0,",
                    "     Weight on the probability of visiting a neighbor node",
                    "     to the one we're coming from in the random walk",
                    "     Having this higher tends the walks to be",
                    "     more like a Depth-First Search.",
                    "     Having this very high makes search more outward.",
                    "     Having this very low makes search very local.",
                    "     Equal to the inverse of q in the Node2Vec paper.",
                    " change_node_type_weight: float = 1.0,",
                    "     Weight on the probability of visiting a neighbor node of a",
                    "     different type than the previous node. This only applies to",
                    "     colored graphs, otherwise it has no impact.",
                    " change_edge_type_weight: float = 1.0,",
                    "     Weight on the probability of visiting a neighbor edge of a",
                    "     different type than the previous edge. This only applies to",
                    "     multigraphs, otherwise it has no impact.",
                    " dense_node_mapping: Dict[int, int] = None,",
                    "     Mapping to use for converting sparse walk space into a dense space.",
                    "     This object can be created using the method available from graph",
                    "     called `get_dense_node_mapping` that returns a mapping from",
                    "     the non trap nodes (those from where a walk could start) and",
                    "     maps these nodes into a dense range of values.",
                    " max_neighbours: int = None,",
                    "     Maximum number of randomly sampled neighbours to consider.",
                    "     If this parameter is used, the walks becomes probabilistic in nature",
                    "     and becomes an approximation of an exact walk.",
                    " random_state: int = 42,",
                    "     random_state to use to reproduce the walks.",
                    " verbose: int = True,",
                    "     whether to show or not the loading bar of the walks.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Triple with integer vectors of words and contexts and max-min normalized frequencies.",
                    ""
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, walk_length, *, window_size, iterations, return_weight, explore_weight, change_edge_type_weight, change_node_type_weight, dense_node_mapping, max_neighbours, random_state, verbose)\"]"
                ],
                "modifiers": "",
                "name": "cooccurence_matrix",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "walk_length",
                        "u64"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<(PyWords, PyWords, PyFrequencies)>",
                "body": "let gil = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, gil.python());\n\n        pe!(validate_kwargs(\n            kwargs,\n            build_walk_parameters_list(&[\"window_size\", \"verbose\"]).as_slice(),\n        ))?;\n\n        let parameters = pe!(self.build_walk_parameters(walk_length, kwargs))?;\n\n        let (number_of_elements, iter) = pe!(self.graph.cooccurence_matrix(\n            &parameters,\n            extract_value!(kwargs, \"window_size\", usize).unwrap_or(3),\n            extract_value!(kwargs, \"verbose\", bool).unwrap_or(true),\n        ))?;\n\n        let srcs = PyArray1::new(gil.python(), [number_of_elements], false);\n        let dsts = PyArray1::new(gil.python(), [number_of_elements], false);\n        let frequencies = PyArray1::new(gil.python(), [number_of_elements], false);\n\n        iter.enumerate().for_each(|(i, (src, dst, freq))| {\n            unsafe{\n                *srcs.uget_mut(i) = src;\n                *dsts.uget_mut(i) = dst;\n                *frequencies.uget_mut(i) = freq;\n            }\n        });\n        \n        Ok((\n            srcs.to_owned(), dsts.to_owned(), frequencies.to_owned()\n        ))"
            },
            {
                "file": "preprocessing.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return training batches for Node2Vec models.",
                    "",
                    " The batch is composed of a tuple as the following:",
                    "",
                    " - (Contexts indices, central nodes indices): the tuple of nodes",
                    "",
                    " This does not provide any output value as the model uses NCE loss",
                    " and basically the central nodes that are fed as inputs work as the",
                    " outputs value.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " batch_size:",
                    "     Number of walks to include within this batch.",
                    "     In some pathological cases, this might leed to an empty batch.",
                    "     These cases include graphs with particularly high number of traps.",
                    "     Consider using the method graph.report() to verify if this might",
                    "     apply to your use case.",
                    " walk_length: int,",
                    "     Maximal length of the random walk.",
                    "     On graphs without traps, all walks have this length.",
                    " window_size: int,",
                    "     Size of the window for local contexts.",
                    " iterations: int = 1,",
                    "     Number of iterations for each node.",
                    " return_weight: float = 1.0,",
                    "     Weight on the probability of returning to node coming from",
                    "     Having this higher tends the walks to be",
                    "     more like a Breadth-First Search.",
                    "     Having this very high  (> 2) makes search very local.",
                    "     Equal to the inverse of p in the Node2Vec paper.",
                    " explore_weight: float = 1.0,",
                    "     Weight on the probability of visiting a neighbor node",
                    "     to the one we're coming from in the random walk",
                    "     Having this higher tends the walks to be",
                    "     more like a Depth-First Search.",
                    "     Having this very high makes search more outward.",
                    "     Having this very low makes search very local.",
                    "     Equal to the inverse of q in the Node2Vec paper.",
                    " change_node_type_weight: float = 1.0,",
                    "     Weight on the probability of visiting a neighbor node of a",
                    "     different type than the previous node. This only applies to",
                    "     colored graphs, otherwise it has no impact.",
                    " change_edge_type_weight: float = 1.0,",
                    "     Weight on the probability of visiting a neighbor edge of a",
                    "     different type than the previous edge. This only applies to",
                    "     multigraphs, otherwise it has no impact.",
                    " dense_node_mapping: Dict[int, int],",
                    "     Mapping to use for converting sparse walk space into a dense space.",
                    "     This object can be created using the method available from graph",
                    "     called `get_dense_node_mapping` that returns a mapping from",
                    "     the non trap nodes (those from where a walk could start) and",
                    "     maps these nodes into a dense range of values.",
                    " max_neighbours: int = None,",
                    "     Maximum number of randomly sampled neighbours to consider.",
                    "     If this parameter is used, the walks becomes probabilistic in nature",
                    "     and becomes an approximation of an exact walk.",
                    " random_state: int,",
                    "     random_state to use to reproduce the walks.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Tuple with vector of integer with contexts and words."
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, batch_size, walk_length, window_size, *, iterations, return_weight, explore_weight, change_edge_type_weight, change_node_type_weight, dense_node_mapping, max_neighbours, random_state)\"]"
                ],
                "modifiers": "",
                "name": "node2vec",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "batch_size",
                        "NodeT"
                    ],
                    [
                        "walk_length",
                        "u64"
                    ],
                    [
                        "window_size",
                        "usize"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<(PyContexts, PyWords)>",
                "body": "let gil = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, gil.python());\n        pe!(validate_kwargs(\n            kwargs,\n            build_walk_parameters_list(&[]).as_slice()\n        ))?;\n        let parameters = pe!(self.build_walk_parameters(walk_length, kwargs))?;\n\n        let iter = pe!(self.graph.node2vec(&parameters, batch_size, window_size))?;\n\n        let elements_per_batch = (walk_length as usize - window_size * 2)\n            * batch_size as usize\n            * parameters.get_iterations() as usize;\n\n        let contexts = ThreadSafe {\n            t: PyArray2::new(gil.python(), [elements_per_batch, window_size * 2], false),\n        };\n        let words = ThreadSafe {\n            t: PyArray1::new(gil.python(), [elements_per_batch], false),\n        };\n        let global_i = AtomicUsize::new(0);\n\n        iter.for_each(|(context, word)| {\n            let i = global_i.fetch_add(1, Ordering::SeqCst);\n            context.iter().enumerate().for_each(|(j, v)| unsafe {\n                *(contexts.t.uget_mut([i, j])) = *v;\n            });\n            unsafe {\n                *(words.t.uget_mut([i])) = word;\n            }\n        });\n        Ok((contexts.t.to_owned(), words.t.to_owned()))"
            },
            {
                "file": "preprocessing.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return iterator over neighbours for the given node IDs, optionally including given the node IDs, and node type.",
                    "",
                    " This method is meant to be used to predict node labels using the NoLaN model.",
                    "",
                    " If you need to predict the node label of a node, not during training,",
                    " use `max_neighbours=None`.",
                    "",
                    " Parameters",
                    " -----------------------------",
                    " - node_ids: List[int],",
                    "     The node ID to retrieve neighbours for.",
                    " - random_state: int = 42,",
                    "     The random state to use to extract the neighbours.",
                    " - include_central_node: bool = True,",
                    "     Whether to include the node ID in the returned iterator.",
                    " - offset: int = 1,",
                    "     Offset for padding porposes.",
                    " - max_neighbours: int = None,",
                    "     Number of maximum neighbours to consider.",
                    "",
                    " Returns",
                    " -----------------------------",
                    " Tuple with input nodes and output node types.",
                    ""
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, node_ids, *, random_state, include_central_node, offset, max_neighbours)\"]"
                ],
                "modifiers": "",
                "name": "get_node_label_prediction_tuple_by_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_ids",
                        "Vec<NodeT>"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<(Py<PyArray2<NodeT>>, Py<PyArray2<NodeTypeT>>)>",
                "body": "let gil = pyo3::Python::acquire_gil();\n\n        // First we normalize the kwargs so that we always at least\n        // an empty dictionary\n        let kwargs = normalize_kwargs!(py_kwargs, gil.python());\n\n        // Then we validate the provided kwargs, that is we verify\n        // that the valid kwarg names are provided.\n        pe!(validate_kwargs(\n            kwargs,\n            &[\n                \"random_state\",\n                \"include_central_node\",\n                \"offset\",\n                \"max_neighbours\",\n            ],\n        ))?;\n\n        // We check that the provided list is not empty.\n        if node_ids.is_empty() {\n            return pe!(Err(\"Given list of node IDs is empty!\".to_string()));\n        }\n\n        // We get the maximum degree among the provided nodes.\n        // We will use this as a maximal value for the size of the batch.\n        // This way if there are no high-degree centrality nodes in this\n        // batch we do not allocate extra memory for no reason.\n        // We can always unwrap this value because we have requested\n        // just above that the list cannot be empty.\n        let mut max_degree = node_ids\n            .iter()\n            .map(|node_id| self.graph.get_node_degree_by_node_id(*node_id).unwrap())\n            .max()\n            .unwrap();\n\n        // We get the number of the requested nodes IDs.\n        let nodes_number = node_ids.len();\n        // Extract the maximum neighbours parameter.\n        let max_neighbours = extract_value!(kwargs, \"max_neighbours\", NodeT);\n        // And whether to include or not the central node.\n        let include_central_node =\n            extract_value!(kwargs, \"include_central_node\", bool).unwrap_or(true);\n\n        // If the maximum neighbours was provided, we set the minimum value\n        // between max degree and maximum neighbours as the size of the\n        // bacth vector to return.\n        if let Some(mn) = &max_neighbours {\n            max_degree = std::cmp::min(max_degree, *mn);\n        }\n\n        // If the batch includes also the central node we need to add an\n        // additional column for it.\n        if include_central_node {\n            max_degree += 1;\n        }\n\n        // We retrieve the batch iterator.\n        let iter = pe!(self.graph.get_node_label_prediction_tuple_by_node_ids(\n            node_ids,\n            extract_value!(kwargs, \"random_state\", u64).unwrap_or(42),\n            include_central_node,\n            extract_value!(kwargs, \"offset\", NodeT).unwrap_or(1),\n            max_neighbours,\n        ))?;\n\n        // We create the vector of zeros where to allocate the neighbours\n        // This vector has `nodes_number` rows, that is the number of required\n        // node IDs, and `max_degree` rows, that is the maximum degree.\n        let neighbours =\n            PyArray2::zeros(gil.python(), [nodes_number, max_degree as usize], false);\n        // We create the vector of zeros for the one-hot encoded labels.\n        // This is also used for the multi-label case.\n        // This vector has the same number of rows as the previous vector,\n        // that is the number of requested node IDs, while the number\n        // of columns is the number of node types in the graph.\n        let labels = PyArray2::zeros(\n            gil.python(),\n            [nodes_number, self.graph.get_node_types_number() as usize],\n            false,\n        );\n\n        // We iterate over the batch.\n        iter.enumerate()\n            .for_each(|(i, (neighbours_iterator, node_types))| {\n                neighbours_iterator.enumerate().for_each(|(j, node_id)| unsafe {\n                    *neighbours.uget_mut([i, j]) = node_id;\n                });\n                if let Some(nts) = node_types {\n                    nts.into_iter().for_each(|label| unsafe {\n                        *labels.uget_mut([i, label as usize]) = 1;\n                    });\n                }\n            });\n\n        Ok((neighbours.to_owned(), labels.to_owned()))"
            },
            {
                "file": "preprocessing.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns ids for a link prediction training batch.",
                    "",
                    " Parameters",
                    " -----------------------------",
                    " idx:int,",
                    "     Index corresponding to batch to be rendered.",
                    " batch_size: int,",
                    "     The batch size to use.",
                    " negative_samples: float = 1.0,",
                    "     Factor of negatives to use in every batch.",
                    "     For example, with a batch size of 128 and negative_samples equal",
                    "     to 1.0, there will be 64 positives and 64 negatives.",
                    " avoid_false_negatives: bool = False,",
                    "     Wether to filter out false negatives.",
                    "     By default False.",
                    "     Enabling this will slow down the batch generation while (likely) not",
                    "     introducing any significant gain to the model performance.",
                    " maximal_sampling_attempts: usize = 100,",
                    "     Number of attempts to execute to sample the negative edges.",
                    " graph_to_avoid: EnsmallenGraph = None,",
                    "     Graph to avoid when generating the links.",
                    "     This can be the validation component of the graph, for example.",
                    "",
                    " Returns",
                    " -----------------------------",
                    " Triple with source and destination nodes and labels.",
                    ""
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, idx, batch_size, negative_samples, avoid_false_negatives, maximal_sampling_attempts, graph_to_avoid)\"]"
                ],
                "modifiers": "",
                "name": "link_prediction_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "idx",
                        "u64"
                    ],
                    [
                        "batch_size",
                        "usize"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<(Py<PyArray1<NodeT>>, Py<PyArray1<NodeT>>, Py<PyArray1<bool>>)>",
                "body": "let gil = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, gil.python());\n\n        pe!(validate_kwargs(\n            kwargs,\n            &[\n                \"negative_samples\",\n                \"avoid_false_negatives\",\n                \"maximal_sampling_attempts\",\n                \"graph_to_avoid\",\n            ],\n        ))?;\n        let graph_to_avoid = extract_value!(kwargs, \"graph_to_avoid\", EnsmallenGraph);\n        let maybe_graph = match &graph_to_avoid {\n            Some(g) => Some(&g.graph),\n            None => None,\n        };\n\n        let iter = pe!(self.graph.link_prediction_ids(\n            idx,\n            batch_size,\n            extract_value!(kwargs, \"negative_samples\", f64).unwrap_or(1.0),\n            extract_value!(kwargs, \"avoid_false_negatives\", bool).unwrap_or(false),\n            extract_value!(kwargs, \"maximal_sampling_attempts\", usize).unwrap_or(100),\n            &maybe_graph,\n        ))?;\n\n        let srcs = ThreadSafe {\n            t: PyArray1::new(gil.python(), [batch_size], false),\n        };\n        let dsts = ThreadSafe {\n            t: PyArray1::new(gil.python(), [batch_size], false),\n        };\n        let labels = ThreadSafe {\n            t: PyArray1::new(gil.python(), [batch_size], false),\n        };\n\n        unsafe {\n            iter.for_each(|(i, src, dst, label)| {\n                *(dsts.t.uget_mut([i])) = src;\n                *(srcs.t.uget_mut([i])) = dst;\n                *(labels.t.uget_mut([i])) = label;\n            });\n        }\n\n        Ok((srcs.t.to_owned(), dsts.t.to_owned(), labels.t.to_owned()))"
            },
            {
                "file": "preprocessing.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns",
                    "",
                    "",
                    " Parameters",
                    " -----------------------------",
                    " idx:int,",
                    "     Index corresponding to batch to be rendered.",
                    " batch_size: int,",
                    "     The batch size to use.",
                    " normalize: bool=True,",
                    "      Divide the degrees by the max, this way the values are in [0, 1].",
                    " negative_samples: float = 1.0,",
                    "     Factor of negatives to use in every batch.",
                    "     For example, with a batch size of 128 and negative_samples equal",
                    "     to 1.0, there will be 64 positives and 64 negatives.",
                    " avoid_false_negatives: bool = False,",
                    "     Wether to filter out false negatives.",
                    "     By default False.",
                    "     Enabling this will slow down the batch generation while (likely) not",
                    "     introducing any significant gain to the model performance.",
                    " maximal_sampling_attempts: usize = 100,",
                    "     Number of attempts to execute to sample the negative edges.",
                    " graph_to_avoid: EnsmallenGraph = None,",
                    "     Graph to avoid when generating the links.",
                    "     This can be the validation component of the graph, for example.",
                    "",
                    " Returns",
                    " -----------------------------",
                    " Tuple containing training and validation graphs.",
                    ""
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, idx, batch_size, normalize, negative_samples, avoid_false_negatives, maximal_sampling_attempts, graph_to_avoid)\"]"
                ],
                "modifiers": "",
                "name": "link_prediction_degrees",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "idx",
                        "u64"
                    ],
                    [
                        "batch_size",
                        "usize"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<(Py<PyArray1<f64>>, Py<PyArray1<f64>>, Py<PyArray1<bool>>)>",
                "body": "let gil = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, gil.python());\n\n        pe!(validate_kwargs(\n            kwargs,\n            &[\n                \"normalize\",\n                \"negative_samples\",\n                \"avoid_false_negatives\",\n                \"maximal_sampling_attempts\",\n                \"graph_to_avoid\",\n            ],\n        ))?;\n        let graph_to_avoid = extract_value!(kwargs, \"graph_to_avoid\", EnsmallenGraph);\n        let maybe_graph = match &graph_to_avoid {\n            Some(g) => Some(&g.graph),\n            None => None,\n        };\n\n        let iter = pe!(self.graph.link_prediction_degrees(\n            idx,\n            batch_size,\n            extract_value!(kwargs, \"normalize\", bool).unwrap_or(true),\n            extract_value!(kwargs, \"negative_samples\", f64).unwrap_or(1.0),\n            extract_value!(kwargs, \"avoid_false_negatives\", bool).unwrap_or(false),\n            extract_value!(kwargs, \"maximal_sampling_attempts\", usize).unwrap_or(100),\n            &maybe_graph,\n        ))?;\n\n        let srcs = ThreadSafe {\n            t: PyArray1::new(gil.python(), [batch_size], false),\n        };\n        let dsts = ThreadSafe {\n            t: PyArray1::new(gil.python(), [batch_size], false),\n        };\n        let labels = ThreadSafe {\n            t: PyArray1::new(gil.python(), [batch_size], false),\n        };\n\n        unsafe {\n            iter.for_each(|(i, src, dst, label)| {\n                *(dsts.t.uget_mut([i])) = src;\n                *(srcs.t.uget_mut([i])) = dst;\n                *(labels.t.uget_mut([i])) = label;\n            });\n        }\n\n        Ok((srcs.t.to_owned(), dsts.t.to_owned(), labels.t.to_owned()))"
            }
        ]
    },
    "remap.rs": {
        "imports": [
            "use super::*;"
        ],
        "functions": [
            {
                "file": "remap.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return graph remapped towards nodes of the given graph.",
                    "",
                    " Parameters",
                    " -----------------------------",
                    " `other`: EnsmallenGraph,",
                    "     The graph to remap towards.",
                    " verbose: bool = True,",
                    "     Wether to show a loading bar. By default True.",
                    "",
                    " Returns",
                    " -----------------------------",
                    " New remapped graph."
                ],
                "attrs": [
                    "#[text_signature = \"($self, other, verbose)\"]"
                ],
                "modifiers": "pub",
                "name": "remap",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "other",
                        "&EnsmallenGraph"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "PyResult<EnsmallenGraph>",
                "body": "Ok(EnsmallenGraph {\n            graph: pe!(self\n                .graph\n                .remap(&other.graph, verbose.unwrap_or(true)))?,\n        })"
            }
        ]
    },
    "connected_components.rs": {
        "imports": [
            "use super::*;",
            "use graph::NodeT;",
            "use numpy::{PyArray, PyArray1};"
        ],
        "functions": [
            {
                "file": "connected_components.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns tuple containing the components and relative data.",
                    "",
                    " Specifically, the values are:",
                    "     - Vector of the components for each node.",
                    "     - Number of components",
                    "     - Minimum component size",
                    "     - Maximum component size.",
                    "",
                    " Parameters",
                    " ------------------------",
                    " verbose: bool = True,",
                    "     Wether to show a loading bar.",
                    "",
                    " Raises",
                    " ------------------------",
                    " ValueError,",
                    "     If the given graph is not undirected.",
                    "",
                    " Returns",
                    " ------------------------",
                    " Set of tuples of NodeIds forming the spanning tree.",
                    "",
                    " References",
                    " ------------------------",
                    " This is the implementaiton of the algorithm presented in the paper",
                    " A Fast, Parallel Spanning Tree Algorithm for Symmetric Multiprocessors",
                    " by David A. Bader and Guojing Cong."
                ],
                "attrs": [
                    "#[text_signature = \"($self, verbose)\"]"
                ],
                "modifiers": "",
                "name": "connected_components",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "PyResult<(Py<PyArray1<NodeT>>, NodeT, NodeT, NodeT)>",
                "body": "let (components, number, min_size, max_size) =\n            pe!(self.graph.connected_components(verbose.unwrap_or(true)))?;\n        let gil = pyo3::Python::acquire_gil();\n        Ok((\n            PyArray::from_vec(gil.python(), components)\n                .cast::<NodeT>(false)\n                .unwrap()\n                .to_owned(),\n            number,\n            min_size,\n            max_size,\n        ))"
            }
        ]
    },
    "modifiers.rs": {
        "imports": [
            "use super::*;"
        ],
        "functions": [
            {
                "file": "modifiers.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Drop all edge types (if presents) and set all the edge to edge_type.",
                    "",
                    " Arguments",
                    " ---------",
                    " * `edge_type`: str,",
                    "     The edge type to assing to all the edges."
                ],
                "attrs": [
                    "#[text_signature = \"($self, edge_type)\"]"
                ],
                "modifiers": "pub",
                "name": "set_all_edge_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type",
                        "String"
                    ]
                ],
                "return_type": "EnsmallenGraph",
                "body": "EnsmallenGraph {\n            graph: self.graph.clone().set_all_edge_types(edge_type),\n        }"
            },
            {
                "file": "modifiers.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Drop all node types (if presents) and set all the node to node_type.",
                    "",
                    " Arguments",
                    " ---------",
                    " * `node_type`: str,",
                    "     The node type to assing to all the nodes."
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_type)\"]"
                ],
                "modifiers": "pub",
                "name": "set_all_node_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type",
                        "String"
                    ]
                ],
                "return_type": "EnsmallenGraph",
                "body": "EnsmallenGraph {\n            graph: self.graph.clone().set_all_node_types(node_type),\n        }"
            },
            {
                "file": "modifiers.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Enable extra perks that buys you time as you accept to spend more memory.",
                    "",
                    " Arguments",
                    " ------------------",
                    " vector_sources: bool = False,",
                    "     Wether to cache sources into a vector for faster walks.",
                    " vector_destinations: bool = True,",
                    "     Wether to cache destinations into a vector for faster walks.",
                    " vector_outbounds: bool = True,",
                    "     Wether to cache outbounds into a vector for faster walks.",
                    " cache_size: float = None,",
                    "     Rate of nodes destinations to cache.",
                    "     Must be a value between 0 and 1.",
                    "     This cannot be used with the vector destinations.",
                    "",
                    " Raises",
                    " -------------------",
                    " ValueError,",
                    "     If the cache_size parameter is given and vector destinations is enabled.",
                    ""
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, *, vector_sources, vector_destinations, vector_outbounds, cache_size)\"]"
                ],
                "modifiers": "pub",
                "name": "enable",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<()>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n        pe!(validate_kwargs(\n            kwargs,\n            &[\"vector_sources\", \"vector_destinations\", \"vector_outbounds\", \"cache_size\"]\n        ))?;\n\n        pe!(self.graph.enable(\n            extract_value!(kwargs, \"vector_sources\", bool).unwrap_or(false),\n            extract_value!(kwargs, \"vector_destinations\", bool).unwrap_or(true),\n            extract_value!(kwargs, \"vector_outbounds\", bool).unwrap_or(true),\n            extract_value!(kwargs, \"cache_size\", f64),\n        ))?;\n        Ok(())"
            },
            {
                "file": "modifiers.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Disable all extra perks, reducing memory impact but incresing time requirements."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "pub",
                "name": "disable_all",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ]
                ],
                "body": "self.graph.disable_all()"
            }
        ]
    },
    "node_file_writer.rs": {
        "imports": [
            "use super::*;",
            "use graph::NodeFileWriter;"
        ],
        "functions": [
            {
                "file": "node_file_writer.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Write to disk the nodes (and optionally the metadata) of the graph.",
                    "",
                    " Parameters",
                    " ------------------------",
                    " path: str,",
                    "     Path where to save the nodes and their metadata.",
                    " verbose: bool = True,",
                    "     Wether to show a loading bar while writing to file.",
                    " separator: str = \"\\t\",",
                    "     What separator to use while writing out to file.",
                    " header: bool = True,",
                    "     Wether to write out the header of the file.",
                    " nodes_column_number: int = 0,",
                    "     The column number where to write the nodes.",
                    " nodes_column: str = \"id\",",
                    "     The name of the column of the nodes.",
                    " node_types_column_number: int = 1,",
                    "     The column number where to write the node types.",
                    " nodes_type_column: str = \"category\",",
                    "     The name of the column of the node types.",
                    "",
                    " Raises",
                    " ------------------------",
                    " TODO: update the set of exceptions",
                    ""
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, path, *, verbose, separator, header, nodes_column_number, nodes_column, node_types_column_number, nodes_type_column)\"]"
                ],
                "modifiers": "",
                "name": "dump_nodes",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "path",
                        "String"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<()>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n\n        pe!(validate_kwargs(\n            kwargs,\n            &[\n                \"verbose\",\n                \"separator\",\n                \"header\",\n                \"nodes_column_number\",\n                \"nodes_column\",\n                \"node_types_column_number\",\n                \"nodes_type_column\",\n            ],\n        ))?;\n\n        let writer = NodeFileWriter::new(path)\n            .set_verbose(extract_value!(kwargs, \"verbose\", bool))\n            .set_separator(extract_value!(kwargs, \"separator\", String))\n            .set_header(extract_value!(kwargs, \"header\", bool))\n            .set_nodes_column_number(extract_value!(kwargs, \"nodes_column_number\", usize))\n            .set_nodes_column(extract_value!(kwargs, \"nodes_column\", String))\n            .set_node_types_column_number(extract_value!(kwargs, \"node_types_column_number\", usize))\n            .set_node_types_column(extract_value!(kwargs, \"nodes_type_column\", String));\n        pe!(writer.dump(&self.graph))"
            }
        ]
    },
    "utilities.rs": {
        "imports": [
            "use super::*;",
            "use graph::{EdgeFileReader, NodeFileReader, NodeT, WalksParameters, WeightT};",
            "use std::collections::HashMap;"
        ],
        "functions": [
            {
                "file": "utilities.rs",
                "doc": [],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "build_csv_file_reader",
                "args": [
                    [
                        "edge_path",
                        "String"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "Result<(EdgeFileReader, Option<NodeFileReader>, String, bool), String>",
                "body": "let py = pyo3::Python::acquire_gil();\n    let kwargs = normalize_kwargs!(py_kwargs, py.python());\n\n    validate_kwargs(\n        kwargs,\n        &[\n            \"directed_edge_list\",\n            \"sources_column_number\",\n            \"sources_column\",\n            \"destinations_column_number\",\n            \"destinations_column\",\n            \"edge_types_column_number\",\n            \"edge_types_column\",\n            \"default_edge_type\",\n            \"weights_column_number\",\n            \"weights_column\",\n            \"default_weight\",\n            \"skip_selfloops\",\n            \"ignore_duplicated_edges\",\n            \"edge_header\",\n            \"edge_rows_to_skip\",\n            \"edge_separator\",\n            \"edge_max_rows_number\",\n            \"node_path\",\n            \"nodes_column_number\",\n            \"nodes_column\",\n            \"node_types_column_number\",\n            \"node_types_column\",\n            \"default_node_type\",\n            \"ignore_duplicated_nodes\",\n            \"node_header\",\n            \"node_rows_to_skip\",\n            \"node_separator\",\n            \"node_types_separator\",\n            \"node_max_rows_number\",\n            \"verbose\",\n            \"numeric_node_ids\",\n            \"numeric_edge_node_ids\",\n            \"numeric_node_type_ids\",\n            \"numeric_edge_type_ids\",\n            \"edge_file_comment_symbol\",\n            \"node_file_comment_symbol\",\n            \"skip_weights_if_unavailable\",\n            \"skip_edge_types_if_unavailable\",\n            \"skip_node_types_if_unavailable\",\n            \"name\",\n        ]\n    )?;\n\n    let graph_name = extract_value_rust_result!(kwargs, \"name\", String).unwrap_or_else(|| \"Graph\".to_owned());\n\n    let edges: EdgeFileReader = EdgeFileReader::new(edge_path)?\n        .set_separator(extract_value_rust_result!(kwargs, \"edge_separator\", String))?\n        .set_skip_edge_types_if_unavailable(extract_value_rust_result!(\n            kwargs,\n            \"skip_edge_types_if_unavailable\",\n            bool\n        ))\n        .set_skip_weights_if_unavailable(extract_value_rust_result!(\n            kwargs,\n            \"skip_weights_if_unavailable\",\n            bool\n        ))\n        .set_comment_symbol(extract_value_rust_result!(kwargs, \"edge_file_comment_symbol\", String))?\n        .set_header(extract_value_rust_result!(kwargs, \"edge_header\", bool))\n        .set_rows_to_skip(extract_value_rust_result!(kwargs, \"edge_rows_to_skip\", usize))\n        .set_sources_column_number(extract_value_rust_result!(kwargs, \"sources_column_number\", usize))?\n        .set_sources_column(extract_value_rust_result!(kwargs, \"sources_column\", String))?\n        .set_destinations_column_number(extract_value_rust_result!(\n            kwargs,\n            \"destinations_column_number\",\n            usize\n        ))?\n        .set_destinations_column(extract_value_rust_result!(kwargs, \"destinations_column\", String))?\n        .set_edge_types_column_number(extract_value_rust_result!(kwargs, \"edge_types_column_number\", usize))?\n        .set_edge_types_column(extract_value_rust_result!(kwargs, \"edge_types_column\", String))?\n        .set_default_edge_type(extract_value_rust_result!(kwargs, \"default_edge_type\", String))\n        .set_weights_column_number(extract_value_rust_result!(kwargs, \"weights_column_number\", usize))?\n        .set_weights_column(extract_value_rust_result!(kwargs, \"weights_column\", String))?\n        .set_default_weight(extract_value_rust_result!(kwargs, \"default_weight\", WeightT))\n        .set_skip_selfloops(extract_value_rust_result!(kwargs, \"skip_selfloops\", bool))\n        .set_ignore_duplicates(extract_value_rust_result!(kwargs, \"ignore_duplicated_edges\", bool))\n        .set_verbose(extract_value_rust_result!(kwargs, \"verbose\", bool))\n        .set_numeric_node_ids(extract_value_rust_result!(kwargs, \"numeric_edge_node_ids\", bool))\n        .set_numeric_edge_type_ids(extract_value_rust_result!(kwargs, \"numeric_edge_type_ids\", bool))\n        .set_max_rows_number(extract_value_rust_result!(kwargs, \"edge_max_rows_number\", u64));\n\n    let nodes: Option<NodeFileReader> = match kwargs.get_item(\"node_path\") {\n        Some(_) => {\n            let maybe_node_path = extract_value_rust_result!(kwargs, \"node_path\", String);\n            match maybe_node_path {\n                None => None,\n                Some(node_path) => Some(\n                    NodeFileReader::new(node_path)?\n                        .set_separator(extract_value_rust_result!(kwargs, \"node_separator\", String))?\n                        .set_skip_node_types_if_unavailable(extract_value_rust_result!(\n                            kwargs,\n                            \"skip_node_types_if_unavailable\",\n                            bool\n                        ))?\n                        .set_comment_symbol(extract_value_rust_result!(\n                            kwargs,\n                            \"node_file_comment_symbol\",\n                            String\n                        ))?\n                        .set_header(extract_value_rust_result!(kwargs, \"node_header\", bool))\n                        .set_rows_to_skip(extract_value_rust_result!(kwargs, \"node_rows_to_skip\", usize))\n                        .set_nodes_column_number(extract_value_rust_result!(\n                            kwargs,\n                            \"nodes_column_number\",\n                            usize\n                        ))\n                        .set_nodes_column(extract_value_rust_result!(kwargs, \"nodes_column\", String))?\n                        .set_node_types_column_number(extract_value_rust_result!(\n                            kwargs,\n                            \"node_types_column_number\",\n                            usize\n                        ))\n                        .set_node_types_column(extract_value_rust_result!(\n                            kwargs,\n                            \"node_types_column\",\n                            String\n                        ))?\n                        .set_node_types_separator(extract_value_rust_result!(\n                            kwargs,\n                            \"node_types_separator\",\n                            String\n                        ))?\n                        .set_default_node_type(extract_value_rust_result!(kwargs, \"default_node_type\", String))\n                        .set_ignore_duplicates(extract_value_rust_result!(\n                            kwargs,\n                            \"ignore_duplicated_nodes\",\n                            bool\n                        ))\n                        .set_verbose(extract_value_rust_result!(kwargs, \"verbose\", bool))\n                        .set_numeric_node_ids(extract_value_rust_result!(kwargs, \"numeric_node_ids\", bool))\n                        .set_numeric_node_type_ids(extract_value_rust_result!(\n                            kwargs,\n                            \"numeric_node_type_ids\",\n                            bool\n                        ))\n                        .set_max_rows_number(extract_value_rust_result!(kwargs, \"node_max_rows_number\", u64)),\n                ),\n            }\n        }\n        None => None,\n    };\n\n    Ok((\n        edges,\n        nodes,\n        graph_name,\n        extract_value_rust_result!(kwargs, \"directed_edge_list\", bool).unwrap_or(false),\n    ))"
            },
            {
                "file": "utilities.rs",
                "struct": "EnsmallenGraph",
                "doc": [],
                "attrs": [],
                "modifiers": "pub(crate)",
                "name": "build_walk_parameters",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "walk_length",
                        "u64"
                    ],
                    [
                        "kwargs",
                        "&PyDict"
                    ]
                ],
                "return_type": "Result<WalksParameters, String>",
                "body": "Ok(WalksParameters::new(walk_length)?\n            .set_change_edge_type_weight(extract_value_rust_result!(\n                kwargs,\n                \"change_edge_type_weight\",\n                WeightT\n            ))?\n            .set_change_node_type_weight(extract_value_rust_result!(\n                kwargs,\n                \"change_node_type_weight\",\n                WeightT\n            ))?\n            .set_explore_weight(extract_value_rust_result!(kwargs, \"explore_weight\", WeightT))?\n            .set_return_weight(extract_value_rust_result!(kwargs, \"return_weight\", WeightT))?\n            .set_random_state(extract_value_rust_result!(kwargs, \"random_state\", usize))\n            .set_max_neighbours(extract_value_rust_result!(kwargs, \"max_neighbours\", NodeT))?\n            .set_iterations(extract_value_rust_result!(kwargs, \"iterations\", NodeT))?\n            .set_dense_node_mapping(\n                extract_value_rust_result!(kwargs, \"dense_node_mapping\", HashMap<NodeT, NodeT>)\n            ))"
            }
        ]
    },
    "tarjan.rs": {
        "imports": [
            "use super::*;",
            "use graph::{NodeT};",
            "use std::collections::HashSet;"
        ],
        "functions": [
            {
                "file": "tarjan.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns list of sets of nodes of connected components.",
                    "",
                    " Raises",
                    " ------------------------",
                    " TODO: update the set of exceptions",
                    "",
                    " Returns",
                    " ------------------------",
                    " List of sets of connected components.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "strongly_connected_components",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<HashSet<NodeT>>",
                "body": "self.graph.strongly_connected_components()"
            }
        ]
    },
    "filters.rs": {
        "imports": [
            "use super::*;",
            "use graph::{WeightT};"
        ],
        "functions": [
            {
                "file": "filters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return graph filtered by given filters.",
                    "",
                    " Parameters",
                    " -------------",
                    " `node_names`: List[str],",
                    "     The node names to keep.",
                    " `node_types`: List[str],",
                    "     The node types to keep.",
                    " `edge_types`: List[str],",
                    "     The edge types to keep.",
                    " `min_weight`: float,",
                    "     Minimum weight to use to filter edges.",
                    " `max_weight`: float,",
                    "     Maximum weight to use to filter edges.",
                    " `verbose`: bool,",
                    "     Wether to show the loading bar.",
                    "",
                    " Returns",
                    " -------------",
                    " The filtered graph."
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_names, node_types, edge_types, min_weight, max_weight, verbose)\"]"
                ],
                "modifiers": "pub",
                "name": "filter",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "nodes",
                        "Option<Vec<String>>"
                    ],
                    [
                        "node_types",
                        "Option<Vec<Option<String>>>"
                    ],
                    [
                        "edge_types",
                        "Option<Vec<Option<String>>>"
                    ],
                    [
                        "min_weight",
                        "Option<WeightT>"
                    ],
                    [
                        "max_weight",
                        "Option<WeightT>"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "PyResult<EnsmallenGraph>",
                "body": "Ok(EnsmallenGraph {\n            graph: pe!(self.graph.filter(\n                nodes,\n                node_types,\n                edge_types,\n                min_weight,\n                max_weight,\n                verbose.unwrap_or(true),\n            ))?,\n        })"
            }
        ]
    },
    "types.rs": {
        "imports": [
            "use graph::{Graph, NodeT};",
            "use numpy::{PyArray1, PyArray2};",
            "use pyo3::prelude::*;"
        ],
        "functions": []
    },
    "metrics.rs": {
        "imports": [
            "use super::*;",
            "use graph::{EdgeT, NodeT};",
            "use numpy::{PyArray, PyArray1};",
            "use std::collections::HashMap;"
        ],
        "functions": [
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns mean node degree of the graph."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "pub",
                "name": "get_node_degrees_mean",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "PyResult<f64>",
                "body": "pe!(self.graph.get_node_degrees_mean())"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns number of connected components in graph.",
                    "",
                    " Returns",
                    " ------------------------",
                    " Number of connected components."
                ],
                "attrs": [
                    "#[text_signature = \"($self, verbose)\"]"
                ],
                "modifiers": "pub",
                "name": "connected_components_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "verbose",
                        "bool"
                    ]
                ],
                "return_type": "(NodeT, NodeT, NodeT)",
                "body": "self.graph.connected_components_number(verbose)"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns number of self-loops."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "pub",
                "name": "get_selfloops_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "self.graph.get_selfloop_number()"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns ratio of self-loops."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "pub",
                "name": "get_selfloops_rate",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "f64",
                "body": "self.graph.get_selfloop_rate()"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns median node degree of the graph."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "pub",
                "name": "get_node_degrees_median",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "PyResult<NodeT>",
                "body": "pe!(self.graph.get_node_degrees_median())"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns max node degree of the graph."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "pub",
                "name": "get_max_node_degree",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "PyResult<NodeT>",
                "body": "pe!(self.graph.get_max_node_degree())"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns min node degree of the graph."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "pub",
                "name": "get_min_node_degree",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "PyResult<NodeT>",
                "body": "pe!(self.graph.get_min_node_degree())"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns mode node degree of the graph."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "pub",
                "name": "get_node_degrees_mode",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "PyResult<NodeT>",
                "body": "pe!(self.graph.get_node_degrees_mode())"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns report relative to the graph metrics.",
                    "",
                    " The report includes a few useful metrics like:",
                    "",
                    " * degrees_median: the median degree of the nodes.",
                    " * degrees_mean: the mean degree of the nodes.",
                    " * degrees_mode: the mode degree of the nodes.",
                    " * degrees_max: the max degree of the nodes.",
                    " * degrees_min: the min degree of the nodes.",
                    " * nodes_number: the number of nodes in the graph.",
                    " * edges_number: the number of edges in the graph.",
                    " * unique_node_types_number: the number of different node types in the graph.",
                    " * unique_edge_types_number: the number of different edge types in the graph.",
                    " * traps_rate: probability to end up in a trap when starting into any given node.",
                    " * selfloops_rate: pecentage of edges that are selfloops.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "report",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "HashMap<&str, String>",
                "body": "self.graph.report()"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return report on overlaps of the two graphs.",
                    "",
                    " Parameters",
                    " -------------------",
                    " `other`: &EnsmallenGraph,",
                    "     Graph to compute the overlaps with.",
                    " verbose: bool = True,",
                    "     Wether to show loading bars.",
                    "",
                    " Returns",
                    " -------------------",
                    " Textual report."
                ],
                "attrs": [],
                "modifiers": "",
                "name": "overlap_textual_report",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "other",
                        "&EnsmallenGraph"
                    ],
                    [
                        "verbose",
                        "Option<bool>"
                    ]
                ],
                "return_type": "PyResult<String>",
                "body": "pe!(self\n            .graph\n            .overlap_textual_report(&other.graph, verbose.unwrap_or(true)))"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the degree for the given node.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " node: int,",
                    "     Node ID to use to compute degrees product.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " degrees product for the two given nodes.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, node)\"]"
                ],
                "modifiers": "",
                "name": "get_node_degree_by_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node",
                        "NodeT"
                    ]
                ],
                "return_type": "PyResult<NodeT>",
                "body": "pe!(self.graph.get_node_degree_by_node_id(node))"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return all the degrees of the nodes graph.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Numpy array with all the degrees of the graph.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "degrees",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "PyResult<Py<PyArray1<NodeT>>>",
                "body": "let degrees = self.graph.get_node_degrees();\n        let gil = pyo3::Python::acquire_gil();\n        Ok(to_ndarray_1d!(gil, degrees, NodeT))"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the Jaccard Index for the two given nodes.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " one: int,",
                    "     First node ID to use to compute Jaccard Index.",
                    " two: int,",
                    "     Second node ID to use to compute Jaccard Index.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Jaccard Index for the two given nodes.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, one, two)\"]"
                ],
                "modifiers": "",
                "name": "jaccard_index",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "one",
                        "NodeT"
                    ],
                    [
                        "two",
                        "NodeT"
                    ]
                ],
                "return_type": "PyResult<f64>",
                "body": "pe!(self.graph.jaccard_index(one, two))"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the Adamic/Adar for the two given nodes.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " one: int,",
                    "     First node ID to use to compute Adamic/Adar.",
                    " two: int,",
                    "     Second node ID to use to compute Adamic/Adar.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Adamic/Adar for the two given nodes.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, one, two)\"]"
                ],
                "modifiers": "",
                "name": "adamic_adar_index",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "one",
                        "NodeT"
                    ],
                    [
                        "two",
                        "NodeT"
                    ]
                ],
                "return_type": "PyResult<f64>",
                "body": "pe!(self.graph.adamic_adar_index(one, two))"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the Resource Allocation Index for the two given nodes.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " one: int,",
                    "     First node ID to use to compute Resource Allocation Index.",
                    " two: int,",
                    "     Second node ID to use to compute Resource Allocation Index.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Resource Allocation Index for the two given nodes.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, one, two)\"]"
                ],
                "modifiers": "",
                "name": "resource_allocation_index",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "one",
                        "NodeT"
                    ],
                    [
                        "two",
                        "NodeT"
                    ]
                ],
                "return_type": "PyResult<f64>",
                "body": "pe!(self.graph.resource_allocation_index(one, two))"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the degrees product for the two given nodes.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " one: int,",
                    "     First node ID to use to compute degrees product.",
                    " two: int,",
                    "     Second node ID to use to compute degrees product.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " degrees product for the two given nodes.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, one, two)\"]"
                ],
                "modifiers": "",
                "name": "degrees_product",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "one",
                        "NodeT"
                    ],
                    [
                        "two",
                        "NodeT"
                    ]
                ],
                "return_type": "PyResult<usize>",
                "body": "pe!(self.graph.degrees_product(one, two))"
            },
            {
                "file": "metrics.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the traps rate of the graph.",
                    "",
                    " This feature is EXPERIMENTAL and still required proving.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"(self)\"]"
                ],
                "modifiers": "",
                "name": "get_traps_rate",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "f64",
                "body": "self.graph.get_traps_rate()"
            }
        ]
    },
    "remove.rs": {
        "imports": [
            "use super::*;",
            "use graph::{EdgeT, NodeT};",
            "use std::collections::HashSet;"
        ],
        "functions": [
            {
                "file": "remove.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return new graph object without the indicated attributes.",
                    "",
                    " Parameters",
                    " --------------------",
                    " allow_nodes_set: Set[str] = None,",
                    "     Optional set of nodes names to keep.",
                    " deny_nodes_set: Set[str] = None,",
                    "     Optional set of nodes names to remove.",
                    " allow_node_types_set: Set[str] = None,",
                    "     Optional set of node types names to keep.",
                    " deny_node_types_set: Set[str] = None,",
                    "     Optional set of node types names to remove.",
                    " allow_edge_set: Set[int] = None,",
                    "     Optional set of numeric edge IDs to keep.",
                    " deny_edge_set: Set[int],",
                    "     Optional set of numeric edge IDs to remove.",
                    " allow_edge_types_set: Set[str] = None,",
                    "     Optional set of edge types names to keep.",
                    " deny_edge_types_set: Set[str],",
                    "     Optional set of edge types names to remove.",
                    " weights: bool = False,",
                    "     Wether to remove the weights.",
                    "     By default the parameter is false.",
                    " node_types: bool = False,",
                    "     Wether to remove the node types.",
                    "     By default the parameter is false.",
                    " edge_types: bool = False,",
                    "     Wether to remove the edge types.",
                    "     By default the parameter is false.",
                    " singletons: bool = False,",
                    "     Wether to remove the singleton nodes.",
                    "     By default the parameter is false.",
                    " selfloops: bool = False,",
                    "     Wether to remove the selfloops edges.",
                    "     By default the parameter is false.",
                    " verbose: bool = True,",
                    "     Wether to show a loading bar while building the graph.",
                    "     By default the parameter is true.",
                    "",
                    " Returns",
                    " ---------------------",
                    " Graph without the required elements."
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, *, allow_nodes_set, deny_nodes_set, allow_node_types_set, deny_node_types_set,  allow_edge_set, deny_edge_set, allow_edge_types_set, deny_edge_types_set, weights, node_types, edge_types, singletons, selfloops, verbose)\"]"
                ],
                "modifiers": "",
                "name": "remove",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<EnsmallenGraph>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n        pe!(validate_kwargs(\n            kwargs,\n            &[\n                \"allow_nodes_set\",\n                \"deny_nodes_set\",\n                \"allow_node_types_set\",\n                \"deny_node_types_set\",\n                \"allow_edge_set\",\n                \"deny_edge_set\",\n                \"allow_edge_types_set\",\n                \"deny_edge_types_set\",\n                \"weights\",\n                \"node_types\",\n                \"edge_types\",\n                \"singletons\",\n                \"selfloops\",\n                \"verbose\"\n            ],\n        ))?;\n\n        Ok(EnsmallenGraph {\n            graph: pe!(self.graph.remove(\n                extract_value!(kwargs, \"allow_nodes_set\", HashSet<String>),\n                extract_value!(kwargs, \"deny_nodes_set\", HashSet<String>),\n                extract_value!(\n                    kwargs,\n                    \"allow_node_types_set\",\n                    HashSet<String>\n                ),\n                extract_value!(\n                    kwargs,\n                    \"deny_node_types_set\",\n                    HashSet<String>\n                ),\n                extract_value!(kwargs, \"allow_edge_set\", HashSet<EdgeT>),\n                extract_value!(kwargs, \"deny_edge_set\", HashSet<EdgeT>),\n                extract_value!(\n                    kwargs,\n                    \"allow_edge_types_set\",\n                    HashSet<String>\n                ),\n                extract_value!(\n                    kwargs,\n                    \"deny_edge_types_set\",\n                    HashSet<String>\n                ),\n                extract_value!(kwargs, \"weights\", bool).unwrap_or(false),\n                extract_value!(kwargs, \"node_types\", bool).unwrap_or(false),\n                extract_value!(kwargs, \"edge_types\", bool).unwrap_or(false),\n                extract_value!(kwargs, \"singletons\", bool).unwrap_or(false),\n                extract_value!(kwargs, \"selfloops\", bool).unwrap_or(false),\n                extract_value!(kwargs, \"verbose\", bool).unwrap_or(true),\n            ))?,\n        })"
            },
            {
                "file": "remove.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " remove all the components that are not connected to interesting",
                    " nodes and edges.",
                    "",
                    " Parameters",
                    " --------------------",
                    " node_names: List[str] = None,",
                    "     The name of the nodes of which components to keep.",
                    " node_types: List[str] = None,",
                    "     The types of the nodes of which components to keep.",
                    " edge_types: List[str] = None,",
                    "     The types of the edges of which components to keep.",
                    " minimum_component_size: int = None,",
                    "     Minimum size of the components to keep.",
                    " top_k_components: int = None,",
                    "     Number of components to keep sorted by number of nodes.",
                    " verbose: bool = True,",
                    "     Wether to show the loading bar.",
                    "",
                    " Returns",
                    " ---------------------",
                    " Graph composed only of filtered components."
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, *, node_names, node_types, edge_types, minimum_component_size, top_k_components, verbose)\"]"
                ],
                "modifiers": "",
                "name": "remove_components",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<EnsmallenGraph>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n        pe!(validate_kwargs(\n            kwargs,\n            &[\n                \"node_names\",\n                \"node_types\",\n                \"edge_types\",\n                \"minimum_component_size\",\n                \"top_k_components\",\n                \"verbose\"\n            ]\n        ))?;\n\n        Ok(EnsmallenGraph {\n            graph: pe!(self.graph.remove_components(\n                extract_value!(kwargs, \"node_names\", Vec<String>),\n                extract_value!(kwargs, \"node_types\", Vec<Option<String>>),\n                extract_value!(kwargs, \"edge_types\", Vec<Option<String>>),\n                extract_value!(kwargs, \"minimum_component_size\", NodeT),\n                extract_value!(kwargs, \"top_k_components\", NodeT),\n                extract_value!(kwargs, \"verbose\", bool).unwrap_or(true),\n            ))?,\n        })"
            }
        ]
    },
    "edge_file_writer.rs": {
        "imports": [
            "use super::*;",
            "use graph::EdgeFileWriter;",
            "use pyo3::types::PyDict;"
        ],
        "functions": [
            {
                "file": "edge_file_writer.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Write to disk the edges (and optionally the metadata) of the graph.",
                    "",
                    " Parameters",
                    " ------------------------",
                    " path: str,",
                    "     Path where to save the edges and their metadata.",
                    " verbose: bool = True,",
                    "     Wether to show a loading bar while writing to file.",
                    " separator: str = \"\\t\",",
                    "     What separator to use while writing out to file.",
                    " header: bool = True,",
                    "     Wether to write out the header of the file.",
                    " sources_column_number: int = 0,",
                    "     The column number where to write out the .",
                    " sources_column: str = \"subject\",",
                    "     The name of the column where to write out the .",
                    " destinations_column_number: int = 1,",
                    "     The column number where to write out the .",
                    " destinations_column: str = \"object\",",
                    "     The name of the column where to write out the .",
                    " edge_types_column_number: int = 2,",
                    "     The column number where to write out the .",
                    " edges_type_column: str = \"label\",",
                    "     The name of the column where to write out the .",
                    " weights_column_number: int = 3,",
                    "     The column number where to write out the .",
                    " weights_column: str = \"weight\",",
                    "     The name of the column where to write out the .",
                    " numeric_node_ids: bool = False,",
                    "     whether to save the internal numeric Ids instead of the string names.",
                    " directed: bool = False,",
                    "     whether to save graph as directed or undirected.",
                    "",
                    " Raises",
                    " ------------------------",
                    " TODO: update the set of exceptions",
                    ""
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, path, *, verbose, separator, header, sources_column_number, sources_column, destinations_column_number, destinations_column, weights_column_number, weights_column, edge_types_column_number, edges_type_column, numeric_node_ids, directed)\"]"
                ],
                "modifiers": "",
                "name": "dump_edges",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "path",
                        "String"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<()>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n\n        pe!(validate_kwargs(\n            kwargs,\n            &[\n                \"verbose\",\n                \"separator\",\n                \"header\",\n                \"sources_column_number\",\n                \"sources_column\",\n                \"destinations_column_number\",\n                \"destinations_column\",\n                \"weights_column_number\",\n                \"weights_column\",\n                \"edge_types_column_number\",\n                \"edges_type_column\",\n                \"numeric_node_ids\",\n                \"directed\"\n            ]\n        ))?;\n\n        let writer = EdgeFileWriter::new(path)\n            .set_verbose(extract_value!(kwargs, \"verbose\", bool))\n            .set_separator(extract_value!(kwargs, \"separator\", String))\n            .set_header(extract_value!(kwargs, \"header\", bool))\n            .set_directed(extract_value!(kwargs, \"directed\", bool))\n            .set_sources_column_number(extract_value!(kwargs, \"sources_column_number\", usize))\n            .set_sources_column(extract_value!(kwargs, \"sources_column\", String))\n            .set_destinations_column_number(extract_value!(\n                kwargs,\n                \"destinations_column_number\",\n                usize\n            ))\n            .set_destinations_column(extract_value!(kwargs, \"destinations_column\", String))\n            .set_weights_column_number(extract_value!(kwargs, \"weights_column_number\", usize))\n            .set_weights_column(extract_value!(kwargs, \"weights_column\", String))\n            .set_edge_types_column_number(extract_value!(kwargs, \"edge_types_column_number\", usize))\n            .set_numeric_node_ids(extract_value!(kwargs, \"numeric_node_ids\", bool))\n            .set_edge_types_column(extract_value!(kwargs, \"edges_type_column\", String));\n        pe!(writer.dump(&self.graph))"
            }
        ]
    },
    "setters.rs": {
        "imports": [
            "use super::*;"
        ],
        "functions": [
            {
                "file": "setters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Set the name of the graph.",
                    "",
                    " Parameters",
                    " -----------------------",
                    " name: str,",
                    "     Name of the graph."
                ],
                "attrs": [
                    "#[text_signature = \"(self, name)\"]"
                ],
                "modifiers": "",
                "name": "set_name",
                "args": [
                    [
                        "self",
                        "&mut self"
                    ],
                    [
                        "name",
                        "String"
                    ]
                ],
                "body": "self.graph.set_name(name)"
            }
        ]
    },
    "walks.rs": {
        "imports": [
            "use super::*;",
            "use graph::NodeT;",
            "use numpy::PyArray2;",
            "use rayon::iter::IndexedParallelIterator;",
            "use rayon::prelude::*;",
            "use thread_safe::ThreadSafe;"
        ],
        "functions": [
            {
                "file": "walks.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return random walks done on the graph using Rust.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " walk_length: int,",
                    "     Maximal length of the random walk.",
                    "     On graphs without traps, all walks have this length.",
                    " quantity: int,",
                    "     Number of nodes to sample.",
                    " return_weight: float = 1.0,",
                    "     Weight on the probability of returning to node coming from",
                    "     Having this higher tends the walks to be",
                    "     more like a Breadth-First Search.",
                    "     Having this very high  (> 2) makes search very local.",
                    "     Equal to the inverse of p in the Node2Vec paper.",
                    " explore_weight: float = 1.0,",
                    "     Weight on the probability of visiting a neighbor node",
                    "     to the one we're coming from in the random walk",
                    "     Having this higher tends the walks to be",
                    "     more like a Depth-First Search.",
                    "     Having this very high makes search more outward.",
                    "     Having this very low makes search very local.",
                    "     Equal to the inverse of q in the Node2Vec paper.",
                    " change_edge_type_weight: float = 1.0,",
                    "     Weight on the probability of visiting a neighbor node of a",
                    "     different type than the previous node. This only applies to",
                    "     colored graphs, otherwise it has no impact.",
                    " change_node_type_weight: float = 1.0,",
                    "     Weight on the probability of visiting a neighbor edge of a",
                    "     different type than the previous edge. This only applies to",
                    "     multigraphs, otherwise it has no impact.",
                    " random_state: int = 42,",
                    "     random_state to use to reproduce the walks.",
                    " iterations: int = 1,",
                    "     Number of cycles on the graphs to execute.",
                    " dense_node_mapping: Dict[int, int] = None,",
                    "     Mapping to use for converting sparse walk space into a dense space.",
                    "     This object can be created using the method available from graph",
                    "     called `get_dense_node_mapping` that returns a mapping from",
                    "     the non trap nodes (those from where a walk could start) and",
                    "     maps these nodes into a dense range of values.",
                    " max_neighbours: int = None,",
                    "     Maximum number of randomly sampled neighbours to consider.",
                    "     If this parameter is used, the walks becomes probabilistic in nature",
                    "     and becomes an approximation of an exact walk.",
                    "",
                    " Raises",
                    " ----------------------------",
                    " TODO: Update raises",
                    "",
                    " Returns",
                    " ----------------------------",
                    " List of list of walks containing the numeric IDs of nodes.",
                    ""
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, walk_length, quantity, *, return_weight, explore_weight, change_edge_type_weight, change_node_type_weight, random_state, iterations, dense_node_mapping, max_neighbours)\"]"
                ],
                "modifiers": "",
                "name": "random_walks",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "walk_length",
                        "u64"
                    ],
                    [
                        "quantity",
                        "NodeT"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<Py<PyArray2<NodeT>>>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n\n        pe!(validate_kwargs(kwargs, build_walk_parameters_list(&[]).as_slice()))?;\n\n        let parameters = pe!(self.build_walk_parameters(walk_length, kwargs))?;\n        let iter = pe!(self.graph.iter_random_walks(quantity, &parameters))?;\n        let array = ThreadSafe {\n            t: PyArray2::new(\n                py.python(),\n                [\n                    quantity as usize * parameters.get_iterations() as usize,\n                    walk_length as usize,\n                ],\n                false,\n            ),\n        };\n        unsafe {\n            iter.enumerate().for_each(|(y, vy)| {\n                vy.iter()\n                    .enumerate()\n                    .for_each(|(x, vyx)| *(array.t.uget_mut([y, x])) = *vyx)\n            });\n        }\n        Ok(array.t.to_owned())"
            },
            {
                "file": "walks.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return complete random walks done on the graph using Rust.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " walk_length: int,",
                    "     Maximal length of the random walk.",
                    "     On graphs without traps, all walks have this length.",
                    " return_weight: float = 1.0,",
                    "     Weight on the probability of returning to node coming from",
                    "     Having this higher tends the walks to be",
                    "     more like a Breadth-First Search.",
                    "     Having this very high  (> 2) makes search very local.",
                    "     Equal to the inverse of p in the Node2Vec paper.",
                    " explore_weight: float = 1.0,",
                    "     Weight on the probability of visiting a neighbor node",
                    "     to the one we're coming from in the random walk",
                    "     Having this higher tends the walks to be",
                    "     more like a Depth-First Search.",
                    "     Having this very high makes search more outward.",
                    "     Having this very low makes search very local.",
                    "     Equal to the inverse of q in the Node2Vec paper.",
                    " change_edge_type_weight: float = 1.0,",
                    "     Weight on the probability of visiting a neighbor node of a",
                    "     different type than the previous node. This only applies to",
                    "     colored graphs, otherwise it has no impact.",
                    " change_node_type_weight: float = 1.0,",
                    "     Weight on the probability of visiting a neighbor edge of a",
                    "     different type than the previous edge. This only applies to",
                    "     multigraphs, otherwise it has no impact.",
                    " random_state: int = 42,",
                    "     random_state to use to reproduce the walks.",
                    " iterations: int = 1,",
                    "     Number of cycles on the graphs to execute.",
                    " dense_node_mapping: Dict[int, int] = None,",
                    "     Mapping to use for converting sparse walk space into a dense space.",
                    "     This object can be created using the method available from graph",
                    "     called `get_dense_node_mapping` that returns a mapping from",
                    "     the non trap nodes (those from where a walk could start) and",
                    "     maps these nodes into a dense range of values.",
                    " max_neighbours: int = None,",
                    "     Maximum number of randomly sampled neighbours to consider.",
                    "     If this parameter is used, the walks becomes probabilistic in nature",
                    "     and becomes an approximation of an exact walk.",
                    "",
                    " Raises",
                    " ----------------------------",
                    " TODO: Update raises",
                    "",
                    " Returns",
                    " ----------------------------",
                    " List of list of walks containing the numeric IDs of nodes.",
                    ""
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, walk_length, *, return_weight, explore_weight, change_edge_type_weight, change_node_type_weight, random_state, iterations, dense_node_mapping, max_neighbours)\"]"
                ],
                "modifiers": "",
                "name": "complete_walks",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "walk_length",
                        "u64"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<Py<PyArray2<NodeT>>>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n\n        pe!(validate_kwargs(kwargs, build_walk_parameters_list(&[]).as_slice()))?;\n\n        let parameters = pe!(self.build_walk_parameters(walk_length, kwargs))?;\n        let iter = pe!(self.graph.iter_complete_walks(&parameters))?;\n        let array = ThreadSafe {\n            t: PyArray2::new(\n                py.python(),\n                [\n                    self.graph.get_unique_source_nodes_number() as usize\n                        * parameters.get_iterations() as usize,\n                    walk_length as usize,\n                ],\n                false,\n            ),\n        };\n        unsafe {\n            iter.enumerate().for_each(|(y, vy)| {\n                vy.iter()\n                    .enumerate()\n                    .for_each(|(x, vyx)| *(array.t.uget_mut([y, x])) = *vyx)\n            });\n        }\n        Ok(array.t.to_owned())"
            }
        ]
    },
    "edge_lists.rs": {
        "imports": [
            "use super::*;",
            "use graph::NodeT;",
            "use numpy::{PyArray, PyArray2};",
            "use std::collections::HashSet;"
        ],
        "functions": [
            {
                "file": "edge_lists.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of tuple of Node IDs that form the edges of the required bipartite graph.",
                    "",
                    " Parameteres",
                    " ----------------------",
                    " removed_existing_edges: bool = True,",
                    "     Wether to filter out the existing edges. By default, true.",
                    " first_nodes_set: Set[str] = None,",
                    "     Optional set of nodes to use to create the first set of nodes of the graph.",
                    " second_nodes_set: Set[str] = None,",
                    "     Optional set of nodes to use to create the second set of nodes of the graph.",
                    " first_node_types_set: Set[str] = None,",
                    "     Optional set of node types to create the first set of nodes of the graph.",
                    " second_node_types_set: Set[str] = None,",
                    "     Optional set of node types to create the second set of nodes of the graph.",
                    "",
                    " Raises",
                    " ----------------------",
                    " ValueError,",
                    "     If given node sets lead to an empty bipartite graph.",
                    " ValueError,",
                    "     If given node sets overlap.",
                    "",
                    " Returns",
                    " ----------------------",
                    " Numpy vector of the node IDs forming the required bipartite graph."
                ],
                "attrs": [
                    "#[text_signature = \"(self, *, removed_existing_edges, first_nodes_set, second_nodes_set, first_node_types_set, second_node_types_set)\"]"
                ],
                "modifiers": "pub",
                "name": "get_bipartite_edges",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "removed_existing_edges",
                        "Option<bool>"
                    ],
                    [
                        "first_nodes_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "second_nodes_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "first_node_types_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "second_node_types_set",
                        "Option<HashSet<String>>"
                    ]
                ],
                "return_type": "PyResult<Py<PyArray2<NodeT>>>",
                "body": "let gil = pyo3::Python::acquire_gil();\n        Ok(to_nparray_2d!(\n            gil,\n            pe!(self.graph.get_bipartite_edges(\n                removed_existing_edges,\n                first_nodes_set,\n                second_nodes_set,\n                first_node_types_set,\n                second_node_types_set,\n            ))?,\n            NodeT\n        ))"
            },
            {
                "file": "edge_lists.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of tuple of Node names that form the edges of the required bipartite graph.",
                    "",
                    " Parameteres",
                    " ----------------------",
                    " removed_existing_edges: bool = True,",
                    "     Wether to filter out the existing edges. By default, true.",
                    " first_nodes_set: Set[str] = None,",
                    "     Optional set of nodes to use to create the first set of nodes of the graph.",
                    " second_nodes_set: Set[str] = None,",
                    "     Optional set of nodes to use to create the second set of nodes of the graph.",
                    " first_node_types_set: Set[str] = None,",
                    "     Optional set of node types to create the first set of nodes of the graph.",
                    " second_node_types_set: Set[str] = None,",
                    "     Optional set of node types to create the second set of nodes of the graph.",
                    "",
                    " Raises",
                    " ----------------------",
                    " ValueError,",
                    "     If given node sets lead to an empty bipartite graph.",
                    " ValueError,",
                    "     If given node sets overlap.",
                    "",
                    " Returns",
                    " ----------------------",
                    " Numpy vector of the node names forming the required bipartite graph."
                ],
                "attrs": [
                    "#[text_signature = \"(self, *, removed_existing_edges, first_nodes_set, second_nodes_set, first_node_types_set, second_node_types_set)\"]"
                ],
                "modifiers": "pub",
                "name": "get_bipartite_edge_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "removed_existing_edges",
                        "Option<bool>"
                    ],
                    [
                        "first_nodes_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "second_nodes_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "first_node_types_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "second_node_types_set",
                        "Option<HashSet<String>>"
                    ]
                ],
                "return_type": "PyResult<Vec<Vec<String>>>",
                "body": "pe!(self.graph.get_bipartite_edge_names(\n            removed_existing_edges,\n            first_nodes_set,\n            second_nodes_set,\n            first_node_types_set,\n            second_node_types_set,\n        ))"
            },
            {
                "file": "edge_lists.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of tuple of Node IDs that form the edges of the required star.",
                    "",
                    " Parameteres",
                    " ----------------------",
                    " central_node: str,",
                    "     Name of the node to use as center of the star.",
                    " removed_existing_edges: bool = True,",
                    "     Wether to filter out the existing edges. By default, true.",
                    " star_points_nodes_set: Set[str] = None,",
                    "     Optional set of nodes to use to create the set of star points.",
                    " star_points_node_types_set: Set[str] = None,",
                    "     Optional set of node types to create the set of star points.",
                    "",
                    " Raises",
                    " ----------------------",
                    " ValueError,",
                    "     If given node sets lead to an empty star graph.",
                    " ValueError,",
                    "     If given central is present in given node set.",
                    "",
                    " Returns",
                    " ----------------------",
                    " Numpy vector of the node IDs forming the required star graph."
                ],
                "attrs": [
                    "#[text_signature = \"(self, *, central_node, removed_existing_edges, star_points_nodes_set, star_points_node_types_set)\"]"
                ],
                "modifiers": "pub",
                "name": "get_star_edges",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "central_node",
                        "String"
                    ],
                    [
                        "removed_existing_edges",
                        "Option<bool>"
                    ],
                    [
                        "star_points_nodes_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "star_points_node_types_set",
                        "Option<HashSet<String>>"
                    ]
                ],
                "return_type": "PyResult<Py<PyArray2<NodeT>>>",
                "body": "let gil = pyo3::Python::acquire_gil();\n        Ok(to_nparray_2d!(\n            gil,\n            pe!(self.graph.get_star_edges(\n                central_node,\n                removed_existing_edges,\n                star_points_nodes_set,\n                star_points_node_types_set\n            ))?,\n            NodeT\n        ))"
            },
            {
                "file": "edge_lists.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of tuple of Node names that form the edges of the required star.",
                    "",
                    " Parameteres",
                    " ----------------------",
                    " central_node: str,",
                    "     Name of the node to use as center of the star.",
                    " removed_existing_edges: bool = True,",
                    "     Wether to filter out the existing edges. By default, true.",
                    " star_points_nodes_set: Set[str] = None,",
                    "     Optional set of nodes to use to create the set of star points.",
                    " star_points_node_types_set: Set[str] = None,",
                    "     Optional set of node types to create the set of star points.",
                    "",
                    " Raises",
                    " ----------------------",
                    " ValueError,",
                    "     If given node sets lead to an empty star graph.",
                    " ValueError,",
                    "     If given central is present in given node set.",
                    "",
                    " Returns",
                    " ----------------------",
                    " Numpy vector of the node names forming the required star graph."
                ],
                "attrs": [
                    "#[text_signature = \"(self, *, central_node, removed_existing_edges, star_points_nodes_set, star_points_node_types_set)\"]"
                ],
                "modifiers": "pub",
                "name": "get_star_edge_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "central_node",
                        "String"
                    ],
                    [
                        "removed_existing_edges",
                        "Option<bool>"
                    ],
                    [
                        "star_points_nodes_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "star_points_node_types_set",
                        "Option<HashSet<String>>"
                    ]
                ],
                "return_type": "PyResult<Vec<Vec<String>>>",
                "body": "pe!(self.graph.get_star_edge_names(\n            central_node,\n            removed_existing_edges,\n            star_points_nodes_set,\n            star_points_node_types_set\n        ))"
            },
            {
                "file": "edge_lists.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of tuple of Node IDs that form the edges of the required clique.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " directed: bool = None,",
                    "     Wether to return the edges as directed or undirected. By default, equal to the graph.",
                    " allow_selfloops: bool = None,",
                    "     Wether to allow self-loops in the clique. By default, equal to the graph.",
                    " removed_existing_edges = True,",
                    "     Wether to filter out the existing edges. By default, true.",
                    " allow_node_type_set: Set[str] = None,",
                    "     Node types to include in the clique.",
                    " allow_node_set: Set[str] = None,",
                    "     Nodes to include i the clique.",
                    "",
                    " Returns",
                    " ----------------------",
                    " Numpy vector of the node IDs forming the required clique."
                ],
                "attrs": [
                    "#[text_signature = \"(self, *, directed, removed_existing_edges, allow_node_type_set, allow_node_set)\"]"
                ],
                "modifiers": "pub",
                "name": "get_clique_edges",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "Option<bool>"
                    ],
                    [
                        "allow_selfloops",
                        "Option<bool>"
                    ],
                    [
                        "removed_existing_edges",
                        "Option<bool>"
                    ],
                    [
                        "allow_node_type_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "allow_node_set",
                        "Option<HashSet<String>>"
                    ]
                ],
                "return_type": "PyResult<Py<PyArray2<NodeT>>>",
                "body": "let gil = pyo3::Python::acquire_gil();\n        Ok(to_nparray_2d!(\n            gil,\n            self.graph.get_clique_edges(\n                directed,\n                allow_selfloops,\n                removed_existing_edges,\n                allow_node_type_set,\n                allow_node_set,\n            ),\n            NodeT\n        ))"
            },
            {
                "file": "edge_lists.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of tuple of Node IDs that form the edges of the required clique.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " directed: bool = None,",
                    "     Wether to return the edges as directed or undirected. By default, equal to the graph.",
                    " allow_selfloops: bool = None,",
                    "     Wether to allow self-loops in the clique. By default, equal to the graph.",
                    " removed_existing_edges = True,",
                    "     Wether to filter out the existing edges. By default, true.",
                    " allow_node_type_set: Set[str] = None,",
                    "     Node types to include in the clique.",
                    " allow_node_set: Set[str] = None,",
                    "     Nodes to include i the clique.",
                    "",
                    " Returns",
                    " ----------------------",
                    " Numpy vector of the node names forming the required clique."
                ],
                "attrs": [
                    "#[text_signature = \"(self, *, directed, allow_selfloops, removed_existing_edges, allow_node_type_set, allow_node_set)\"]"
                ],
                "modifiers": "pub",
                "name": "get_clique_edge_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "Option<bool>"
                    ],
                    [
                        "allow_selfloops",
                        "Option<bool>"
                    ],
                    [
                        "removed_existing_edges",
                        "Option<bool>"
                    ],
                    [
                        "allow_node_type_set",
                        "Option<HashSet<String>>"
                    ],
                    [
                        "allow_node_set",
                        "Option<HashSet<String>>"
                    ]
                ],
                "return_type": "Vec<Vec<String>>",
                "body": "self.graph.get_clique_edge_names(\n            directed,\n            allow_selfloops,\n            removed_existing_edges,\n            allow_node_type_set,\n            allow_node_set,\n        )"
            }
        ]
    },
    "getters.rs": {
        "imports": [
            "use super::*;",
            "use graph::{EdgeT, EdgeTypeT, NodeT, NodeTypeT, WeightT};",
            "use numpy::{PyArray, PyArray1, PyArray2};",
            "use std::collections::HashMap;"
        ],
        "functions": [
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the number of nodes in the graph."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "get_nodes_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "NodeT",
                "body": "self.graph.get_nodes_number()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return List with top k central node Ids.",
                    "",
                    " Parameters",
                    " -----------------",
                    " k: int,",
                    "      Number of central nodes to extract.",
                    "",
                    " Returns",
                    " -----------------",
                    " List of the top k central node Ids."
                ],
                "attrs": [
                    "#[text_signature = \"($self, k)\"]"
                ],
                "modifiers": "",
                "name": "get_top_k_central_nodes_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "k",
                        "NodeT"
                    ]
                ],
                "return_type": "Vec<NodeT>",
                "body": "self.graph.get_top_k_central_nodes_ids(k)"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return List with top k central node names.",
                    "",
                    " Parameters",
                    " -----------------",
                    " k: int,",
                    "      Number of central nodes names to extract.",
                    "",
                    " Returns",
                    " -----------------",
                    " List of the top k central node names."
                ],
                "attrs": [
                    "#[text_signature = \"($self, k)\"]"
                ],
                "modifiers": "",
                "name": "get_top_k_central_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "k",
                        "NodeT"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "self.graph.get_top_k_central_node_names(k)"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the name of the graph."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "get_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "String",
                "body": "self.graph.get_name()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the number of edges in the graph."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "get_edges_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "self.graph.get_edges_number()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the number of undirected edges in the graph."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "get_undirected_edges_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeT",
                "body": "self.graph.get_undirected_edges_number()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the number of edges types in the graph.",
                    "",
                    " This method will include, if found necessary by a missing value,",
                    " also the default edge type in the count of total edge types.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "get_edge_types_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "EdgeTypeT",
                "body": "self.graph.get_edge_types_number()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the number of edges in the graph.",
                    "",
                    " This method will include, if found necessary by a missing value,",
                    " also the default node type in the count of total node types.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "get_node_types_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "NodeTypeT",
                "body": "self.graph.get_node_types_number()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the number of edges with the given edge type in the graph.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " * `edge_type`: int,",
                    "     Edge type ID for which to count the edges.",
                    "",
                    " Raises",
                    " ---------------------",
                    " ValueError,",
                    "     If the graph has no edge types.",
                    " ValueError,",
                    "     If the graph has not the given edge type.",
                    "",
                    " Returns",
                    " ---------------------",
                    " Number of edges of given edge type."
                ],
                "attrs": [
                    "#[text_signature = \"($self, edge_type)\"]"
                ],
                "modifiers": "",
                "name": "get_edge_count_by_edge_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type",
                        "Option<EdgeTypeT>"
                    ]
                ],
                "return_type": "PyResult<EdgeT>",
                "body": "pe!(self.graph.get_edge_count_by_edge_type_id(edge_type))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the number of nodes with the given node type in the graph.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " * `node_type`: int,",
                    "     Node type ID for which to number the nodes.",
                    "",
                    " Raises",
                    " ---------------------",
                    " ValueError,",
                    "     If the graph has no node types.",
                    " ValueError,",
                    "     If the graph has not the given node type.",
                    "",
                    " Returns",
                    " ---------------------",
                    " Number of nodes of given node type."
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_type)\"]"
                ],
                "modifiers": "",
                "name": "get_node_count_by_node_type_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type",
                        "Option<NodeTypeT>"
                    ]
                ],
                "return_type": "PyResult<NodeT>",
                "body": "pe!(self.graph.get_node_count_by_node_type_id(node_type))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the number of edges with the given edge type name in the graph.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " * `edge_type`: str,",
                    "     Edge type name for which to number the edges.",
                    "",
                    " Raises",
                    " ---------------------",
                    " ValueError,",
                    "     If the graph has no edge types.",
                    " ValueError,",
                    "     If the graph has not the given edge type.",
                    "",
                    " Returns",
                    " ---------------------",
                    " Number of edges of given edge type."
                ],
                "attrs": [
                    "#[text_signature = \"($self, edge_type)\"]"
                ],
                "modifiers": "",
                "name": "get_edge_count_by_edge_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_type",
                        "Option<&str>"
                    ]
                ],
                "return_type": "PyResult<EdgeT>",
                "body": "pe!(self.graph.get_edge_count_by_edge_type_name(edge_type))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the number of nodes with the given node type name in the graph.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " * `node_type`: str,",
                    "     Node type name for which to number the nodes.",
                    "",
                    " Raises",
                    " ---------------------",
                    " ValueError,",
                    "     If the graph has no node types.",
                    " ValueError,",
                    "     If the graph has not the given node type.",
                    "",
                    " Returns",
                    " ---------------------",
                    " Number of nodes of given node type."
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_type)\"]"
                ],
                "modifiers": "",
                "name": "get_node_count_by_node_type_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_type",
                        "Option<&str>"
                    ]
                ],
                "return_type": "PyResult<NodeT>",
                "body": "pe!(self.graph.get_node_count_by_node_type_name(node_type))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return boolean representing if given node is a trap.",
                    "",
                    " A trap node is a node with no outbounds edges.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " node: int,",
                    "     Node ID to search if it's a trap.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Boolean representing if given node is a trap.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, node)\"]"
                ],
                "modifiers": "",
                "name": "is_trap_node_by_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node",
                        "NodeT"
                    ]
                ],
                "return_type": "PyResult<bool>",
                "body": "pe!(self.graph.is_trap_node_by_node_id(node))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return boolean representing singletons.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " node_id: int,",
                    "     Node ID to search if it's a singleton.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Boolean representing if given node is a singleton.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_id)\"]"
                ],
                "modifiers": "",
                "name": "is_singleton_by_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "PyResult<bool>",
                "body": "pe!(self.graph.is_singleton_by_node_id(node_id))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return boolean representing singletons.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " node_name: str,",
                    "     Node name to search if it's a singleton.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Boolean representing if given node is a singleton.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_name)\"]"
                ],
                "modifiers": "",
                "name": "is_singleton_by_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "PyResult<bool>",
                "body": "pe!(self.graph.is_singleton_by_node_name(node_name))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return boolean representing if given edge exists in graph.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " src: int,",
                    "     Node ID to use as source of given edge.",
                    " dst: int,",
                    "     Node ID to use as destination of given edge.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Boolean representing if given edge exists in graph.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, src, dst)\"]"
                ],
                "modifiers": "",
                "name": "has_edge_by_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "bool",
                "body": "self.graph.has_edge_by_node_ids(src, dst)"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return boolean representing if given edge with type exists in graph.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " src: int,",
                    "     Node ID to use as source of given edge.",
                    " dst: int,",
                    "     Node ID to use as destination of given edge.",
                    " * `edge_type`: Union[None, int],",
                    "     Edge type ID. (By deafult is None).",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Boolean representing if given edge exists in graph.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, src, dst, edge_type)\"]"
                ],
                "modifiers": "",
                "name": "has_edge_with_type_by_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ],
                    [
                        "edge_type",
                        "Option<EdgeTypeT>"
                    ]
                ],
                "return_type": "bool",
                "body": "self.graph.has_edge_with_type_by_node_ids(src, dst, edge_type)"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return boolean representing if given edge exists in graph.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " src: str,",
                    "     Node name to use as source of given edge.",
                    " dst: str,",
                    "     Node name to use as destination of given edge.",
                    " * `edge_type`: Union[None, str],",
                    "     Edge type name. (By deafult is None).",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Boolean representing if given edge exists in graph.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, src, dst, edge_type)\"]"
                ],
                "modifiers": "",
                "name": "has_edge_with_type_by_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "&str"
                    ],
                    [
                        "dst",
                        "&str"
                    ],
                    [
                        "edge_type",
                        "Option<String>"
                    ]
                ],
                "return_type": "bool",
                "body": "self.graph\n            .has_edge_with_type_by_node_names(&src, &dst, edge_type.as_ref())"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return boolean representing if given node exists in graph.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " node_name: str,",
                    "     Name of the node.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Boolean representing if given node exists in graph.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_name)\"]"
                ],
                "modifiers": "",
                "name": "has_node_by_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "bool",
                "body": "self.graph.has_node_by_node_name(node_name)"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return boolean representing if given node with type exists in graph.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " node_name: str,",
                    "     Name of the node.",
                    " * `node_type`: List[str] = None,",
                    "     Optional node type of the node.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Boolean representing if given node exists in graph.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_name, node_type)\"]"
                ],
                "modifiers": "",
                "name": "has_node_with_type_by_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ],
                    [
                        "node_type",
                        "Option<Vec<String>>"
                    ]
                ],
                "return_type": "bool",
                "body": "self.graph.has_node_with_type_by_node_name(node_name, node_type)"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return integer representing ID of the edge.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " src: int,",
                    "     Node ID to use as source of given edge.",
                    " dst: int,",
                    "     Node ID to use as destination of given edge.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Integer representing ID of the edge.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, src, dst)\"]"
                ],
                "modifiers": "",
                "name": "get_edge_id_by_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "PyResult<EdgeT>",
                "body": "pe!(self.graph.get_edge_id_by_node_ids(src, dst))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return integer representing ID of the edge with type.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " src: int,",
                    "     Node ID to use as source of given edge.",
                    " dst: int,",
                    "     Node ID to use as destination of given edge.",
                    " * `edge_type`: Union[None, int],",
                    "     Edge type ID. (By deafult is None).",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Integer representing ID of the edge.",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self, src, dst, edge_type)\"]"
                ],
                "modifiers": "",
                "name": "get_edge_id_with_type_by_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ],
                    [
                        "edge_type",
                        "Option<EdgeTypeT>"
                    ]
                ],
                "return_type": "PyResult<EdgeT>",
                "body": "pe!(self\n            .graph\n            .get_edge_id_with_type_by_node_ids(src, dst, edge_type))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return integer representing ID of the edge.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " src: str,",
                    "     Node name to use as source of given edge.",
                    " dst: str,",
                    "     Node name to use as destination of given edge.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Integer representing ID of the edge. It will return None when the edge does not exist."
                ],
                "attrs": [
                    "#[text_signature = \"($self, src, dst)\"]"
                ],
                "modifiers": "",
                "name": "get_edge_id_by_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "&str"
                    ],
                    [
                        "dst",
                        "&str"
                    ]
                ],
                "return_type": "PyResult<EdgeT>",
                "body": "pe!(self.graph.get_edge_id_by_node_names(src, dst))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return integer representing ID of the edge.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " src: str,",
                    "     Node name to use as source of given edge.",
                    " dst: str,",
                    "     Node name to use as destination of given edge.",
                    " * `edge_type`: Union[None, str],",
                    "     Edge type name. (By deafult is None).",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Integer representing ID of the edge. It will return None when the edge does not exist."
                ],
                "attrs": [
                    "#[text_signature = \"($self, src, dst, edge_type)\"]"
                ],
                "modifiers": "",
                "name": "get_edge_id_with_type_by_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "&str"
                    ],
                    [
                        "dst",
                        "&str"
                    ],
                    [
                        "edge_type",
                        "Option<String>"
                    ]
                ],
                "return_type": "PyResult<EdgeT>",
                "body": "pe!(self\n            .graph\n            .get_edge_id_with_type_by_node_names(src, dst, edge_type.as_ref()))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return mapping from instance not trap nodes to dense range of nodes.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Dict with mapping from not trap nodes to dense range of nodes."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "get_dense_node_mapping",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "HashMap<NodeT, NodeT>",
                "body": "self.graph.get_dense_node_mapping()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the number of source nodes.",
                    "",
                    " Returns",
                    " ----------------------------",
                    " Number of the source nodes."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "get_unique_source_nodes_number",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "NodeT",
                "body": "self.graph.get_unique_source_nodes_number()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of the non-unique source nodes.",
                    "",
                    " Parameters",
                    " --------------------------",
                    " directed: bool,",
                    "     whether to filter out the undirected edges.",
                    "",
                    " Returns",
                    " --------------------------",
                    " Numpy array with numeric sources Ids."
                ],
                "attrs": [
                    "#[text_signature = \"($self, directed)\"]"
                ],
                "modifiers": "",
                "name": "get_sources",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Py<PyArray1<NodeT>>",
                "body": "let gil = pyo3::Python::acquire_gil();\n        to_ndarray_1d!(gil, self.graph.get_sources(directed.unwrap_or(true)), NodeT)"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector on the (non unique) destination nodes of the graph.",
                    "",
                    " Parameters",
                    " --------------------------",
                    " directed: bool,",
                    "     whether to filter out the undirected edges.",
                    "",
                    " Returns",
                    " --------------------------",
                    " Numpy array with numeric destination Ids."
                ],
                "attrs": [
                    "#[text_signature = \"($self, directed)\"]"
                ],
                "modifiers": "",
                "name": "get_destinations",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Py<PyArray1<NodeT>>",
                "body": "let gil = pyo3::Python::acquire_gil();\n        to_ndarray_1d!(gil, self.graph.get_destinations(directed.unwrap_or(true)), NodeT)"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector on the edges of the graph.",
                    "",
                    " Parameters",
                    " --------------------------",
                    " directed: bool,",
                    "     whether to filter out the undirected edges.",
                    "",
                    " Returns",
                    " --------------------------",
                    " Numpy array with numeric source and destination Ids."
                ],
                "attrs": [
                    "#[text_signature = \"($self, directed)\"]"
                ],
                "modifiers": "pub",
                "name": "get_edges",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "Option<bool>"
                    ]
                ],
                "return_type": "PyResult<Py<PyArray2<NodeT>>>",
                "body": "let gil = pyo3::Python::acquire_gil();\n        Ok(to_nparray_2d!(\n            gil,\n            self.graph.get_edges(directed.unwrap_or(true)),\n            NodeT\n        ))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return list on the name of the edges of the graph.",
                    "",
                    " Parameters",
                    " --------------------------",
                    " directed: bool,",
                    "     whether to filter out the undirected edges.",
                    "",
                    " Returns",
                    " --------------------------",
                    " Numpy array with numeric source and destination string names."
                ],
                "attrs": [
                    "#[text_signature = \"($self, directed)\"]"
                ],
                "modifiers": "pub",
                "name": "get_edge_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Vec<(String, String)>",
                "body": "self.graph.get_edge_names(directed.unwrap_or(true))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of the non-unique source nodes names.",
                    "",
                    " Parameters",
                    " --------------------------",
                    " directed: bool,",
                    "     whether to filter out the undirected edges."
                ],
                "attrs": [
                    "#[text_signature = \"($self, directed)\"]"
                ],
                "modifiers": "pub",
                "name": "get_source_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "self.graph.get_source_names(directed.unwrap_or(true))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector on the (non unique) destination nodes of the graph.",
                    "",
                    " Parameters",
                    " --------------------------",
                    " directed: bool,",
                    "     whether to filter out the undirected edges."
                ],
                "attrs": [
                    "#[text_signature = \"($self, directed)\"]"
                ],
                "modifiers": "pub",
                "name": "get_destination_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "directed",
                        "Option<bool>"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "self.graph.get_destination_names(directed.unwrap_or(true))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector with the sorted nodes names."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Vec<String>",
                "body": "self.graph.get_node_names()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector with the sorted nodes Ids."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_nodes",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Py<PyArray1<NodeT>>",
                "body": "let gil = pyo3::Python::acquire_gil();\n        PyArray::from_vec(gil.python(), self.graph.get_nodes())\n            .cast::<NodeT>(false)\n            .unwrap()\n            .to_owned()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of node types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "PyResult<Vec<Option<Vec<NodeTypeT>>>>",
                "body": "pe!(self.graph.get_node_types())"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of edge types."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "PyResult<Vec<Option<EdgeTypeT>>>",
                "body": "pe!(self.graph.get_edge_types())"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of weights."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_weights",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "PyResult<Py<PyArray1<WeightT>>>",
                "body": "let gil = pyo3::Python::acquire_gil();\n        Ok(to_ndarray_1d!(gil, pe!(self.graph.get_weights())?, WeightT))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of node types_name."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_node_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Option<Vec<String>>",
                "body": "self.graph.get_node_type_names()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of edge types_name."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_edge_type_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "Option<Vec<String>>",
                "body": "self.graph.get_edge_type_names()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return dictionary of strings to Ids representing the ndoes mapping."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "get_nodes_mapping",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "HashMap<String, NodeT>",
                "body": "self.graph.get_nodes_mapping()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the id of the edge type of the edge.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " edge_id: int,",
                    "     Numeric ID of the edge.",
                    "",
                    " Returns",
                    " ---------------------",
                    " Id of the edge type of the edge."
                ],
                "attrs": [
                    "#[text_signature = \"($self, edge_id)\"]"
                ],
                "modifiers": "",
                "name": "get_edge_type_id_by_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "PyResult<Option<EdgeTypeT>>",
                "body": "pe!(self.graph.get_edge_type_id_by_edge_id(edge_id))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the id of the node type of the node.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " node_id: int,",
                    "     Numeric ID of the node.",
                    "",
                    " Returns",
                    " ---------------------",
                    " Id of the node type of the node."
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_id)\"]"
                ],
                "modifiers": "",
                "name": "get_node_type_id_by_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "PyResult<Option<Vec<NodeTypeT>>>",
                "body": "pe!(self.graph.get_node_type_id_by_node_id(node_id))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the string name of the node.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " node_id: int,",
                    "     Numeric ID of the node.",
                    "",
                    " Returns",
                    " ---------------------",
                    " String name of the node."
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_id)\"]"
                ],
                "modifiers": "",
                "name": "get_node_name_by_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "PyResult<String>",
                "body": "pe!(self.graph.get_node_name_by_node_id(node_id))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the node id curresponding to given string name.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " node_name: str,",
                    "     String name of the node.",
                    "",
                    " Returns",
                    " ---------------------",
                    " Node ID."
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_name)\"]"
                ],
                "modifiers": "",
                "name": "get_node_id_by_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "PyResult<NodeT>",
                "body": "pe!(self.graph.get_node_id_by_node_name(node_name))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return dictionary count of how many time an edge type appears.",
                    "",
                    " The dictionary looks like the following:",
                    "",
                    " {",
                    "    edge_type_id: count_of_edge_types",
                    " }",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "get_edge_type_counts",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "PyResult<HashMap<EdgeTypeT, usize>>",
                "body": "pe!(self.graph.get_edge_type_counts_hashmap())"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return dictionary count of how many time an node type appears.",
                    "",
                    " The dictionary looks like the following:",
                    "",
                    " {",
                    "    node_type_id: count_of_node_types",
                    " }",
                    ""
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "get_node_type_counts",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "PyResult<HashMap<EdgeTypeT, usize>>",
                "body": "pe!(self.graph.get_node_type_counts_hashmap())"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return node type ID for the given node name if available.",
                    "",
                    " Arguments",
                    " -------------------",
                    " node_name: str,",
                    "     Name of the node.",
                    "",
                    " Returns",
                    " -------------------",
                    " Vector of the node type IDs or None if unknown."
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_name)\"]"
                ],
                "modifiers": "pub",
                "name": "get_node_type_id_by_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "PyResult<Option<Vec<NodeTypeT>>>",
                "body": "pe!(self.graph.get_node_type_id_by_node_name(node_name))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return node type name for the given node name if available.",
                    "",
                    " Arguments",
                    " -------------------",
                    " node_name: str,",
                    "     Name of the node.",
                    "",
                    " Returns",
                    " -------------------",
                    " Vector of the node type names or None if unknown."
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_name)\"]"
                ],
                "modifiers": "pub",
                "name": "get_node_type_name_by_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "PyResult<Option<Vec<String>>>",
                "body": "pe!(self.graph.get_node_type_name_by_node_name(node_name))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the weight curresponding to the edge composed by the given edge ids.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " edge_id: int,",
                    "     ID of the edge.",
                    "",
                    " Returns",
                    " ---------------------",
                    " Weight of the edge.",
                    "",
                    " Raises",
                    " ---------------------",
                    " ValueError,",
                    "     If the current graph instance does not have weights.",
                    " ValueError,",
                    "     If the given edge_id does not exist."
                ],
                "attrs": [
                    "#[text_signature = \"($self, edge_id)\"]"
                ],
                "modifiers": "pub",
                "name": "get_weight_by_edge_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "edge_id",
                        "EdgeT"
                    ]
                ],
                "return_type": "PyResult<WeightT>",
                "body": "pe!(self.graph.get_weight_by_edge_id(edge_id))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the weight curresponding to the edge composed by the given node ids.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " src: int,",
                    "     id of the source node.",
                    " dst: int,",
                    "     id of the destination node.",
                    "",
                    " Returns",
                    " ---------------------",
                    " Weight of the edge.",
                    "",
                    " Raises",
                    " ---------------------",
                    " ValueError,",
                    "     If the current graph instance does not have weights.",
                    " ValueError,",
                    "     If one or more of the given node ids do not exist in the graph.",
                    " ValueError,",
                    "     If the edge composed of the given node ids does not exist."
                ],
                "attrs": [
                    "#[text_signature = \"($self, src, dst)\"]"
                ],
                "modifiers": "pub",
                "name": "get_weight_by_node_ids",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src",
                        "NodeT"
                    ],
                    [
                        "dst",
                        "NodeT"
                    ]
                ],
                "return_type": "PyResult<WeightT>",
                "body": "pe!(self.graph.get_weight_by_node_ids(src, dst))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return the weight curresponding to the edge composed by the given node names.",
                    "",
                    " Parameters",
                    " ---------------------",
                    " src_name: str,",
                    "     Name of the source node.",
                    " dst_name: str,",
                    "     Name of the destination node.",
                    "",
                    " Returns",
                    " ---------------------",
                    " Weight of the edge.",
                    "",
                    " Raises",
                    " ---------------------",
                    " ValueError,",
                    "     If the current graph instance does not have weights.",
                    " ValueError,",
                    "     If one or more of the given node names do not exist in the graph.",
                    " ValueError,",
                    "     If the edge composed of the given node names does not exist."
                ],
                "attrs": [
                    "#[text_signature = \"($self, src_name, dst_name)\"]"
                ],
                "modifiers": "pub",
                "name": "get_weight_by_node_names",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "src_name",
                        "&str"
                    ],
                    [
                        "dst_name",
                        "&str"
                    ]
                ],
                "return_type": "PyResult<WeightT>",
                "body": "pe!(self.graph.get_weight_by_node_names(src_name, dst_name))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of destination IDs for the given source node ID.",
                    "",
                    " Parameters",
                    " ----------------",
                    " node_id: int,",
                    "     Node ID whose neighbours are to be retrieved.",
                    "",
                    " Returns",
                    " ----------------",
                    " Vector of the node IDs of the neighbours of given node."
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_id)\"]"
                ],
                "modifiers": "pub",
                "name": "get_node_neighbours_by_node_id",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_id",
                        "NodeT"
                    ]
                ],
                "return_type": "PyResult<Vec<NodeT>>",
                "body": "pe!(self.graph.get_node_neighbours_by_node_id(node_id))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of destination IDs for the given source node name.",
                    "",
                    " Parameters",
                    " ----------------",
                    " node_name: str,",
                    "     Node name whose neighbours are to be retrieved.",
                    "",
                    " Returns",
                    " ----------------",
                    " Vector of the node IDs of the neighbours of given node."
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_name)\"]"
                ],
                "modifiers": "pub",
                "name": "get_node_neighbours_by_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "PyResult<Vec<NodeT>>",
                "body": "pe!(self.graph.get_node_neighbours_by_node_name(node_name))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return vector of destination names for the given source node name.",
                    "",
                    " Parameters",
                    " ----------------",
                    " node_name: str,",
                    "     Node name whose neighbours are to be retrieved.",
                    "",
                    " Returns",
                    " ----------------",
                    " Vector of the node names of the neighbours of given node."
                ],
                "attrs": [
                    "#[text_signature = \"($self, node_name)\"]"
                ],
                "modifiers": "pub",
                "name": "get_neighbour_node_names_by_node_name",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "node_name",
                        "&str"
                    ]
                ],
                "return_type": "PyResult<Vec<String>>",
                "body": "pe!(self.graph.get_neighbour_node_names_by_node_name(node_name))"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns a boolean representing if the graph contains an edge that has",
                    " source == destination."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "has_selfloops",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.graph.has_selfloops()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns true if the graph has weights."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "has_edge_weights",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.graph.has_edge_weights()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns true if the graph has node types."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "has_node_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.graph.has_node_types()"
            },
            {
                "file": "getters.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns true if the graph has edge types."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "",
                "name": "has_edge_types",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "bool",
                "body": "self.graph.has_edge_types()"
            }
        ]
    },
    "macros.rs": {
        "imports": [],
        "functions": [
            {
                "file": "macros.rs",
                "doc": [],
                "attrs": [
                    "#[macro_export]",
                    "#[macro_export]",
                    "#[macro_export]",
                    "#[macro_export]",
                    "#[macro_export]"
                ],
                "modifiers": "pub",
                "name": "build_walk_parameters_list",
                "generics": "'a",
                "args": [
                    [
                        "parameters",
                        "&[&'a str]"
                    ]
                ],
                "return_type": "Vec<&'a str>",
                "body": "let default = &[\n        \"return_weight\",\n        \"explore_weight\",\n        \"change_edge_type_weight\",\n        \"change_node_type_weight\",\n        \"max_neighbours\",\n        \"random_state\",\n        \"iterations\",\n        \"dense_node_mapping\",\n    ];\n    default.into_iter().chain(parameters.into_iter()).map(|x| *x).collect()"
            },
            {
                "file": "macros.rs",
                "doc": [
                    " Validate given kwargs."
                ],
                "attrs": [],
                "modifiers": "pub",
                "name": "validate_kwargs",
                "args": [
                    [
                        "kwargs",
                        "&PyDict"
                    ],
                    [
                        "columns",
                        "&[&str]"
                    ]
                ],
                "return_type": "Result<(), String>",
                "body": "let mut keys: HashSet<String> = kwargs\n        .keys()\n        .iter()\n        .map(|v| v.extract::<String>().unwrap())\n        .collect();\n    let columns: HashSet<String> = columns.into_iter().map(|x| x.to_string()).collect();\n    if keys.is_subset(&columns) {\n        return Ok(());\n    }\n\n    for k in &columns {\n        keys.remove(k);\n    }\n    let mut err_msg = String::new();\n    for k in &keys {\n        let (distance, column) = columns\n            .iter()\n            .map(|col| (edit_distance(k, col), col))\n            .min_by_key(|x| x.0)\n            .unwrap();\n\n        if distance <= 2 {\n            err_msg = format!(\n                    \"The passed argument {} is not valid.\\n Did you mean {} ?\\nThe available ones are: \\n{:?}\",\n                    k, column, columns\n                );\n            break;\n        }\n    }\n    if err_msg.is_empty() {\n        err_msg = format!(\n            \"The following arguments are not valid keyword arguments for this function. \\n{:?}\\n the available ones are: \\n{:?}\",\n            keys, columns\n        );\n    }\n    Err(err_msg)"
            }
        ]
    },
    "from_csv.rs": {
        "imports": [
            "use super::*;",
            "use graph::{Graph, NodeT};"
        ],
        "functions": [
            {
                "file": "from_csv.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return graph loaded from given edge file and optionally node file.",
                    "",
                    " Parameters",
                    " -------------------------------",
                    " edge_path: String,",
                    "     The path from where load the edge file.",
                    " directed: bool,",
                    "     whether to load the graph as directed or undirected.",
                    " directed_edge_list: bool = False,",
                    "     Wether to load the edge list as directed or undirected.",
                    "     The default behaviour is to treat he list as undirected and handle the",
                    "     undirected edges automatically if the parameter `directed=False`.",
                    " sources_column_number: int = 0,",
                    "     The column number of the sources of the edges.",
                    "     This value is overwritten by the source column value if one is provided.",
                    "     If the edge file you are loading does not have a header, remember",
                    "     to set the edge_header parameter to false.",
                    " sources_column: str = None,",
                    "     Name of the column to be loaded as source of the edges.",
                    " destinations_column_number: int = 1,",
                    "     The column number of the destinations of the edges.",
                    "     This value is overwritten by the destination column value if one is provided.",
                    "     If the edge file you are loading does not have a header, remember",
                    "     to set the edge_header parameter to false.",
                    " destinations_column: str = None,",
                    "     Name of the column to be loaded as destination of the edges.",
                    " edge_types_column_number: int = None,",
                    "     The column number of the edge type of the edges.",
                    "     This value is overwritten by the edge types column value if one is provided.",
                    "     If the edge file you are loading does not have a header, remember",
                    "     to set the edge_header parameter to false.",
                    " edge_types_column: str = None,",
                    "     Name of the column to be loaded as edge type of the edges.",
                    " default_edge_type: str = None,",
                    "     String representing the default edge type to use when the edge type",
                    "     in the provided column is empty.",
                    " weights_column_number: int = None,",
                    "     The column number of the weight of the edges.",
                    "     This value is overwritten by the weights column value if one is provided.",
                    "     If the edge file you are loading does not have a header, remember",
                    "     to set the edge_header parameter to false.",
                    " weights_column: str = None,",
                    "     Name of the column to be loaded as weight of the edges.",
                    " default_weight: float = None,",
                    "     String representing the default edge type to use when the edge type",
                    "     in the provided column is empty.",
                    " skip_selfloops: bool = False,",
                    "     whether to skip self loops while loading the edge file.",
                    " ignore_duplicated_edges: bool = True,",
                    "     whether to skip duplicated edges while loading the edge file.",
                    "     When NOT ignoring the duplicated edges, an exception with information",
                    "     on the duplicated edge will be raised.",
                    "     When ignoring the edge type while reading the file duplicated edges",
                    "     in a multi-graph will be marked as duplicates.",
                    " edge_header: bool = True,",
                    "     whether to expect the first line of the edge file to be a header.",
                    " edge_rows_to_skip: int = 0,",
                    "     If the edge file has some descriptive text in the first few lines,",
                    "     this is the parameter that allows you to skip it.",
                    " edge_max_rows_number: int = None,",
                    "     Number of rows to read.",
                    " edge_separator: str = \"\\t\",",
                    "     The expected separator for the edge file.",
                    " node_path: str = None,",
                    "     The path from where to load the node file.",
                    "     If one is not provided, no node types will be loaded and the graph",
                    "     might end-up with node IDs that are not aligned with other subgraphs",
                    "     from the same edge file.",
                    " nodes_column_number: int = None,",
                    "     The column number of the node Ids.",
                    "     This value is overwritten by the nodes column value if one is provided.",
                    "     If the node file you are loading does not have a header, remember",
                    "     to set the node_header parameter to false.",
                    " nodes_column: str = None,",
                    "     Name of the column to be loaded as node Ids.",
                    " node_types_column_number: int = None,",
                    "     The column number of the node type of the nodes.",
                    "     This value is overwritten by the node types column value if one is provided.",
                    "     If the node file you are loading does not have a header, remember",
                    "     to set the node_header parameter to false.",
                    " node_types_column: str = None,",
                    "     Name of the column to be loaded as node types.",
                    " default_node_type: str = None,",
                    "     String representing the default node type to use when the node type",
                    "     in the provided column is empty.",
                    " ignore_duplicated_nodes: bool = True,",
                    "     whether to skip duplicated nodes while loading the node file.",
                    "     When NOT ignoring the duplicated nodes, an exception with information",
                    "     on the duplicated node will be raised.",
                    " node_header: bool = True,",
                    "     whether to expect the first line of the node file to be a header.",
                    " node_rows_to_skip: int = 0,",
                    "     If the node file has some descriptive text in the first few lines,",
                    "     this is the parameter that allows you to skip it.",
                    " node_max_rows_number: int = None,",
                    "     Number of rows to read.",
                    " node_separator: str = \"\\t\",",
                    "     The expected separator for the node file.",
                    " node_types_separator: str = None,",
                    "     The separator to split the node types if a graph with",
                    "     multi-label node types is being loaded.",
                    " numeric_node_ids: bool = False,",
                    "     Wether to load the Node Ids as numeric.",
                    " numeric_edge_node_ids: bool = False,",
                    "     Wether to load the edge file Node Ids as numeric.",
                    " numeric_node_type_ids: bool = False,",
                    "     Wether to load the Node Type Ids as numeric.",
                    " numeric_edge_type_ids: bool = False,",
                    "     Wether to load the Edge Type Ids as numeric.",
                    " edge_file_comment_symbol: str = None,",
                    "     The symbol to use for the lines to be ignored in the edge file.",
                    " node_file_comment_symbol: str = None,",
                    "     The symbol to use for the lines to be ignored in the node file.",
                    " skip_weights_if_unavailable: bool = False,",
                    "     Wether to skip the loading of the weights even if requested but",
                    "     in the file the column is actually unavailable.",
                    " skip_edge_types_if_unavailable: bool = False,",
                    "     Wether to skip the loading of the edge types even if requested but",
                    "     in the file the column is actually unavailable.",
                    " skip_node_types_if_unavailable: bool = False,",
                    "     Wether to skip the loading of the node types even if requested but",
                    "     in the file the column is actually unavailable.",
                    " name: str = \"Graph\",",
                    "     The name of the graph to use.",
                    " verbose: bool = True,",
                    "     whether to load the files verbosely, showing a loading bar.",
                    "",
                    " Raises",
                    " ------------------------",
                    " ValueError,",
                    "     TODO: Update the list of raised exceptions.",
                    "",
                    " Returns",
                    " ------------------------",
                    " The loaded graph."
                ],
                "attrs": [
                    "#[staticmethod]",
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"(edge_path, directed, *, directed_edge_list, sources_column_number, sources_column, destinations_column_number, destinations_column, edge_types_column_number, edge_types_column, default_edge_type, weights_column_number, weights_column, default_weight, skip_selfloops, ignore_duplicated_edges, edge_header, edge_rows_to_skip, edge_max_rows_number, edge_separator, node_path, nodes_column_number, nodes_column, node_types_column_number, node_types_column, default_node_type, ignore_duplicated_nodes, node_header, node_rows_to_skip, node_max_rows_number, node_separator, node_types_separator, numeric_node_ids, numeric_edge_node_ids, numeric_node_type_ids, numeric_edge_type_ids, edge_file_comment_symbol, node_file_comment_symbol, skip_weights_if_unavailable, skip_edge_types_if_unavailable, skip_node_types_if_unavailable, name, verbose)\"]"
                ],
                "modifiers": "",
                "name": "from_unsorted_csv",
                "args": [
                    [
                        "edge_path",
                        "String"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<EnsmallenGraph>",
                "body": "let _ = ctrlc::set_handler(|| std::process::exit(2));\n        let (edges, nodes, name, directed_edge_list) =\n            pe!(build_csv_file_reader(edge_path, py_kwargs))?;\n\n        Ok(EnsmallenGraph {\n            graph: pe!(Graph::from_unsorted_csv(\n                edges,\n                nodes,\n                directed,\n                directed_edge_list,\n                name,\n            ))?,\n        })"
            },
            {
                "file": "from_csv.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Return graph loaded from given edge file and optionally node file.",
                    "",
                    " Parameters",
                    " -------------------------------",
                    " edge_path: String,",
                    "     The path from where load the edge file.",
                    " directed: bool,",
                    "     whether to load the graph as directed or undirected.",
                    " directed_edge_list: bool = False,",
                    "     Wether to load the edge list as directed or undirected.",
                    "     The default behaviour is to the list as undirected and handle the",
                    "     undirected edges automatically if the parameter `directed=False`.",
                    " sources_column_number: int = 0,",
                    "     The column number of the sources of the edges.",
                    "     This value is overwritten by the source column value if one is provided.",
                    "     If the edge file you are loading does not have a header, remember",
                    "     to set the edge_header parameter to false.",
                    " sources_column: str = None,",
                    "     Name of the column to be loaded as source of the edges.",
                    " destinations_column_number: int = 1,",
                    "     The column number of the destinations of the edges.",
                    "     This value is overwritten by the destination column value if one is provided.",
                    "     If the edge file you are loading does not have a header, remember",
                    "     to set the edge_header parameter to false.",
                    " destinations_column: str = None,",
                    "     Name of the column to be loaded as destination of the edges.",
                    " edge_types_column_number: int = None,",
                    "     The column number of the edge type of the edges.",
                    "     This value is overwritten by the edge types column value if one is provided.",
                    "     If the edge file you are loading does not have a header, remember",
                    "     to set the edge_header parameter to false.",
                    " edge_types_column: str = None,",
                    "     Name of the column to be loaded as edge type of the edges.",
                    " default_edge_type: str = None,",
                    "     String representing the default edge type to use when the edge type",
                    "     in the provided column is empty.",
                    " weights_column_number: int = None,",
                    "     The column number of the weight of the edges.",
                    "     This value is overwritten by the weights column value if one is provided.",
                    "     If the edge file you are loading does not have a header, remember",
                    "     to set the edge_header parameter to false.",
                    " weights_column: str = None,",
                    "     Name of the column to be loaded as weight of the edges.",
                    " default_weight: float = None,",
                    "     String representing the default edge type to use when the edge type",
                    "     in the provided column is empty.",
                    " skip_selfloops: bool = False,",
                    "     whether to skip self loops while loading the edge file.",
                    " ignore_duplicated_edges: bool = True,",
                    "     whether to skip duplicated edges while loading the edge file.",
                    "     When NOT ignoring the duplicated edges, an exception with information",
                    "     on the duplicated edge will be raised.",
                    "     When ignoring the edge type while reading the file duplicated edges",
                    "     in a multi-graph will be marked as duplicates.",
                    " edge_header: bool = True,",
                    "     whether to expect the first line of the edge file to be a header.",
                    " edge_rows_to_skip: int = 0,",
                    "     If the edge file has some descriptive text in the first few lines,",
                    "     this is the parameter that allows you to skip it.",
                    " edge_max_rows_number: int = None,",
                    "     Number of rows to read.",
                    " edge_separator: str = \"\\t\",",
                    "     The expected separator for the edge file.",
                    " node_path: str = None,",
                    "     The path from where to load the node file.",
                    "     If one is not provided, no node types will be loaded and the graph",
                    "     might end-up with node IDs that are not aligned with other subgraphs",
                    "     from the same edge file.",
                    " nodes_column_number: int = None,",
                    "     The column number of the node Ids.",
                    "     This value is overwritten by the nodes column value if one is provided.",
                    "     If the node file you are loading does not have a header, remember",
                    "     to set the node_header parameter to false.",
                    " nodes_column: str = None,",
                    "     Name of the column to be loaded as node Ids.",
                    " node_types_column_number: int = None,",
                    "     The column number of the node type of the nodes.",
                    "     This value is overwritten by the node types column value if one is provided.",
                    "     If the node file you are loading does not have a header, remember",
                    "     to set the node_header parameter to false.",
                    " node_types_column: str = None,",
                    "     Name of the column to be loaded as node types.",
                    " default_node_type: str = None,",
                    "     String representing the default node type to use when the node type",
                    "     in the provided column is empty.",
                    " ignore_duplicated_nodes: bool = True,",
                    "     whether to skip duplicated nodes while loading the node file.",
                    "     When NOT ignoring the duplicated nodes, an exception with information",
                    "     on the duplicated node will be raised.",
                    " node_header: bool = True,",
                    "     whether to expect the first line of the node file to be a header.",
                    " node_rows_to_skip: int = 0,",
                    "     If the node file has some descriptive text in the first few lines,",
                    "     this is the parameter that allows you to skip it.",
                    " node_max_rows_number: int = None,",
                    "     Number of rows to read.",
                    " node_separator: str = \"\\t\",",
                    "      The expected separator for the node file.",
                    " node_types_separator: str = None,",
                    "     The separator to split the node types if a graph with",
                    "     multi-label node types is being loaded.",
                    " numeric_node_ids: bool = False,",
                    "     Wether to load the Node Ids as numeric.",
                    " numeric_edge_node_ids: bool = False,",
                    "     Wether to load the edge file Node Ids as numeric.",
                    " numeric_node_type_ids: bool = False,",
                    "     Wether to load the Node Type Ids as numeric.",
                    " numeric_edge_type_ids: bool = False,",
                    "     Wether to load the Edge Type Ids as numeric.",
                    " edge_file_comment_symbol: str = None,",
                    "     The symbol to use for the lines to be ignored in the edge file.",
                    " node_file_comment_symbol: str = None,",
                    "     The symbol to use for the lines to be ignored in the node file.",
                    " skip_weights_if_unavailable: bool = False,",
                    "     Wether to skip the loading of the weights even if requested but",
                    "     in the file the column is actually unavailable.",
                    " skip_edge_types_if_unavailable: bool = False,",
                    "     Wether to skip the loading of the edge types even if requested but",
                    "     in the file the column is actually unavailable.",
                    " skip_node_types_if_unavailable: bool = False,",
                    "     Wether to skip the loading of the node types even if requested but",
                    "     in the file the column is actually unavailable.",
                    " name: str = \"Graph\",",
                    "     The name of the graph to use.",
                    " verbose: bool = True,",
                    "     whether to load the files verbosely, showing a loading bar.",
                    "",
                    " Raises",
                    " ------------------------",
                    " ValueError,",
                    "     TODO: Update the list of raised exceptions.",
                    "",
                    " Returns",
                    " ------------------------",
                    " The loaded graph."
                ],
                "attrs": [
                    "#[staticmethod]",
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"(edge_path, directed, *, directed_edge_list, sources_column_number, sources_column, destinations_column_number, destinations_column, edge_types_column_number, edge_types_column, default_edge_type, weights_column_number, weights_column, default_weight, skip_selfloops, ignore_duplicated_edges, edge_header, edge_rows_to_skip, edge_max_rows_number, edge_separator, node_path, nodes_column_number, nodes_column, node_types_column_number, node_types_column, default_node_type, ignore_duplicated_nodes, node_header, node_rows_to_skip, node_max_rows_number, node_separator, node_types_separator, numeric_node_ids, numeric_edge_node_ids, numeric_node_type_ids, numeric_edge_type_ids, edge_file_comment_symbol, node_file_comment_symbol, skip_weights_if_unavailable, skip_edge_types_if_unavailable, skip_node_types_if_unavailable, name, verbose, )\"]"
                ],
                "modifiers": "",
                "name": "from_sorted_csv",
                "args": [
                    [
                        "edge_path",
                        "String"
                    ],
                    [
                        "directed",
                        "bool"
                    ],
                    [
                        "nodes_number",
                        "NodeT"
                    ],
                    [
                        "edges_number",
                        "usize"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<EnsmallenGraph>",
                "body": "let _ = ctrlc::set_handler(|| std::process::exit(2));\n        let (edges, nodes, name, directed_edge_list) =\n            pe!(build_csv_file_reader(edge_path, py_kwargs))?;\n\n        Ok(EnsmallenGraph {\n            graph: pe!(Graph::from_sorted_csv(\n                edges,\n                nodes,\n                directed,\n                directed_edge_list,\n                edges_number,\n                nodes_number,\n                name\n            ))?,\n        })"
            }
        ]
    },
    "lib.rs": {
        "imports": [
            "use pyo3::prelude::*;",
            "use pyo3::types::PyDict;",
            "use pyo3::exceptions::PyValueError;",
            "use pyo3::exceptions::PyTypeError;",
            "use pyo3::{wrap_pymodule};"
        ],
        "functions": [
            {
                "file": "lib.rs",
                "doc": [],
                "attrs": [
                    "#[pymodule]"
                ],
                "modifiers": "",
                "name": "ensmallen_graph",
                "args": [
                    [
                        "_py",
                        "Python"
                    ],
                    [
                        "m",
                        "&PyModule"
                    ]
                ],
                "return_type": "PyResult<()>",
                "body": "m.add_class::<EnsmallenGraph>()?;\n    m.add_wrapped(wrap_pymodule!(preprocessing))?;\n    env_logger::init();\n    Ok(())"
            }
        ]
    },
    "hash.rs": {
        "imports": [
            "use super::*;"
        ],
        "functions": [
            {
                "file": "hash.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns a 64-bit hash of the graph."
                ],
                "attrs": [
                    "#[text_signature = \"($self)\"]"
                ],
                "modifiers": "pub",
                "name": "hash",
                "args": [
                    [
                        "self",
                        "&self"
                    ]
                ],
                "return_type": "u64",
                "body": "self.graph.compute_hash()"
            }
        ]
    },
    "holdout.rs": {
        "imports": [
            "use super::*;",
            "use graph::{EdgeT, NodeT};"
        ],
        "functions": [
            {
                "file": "holdout.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns training and validation holdouts extracted from current graph.",
                    "",
                    " The holdouts is generated in such a way that the training set remains",
                    " connected if the starting graph is connected by using a spanning tree.",
                    "",
                    " Parameters",
                    " -----------------------------",
                    " train_size: float,",
                    "     The rate of edges to reserve for the training.",
                    " random_state: int = 42,",
                    "     The random_state to use to generate the holdout.",
                    " edge_types: List[str] = None,",
                    "     List of names of the edge types to put into the validation.",
                    " include_all_edge_types: bool = False,",
                    "     whether to include all the edges between two nodes.",
                    "     This is only relevant in multi-graphs.",
                    " verbose: bool = True,",
                    "     whether to show the loading bar.",
                    "",
                    " Raises",
                    " -----------------------------",
                    " ValueError,",
                    "     If the given train rate is not a real number between 0 and 1.",
                    "",
                    " Returns",
                    " -----------------------------",
                    " Tuple containing training and validation graphs."
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, train_size, *, random_state, edge_types, include_all_edge_types, verbose)\"]"
                ],
                "modifiers": "",
                "name": "connected_holdout",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "train_size",
                        "f64"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<(EnsmallenGraph, EnsmallenGraph)>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n\n        pe!(validate_kwargs(\n            kwargs,\n            &[\n                \"random_state\",\n                \"edge_types\",\n                \"include_all_edge_types\",\n                \"verbose\"\n            ],\n        ))?;\n\n        let (g1, g2) = pe!(self.graph.connected_holdout(\n            extract_value!(kwargs, \"random_state\", EdgeT).unwrap_or(42),\n            train_size,\n            extract_value!(kwargs, \"edge_types\", Vec<Option<String>>),\n            extract_value!(kwargs, \"include_all_edge_types\", bool).unwrap_or(false),\n            extract_value!(kwargs, \"verbose\", bool).unwrap_or(true),\n        ))?;\n        Ok((EnsmallenGraph { graph: g1 }, EnsmallenGraph { graph: g2 }))"
            },
            {
                "file": "holdout.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns partial subgraph.",
                    "",
                    " This method creates a subset of the graph starting from a random node",
                    " sampled using given random_state and includes all neighbouring nodes until",
                    " the required number of nodes is reached. All the edges connecting any",
                    " of the selected nodes are then inserted into this graph.",
                    "",
                    " Parameters",
                    " -----------------------------",
                    " nodes_number: int,",
                    "     The number of edges to insert in the partial graph.",
                    " random_state: int = 42,",
                    "     The random_state to use to generate the partial graph.",
                    " verbose: bool = True,",
                    "     whether to show the loading bar.",
                    "",
                    " Raises",
                    " -----------------------------",
                    " TODO: Add the docstring for the raised exceptions.",
                    "",
                    " Returns",
                    " -----------------------------",
                    " Partial graph."
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, nodes_number, *, random_state, verbose)\"]"
                ],
                "modifiers": "",
                "name": "random_subgraph",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "nodes_number",
                        "NodeT"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<EnsmallenGraph>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n\n        pe!(validate_kwargs(\n            kwargs,\n            &[\"random_state\", \"verbose\"]\n        ))?;\n\n        Ok(EnsmallenGraph {\n            graph: pe!(self.graph.random_subgraph(\n                extract_value!(kwargs, \"random_state\", usize).unwrap_or(42),\n                nodes_number,\n                extract_value!(kwargs, \"verbose\", bool).unwrap_or(true),\n            ))?,\n        })"
            },
            {
                "file": "holdout.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns training and validation holdouts extracted from current graph.",
                    "",
                    " The holdouts edges are randomly sampled and have no garanties that any",
                    " particular graph structure is maintained.",
                    "",
                    " Parameters",
                    " -----------------------------",
                    " train_size: float,",
                    "     The rate to reserve for the training.",
                    " random_state: int = 42,",
                    "     The random_state to make the holdout reproducible.",
                    " include_all_edge_types: bool = False,",
                    "     whether to include all the edges between two nodes.",
                    "     This is only relevant in multi-graphs.",
                    " edge_types: List[String] = None,",
                    "     The edge types to be included in the validation.",
                    "     If None (default value) is passed, any edge type can be in the validation set.",
                    "     If a non None value is passed, the graph MUST be an heterogeneous graph",
                    "     with multiple edge types, otherwise an exception will be raised.",
                    " min_number_overlaps: int = None,",
                    "     The minimum number of overlapping edges for an edge to be put into the validation set.",
                    "     If the value passed is None (default value) any edge can be put into the validation set.",
                    "     If a non None value is passed, the graph MUST be a multi-graph, otherwise an exception will be raised.",
                    " verbose: bool = True,",
                    "     whether to show the loading bar.",
                    "",
                    " Raises",
                    " -----------------------------",
                    " ValueError,",
                    "     If the given train rate is invalid, for example less or equal to 0",
                    "     or greater than one.",
                    " ValueError,",
                    "     If edge types are required but graph is not heterogeneous.",
                    " ValueError,",
                    "     If given edge types do not exist.",
                    " ValueError,",
                    "     If min number overlaps is given but graph is not a multigraph.",
                    "",
                    " Returns",
                    " -----------------------------",
                    " Tuple containing training and validation graphs."
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, train_size, *, random_state, include_all_edge_types, edge_types, min_number_overlaps, verbose)\"]"
                ],
                "modifiers": "",
                "name": "random_holdout",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "train_size",
                        "f64"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<(EnsmallenGraph, EnsmallenGraph)>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n\n        pe!(validate_kwargs(\n            kwargs,\n            &[\n                \"random_state\",\n                \"include_all_edge_types\",\n                \"edge_types\",\n                \"min_number_overlaps\",\n                \"verbose\",\n            ],\n        ))?;\n\n        let (g1, g2) = pe!(self.graph.random_holdout(\n            extract_value!(kwargs, \"random_state\", EdgeT).unwrap_or(42),\n            train_size,\n            extract_value!(kwargs, \"include_all_edge_types\", bool).unwrap_or(false),\n            extract_value!(kwargs, \"edge_types\", Vec<Option<String>>),\n            extract_value!(kwargs, \"min_number_overlaps\", EdgeT),\n            extract_value!(kwargs, \"verbose\", bool).unwrap_or(true),\n        ))?;\n        Ok((EnsmallenGraph { graph: g1 }, EnsmallenGraph { graph: g2 }))"
            },
            {
                "file": "holdout.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns Graph with given amount of negative edges as positive edges.",
                    "",
                    " The graph generated may be used as a testing negatives partition to be",
                    " fed into the argument \"graph_to_avoid\" of the link_prediction or the",
                    " binary_skipgrams algorithm.",
                    "",
                    "",
                    " Parameters",
                    " -----------------------------",
                    " negatives_number: int,",
                    "     The number of negative edges to use.",
                    " random_state: int = 42,",
                    "     The random_state to use to generate the holdout.",
                    " seed_graph: EnsmallenGraph = None,",
                    "     The (optional) graph whose nodes are used as sources or destinations",
                    "     of the generated negative edges.",
                    " only_from_same_component: bool = True,",
                    "     Wether to sample negative edges only from the same node component.",
                    "     This avoids generating topologically impossible negative edges.",
                    " verbose: bool = True,",
                    "     whether to show the loading bar.",
                    "     The loading bar will only be visible in console.",
                    "",
                    " Raises",
                    " -----------------------------",
                    " TODO: Add the docstring for the raised exceptions.",
                    "",
                    " Returns",
                    " -----------------------------",
                    " Graph containing given amount of edges missing in the original graph."
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, negatives_number, *, random_state, seed_graph, only_from_same_component, verbose)\"]"
                ],
                "modifiers": "",
                "name": "sample_negatives",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "negatives_number",
                        "EdgeT"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<EnsmallenGraph>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n\n        pe!(validate_kwargs(\n            kwargs,\n            &[\n                \"random_state\",\n                \"verbose\",\n                \"seed_graph\",\n                \"only_from_same_component\"\n            ],\n        ))?;\n\n        let seed_graph = extract_value!(kwargs, \"seed_graph\", EnsmallenGraph);\n\n        Ok(EnsmallenGraph {\n            graph: pe!(self.graph.sample_negatives(\n                extract_value!(kwargs, \"random_state\", EdgeT).unwrap_or(42),\n                negatives_number,\n                match &seed_graph {\n                    Some(sg) => Some(&sg.graph),\n                    None => None,\n                },\n                extract_value!(kwargs, \"only_from_same_component\", bool).unwrap_or(true),\n                extract_value!(kwargs, \"verbose\", bool).unwrap_or(true),\n            ))?,\n        })"
            },
            {
                "file": "holdout.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns train and test graph following kfold validation scheme.",
                    "",
                    " The edges are splitted into k chunks. The k_index-th chunk is used to build",
                    " the validation graph, all the other edges create the training graph.",
                    "",
                    " Parameters",
                    " -----------------------------",
                    " k: int,",
                    "     The number of folds.",
                    " k_index: int,",
                    "     Which fold to use for the validation.",
                    " edge_types: List[str] = None,",
                    "     Edge types to be selected when computing the folds",
                    "        (All the edge types not listed here will be always be used in the training set).",
                    " random_state: int = 42,",
                    "     The random_state (seed) to use for the holdout,",
                    " verbose: bool = True,",
                    "     whether to show the loading bar.",
                    "",
                    " Raises",
                    " -----------------------------",
                    " TODO: Add the docstring for the raised exceptions.",
                    "",
                    " Returns",
                    " -----------------------------",
                    " train, test graph."
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, k, k_index, *, edge_types, random_state, verbose)\"]"
                ],
                "modifiers": "",
                "name": "kfold",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "k",
                        "EdgeT"
                    ],
                    [
                        "k_index",
                        "u64"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<(EnsmallenGraph, EnsmallenGraph)>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n\n        pe!(validate_kwargs(\n            kwargs,\n            &[\"edge_types\", \"random_state\", \"verbose\"]\n        ))?;\n\n        let (train, test) = pe!(self.graph.kfold(\n            k,\n            k_index,\n            extract_value!(kwargs, \"edge_types\", Vec<Option<String>>),\n            extract_value!(kwargs, \"random_state\", u64).unwrap_or(42),\n            extract_value!(kwargs, \"verbose\", bool).unwrap_or(true),\n        ))?;\n\n        Ok((\n            EnsmallenGraph { graph: train },\n            EnsmallenGraph { graph: test },\n        ))"
            },
            {
                "file": "holdout.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns train and test graphs for node-label prediction tasks.",
                    "",
                    " The split is done using Monte Carlo split or, if stratification is",
                    " enabled, Stratified Monte Carlo.",
                    "",
                    " Parameters",
                    " -----------------------------",
                    " train_size: float,",
                    "     Rate target to reserve for training,",
                    " random_state: int = 42,",
                    "     The random_state to use for the holdout,",
                    " use_stratification: bool = True,",
                    "     Whether to use node-label stratification,",
                    "",
                    " Raises",
                    " -----------------------------",
                    " ValueError,",
                    "     If the graph does not have node types.",
                    " ValueError,",
                    "     If the stratification is required but the graph has multi-label node types.",
                    " ValueError,",
                    "     If the stratification is required but the graph has some node types with insufficient cardinality.",
                    "",
                    " Returns",
                    " -----------------------------",
                    " Train and test graph."
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, train_size, random_state, use_stratification)\"]"
                ],
                "modifiers": "",
                "name": "node_label_holdout",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "train_size",
                        "f64"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<(EnsmallenGraph, EnsmallenGraph)>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n\n        pe!(validate_kwargs(\n            kwargs,\n            &[\"random_state\", \"use_stratification\"]\n        ))?;\n\n        let (train, test) = pe!(self.graph.node_label_holdout(\n            train_size,\n            extract_value!(kwargs, \"use_stratification\", bool).unwrap_or(true),\n            extract_value!(kwargs, \"random_state\", u64).unwrap_or(42),\n        ))?;\n\n        Ok((\n            EnsmallenGraph { graph: train },\n            EnsmallenGraph { graph: test },\n        ))"
            },
            {
                "file": "holdout.rs",
                "struct": "EnsmallenGraph",
                "doc": [
                    " Returns train and test graphs for edge-label prediction tasks.",
                    "",
                    " The split is done using Monte Carlo split or, if stratification is",
                    " enabled, Stratified Monte Carlo.",
                    "",
                    " Parameters",
                    " -----------------------------",
                    " train_size: float,",
                    "     Rate target to reserve for training,",
                    " random_state: int = 42,",
                    "     The random_state to use for the holdout,",
                    " use_stratification: bool = True,",
                    "     Whether to use edge-label stratification,",
                    "",
                    " Raises",
                    " -----------------------------",
                    " ValueError,",
                    "     If the graph does not have edge types.",
                    " ValueError,",
                    "     If the stratification is required but the graph has some edge types with insufficient cardinality.",
                    "",
                    " Returns",
                    " -----------------------------",
                    " Train and test graph."
                ],
                "attrs": [
                    "#[args(py_kwargs = \"**\")]",
                    "#[text_signature = \"($self, train_size, random_state, use_stratification)\"]"
                ],
                "modifiers": "",
                "name": "edge_label_holdout",
                "args": [
                    [
                        "self",
                        "&self"
                    ],
                    [
                        "train_size",
                        "f64"
                    ],
                    [
                        "py_kwargs",
                        "Option<&PyDict>"
                    ]
                ],
                "return_type": "PyResult<(EnsmallenGraph, EnsmallenGraph)>",
                "body": "let py = pyo3::Python::acquire_gil();\n        let kwargs = normalize_kwargs!(py_kwargs, py.python());\n\n        pe!(validate_kwargs(\n            kwargs,\n            &[\"random_state\", \"use_stratification\"]\n        ))?;\n\n        let (train, test) = pe!(self.graph.edge_label_holdout(\n            train_size,\n            extract_value!(kwargs, \"use_stratification\", bool).unwrap_or(true),\n            extract_value!(kwargs, \"random_state\", u64).unwrap_or(42),\n        ))?;\n\n        Ok((\n            EnsmallenGraph { graph: train },\n            EnsmallenGraph { graph: test },\n        ))"
            }
        ]
    }
}