{
    "get_node_edges_and_destinations": {
        "file": "queries_walk.rs",
        "function": "get_node_edges_and_destinations",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_destinations_slice": {
        "file": "queries_walk.rs",
        "function": "get_destinations_slice",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "build_operator_graph_name": {
        "file": "operators.rs",
        "function": "build_operator_graph_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "generic_string_operator": {
        "file": "operators.rs",
        "function": "generic_string_operator",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "main",
                    "type": "&Graph",
                    "desc": "The current graph instance"
                },
                {
                    "name": "other",
                    "type": "&Graph",
                    "desc": "The other graph"
                },
                {
                    "name": "operator",
                    "type": "String",
                    "desc": "The operator used"
                },
                {
                    "name": "graphs",
                    "type": "Vec<(&Graph, Option<&Graph>, Option<&Graph>)>",
                    "desc": "Graph list for the operation"
                },
                {
                    "name": "might_contain_singletons",
                    "type": "bool",
                    "desc": "Whether we expect the graph to have singletons"
                },
                {
                    "name": "might_contain_singletons_with_selfloops",
                    "type": "bool",
                    "desc": "Whether we expect the graph to have singletons with self-loops"
                },
                {
                    "name": "might_contain_trap_nodes",
                    "type": "bool",
                    "desc": "Whether we expect the graph to have trap nodes"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "generic_integer_operator": {
        "file": "operators.rs",
        "function": "generic_integer_operator",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "main",
                    "type": "&Graph",
                    "desc": "The current graph instance"
                },
                {
                    "name": "other",
                    "type": "&Graph",
                    "desc": "The other graph"
                },
                {
                    "name": "operator",
                    "type": "String",
                    "desc": "The operator used"
                },
                {
                    "name": "graphs",
                    "type": "Vec<(&Graph, Option<&Graph>, Option<&Graph>)>",
                    "desc": "Graph list for the operation"
                },
                {
                    "name": "might_contain_singletons",
                    "type": "bool",
                    "desc": "Whether we expect the graph to have singletons"
                },
                {
                    "name": "might_contain_singletons_with_selfloops",
                    "type": "bool",
                    "desc": "Whether we expect the graph to have singletons with self-loops"
                },
                {
                    "name": "might_contain_trap_nodes",
                    "type": "bool",
                    "desc": "Whether we expect the graph to have trap nodes"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "validate_operator_terms": {
        "file": "operators.rs",
        "function": "validate_operator_terms",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument type '&Graph' of 'other' does not match the function declaration which is '&'b Graph'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'other'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "is_compatible": {
        "file": "operators.rs",
        "function": "is_compatible",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "other",
                    "type": "&Graph",
                    "desc": "The other graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "generic_operator": {
        "file": "operators.rs",
        "function": "generic_operator",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "other",
                    "type": "&Graph",
                    "desc": "The other graph"
                },
                {
                    "name": "operator",
                    "type": "String",
                    "desc": "The operator used"
                },
                {
                    "name": "graphs",
                    "type": "Vec<(&Graph, Option<&Graph>, Option<&Graph>)>",
                    "desc": "Graph list for the operation"
                },
                {
                    "name": "might_contain_singletons",
                    "type": "bool",
                    "desc": "Whether we expect the graph to have singletons"
                },
                {
                    "name": "might_contain_singletons_with_selfloops",
                    "type": "bool",
                    "desc": "Whether we expect the graph to have singletons with self-loops"
                },
                {
                    "name": "might_contain_trap_nodes",
                    "type": "bool",
                    "desc": "Whether we expect the graph to have trap nodes"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "bitor": {
        "file": "operators.rs",
        "function": "bitor",
        "errors": [
            {
                "doc_line": 6,
                "msg": "The argument type '&Graph' of 'other' does not match the function declaration which is '&'b Graph'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'other'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "bitxor": {
        "file": "operators.rs",
        "function": "bitxor",
        "errors": [
            {
                "doc_line": 6,
                "msg": "The argument type '&Graph' of 'other' does not match the function declaration which is '&'b Graph'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'other'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "sub": {
        "file": "operators.rs",
        "function": "sub",
        "errors": [
            {
                "doc_line": 6,
                "msg": "The argument type '&Graph' of 'other' does not match the function declaration which is '&'b Graph'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'other'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "bitand": {
        "file": "operators.rs",
        "function": "bitand",
        "errors": [
            {
                "doc_line": 6,
                "msg": "The argument type '&Graph' of 'other' does not match the function declaration which is '&'b Graph'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'other'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "default": {
        "file": "edge_type_vocabulary.rs",
        "function": "default",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "validate_weight": {
        "file": "utils.rs",
        "function": "validate_weight",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "weight",
                    "type": "WeightT",
                    "desc": "The weight to validate"
                }
            ]
        },
        "example": {
            "desc": "The weight can be validated as follows:\n",
            "content": "```rust# use graph::utils::validate_weight;\nassert!(validate_weight(0.0).is_err());\nassert!(validate_weight(-1.0).is_err());\nassert!(validate_weight(2.0).is_ok());\nassert_eq!(validate_weight(2.0).unwrap(), 2.0);\n"
        },
        "extra_headers": []
    },
    "is_first_order_walk": {
        "file": "walks_parameters.rs",
        "function": "is_first_order_walk",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "The default parametrization defines a first order walk:\n",
            "content": "```rust# use graph::walks_parameters::WalksParameters;\nassert!(WalksParameters::new(32).unwrap().is_first_order_walk());\n"
        },
        "extra_headers": []
    },
    "new": {
        "file": "node_file_reader.rs",
        "function": "new",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* reader: CSVFileParameters - Path where to store/load the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'path'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_iterations": {
        "file": "walks_parameters.rs",
        "function": "set_iterations",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "iterations",
                    "type": "Option<NodeT>",
                    "desc": "Whether to show the loading bar or not"
                }
            ]
        },
        "example": {
            "desc": "You can change the `iterations` parameter as follows:\n",
            "content": "```rust# use graph::walks_parameters::WalksParameters;\nassert!(WalksParameters::new(32).unwrap().set_iterations(Some(0)).is_err());\nassert!(WalksParameters::new(32).unwrap().set_iterations(Some(2)).is_ok());\n",
            "footer": "You can also call the method with an option None, in order to avoid a match\nwrapper above. This will end up don't doing anything, just a passthrough.\n```rust\n"
        },
        "extra_headers": [
            {
                "name": "use graph::walks_parameters::WalksParameters;",
                "content": "assert!(WalksParameters::new(32).unwrap().set_iterations(None).is_ok());\n```\n"
            }
        ]
    },
    "get_iterations": {
        "file": "walks_parameters.rs",
        "function": "get_iterations",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To retrieve the number of iterations you can do the following:\n",
            "content": "```rust# use graph::walks_parameters::WalksParameters;\nlet mut walk_parameters = WalksParameters::new(32).unwrap();\nassert_eq!(walk_parameters.get_iterations(), 1);\nlet iterations_number = 56;\nwalk_parameters = walk_parameters.set_iterations(Some(iterations_number)).unwrap();\nassert_eq!(walk_parameters.get_iterations(), iterations_number);\n"
        },
        "extra_headers": []
    },
    "set_max_neighbours": {
        "file": "walks_parameters.rs",
        "function": "set_max_neighbours",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "max_neighbours",
                    "type": "Option<NodeT>",
                    "desc": "Number of neighbours to consider for each extraction"
                }
            ]
        },
        "example": {
            "desc": "You can change the `max_neighbours` parameter as follows:\n",
            "content": "```rust# use graph::walks_parameters::WalksParameters;\nassert!(WalksParameters::new(32).unwrap().set_max_neighbours(Some(0)).is_err());\nassert!(WalksParameters::new(32).unwrap().set_max_neighbours(Some(2)).is_ok());\n",
            "footer": "You can also call the method with an option None, in order to avoid a match\nwrapper above. This will end up don't doing anything, just a passthrough.\n```rust\n"
        },
        "extra_headers": [
            {
                "name": "use graph::walks_parameters::WalksParameters;",
                "content": "assert!(WalksParameters::new(32).unwrap().set_max_neighbours(None).is_ok());\n```\n"
            }
        ]
    },
    "set_random_state": {
        "file": "walks_parameters.rs",
        "function": "set_random_state",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "random_state",
                    "type": "Option<usize>",
                    "desc": "random_state for reproducible random walks"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "set_dense_node_mapping": {
        "file": "walks_parameters.rs",
        "function": "set_dense_node_mapping",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "dense_node_mapping",
                    "type": "Option<HashMap<NodeT, NodeT>>",
                    "desc": "mapping for the mapping the nodes of the walks"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "set_return_weight": {
        "file": "walks_parameters.rs",
        "function": "set_return_weight",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "return_weight",
                    "type": "Option<WeightT>",
                    "desc": "weight for the exploitation factor"
                }
            ]
        },
        "example": {
            "desc": "You can change the `return_weight` parameter as follows:\n",
            "content": "```rust# use graph::walks_parameters::WalksParameters;\nassert!(WalksParameters::new(32).unwrap().set_return_weight(Some(-1.0)).is_err());\nassert!(WalksParameters::new(32).unwrap().set_return_weight(Some(2.0)).is_ok());\nassert!(WalksParameters::new(32).unwrap().set_return_weight(Some(1.0)).is_ok());\nassert!(WalksParameters::new(32).unwrap().set_return_weight(Some(1.0)).unwrap().is_first_order_walk());\n",
            "footer": "You can also call the method with an option None, in order to avoid a match\nwrapper above. This will end up don't doing anything, just a passthrough.\n```rust\n"
        },
        "extra_headers": [
            {
                "name": "use graph::walks_parameters::WalksParameters;",
                "content": "assert!(WalksParameters::new(32).unwrap().set_return_weight(None).unwrap().is_first_order_walk());\n```\n"
            }
        ]
    },
    "set_explore_weight": {
        "file": "walks_parameters.rs",
        "function": "set_explore_weight",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "explore_weight",
                    "type": "Option<WeightT>",
                    "desc": "weight for the exploration factor"
                }
            ]
        },
        "example": {
            "desc": "You can change the `explore_weight` parameter as follows:\n",
            "content": "```rust# use graph::walks_parameters::WalksParameters;\nassert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(-1.0)).is_err());\nassert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(2.0)).is_ok());\nassert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(1.0)).is_ok());\nassert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(1.0)).unwrap().is_first_order_walk());\n",
            "footer": "You can also call the method with an option None, in order to avoid a match\nwrapper above. This will end up don't doing anything, just a passthrough.\n```rust\n"
        },
        "extra_headers": [
            {
                "name": "use graph::walks_parameters::WalksParameters;",
                "content": "assert!(WalksParameters::new(32).unwrap().set_explore_weight(None).unwrap().is_first_order_walk());\n```\n"
            }
        ]
    },
    "set_change_node_type_weight": {
        "file": "walks_parameters.rs",
        "function": "set_change_node_type_weight",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "change_node_type_weight",
                    "type": "Option<WeightT>",
                    "desc": "weight for the exploration of different node types"
                }
            ]
        },
        "example": {
            "desc": "You can change the `change_node_type_weight` parameter as follows:\n",
            "content": "```rust# use graph::walks_parameters::WalksParameters;\nassert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(-1.0)).is_err());\nassert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(2.0)).is_ok());\nassert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(1.0)).is_ok());\nassert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(1.0)).unwrap().is_first_order_walk());\n",
            "footer": "You can also call the method with an option None, in order to avoid a match\nwrapper above. This will end up don't doing anything, just a passthrough.\n```rust\n"
        },
        "extra_headers": [
            {
                "name": "use graph::walks_parameters::WalksParameters;",
                "content": "assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(None).unwrap().is_first_order_walk());\n```\n"
            }
        ]
    },
    "set_change_edge_type_weight": {
        "file": "walks_parameters.rs",
        "function": "set_change_edge_type_weight",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "change_edge_type_weight",
                    "type": "Option<WeightT>",
                    "desc": "weight for the exploration of different node types"
                }
            ]
        },
        "example": {
            "desc": "You can change the `change_edge_type_weight` parameter as follows:\n",
            "content": "```rust# use graph::walks_parameters::WalksParameters;\nassert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(-1.0)).is_err());\nassert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(2.0)).is_ok());\nassert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(1.0)).is_ok());\nassert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(1.0)).unwrap().is_first_order_walk());\n",
            "footer": "You can also call the method with an option None, in order to avoid a match\nwrapper above. This will end up don't doing anything, just a passthrough.\n```rust\n"
        },
        "extra_headers": [
            {
                "name": "use graph::walks_parameters::WalksParameters;",
                "content": "assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(None).unwrap().is_first_order_walk());\n```\n"
            }
        ]
    },
    "validate": {
        "file": "walks_parameters.rs",
        "function": "validate",
        "errors": [
            {
                "doc_line": 6,
                "msg": "The argument type 'Graph' of 'graph' does not match the function declaration which is '&Graph'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'graph'."
            }
        ],
        "args": {
            "args": []
        },
        "example": {
            "desc": "A graph is always remappable to itself:\n",
            "content": "```rust# use graph::walks_parameters::WalksParameters;\n# let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);\n# let mut parameters = WalksParameters::new(32).unwrap();\nassert!(parameters.set_dense_node_mapping(Some(ppi.get_dense_nodes_mapping())).validate(&ppi).is_ok());\n",
            "footer": "Two different graphs, like Cora and STRING, are not remappable:\n```rust\n"
        },
        "extra_headers": [
            {
                "name": "use graph::walks_parameters::WalksParameters;",
                "content": ""
            },
            {
                "name": "let cora = graph::test_utilities::load_cora().unwrap();",
                "content": ""
            },
            {
                "name": "let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                "content": ""
            },
            {
                "name": "let mut parameters = WalksParameters::new(32).unwrap();",
                "content": "assert!(parameters.set_dense_node_mapping(Some(ppi.get_dense_nodes_mapping())).validate(&cora).is_err());\n```\n"
            }
        ]
    },
    "get_thread_pool": {
        "file": "trees.rs",
        "function": "get_thread_pool",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_edges_from_random_state": {
        "file": "trees.rs",
        "function": "iter_edges_from_random_state",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "random_state",
                    "type": "u64",
                    "desc": "The random state to reproduce the given edge sampling"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_on_edges_with_preference_from_random_state": {
        "file": "trees.rs",
        "function": "iter_on_edges_with_preference_from_random_state",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "random_state",
                    "type": "u64",
                    "desc": "The random state to reproduce the given edge sampling"
                },
                {
                    "name": "undesired_edge_types",
                    "type": "&'a Option<HashSet<Option<EdgeTypeT>>>",
                    "desc": "The edge types whose edges are to leave as last"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "kruskal": {
        "file": "trees.rs",
        "function": "kruskal",
        "errors": [
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'edges'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [],
            "desc": "`edges`: impl Iterator<Item = (NodeT, NodeT)> + 'a - Iterator for the edges to explore. If sorted, computed a minimum spanning tree.\n# Returns\nTuple with:\n- Set of the edges\n- Vector of the nodes components\n- Total components number\n- Minimum component size\n- Maximum component size\n"
        },
        "example": {},
        "extra_headers": []
    },
    "random_spanning_arborescence_kruskal": {
        "file": "trees.rs",
        "function": "random_spanning_arborescence_kruskal",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "random_state",
                    "type": "EdgeT",
                    "desc": "The random_state to use for the holdout"
                },
                {
                    "name": "undesired_edge_types",
                    "type": "&Option<HashSet<Option<EdgeTypeT>>>",
                    "desc": "Which edge types id to try to avoid"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar or not"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "spanning_arborescence_kruskal": {
        "file": "trees.rs",
        "function": "spanning_arborescence_kruskal",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar or not"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "spanning_arborescence": {
        "file": "trees.rs",
        "function": "spanning_arborescence",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar or not"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "connected_components": {
        "file": "trees.rs",
        "function": "connected_components",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar or not"
                }
            ]
        },
        "example": {
            "content": "```rust# #![feature(impl_trait_in_bindings)]\n# use graph::Graph;\n// Graph is a weightless graph with the edges\n// [(0, 1), (1, 4), (2, 3)]\n# let edge: Vec<Result<(String, String, Option<String>, Option<f32>), String>> = vec![\n#        Ok((\"0\".to_string(), \"1\".to_string(), None, None)),\n#        Ok((\"1\".to_string(), \"4\".to_string(), None, None)),\n#        Ok((\"2\".to_string(), \"3\".to_string(), None, None)),\n#     ];\n#\n# let nodes = None.map(|x: Vec<Result<(String, Option<Vec<String>>), String>>| x.into_iter());\n#\n# let graph = Graph::from_string_unsorted(\n#     edge.into_iter(),\n#     nodes,      // nodes\n#     false,     // directed\n#     false,      // directe edge list\n#     \"test graph\",// name\n#     false,     // ignore_duplicated_nodes\n#     true,     // node_list_is_correct\n#     false,     // ignore_duplicated_nodes\n#     true,     // node_list_is_correct\n#     false,     // numeric_edge_types_ids\n#     false,     // numeric_node_ids\n#     false,     // numeric_edge_node_ids\n#     false,     // numeric_node_types_ids\n#     false,     // has_node_types\n#     false,     // has_edge_types\n#     false,     // has_edge_weights\n#     true,    // maybe_has_singleton\n#     true,    // maybe_has_singleton_with_selfloops\n#     true,    // maybe_has_node_traps\n#     false,     // verbose\n# ).unwrap();\nlet (components, number_of_components, smallest, biggest) =\ngraph.connected_components(false).unwrap();\n//   nodes names:       0  1  4  2  3\nassert_eq!(components, [0, 0, 0, 1, 1].to_vec());\nassert_eq!(number_of_components, 2);\nassert_eq!(smallest, 2); // the size of the smallest component\nassert_eq!(biggest, 3);  // the size of the biggest component\n"
        },
        "extra_headers": []
    },
    "write_lines": {
        "file": "csv_file_writer.rs",
        "function": "write_lines",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument type 'u64' of 'lines_number' does not match the function declaration which is 'usize'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'lines_number'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "header",
                    "type": "Vec<String>",
                    "desc": "The header to write out, if so required"
                },
                {
                    "name": "values",
                    "type": "impl Iterator<Item = Vec<String>>",
                    "desc": "Iterator of rows to write out"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "compose_lines": {
        "file": "csv_file_writer.rs",
        "function": "compose_lines",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The argument type 'Vec<(String, usize)>' of 'pairs' does not match the function declaration which is 'Vec<(String'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'pairs'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "number_of_columns",
                    "type": "usize",
                    "desc": "Total number of columns to renderize"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "overlaps": {
        "file": "graph.rs",
        "function": "overlaps",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "other",
                    "type": "&Graph",
                    "desc": "The graph to check against"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "contains": {
        "file": "graph.rs",
        "function": "contains",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "other",
                    "type": "&Graph",
                    "desc": "The graph to check against"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "fast_u32_modulo": {
        "file": "preprocessing.rs",
        "function": "fast_u32_modulo",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "word2vec": {
        "file": "preprocessing.rs",
        "function": "word2vec",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "sequences",
                    "type": "impl ParallelIterator<Item = Vec<NodeT>> + 'a",
                    "desc": "the sequence of sequences of integers to preprocess"
                },
                {
                    "name": "window_size",
                    "type": "usize",
                    "desc": "Window size to consider for the sequences"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "cooccurence_matrix": {
        "file": "preprocessing.rs",
        "function": "cooccurence_matrix",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "walks_parameters",
                    "type": "&'a WalksParameters",
                    "desc": "the walks parameters"
                },
                {
                    "name": "window_size",
                    "type": "usize",
                    "desc": "Window size to consider for the sequences"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show the progress bars. The default behaviour is false"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "node2vec": {
        "file": "preprocessing.rs",
        "function": "node2vec",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "walk_parameters",
                    "type": "&'a WalksParameters",
                    "desc": "the weighted walks parameters"
                },
                {
                    "name": "quantity",
                    "type": "NodeT",
                    "desc": "Number of nodes to consider"
                },
                {
                    "name": "window_size",
                    "type": "usize",
                    "desc": "Window size to consider for the sequences"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_neighbours_from_node_id": {
        "file": "preprocessing.rs",
        "function": "get_neighbours_from_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "central_node_id",
                    "type": "NodeT",
                    "desc": "The node ID to retrieve neighbours for"
                },
                {
                    "name": "random_state",
                    "type": "u64",
                    "desc": "The random state to use to extract the neighbours"
                },
                {
                    "name": "include_central_node",
                    "type": "bool",
                    "desc": "Whether to include the node ID in the returned iterator"
                },
                {
                    "name": "offset",
                    "type": "NodeT",
                    "desc": "Offset for padding porposes"
                },
                {
                    "name": "max_neighbours",
                    "type": "Option<NodeT>",
                    "desc": "Number of maximum neighbours to consider"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_label_prediction_tuple_from_node_id": {
        "file": "preprocessing.rs",
        "function": "get_node_label_prediction_tuple_from_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "The node ID to retrieve neighbours for"
                },
                {
                    "name": "random_state",
                    "type": "u64",
                    "desc": "The random state to use to extract the neighbours"
                },
                {
                    "name": "include_central_node",
                    "type": "bool",
                    "desc": "Whether to include the node ID in the returned iterator"
                },
                {
                    "name": "offset",
                    "type": "NodeT",
                    "desc": "Offset for padding porposes"
                },
                {
                    "name": "max_neighbours",
                    "type": "Option<NodeT>",
                    "desc": "Number of maximum neighbours to consider"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_label_prediction_tuple_from_node_ids": {
        "file": "preprocessing.rs",
        "function": "get_node_label_prediction_tuple_from_node_ids",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "node_ids",
                    "type": "Vec<NodeT>",
                    "desc": "The node ID to retrieve neighbours for"
                },
                {
                    "name": "random_state",
                    "type": "u64",
                    "desc": "The random state to use to extract the neighbours"
                },
                {
                    "name": "include_central_node",
                    "type": "bool",
                    "desc": "Whether to include the node ID in the returned iterator"
                },
                {
                    "name": "offset",
                    "type": "NodeT",
                    "desc": "Offset for padding porposes"
                },
                {
                    "name": "max_neighbours",
                    "type": "Option<NodeT>",
                    "desc": "Number of maximum neighbours to consider"
                }
            ]
        },
        "example": {
            "desc": "Suppose you want to the get the neighbours of the first 10 nodes:\n",
            "content": "```rust# use rayon::iter::ParallelIterator;\n# use graph::NodeT;\n# use rayon::iter::IndexedParallelIterator;\n# let graph = graph::test_utilities::load_ppi(true, true, true, false, false, false);\nlet node_ids = (0..10).collect::<Vec<NodeT>>();\nlet include_central_nodes = true;\nlet offset = 0;\nlet max_neighbours = 5;\nlet iterator = graph.get_node_label_prediction_tuple_from_node_ids(\nnode_ids.clone(), 42, include_central_nodes, offset, Some(max_neighbours)\n).unwrap();\niterator.enumerate().for_each(|(i, (neighbours_iter, labels))|{\nfor (j, node_id) in neighbours_iter.enumerate(){\nif j==0 && include_central_nodes{\nassert!(node_id==node_ids[i]);\n}\nassert!(\nmax_neighbours + include_central_nodes as NodeT > j as NodeT,\n\"The index {} is higher than the given maximum neighbours number {}!\",\nj,\nmax_neighbours\n);\n}\n});\n"
        },
        "extra_headers": []
    },
    "link_prediction_degrees": {
        "file": "preprocessing.rs",
        "function": "link_prediction_degrees",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "idx",
                    "type": "u64",
                    "desc": "The index of the batch to generate, behaves like a random random_state"
                },
                {
                    "name": "batch_size",
                    "type": "usize",
                    "desc": "The maximal size of the batch to generate"
                },
                {
                    "name": "normalize",
                    "type": "bool",
                    "desc": "Divide the degrees by the max, this way the values are in [0, 1]"
                },
                {
                    "name": "negative_samples",
                    "type": "f64",
                    "desc": "The component of netagetive samples to use"
                },
                {
                    "name": "avoid_false_negatives",
                    "type": "bool",
                    "desc": "Whether to remove the false negatives when generated. It should be left to false, as it has very limited impact on the training, but enabling this will slow things down"
                },
                {
                    "name": "maximal_sampling_attempts",
                    "type": "usize",
                    "desc": "Number of attempts to execute to sample the negative edges"
                },
                {
                    "name": "graph_to_avoid",
                    "type": "&'a Option<&Graph>",
                    "desc": "The graph whose edges are to be avoided during the generation of false negatives"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "link_prediction_ids": {
        "file": "preprocessing.rs",
        "function": "link_prediction_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "idx",
                    "type": "u64",
                    "desc": "The index of the batch to generate, behaves like a random random_state"
                },
                {
                    "name": "batch_size",
                    "type": "usize",
                    "desc": "The maximal size of the batch to generate"
                },
                {
                    "name": "negative_samples",
                    "type": "f64",
                    "desc": "The component of netagetive samples to use"
                },
                {
                    "name": "avoid_false_negatives",
                    "type": "bool",
                    "desc": "Whether to remove the false negatives when generated. It should be left to false, as it has very limited impact on the training, but enabling this will slow things down"
                },
                {
                    "name": "maximal_sampling_attempts",
                    "type": "usize",
                    "desc": "Number of attempts to execute to sample the negative edges"
                },
                {
                    "name": "graph_to_avoid",
                    "type": "&'a Option<&Graph>",
                    "desc": "The graph whose edges are to be avoided during the generation of false negatives"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_loading_bar": {
        "file": "utils.rs",
        "function": "get_loading_bar",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "not_one": {
        "file": "utils.rs",
        "function": "not_one",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "compute_edge_ids_vector": {
        "file": "utils.rs",
        "function": "compute_edge_ids_vector",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "parse_weight": {
        "file": "utils.rs",
        "function": "parse_weight",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "weight",
                    "type": "String",
                    "desc": "The weight to be parsed"
                }
            ]
        },
        "example": {
            "desc": "The weight can be validated as follows:\n",
            "content": "```rust# use graph::utils::parse_weight;\nassert!(parse_weight(\"0.0\".to_string()).is_ok());\nassert!(parse_weight(\"-1.0\".to_string()).is_ok());\nassert!(parse_weight(\"2.0\".to_string()).is_ok());\nassert!(parse_weight(\"2ghgjh.0\".to_string()).is_err());\nassert_eq!(parse_weight(\"2.0\".to_string()).unwrap(), 2.0);\n"
        },
        "extra_headers": []
    },
    "get_buffer_reader": {
        "file": "csv_file_reader.rs",
        "function": "get_buffer_reader",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "count_rows": {
        "file": "csv_file_reader.rs",
        "function": "count_rows",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_header": {
        "file": "csv_file_reader.rs",
        "function": "get_header",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_lines_iterator": {
        "file": "csv_file_reader.rs",
        "function": "get_lines_iterator",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_elements_per_line": {
        "file": "csv_file_reader.rs",
        "function": "get_elements_per_line",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "read_lines": {
        "file": "node_file_reader.rs",
        "function": "read_lines",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_column_number": {
        "file": "csv_file_reader.rs",
        "function": "get_column_number",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* column_name: String - Column to get the number of.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'column_name'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "are_nodes_remappable": {
        "file": "remap.rs",
        "function": "are_nodes_remappable",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "other",
                    "type": "&Graph",
                    "desc": "graph towards remap the nodes to"
                }
            ]
        },
        "example": {
            "desc": "A graph is always remappable to itself:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert!(graph.are_nodes_remappable(&graph));\n",
            "footer": "Two different graphs, like Cora and STRING, are not remappable:\n```rust\n"
        },
        "extra_headers": [
            {
                "name": "let cora = graph::test_utilities::load_cora().unwrap();",
                "content": ""
            },
            {
                "name": "let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                "content": "assert!(!cora.are_nodes_remappable(&ppi));\n```\n"
            }
        ]
    },
    "remap": {
        "file": "remap.rs",
        "function": "remap",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "other",
                    "type": "&Graph",
                    "desc": "The graph to remap towards"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loding bar"
                }
            ]
        },
        "example": {
            "desc": "A graph is always remappable to itself:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert_eq!(graph, graph.remap(&graph, false).unwrap());\n"
        },
        "extra_headers": []
    },
    "set_sources_column": {
        "file": "edge_file_writer.rs",
        "function": "set_sources_column",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* sources_column: Option<String> - The source nodes column to use for the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'sources_column'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_sources_column_number": {
        "file": "edge_file_writer.rs",
        "function": "set_sources_column_number",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* sources_column_number: Option<String> - The source nodes column to use for the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'sources_column_number'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_destinations_column": {
        "file": "edge_file_writer.rs",
        "function": "set_destinations_column",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* destinations_column: Option<String> - The node types column to use for the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'destinations_column'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_destinations_column_number": {
        "file": "edge_file_writer.rs",
        "function": "set_destinations_column_number",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* destinations_column_number: Option<String> - The node types column to use for the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'destinations_column_number'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_edge_types_column": {
        "file": "edge_file_writer.rs",
        "function": "set_edge_types_column",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* edge_types_column: Option<String> - The node types column to use for the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'edge_type_column'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_edge_types_column_number": {
        "file": "edge_file_writer.rs",
        "function": "set_edge_types_column_number",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* edge_types_column_number: Option<usize> - The node types column to use for the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'edge_type_column_number'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_weights_column": {
        "file": "edge_file_writer.rs",
        "function": "set_weights_column",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* weights_column: Option<String> - The node types column to use for the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'weights_column'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_weights_column_number": {
        "file": "edge_file_writer.rs",
        "function": "set_weights_column_number",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* weights_column_number: Option<usize> - The node types column to use for the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'weights_column_number'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_skip_weights_if_unavailable": {
        "file": "edge_file_reader.rs",
        "function": "set_skip_weights_if_unavailable",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* skip_weights_if_unavailable: Option<bool> - Whether to skip weights if they are not available.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'skip_weights_if_unavailable'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_skip_edge_types_if_unavailable": {
        "file": "edge_file_reader.rs",
        "function": "set_skip_edge_types_if_unavailable",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* skip_edge_types_if_unavailable: Option<bool> - Whether to skip edge types if they are not available.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'skip_edge_types_if_unavailable'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_default_weight": {
        "file": "edge_file_reader.rs",
        "function": "set_default_weight",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* default_weight: Option<WeightT> - The default_weight to use when default_weight is missing.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'default_weight'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_graph_name": {
        "file": "node_file_reader.rs",
        "function": "set_graph_name",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* graph_name: String - The name of the graph to be loaded.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'graph_name'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_default_edge_type": {
        "file": "edge_file_reader.rs",
        "function": "set_default_edge_type",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* default_edge_type: Option<String> - The edge type to use when edge type is missing.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'default_edge_type'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_skip_selfloops": {
        "file": "edge_file_reader.rs",
        "function": "set_skip_selfloops",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "skip_selfloops",
                    "type": "Option<bool>",
                    "desc": "Whether should ignore or not selfloops"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "set_csv_is_correct": {
        "file": "node_file_reader.rs",
        "function": "set_csv_is_correct",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* csv_is_correct: Option<bool> - Whether you pinky swear the node list is correct.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'csv_is_correct'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_comment_symbol": {
        "file": "node_file_reader.rs",
        "function": "set_comment_symbol",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* comment_symbol: Option<String> - if the reader should ignore or not duplicated edges.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'comment_symbol'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_verbose": {
        "file": "node_file_reader.rs",
        "function": "set_verbose",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "Option<bool>",
                    "desc": "Whether to show the loading bar or not"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "set_might_contain_singletons_with_selfloops": {
        "file": "edge_file_reader.rs",
        "function": "set_might_contain_singletons_with_selfloops",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "might_contain_singletons_with_selfloops",
                    "type": "Option<bool>",
                    "desc": "Whether this graph has singletons with self-loops"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "set_might_contain_trap_nodes": {
        "file": "edge_file_reader.rs",
        "function": "set_might_contain_trap_nodes",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "might_contain_trap_nodes",
                    "type": "Option<bool>",
                    "desc": "Whether this graph has trap nodes with self-loops"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "set_numeric_edge_type_ids": {
        "file": "edge_file_reader.rs",
        "function": "set_numeric_edge_type_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_numeric_node_ids": {
        "file": "node_file_reader.rs",
        "function": "set_numeric_node_ids",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* numeric_node_ids: Option<bool> - Whether to convert numeric node type Ids to Node Type Ids.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'numeric_node_ids'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_ignore_duplicates": {
        "file": "node_file_reader.rs",
        "function": "set_ignore_duplicates",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* ignore_duplicates: Option<bool> - Whether to ignore detected duplicates or raise exception.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'ignore_duplicates'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_separator": {
        "file": "node_file_reader.rs",
        "function": "set_separator",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* separator: Option<String> - The separator to use for the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'separator'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_header": {
        "file": "node_file_reader.rs",
        "function": "set_header",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* header: Option<bool> - Whether to expect an header or not.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'header'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_rows_to_skip": {
        "file": "node_file_reader.rs",
        "function": "set_rows_to_skip",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* rows_to_skip: Option<bool> - Whether to show the loading bar or not.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'rows_to_skip'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_max_rows_number": {
        "file": "node_file_reader.rs",
        "function": "set_max_rows_number",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* max_rows_number: Option<u64> - The edge type to use when edge type is missing.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'max_rows_number'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "has_edge_types": {
        "file": "getters_boolean.rs",
        "function": "has_edge_types",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rustlet string_ppi_with_edge_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert!(string_ppi_with_edge_types.has_edge_types());\nlet string_ppi_without_edge_types = graph::test_utilities::load_ppi(true, false, true, true, false, false);\nassert!(!string_ppi_without_edge_types.has_edge_types());\n"
        },
        "extra_headers": []
    },
    "has_edge_weights": {
        "file": "getters_boolean.rs",
        "function": "has_edge_weights",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rustlet weights_string_ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert!(weights_string_ppi.has_edge_weights());\nlet unweights_string_ppi = graph::test_utilities::load_ppi(true, true, false, true, false, false);\nassert!(!unweights_string_ppi.has_edge_weights());\n"
        },
        "extra_headers": []
    },
    "parse_edge_line": {
        "file": "edge_file_reader.rs",
        "function": "parse_edge_line",
        "errors": [
            {
                "doc_line": 3,
                "msg": "The argument line '* vals: Vec<String> - Vector of the values of the line to be parsed' (doc_line: 3) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'vals'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "is_unchecked_singleton_from_node_id": {
        "file": "queries_boolean.rs",
        "function": "is_unchecked_singleton_from_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "The node to be checked for"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "is_singleton_from_node_id": {
        "file": "queries_boolean.rs",
        "function": "is_singleton_from_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "The node to be checked for"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "is_singleton_with_selfloops_from_node_id": {
        "file": "queries_boolean.rs",
        "function": "is_singleton_with_selfloops_from_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "The node to be checked for"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "is_unchecked_singleton_from_node_name": {
        "file": "queries_boolean.rs",
        "function": "is_unchecked_singleton_from_node_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_name",
                    "type": "&str",
                    "desc": "The node name to be checked for"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "is_singleton_from_node_name": {
        "file": "queries_boolean.rs",
        "function": "is_singleton_from_node_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_name",
                    "type": "&str",
                    "desc": "The node name to be checked for"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "has_node_name": {
        "file": "queries_boolean.rs",
        "function": "has_node_name",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "node_name",
                    "type": "&str",
                    "desc": "Name of the node"
                }
            ]
        },
        "example": {
            "desc": "To check if a node appears in the graph you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nlet node_name = \"ENSP00000000233\";\nlet unexistent_node_name = \"I_do_not_exist!\";\nassert!(graph.has_node_name(node_name));\nassert!(!graph.has_node_name(unexistent_node_name));\n"
        },
        "extra_headers": []
    },
    "has_edge_from_node_ids": {
        "file": "queries_boolean.rs",
        "function": "has_edge_from_node_ids",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "Source node id"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": "Destination node id"
                }
            ]
        },
        "example": {
            "desc": "To check if an edge appears in the graph you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nassert!(graph.has_edge_from_node_ids(0, 1));\nassert!(!graph.has_edge_from_node_ids(0, 4565));\n"
        },
        "extra_headers": []
    },
    "has_edge_from_node_ids_and_edge_type_id": {
        "file": "queries_boolean.rs",
        "function": "has_edge_from_node_ids_and_edge_type_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "The source node of the edge"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": "The destination node of the edge"
                },
                {
                    "name": "edge_type",
                    "type": "Option<EdgeTypeT>",
                    "desc": "The (optional) edge type"
                }
            ]
        },
        "example": {
            "desc": "To check if an edge with given type appears in the graph you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nassert!(graph.has_edge_from_node_ids_and_edge_type_id(0, 1, Some(0)));\nassert!(!graph.has_edge_from_node_ids_and_edge_type_id(0, 1, Some(1)));\n"
        },
        "extra_headers": []
    },
    "is_unchecked_trap_node_from_node_id": {
        "file": "queries_boolean.rs",
        "function": "is_unchecked_trap_node_from_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "Integer ID of the node, if this is bigger that the number of nodes it will panic"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "is_trap_node_from_node_id": {
        "file": "queries_boolean.rs",
        "function": "is_trap_node_from_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "Integer ID of the node, if this is bigger that the number of nodes it will panic"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "has_node_name_and_node_type_name": {
        "file": "queries_boolean.rs",
        "function": "has_node_name_and_node_type_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_name",
                    "type": "&str",
                    "desc": "The node name"
                },
                {
                    "name": "node_type_name",
                    "type": "Option<Vec<String>>",
                    "desc": "The node types name"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "has_edge_from_node_names": {
        "file": "queries_boolean.rs",
        "function": "has_edge_from_node_names",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "src_name",
                    "type": "&str",
                    "desc": "The source node name of the edge"
                },
                {
                    "name": "dst_name",
                    "type": "&str",
                    "desc": "The destination node name of the edge"
                }
            ]
        },
        "example": {
            "desc": "To check if an edge in the graph you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nassert!(graph.has_edge_from_node_names(\"ENSP00000000233\", \"ENSP00000432568\"));\nassert!(!graph.has_edge_from_node_names(\"ENSP00000000233\", \"NonExistent\"));\n"
        },
        "extra_headers": []
    },
    "has_edge_from_node_names_and_edge_type_name": {
        "file": "queries_boolean.rs",
        "function": "has_edge_from_node_names_and_edge_type_name",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "src_name",
                    "type": "&str",
                    "desc": "The source node name of the edge"
                },
                {
                    "name": "dst_name",
                    "type": "&str",
                    "desc": "The destination node name of the edge"
                },
                {
                    "name": "edge_type_name",
                    "type": "Option<&str>",
                    "desc": "The (optional) edge type name"
                }
            ]
        },
        "example": {
            "desc": "To check if an edge with type in the graph you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nlet edge_type = Some(\"red\");\nlet unexistent_edge_type = Some(\"NonExistent\");\nassert!(graph.has_edge_from_node_names_and_edge_type_name(\"ENSP00000000233\", \"ENSP00000432568\", edge_type));\nassert!(!graph.has_edge_from_node_names_and_edge_type_name(\"ENSP00000000233\", \"ENSP00000432568\", unexistent_edge_type));\nassert!(!graph.has_edge_from_node_names_and_edge_type_name(\"ENSP00000000233\", \"NonExistent\", edge_type));\nassert!(!graph.has_edge_from_node_names_and_edge_type_name(\"ENSP00000000233\", \"NonExistent\", unexistent_edge_type));\n"
        },
        "extra_headers": []
    },
    "get_filter_bitmap": {
        "file": "bitmaps.rs",
        "function": "get_filter_bitmap",
        "errors": [
            {
                "doc_line": 6,
                "msg": "The argument line '* `node_names` - The nodes to keep as strings' (doc_line: 6) is not in the standard format."
            },
            {
                "doc_line": 7,
                "msg": "The argument line '* `node_types` - The nodes types to keep as strings' (doc_line: 7) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node_types'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node_names'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "random_string": {
        "file": "test_utilities.rs",
        "function": "random_string",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "random_path": {
        "file": "test_utilities.rs",
        "function": "random_path",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "load_ppi": {
        "file": "test_utilities.rs",
        "function": "load_ppi",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "load_empty_graph": {
        "file": "test_utilities.rs",
        "function": "load_empty_graph",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "load_cora": {
        "file": "test_utilities.rs",
        "function": "load_cora",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "first_order_walker": {
        "file": "test_utilities.rs",
        "function": "first_order_walker",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "second_order_walker": {
        "file": "test_utilities.rs",
        "function": "second_order_walker",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "validate_vocabularies": {
        "file": "test_utilities.rs",
        "function": "validate_vocabularies",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "default_holdout_test_suite": {
        "file": "test_utilities.rs",
        "function": "default_holdout_test_suite",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_spanning_arborescence_bader": {
        "file": "test_utilities.rs",
        "function": "test_spanning_arborescence_bader",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_graph_properties": {
        "file": "test_utilities.rs",
        "function": "test_graph_properties",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_random_walks": {
        "file": "test_utilities.rs",
        "function": "test_random_walks",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_edge_holdouts": {
        "file": "test_utilities.rs",
        "function": "test_edge_holdouts",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_remove_components": {
        "file": "test_utilities.rs",
        "function": "test_remove_components",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_kfold": {
        "file": "test_utilities.rs",
        "function": "test_kfold",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_negative_edges_generation": {
        "file": "test_utilities.rs",
        "function": "test_negative_edges_generation",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_subgraph_generation": {
        "file": "test_utilities.rs",
        "function": "test_subgraph_generation",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_dump_graph": {
        "file": "test_utilities.rs",
        "function": "test_dump_graph",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_embiggen_preprocessing": {
        "file": "test_utilities.rs",
        "function": "test_embiggen_preprocessing",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_edgelist_generation": {
        "file": "test_utilities.rs",
        "function": "test_edgelist_generation",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_nodelabel_holdouts": {
        "file": "test_utilities.rs",
        "function": "test_nodelabel_holdouts",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_edgelabel_holdouts": {
        "file": "test_utilities.rs",
        "function": "test_edgelabel_holdouts",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_graph_removes": {
        "file": "test_utilities.rs",
        "function": "test_graph_removes",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_clone_and_setters": {
        "file": "test_utilities.rs",
        "function": "test_clone_and_setters",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_graph_remapping": {
        "file": "test_utilities.rs",
        "function": "test_graph_remapping",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "_default_test_suite": {
        "file": "test_utilities.rs",
        "function": "_default_test_suite",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "default_test_suite": {
        "file": "test_utilities.rs",
        "function": "default_test_suite",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "enable": {
        "file": "modifiers.rs",
        "function": "enable",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "vector_sources",
                    "type": "bool",
                    "desc": "Whether to cache sources into a vector for faster walks"
                },
                {
                    "name": "vector_destinations",
                    "type": "bool",
                    "desc": "Whether to cache destinations into a vector for faster walks"
                },
                {
                    "name": "vector_cumulative_node_degrees",
                    "type": "bool",
                    "desc": "Whether to cache cumulative_node_degrees into a vector for faster walks"
                },
                {
                    "name": "cache_size",
                    "type": "Option<f64>",
                    "desc": "percentage of nodes destinations to cache. This cannot be used with the vector destinations"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "disable_all": {
        "file": "modifiers.rs",
        "function": "disable_all",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_nodes_column": {
        "file": "node_file_reader.rs",
        "function": "set_nodes_column",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* nodes_column: Option<String> - The nodes column to use for the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'nodes_column'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_node_types_column": {
        "file": "node_file_reader.rs",
        "function": "set_node_types_column",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* node_types_column: Option<String> - The node types column to use for the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'nodes_type_column'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_nodes_column_number": {
        "file": "node_file_reader.rs",
        "function": "set_nodes_column_number",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* nodes_column_number: Option<usize> - The nodes column_number to use for the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'nodes_column_number'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [],
            "footer": "t\n"
        },
        "example": {},
        "extra_headers": []
    },
    "set_node_types_column_number": {
        "file": "node_file_reader.rs",
        "function": "set_node_types_column_number",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* node_types_column_number: Option<usize> - The node types column_number to use for the file.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node_types_column_number'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "dump": {
        "file": "edge_file_writer.rs",
        "function": "dump",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "graph",
                    "type": "&Graph",
                    "desc": "the graph to write out"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unchecked_edge_ids_from_source_node_id": {
        "file": "iter_queries.rs",
        "function": "iter_unchecked_edge_ids_from_source_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "Source node of the edge"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "par_iter_unchecked_edge_ids_from_source_node_id": {
        "file": "iter_queries.rs",
        "function": "par_iter_unchecked_edge_ids_from_source_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "Source node of the edge"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unchecked_edge_ids_from_node_ids": {
        "file": "iter_queries.rs",
        "function": "iter_unchecked_edge_ids_from_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "Source node of the edge"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": " Destination node of the edge"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unchecked_neighbour_node_ids_from_source_node_id": {
        "file": "iter_queries.rs",
        "function": "iter_unchecked_neighbour_node_ids_from_source_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "The node whose neighbours are to be retrieved"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unchecked_neighbour_node_names_from_source_node_id": {
        "file": "iter_queries.rs",
        "function": "iter_unchecked_neighbour_node_names_from_source_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "The node whose neighbour names are to be retrieved"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_edge_ids_from_node_ids": {
        "file": "iter_queries.rs",
        "function": "iter_edge_ids_from_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "Source node id of the edge"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": " Destination node id of the edge"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_edge_node_ids_and_edge_type_id_from_edge_type_id": {
        "file": "iter_queries.rs",
        "function": "iter_edge_node_ids_and_edge_type_id_from_edge_type_id",
        "errors": [
            {
                "doc_line": 6,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_id",
                    "type": "Option<EdgeTypeT>",
                    "desc": "Edge type ID to extract"
                },
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to iterate the edge list as directed or undirected"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no edge types in the graph.\n* If the given edge type ID does not exist in the graph.\n"
            }
        ]
    },
    "iter_node_ids_and_node_type_ids_from_node_type_id": {
        "file": "iter_queries.rs",
        "function": "iter_node_ids_and_node_type_ids_from_node_type_id",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_id",
                    "type": "Option<NodeTypeT>",
                    "desc": "node type ID to extract"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no node types in the graph.\n* If the given node type ID does not exist in the graph.\n"
            }
        ]
    },
    "iter_node_names_and_node_type_names_from_node_type_id": {
        "file": "iter_queries.rs",
        "function": "iter_node_names_and_node_type_names_from_node_type_id",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_id",
                    "type": "Option<NodeTypeT>",
                    "desc": "node type ID to extract"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no node types in the graph.\n* If the given node type ID does not exist in the graph.\n"
            }
        ]
    },
    "iter_edge_node_names_and_edge_type_name_from_edge_type_id": {
        "file": "iter_queries.rs",
        "function": "iter_edge_node_names_and_edge_type_name_from_edge_type_id",
        "errors": [
            {
                "doc_line": 6,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_id",
                    "type": "Option<EdgeTypeT>",
                    "desc": "Edge type ID to extract"
                },
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to iterate the edge list as directed or undirected"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no edge types in the graph.\n* If the given edge type ID does not exist in the graph.\n"
            }
        ]
    },
    "strongly_connected_components": {
        "file": "tarjan.rs",
        "function": "strongly_connected_components",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_edge_weight_from_edge_id": {
        "file": "queries.rs",
        "function": "get_unchecked_edge_weight_from_edge_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "The edge whose edge weight is to be returned"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_node_id_from_node_name": {
        "file": "queries.rs",
        "function": "get_unchecked_node_id_from_node_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_name",
                    "type": "&str",
                    "desc": "The node name whose node ID is to be returned"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_edge_type_id_from_edge_type_name": {
        "file": "queries.rs",
        "function": "get_unchecked_edge_type_id_from_edge_type_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_name",
                    "type": "&str",
                    "desc": "The edge type name whose edge type ID is to be returned"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_edge_type_name_from_edge_type_id": {
        "file": "queries.rs",
        "function": "get_unchecked_edge_type_name_from_edge_type_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_id",
                    "type": "Option<EdgeTypeT>",
                    "desc": "The edge type naIDme whose edge type name is to be returned"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_edge_count_from_edge_type_id": {
        "file": "queries.rs",
        "function": "get_unchecked_edge_count_from_edge_type_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type",
                    "type": "Option<EdgeTypeT>",
                    "desc": "The edge type to retrieve count of"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_node_count_from_node_type_id": {
        "file": "queries.rs",
        "function": "get_unchecked_node_count_from_node_type_id",
        "errors": [
            {
                "doc_line": 3,
                "msg": "The argument line '* node_type: Option<NodeTypeT> - The node type to retrieve count of.' (doc_line: 3) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node_type'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_destination_node_ids_from_node_id": {
        "file": "queries.rs",
        "function": "get_unchecked_destination_node_ids_from_node_id",
        "errors": [
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'max_neighbours'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'random_state'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [],
            "desc": "`node`: NodeT - Node whose neighbours are to return.\n`random_state`: u64 - Random state to subsample neighbours.\n`max_neighbours`: Option<NodeT> - Optionally number of neighbours to consider.\n"
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_edge_id_from_node_ids_and_edge_type_id": {
        "file": "queries.rs",
        "function": "get_unchecked_edge_id_from_node_ids_and_edge_type_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "Source node of the edge"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": "Destination node of the edge"
                },
                {
                    "name": "edge_type",
                    "type": "Option<EdgeTypeT>",
                    "desc": "Edge Type of the edge"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_minmax_edge_ids_from_node_ids": {
        "file": "queries.rs",
        "function": "get_unchecked_minmax_edge_ids_from_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "Source node"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": "Destination node"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_edge_degree_from_node_ids": {
        "file": "queries.rs",
        "function": "get_unchecked_edge_degree_from_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "Source node"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": "Destination node"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_node_ids_from_edge_id": {
        "file": "queries.rs",
        "function": "get_unchecked_node_ids_from_edge_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "The edge ID whose source and destination node IDs are to e retrieved"
                }
            ]
        },
        "example": {
            "desc": "To retrieve the source and destination node IDs of a given edge ID you can use the following:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nlet edge_id = 0;\nlet (src, dst) = graph.get_unchecked_node_ids_from_edge_id(edge_id);\nprintln!(\"The edge with ID {} has source node ID {} and destination node ID {}.\", edge_id, src, dst);\n"
        },
        "extra_headers": []
    },
    "get_node_ids_from_edge_id": {
        "file": "queries.rs",
        "function": "get_node_ids_from_edge_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "The edge ID whose source and destination node IDs are to e retrieved"
                }
            ]
        },
        "example": {
            "desc": "To retrieve the source and destination node IDs of a given edge ID you can use the following:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert!(graph.get_node_ids_from_edge_id(0).is_ok());\nassert!(graph.get_node_ids_from_edge_id(10000000000).is_err());\n"
        },
        "extra_headers": []
    },
    "get_unchecked_edge_id_from_node_ids": {
        "file": "queries.rs",
        "function": "get_unchecked_edge_id_from_node_ids",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "The source node ID"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": "The destination node ID"
                }
            ]
        },
        "example": {
            "desc": "To retrieve the edge ID curresponding to the given source and destination node IDs you can use the following:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nlet src = 0;\nlet dst = 1;\nlet edge_id = graph.get_unchecked_edge_id_from_node_ids(src, dst);\nprintln!(\"The source node ID {} and destination node ID {} corrrespond to the edge with ID {}.\", src, dst, edge_id);\n"
        },
        "extra_headers": []
    },
    "get_edge_id_from_node_ids": {
        "file": "queries.rs",
        "function": "get_edge_id_from_node_ids",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "The source node ID"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": "The destination node ID"
                }
            ]
        },
        "example": {
            "desc": "To retrieve the edge ID curresponding to the given source and destination node IDs you can use the following:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nassert!(graph.get_edge_id_from_node_ids(0, 1).is_ok());\nassert!(graph.get_edge_id_from_node_ids(0, 100000000).is_err());\n"
        },
        "extra_headers": []
    },
    "get_unchecked_unique_source_node_id": {
        "file": "queries.rs",
        "function": "get_unchecked_unique_source_node_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "source_id",
                    "type": "NodeT",
                    "desc": "The source node ID"
                }
            ]
        },
        "example": {
            "desc": "To retrieve the edge ID curresponding to the given source and destination node IDs you can use the following:\n",
            "content": "```rust# let graph_with_singletons = graph::test_utilities::load_ppi(true, true, true, true, false, false);\n# let graph_without_singletons = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nassert!(\ngraph_without_singletons.iter_node_ids()\n.all(|node_id|\ngraph_without_singletons.get_unchecked_unique_source_node_id(node_id) == node_id)\n);\n"
        },
        "extra_headers": []
    },
    "get_unchecked_node_ids_and_edge_type_id_from_edge_id": {
        "file": "queries.rs",
        "function": "get_unchecked_node_ids_and_edge_type_id_from_edge_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "The edge ID whose source, destination and edge type are to be retrieved"
                }
            ]
        },
        "example": {
            "desc": "In order to retrieve a given edge ID informations, you can use the following:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nlet edge_id = 0;\nlet (src, dst, edge_type) = graph.get_unchecked_node_ids_and_edge_type_id_from_edge_id(edge_id);\nprintln!(\"The edge with ID {} has source node ID {}, destination node ID {} and edge type ID {:?}\", edge_id, src, dst, edge_type);\n"
        },
        "extra_headers": []
    },
    "get_node_ids_and_edge_type_id_from_edge_id": {
        "file": "queries.rs",
        "function": "get_node_ids_and_edge_type_id_from_edge_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "The edge ID whose source, destination and edge type are to be retrieved"
                }
            ]
        },
        "example": {
            "desc": "In order to retrieve a given edge ID informations, you can use the following:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert!(graph.get_node_ids_and_edge_type_id_from_edge_id(0).is_ok());\nassert!(graph.get_node_ids_and_edge_type_id_from_edge_id(10000000000).is_err());\n"
        },
        "extra_headers": []
    },
    "get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id": {
        "file": "queries.rs",
        "function": "get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "The edge ID whose source, destination, edge type and weight are to be retrieved"
                }
            ]
        },
        "example": {
            "desc": "In order to retrieve a given edge ID informations, you can use the following:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nlet edge_id = 0;\nlet (src, dst, edge_type, weight) = graph.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(edge_id);\nprintln!(\"The edge with ID {} has source node ID {}, destination node ID {}, edge type ID {:?} and weight {:?}.\", edge_id, src, dst, edge_type, weight);\n"
        },
        "extra_headers": []
    },
    "get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id": {
        "file": "queries.rs",
        "function": "get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "The edge ID whose source, destination, edge type and weight are to be retrieved"
                }
            ]
        },
        "example": {
            "desc": "In order to retrieve a given edge ID informations, you can use the following:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert!(graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(0).is_ok());\nassert!(graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(10000000000).is_err());\n"
        },
        "extra_headers": []
    },
    "get_top_k_central_node_ids": {
        "file": "queries.rs",
        "function": "get_top_k_central_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "k",
                    "type": "NodeT",
                    "desc": "Number of central nodes to extract"
                }
            ],
            "footer": "TODO: This can be refactored to run faster!\n"
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_node_degree_from_node_id": {
        "file": "queries.rs",
        "function": "get_unchecked_node_degree_from_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "Integer ID of the node"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_degree_from_node_id": {
        "file": "queries.rs",
        "function": "get_node_degree_from_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "Integer ID of the node"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_degree_from_node_name": {
        "file": "queries.rs",
        "function": "get_node_degree_from_node_name",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_name",
                    "type": "&str",
                    "desc": "Integer ID of the node"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the given node name does not exist in the graph.\n"
            }
        ]
    },
    "get_top_k_central_node_names": {
        "file": "queries.rs",
        "function": "get_top_k_central_node_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "k",
                    "type": "NodeT",
                    "desc": "Number of central nodes to extract"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_node_type_id_from_node_id": {
        "file": "queries.rs",
        "function": "get_unchecked_node_type_id_from_node_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "node whose node type is to be returned"
                }
            ]
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The node type id of node {} is {:?}\", 0, graph.get_unchecked_node_type_id_from_node_id(0));\n"
        },
        "extra_headers": []
    },
    "get_node_type_id_from_node_id": {
        "file": "queries.rs",
        "function": "get_node_type_id_from_node_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "node whose node type is to be returned"
                }
            ]
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The node type id of node {} is {:?}\", 0, graph.get_node_type_id_from_node_id(0));\n"
        },
        "extra_headers": []
    },
    "get_unchecked_edge_type_id_from_edge_id": {
        "file": "queries.rs",
        "function": "get_unchecked_edge_type_id_from_edge_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "edge whose edge type is to be returned"
                }
            ]
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert_eq!(graph.get_unchecked_edge_type_id_from_edge_id(0), Some(0));\n"
        },
        "extra_headers": []
    },
    "get_edge_type_id_from_edge_id": {
        "file": "queries.rs",
        "function": "get_edge_type_id_from_edge_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "edge whose edge type is to be returned"
                }
            ]
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\n# let graph_without_edge_types = graph::test_utilities::load_ppi(true, false, true, true, false, false);\nassert_eq!(graph.get_edge_type_id_from_edge_id(0).unwrap(), Some(0));\nassert!(graph_without_edge_types.get_edge_type_id_from_edge_id(0).is_err());\n"
        },
        "extra_headers": []
    },
    "get_unchecked_node_type_names_from_node_id": {
        "file": "queries.rs",
        "function": "get_unchecked_node_type_names_from_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "The node ID whose node types are to be returned"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_type_names_from_node_id": {
        "file": "queries.rs",
        "function": "get_node_type_names_from_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "The node ID whose node types are to be returned"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_type_name_from_edge_id": {
        "file": "queries.rs",
        "function": "get_edge_type_name_from_edge_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "The edge ID whose edge type is to be returned"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_type_name_from_edge_type_id": {
        "file": "queries.rs",
        "function": "get_edge_type_name_from_edge_type_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_id",
                    "type": "EdgeTypeT",
                    "desc": "Id of the edge type"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_weight_from_edge_id": {
        "file": "queries.rs",
        "function": "get_edge_weight_from_edge_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "The edge ID whose weight is to be returned"
                }
            ]
        },
        "example": {
            "desc": "To get the weight of a given `edge_id` you can run:\n",
            "content": "```rust# let weighted_graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\n# let unweighted_graph = graph::test_utilities::load_ppi(true, true, false, true, false, false);\nlet edge_id = 0;\nlet unexistent_edge_id = 123456789;\nassert!(weighted_graph.get_edge_weight_from_edge_id(edge_id).is_ok());\nassert!(weighted_graph.get_edge_weight_from_edge_id(unexistent_edge_id).is_err());\nassert!(unweighted_graph.get_edge_weight_from_edge_id(edge_id).is_err());\n"
        },
        "extra_headers": []
    },
    "get_edge_weight_from_node_ids": {
        "file": "queries.rs",
        "function": "get_edge_weight_from_node_ids",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "The node ID of the source node"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": "The node ID of the destination node"
                }
            ]
        },
        "example": {
            "desc": "To get the weight of a given `src` and `dst` you can run:\n",
            "content": "```rust# let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nlet src = 0;\nlet dst = 1;\nassert!(weighted_graph.get_edge_weight_from_node_ids(src, dst).is_ok());\n"
        },
        "extra_headers": []
    },
    "get_edge_weight_from_node_ids_and_edge_type_id": {
        "file": "queries.rs",
        "function": "get_edge_weight_from_node_ids_and_edge_type_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "The node ID of the source node"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": "The node ID of the destination node"
                },
                {
                    "name": "edge_type",
                    "type": "Option<EdgeTypeT>",
                    "desc": "The edge type ID of the edge"
                }
            ]
        },
        "example": {
            "desc": "To get the weight of a given `src` and `dst` and `edge_type` you can run:\n",
            "content": "```rust# let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nlet src = 0;\nlet dst = 1;\nlet edge_type = Some(0);\nassert!(weighted_graph.get_edge_weight_from_node_ids_and_edge_type_id(src, dst, edge_type).is_ok());\n"
        },
        "extra_headers": []
    },
    "get_edge_weight_from_node_names_and_edge_type_name": {
        "file": "queries.rs",
        "function": "get_edge_weight_from_node_names_and_edge_type_name",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "&str",
                    "desc": "The node name of the source node"
                },
                {
                    "name": "dst",
                    "type": "&str",
                    "desc": "The node name of the destination node"
                },
                {
                    "name": "edge_type",
                    "type": "Option<&str>",
                    "desc": "The edge type name of the edge"
                }
            ]
        },
        "example": {
            "desc": "To get the weight of a given `src` and `dst` and `edge_type` you can run:\n",
            "content": "```rust# let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nlet src = \"ENSP00000000233\";\nlet dst = \"ENSP00000432568\";\nlet edge_type = Some(\"red\");\nassert!(weighted_graph.get_edge_weight_from_node_names_and_edge_type_name(src, dst, edge_type).is_ok());\n"
        },
        "extra_headers": []
    },
    "get_edge_weight_from_node_names": {
        "file": "queries.rs",
        "function": "get_edge_weight_from_node_names",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "src_name",
                    "type": "&str",
                    "desc": "The node name of the source node"
                },
                {
                    "name": "dst_name",
                    "type": "&str",
                    "desc": "The node name of the destination node"
                }
            ]
        },
        "example": {
            "desc": "To get the weight of a given `src_name` and `dst_name` you can run:\n",
            "content": "```rust# let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nlet src_name = \"ENSP00000000233\";\nlet dst_name = \"ENSP00000432568\";\nassert!(weighted_graph.get_edge_weight_from_node_names(src_name, dst_name).is_ok());\n"
        },
        "extra_headers": []
    },
    "get_unchecked_node_name_from_node_id": {
        "file": "queries.rs",
        "function": "get_unchecked_node_name_from_node_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "The node ID whose name is to be returned"
                }
            ]
        },
        "example": {
            "desc": "To get the name of a node you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert_eq!(graph.get_unchecked_node_name_from_node_id(0), \"ENSG00000004059\".to_string());\n"
        },
        "extra_headers": []
    },
    "get_node_name_from_node_id": {
        "file": "queries.rs",
        "function": "get_node_name_from_node_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "The node ID whose name is to be returned"
                }
            ]
        },
        "example": {
            "desc": "To get the name of a node you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert!(graph.get_node_name_from_node_id(0).is_ok());\n"
        },
        "extra_headers": []
    },
    "get_node_id_from_node_name": {
        "file": "queries.rs",
        "function": "get_node_id_from_node_name",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_name",
                    "type": "&str",
                    "desc": "The node name whose node ID is to be returned"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* When the given node name does not exists in the current graph.\n"
            }
        ]
    },
    "get_node_ids_from_node_names": {
        "file": "queries.rs",
        "function": "get_node_ids_from_node_names",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_names",
                    "type": "Vec<&str>",
                    "desc": "The node names whose node IDs is to be returned"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* When any of the given node name does not exists in the current graph.\n"
            }
        ]
    },
    "get_edge_node_ids_from_edge_node_names": {
        "file": "queries.rs",
        "function": "get_edge_node_ids_from_edge_node_names",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_node_names",
                    "type": "Vec<(&str, &str)>",
                    "desc": "The node names whose node IDs is to be returned"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* When any of the given node name does not exists in the current graph.\n"
            }
        ]
    },
    "get_edge_node_names_from_edge_node_ids": {
        "file": "queries.rs",
        "function": "get_edge_node_names_from_edge_node_ids",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_node_ids",
                    "type": "Vec<(NodeT, NodeT)>",
                    "desc": "The node names whose node names is to be returned"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* When any of the given node IDs does not exists in the current graph.\n"
            }
        ]
    },
    "get_node_type_id_from_node_name": {
        "file": "queries.rs",
        "function": "get_node_type_id_from_node_name",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "node_name",
                    "type": "&str",
                    "desc": "Name of the node"
                }
            ]
        },
        "example": {
            "desc": "To get the node type ID for a given node name you can run:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nlet node_name = \"ENSP00000000233\";\nprintln!(\"The node type ID of node {} is {:?}.\", node_name, graph.get_node_type_id_from_node_name(node_name).unwrap());\n"
        },
        "extra_headers": []
    },
    "get_node_type_name_from_node_name": {
        "file": "queries.rs",
        "function": "get_node_type_name_from_node_name",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "node_name",
                    "type": "&str",
                    "desc": "Name of the node"
                }
            ]
        },
        "example": {
            "desc": "To get the node type name for a given node name you can run:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nlet node_name = \"ENSP00000000233\";\nprintln!(\"The node type of node {} is {:?}\", node_name, graph.get_node_type_name_from_node_name(node_name).unwrap());\n"
        },
        "extra_headers": []
    },
    "get_edge_count_from_edge_type_id": {
        "file": "queries.rs",
        "function": "get_edge_count_from_edge_type_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_id",
                    "type": "Option<EdgeTypeT>",
                    "desc": "The edge type ID to count the edges of"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_type_id_from_edge_type_name": {
        "file": "queries.rs",
        "function": "get_edge_type_id_from_edge_type_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_name",
                    "type": "Option<&str>",
                    "desc": "The edge type name whose ID is to be returned"
                }
            ],
            "footer": "TODO: refactor this method using new validation methods.\n"
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_count_from_edge_type_name": {
        "file": "queries.rs",
        "function": "get_edge_count_from_edge_type_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_name",
                    "type": "Option<&str>",
                    "desc": "The edge type name to count the edges of"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_type_id_from_node_type_name": {
        "file": "queries.rs",
        "function": "get_node_type_id_from_node_type_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_name",
                    "type": "&str",
                    "desc": "The node type name whose ID is to be returned"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_count_from_node_type_id": {
        "file": "queries.rs",
        "function": "get_node_count_from_node_type_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_id",
                    "type": "Option<NodeTypeT>",
                    "desc": "The node type ID to count the nodes of"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_count_from_node_type_name": {
        "file": "queries.rs",
        "function": "get_node_count_from_node_type_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_name",
                    "type": "Option<&str>",
                    "desc": "The node type name to count the nodes of"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_destination_node_id_from_edge_id": {
        "file": "queries.rs",
        "function": "get_unchecked_destination_node_id_from_edge_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "The edge ID whose destination is to be retrieved"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_destination_node_id_from_edge_id": {
        "file": "queries.rs",
        "function": "get_destination_node_id_from_edge_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "The edge ID whose destination is to be retrieved"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_neighbour_node_ids_from_node_id": {
        "file": "queries.rs",
        "function": "get_neighbour_node_ids_from_node_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "Node ID whose neighbours are to be retrieved"
                }
            ]
        },
        "example": {
            "desc": "To retrieve the neighbours of a given node `src` you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\n# let node_id = 0;\nprintln!(\"The neighbours of the node {} are {:?}.\", node_id, graph.get_neighbour_node_ids_from_node_id(node_id).unwrap());\nlet unavailable_node = 2349765432;\nassert!(graph.get_neighbour_node_ids_from_node_id(unavailable_node).is_err());\n"
        },
        "extra_headers": []
    },
    "get_neighbour_node_ids_from_node_name": {
        "file": "queries.rs",
        "function": "get_neighbour_node_ids_from_node_name",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "node_name",
                    "type": "&str",
                    "desc": "Node ID whose neighbours are to be retrieved"
                }
            ]
        },
        "example": {
            "desc": "To retrieve the neighbours of a given node `src` you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nlet node_name = \"ENSP00000000233\";\nprintln!(\"The neighbours of the node {} are {:?}.\", node_name, graph.get_neighbour_node_ids_from_node_name(node_name).unwrap());\n"
        },
        "extra_headers": []
    },
    "get_neighbour_node_names_from_node_name": {
        "file": "queries.rs",
        "function": "get_neighbour_node_names_from_node_name",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "node_name",
                    "type": "&str",
                    "desc": "Node name whose neighbours are to be retrieved"
                }
            ]
        },
        "example": {
            "desc": "To retrieve the neighbours of a given node `src` you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nlet node_name = \"ENSP00000000233\";\nprintln!(\"The neighbours of the node {} are {:?}.\", node_name, graph.get_neighbour_node_names_from_node_name(node_name).unwrap());\n"
        },
        "extra_headers": []
    },
    "get_minmax_edge_ids_from_node_ids": {
        "file": "queries.rs",
        "function": "get_minmax_edge_ids_from_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "Source node"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": "Destination node"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_id_from_node_ids_and_edge_type_id": {
        "file": "queries.rs",
        "function": "get_edge_id_from_node_ids_and_edge_type_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "Source node of the edge"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": "Destination node of the edge"
                },
                {
                    "name": "edge_type",
                    "type": "Option<EdgeTypeT>",
                    "desc": "Edge Type of the edge"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_id_from_node_names": {
        "file": "queries.rs",
        "function": "get_edge_id_from_node_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src_name",
                    "type": "&str",
                    "desc": "Source node name of the edge"
                },
                {
                    "name": "dst_name",
                    "type": "&str",
                    "desc": "Destination node name of the edge"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_id_from_node_names_and_edge_type_name": {
        "file": "queries.rs",
        "function": "get_edge_id_from_node_names_and_edge_type_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src_name",
                    "type": "&str",
                    "desc": "Source node name of the edge"
                },
                {
                    "name": "dst_name",
                    "type": "&str",
                    "desc": "Destination node name of the edge"
                },
                {
                    "name": "edge_type_name",
                    "type": "Option<&str>",
                    "desc": "Edge type name"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_type_ids_from_edge_type_names": {
        "file": "queries.rs",
        "function": "get_edge_type_ids_from_edge_type_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_names",
                    "type": "Vec<Option<String>>",
                    "desc": "Vector of edge types to be converted"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_type_ids_from_node_type_names": {
        "file": "queries.rs",
        "function": "get_node_type_ids_from_node_type_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_names",
                    "type": "Vec<Option<String>>",
                    "desc": "Vector of node types to be converted"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_multiple_node_type_ids_from_node_type_names": {
        "file": "queries.rs",
        "function": "get_multiple_node_type_ids_from_node_type_names",
        "errors": [
            {
                "doc_line": 6,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_names",
                    "type": "Vec<Option<Vec<&str>>>",
                    "desc": "Vector of node types to be converted"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n* If any of the given node type names do not exists in the graph.\n"
            }
        ]
    },
    "get_unchecked_minmax_edge_ids_from_source_node_id": {
        "file": "queries.rs",
        "function": "get_unchecked_minmax_edge_ids_from_source_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "Node for which we need to compute the cumulative_node_degrees range"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_minmax_edge_ids_from_source_node_id": {
        "file": "queries.rs",
        "function": "get_minmax_edge_ids_from_source_node_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "Node for which we need to compute the cumulative_node_degrees range"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_type_name_from_node_type_id": {
        "file": "queries.rs",
        "function": "get_node_type_name_from_node_type_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_id",
                    "type": "NodeTypeT",
                    "desc": "Id of the node type"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_unchecked_node_type_names_from_node_type_ids": {
        "file": "queries.rs",
        "function": "get_unchecked_node_type_names_from_node_type_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_ids",
                    "type": "Vec<NodeTypeT>",
                    "desc": "Id of the node type"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "filter_from_ids": {
        "file": "filters.rs",
        "function": "filter_from_ids",
        "errors": [
            {
                "doc_line": 23,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_ids_to_keep",
                    "type": "Option<Vec<NodeT>>",
                    "desc": "List of node IDs to keep during filtering"
                },
                {
                    "name": "node_ids_to_filter",
                    "type": "Option<Vec<NodeT>>",
                    "desc": "List of node IDs to remove during filtering"
                },
                {
                    "name": "node_type_ids_to_keep",
                    "type": "Option<Vec<Option<Vec<NodeTypeT>>>>",
                    "desc": "List of node type IDs to keep during filtering. The node types must match entirely the given node types vector provided"
                },
                {
                    "name": "node_type_ids_to_filter",
                    "type": "Option<Vec<Option<Vec<NodeTypeT>>>>",
                    "desc": "List of node type IDs to remove during filtering. The node types must match entirely the given node types vector provided"
                },
                {
                    "name": "node_type_id_to_keep",
                    "type": "Option<Vec<Option<NodeTypeT>>>",
                    "desc": "List of node type IDs to keep during filtering. Any of node types must match with one of the node types given"
                },
                {
                    "name": "node_type_id_to_filter",
                    "type": "Option<Vec<Option<NodeTypeT>>>",
                    "desc": "List of node type IDs to remove during filtering. Any of node types must match with one of the node types given"
                },
                {
                    "name": "edge_ids_to_keep",
                    "type": "Option<Vec<EdgeT>>",
                    "desc": "List of edge IDs to keep during filtering"
                },
                {
                    "name": "edge_ids_to_filter",
                    "type": "Option<Vec<EdgeT>>",
                    "desc": "List of edge IDs to remove during filtering"
                },
                {
                    "name": "edge_node_ids_to_keep",
                    "type": "Option<Vec<(NodeT, NodeT)>>",
                    "desc": "List of tuple of node IDs to keep during filtering"
                },
                {
                    "name": "edge_node_ids_to_filter",
                    "type": "Option<Vec<(NodeT, NodeT)>>",
                    "desc": "List of tuple of node IDs to remove during filtering"
                },
                {
                    "name": "edge_type_ids_to_keep",
                    "type": "Option<Vec<Option<EdgeTypeT>>>",
                    "desc": "List of edge type IDs to keep during filtering"
                },
                {
                    "name": "edge_type_ids_to_filter",
                    "type": "Option<Vec<Option<EdgeTypeT>>>",
                    "desc": "List of edge type IDs to remove during filtering"
                },
                {
                    "name": "min_edge_weight",
                    "type": "Option<WeightT>",
                    "desc": "Minimum edge weight. Values lower than this are removed"
                },
                {
                    "name": "max_edge_weight",
                    "type": "Option<WeightT>",
                    "desc": "Maximum edge weight. Values higher than this are removed"
                },
                {
                    "name": "filter_singleton_nodes",
                    "type": "bool",
                    "desc": "Whether to filter out singleton nodes"
                },
                {
                    "name": "filter_singleton_nodes_with_selfloop",
                    "type": "bool",
                    "desc": "Whether to filter out singleton nodes with selfloops"
                },
                {
                    "name": "filter_selfloops",
                    "type": "bool",
                    "desc": "Whether to filter out selfloops"
                },
                {
                    "name": "filter_parallel_edges",
                    "type": "bool",
                    "desc": "Whether to filter out parallel edges"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show loading bar while building the graphs"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "# Implementation details",
                "content": ""
            },
            {
                "name": "## How the collapse of multigraphs is handled",
                "content": "We keep only the first edge when a multigraph is collapsed while removing\nthe edge types, in the order provided when first reading from the CSV file.\n"
            },
            {
                "name": "## Generation of new singleton nodes when removing edges",
                "content": "Some of the remove operations allowed in this method might lead to the\ngeneration of new singleton nodes that will not be handled within this\nfunction call even if you provide the flag singletons to true, but you\nwill need to call the method again if you want to get reed of also those\nnewly created singleton nodes.\n"
            }
        ]
    },
    "filter_from_names": {
        "file": "filters.rs",
        "function": "filter_from_names",
        "errors": [
            {
                "doc_line": 21,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_names_to_keep",
                    "type": "Option<Vec<&str>>",
                    "desc": "List of node names to keep during filtering"
                },
                {
                    "name": "node_names_to_filter",
                    "type": "Option<Vec<&str>>",
                    "desc": "List of node names to remove during filtering"
                },
                {
                    "name": "node_type_names_to_keep",
                    "type": "Option<Vec<Option<Vec<&str>>>>",
                    "desc": "List of node type names to keep during filtering. The node types must match entirely the given node types vector provided"
                },
                {
                    "name": "node_type_names_to_filter",
                    "type": "Option<Vec<Option<Vec<&str>>>>",
                    "desc": "List of node type names to remove during filtering. The node types must match entirely the given node types vector provided"
                },
                {
                    "name": "node_type_name_to_keep",
                    "type": "Option<Vec<Option<String>>>",
                    "desc": "List of node type name to keep during filtering. Any of node types must match with one of the node types given"
                },
                {
                    "name": "node_type_name_to_filter",
                    "type": "Option<Vec<Option<String>>>",
                    "desc": "List of node type name to remove during filtering. Any of node types must match with one of the node types given"
                },
                {
                    "name": "edge_node_names_to_keep",
                    "type": "Option<Vec<(&str, &str)>>",
                    "desc": "List of tuple of node names to keep during filtering"
                },
                {
                    "name": "edge_node_names_to_filter",
                    "type": "Option<Vec<(&str, &str)>>",
                    "desc": "List of tuple of node names to remove during filtering"
                },
                {
                    "name": "edge_type_names_to_keep",
                    "type": "Option<Vec<Option<String>>>",
                    "desc": "List of edge type names to keep during filtering"
                },
                {
                    "name": "edge_type_names_to_filter",
                    "type": "Option<Vec<Option<String>>>",
                    "desc": "List of edge type names to remove during filtering"
                },
                {
                    "name": "min_edge_weight",
                    "type": "Option<WeightT>",
                    "desc": "Minimum edge weight. Values lower than this are removed"
                },
                {
                    "name": "max_edge_weight",
                    "type": "Option<WeightT>",
                    "desc": "Maximum edge weight. Values higher than this are removed"
                },
                {
                    "name": "filter_singleton_nodes",
                    "type": "bool",
                    "desc": "Whether to filter out singletons"
                },
                {
                    "name": "filter_singleton_nodes_with_selfloop",
                    "type": "bool",
                    "desc": "Whether to filter out singleton nodes with selfloops"
                },
                {
                    "name": "filter_selfloops",
                    "type": "bool",
                    "desc": "Whether to filter out selfloops"
                },
                {
                    "name": "filter_parallel_edges",
                    "type": "bool",
                    "desc": "Whether to filter out parallel edges"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show loading bar while building the graphs"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "# Implementation details",
                "content": ""
            },
            {
                "name": "## How the collapse of multigraphs is handled",
                "content": "We keep only the first edge when a multigraph is collapsed while removing\nthe edge types, in the order provided when first reading from the CSV file.\n"
            },
            {
                "name": "## Generation of new singleton nodes when removing edges",
                "content": "Some of the remove operations allowed in this method might lead to the\ngeneration of new singleton nodes that will not be handled within this\nfunction call even if you provide the flag singletons to true, but you\nwill need to call the method again if you want to get reed of also those\nnewly created singleton nodes.\n"
            }
        ]
    },
    "drop_unknown_node_types": {
        "file": "filters.rs",
        "function": "drop_unknown_node_types",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar while building the graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "drop_unknown_edge_types": {
        "file": "filters.rs",
        "function": "drop_unknown_edge_types",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar while building the graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "drop_singleton_nodes": {
        "file": "filters.rs",
        "function": "drop_singleton_nodes",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar while building the graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "drop_singleton_nodes_with_selfloops": {
        "file": "filters.rs",
        "function": "drop_singleton_nodes_with_selfloops",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar while building the graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "drop_selfloops": {
        "file": "filters.rs",
        "function": "drop_selfloops",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar while building the graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "drop_parallel_edges": {
        "file": "filters.rs",
        "function": "drop_parallel_edges",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar while building the graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "from_usize": {
        "file": "types.rs",
        "function": "from_usize",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "read": {
        "file": "types.rs",
        "function": "read",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "write": {
        "file": "types.rs",
        "function": "write",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "clone": {
        "file": "types.rs",
        "function": "clone",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "validate_node_id": {
        "file": "validators.rs",
        "function": "validate_node_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "node_id",
                    "type": "NodeT",
                    "desc": "node ID to validate"
                }
            ]
        },
        "example": {
            "desc": "In order to validate a given node ID, you can use the following:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert!(graph.validate_node_id(0).is_ok());\nassert!(graph.validate_node_id(100000000).is_err());\n"
        },
        "extra_headers": []
    },
    "validate_edge_id": {
        "file": "validators.rs",
        "function": "validate_edge_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "edge_id",
                    "type": "EdgeT",
                    "desc": "Edge ID to validate"
                }
            ]
        },
        "example": {
            "desc": "In order to validate a given edge ID, you can use the following:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert!(graph.validate_edge_id(0).is_ok());\nassert!(graph.validate_edge_id(10000000000).is_err());\n"
        },
        "extra_headers": []
    },
    "validate_node_type_id": {
        "file": "validators.rs",
        "function": "validate_node_type_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "node_type_id",
                    "type": "Option<NodeTypeT>",
                    "desc": "Node type ID to validate"
                }
            ]
        },
        "example": {
            "desc": "In order to validate a given node type ID, you can use the following:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert!(graph.validate_node_type_id(Some(0)).is_ok());\nassert!(graph.validate_node_type_id(Some(1000)).is_err());\n"
        },
        "extra_headers": []
    },
    "validate_node_type_ids": {
        "file": "validators.rs",
        "function": "validate_node_type_ids",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_ids",
                    "type": "Vec<Option<NodeTypeT>>",
                    "desc": "Vector of node type IDs to validate"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no node types in the graph.\n"
            }
        ]
    },
    "validate_edge_type_id": {
        "file": "validators.rs",
        "function": "validate_edge_type_id",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "edge_type_id",
                    "type": "Option<EdgeTypeT>",
                    "desc": "edge type ID to validate"
                }
            ]
        },
        "example": {
            "desc": "In order to validate a given edge type ID, you can use the following:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert!(graph.validate_edge_type_id(Some(0)).is_ok());\nassert!(graph.validate_edge_type_id(Some(1000)).is_err());\n"
        },
        "extra_headers": []
    },
    "validate_edge_type_ids": {
        "file": "validators.rs",
        "function": "validate_edge_type_ids",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_ids",
                    "type": "Vec<Option<EdgeTypeT>>",
                    "desc": "Vector of edge type IDs to validate"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no edge types in the graph.\n"
            }
        ]
    },
    "must_have_node_types": {
        "file": "validators.rs",
        "function": "must_have_node_types",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "In order to validate a graph instance, you can use:\n",
            "content": "```rust# let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);\n# let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nassert!(graph_with_node_types.must_have_node_types().is_ok());\nassert!(graph_without_node_types.must_have_node_types().is_err());\n"
        },
        "extra_headers": []
    },
    "must_have_edge_types": {
        "file": "validators.rs",
        "function": "must_have_edge_types",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "In order to validate a graph instance, you can use:\n",
            "content": "```rust# let graph_with_edge_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);\n# let graph_without_edge_types = graph::test_utilities::load_ppi(false, false, true, true, false, false);\nassert!(graph_with_edge_types.must_have_edge_types().is_ok());\nassert!(graph_without_edge_types.must_have_edge_types().is_err());\n"
        },
        "extra_headers": []
    },
    "must_be_undirected": {
        "file": "validators.rs",
        "function": "must_be_undirected",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "In order to validate a graph instance, you can use:\n",
            "content": "```rust# let undirecte_graph = graph::test_utilities::load_ppi(false, false, false, false, false, false);\n# let directed_graph = graph::test_utilities::load_ppi(false, false, true, true, false, false);\nassert!(undirecte_graph.must_be_undirected().is_ok());\nassert!(directed_graph.must_be_undirected().is_err());\n"
        },
        "extra_headers": []
    },
    "must_be_multigraph": {
        "file": "validators.rs",
        "function": "must_be_multigraph",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "In order to validate a graph instance, you can use:\n",
            "content": "```rust# let multigraph = graph::test_utilities::load_ppi(false, true, false, false, false, false);\n# let homogeneous = graph::test_utilities::load_ppi(false, false, false, false, false, false);\nassert!(multigraph.must_be_multigraph().is_ok());\nassert!(homogeneous.must_be_multigraph().is_err());\n"
        },
        "extra_headers": []
    },
    "must_not_be_multigraph": {
        "file": "validators.rs",
        "function": "must_not_be_multigraph",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "In order to validate a graph instance, you can use:\n",
            "content": "```rust# let multigraph = graph::test_utilities::load_ppi(false, true, false, false, false, false);\n# let homogeneous = graph::test_utilities::load_ppi(false, false, false, false, false, false);\nassert!(multigraph.must_not_be_multigraph().is_err());\nassert!(homogeneous.must_not_be_multigraph().is_ok());\n"
        },
        "extra_headers": []
    },
    "must_have_edge_weights": {
        "file": "validators.rs",
        "function": "must_have_edge_weights",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "In order to validate a graph instance, you can use:\n",
            "content": "```rust# let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);\n# let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);\nassert!(graph_with_weights.must_have_edge_weights().is_ok());\nassert!(graph_without_weights.must_have_edge_weights().is_err());\n"
        },
        "extra_headers": []
    },
    "must_have_edges": {
        "file": "validators.rs",
        "function": "must_have_edges",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "In order to validate a graph instance, you can use:\n",
            "content": "```rust# let graph_with_edges = graph::test_utilities::load_ppi(false, false, true, true, false, false);\n# let graph_without_edges = graph::test_utilities::load_empty_graph(false);\nassert!(graph_with_edges.must_have_edges().is_ok());\nassert!(graph_without_edges.must_have_edges().is_err());\n"
        },
        "extra_headers": []
    },
    "must_have_nodes": {
        "file": "validators.rs",
        "function": "must_have_nodes",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "In order to validate a graph instance, you can use:\n",
            "content": "```rust# let graph_with_nodes = graph::test_utilities::load_ppi(false, false, true, true, false, false);\n# let graph_without_nodes = graph::test_utilities::load_empty_graph(false);\nassert!(graph_with_nodes.must_have_nodes().is_ok());\nassert!(graph_without_nodes.must_have_nodes().is_err());\n"
        },
        "extra_headers": []
    },
    "degrees_product": {
        "file": "metrics.rs",
        "function": "degrees_product",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "one",
                    "type": "NodeT",
                    "desc": "Integer ID of the first node"
                },
                {
                    "name": "two",
                    "type": "NodeT",
                    "desc": "Integer ID of the second node"
                }
            ],
            "footer": "=\n"
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The degrees_product between 0 and 1 is {}\", graph.degrees_product(0, 1).unwrap());\n"
        },
        "extra_headers": []
    },
    "jaccard_index": {
        "file": "metrics.rs",
        "function": "jaccard_index",
        "errors": [
            {
                "doc_line": 7,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "one",
                    "type": "NodeT",
                    "desc": "Integer ID of the first node"
                },
                {
                    "name": "two",
                    "type": "NodeT",
                    "desc": "Integer ID of the second node"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "References",
                "content": "[D. Liben-Nowell, J. Kleinberg.\nThe Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)\n"
            },
            {
                "name": "Example",
                "content": "```rust\n"
            },
            {
                "name": "let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                "content": "println!(\"The Jaccard Index between node 1 and node 2 is {}\", graph.jaccard_index(1, 2).unwrap());\n```\n"
            }
        ]
    },
    "adamic_adar_index": {
        "file": "metrics.rs",
        "function": "adamic_adar_index",
        "errors": [
            {
                "doc_line": 7,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "one",
                    "type": "NodeT",
                    "desc": "Integer ID of the first node"
                },
                {
                    "name": "two",
                    "type": "NodeT",
                    "desc": "Integer ID of the second node"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Implementation details",
                "content": "Since the Adamic/Adar Index is only defined for graph not containing\nnode traps (nodes without any outbound edge) and must support all kind\nof graphs, the sinks node are excluded from\nthe computation because they would result in an infinity.\n"
            },
            {
                "name": "References",
                "content": "[D. Liben-Nowell, J. Kleinberg.\nThe Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)\n"
            },
            {
                "name": "Example",
                "content": "```rust\n"
            },
            {
                "name": "let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                "content": "println!(\"The Adamic/Adar Index between node 1 and node 2 is {}\", graph.adamic_adar_index(1, 2).unwrap());\n```\n"
            }
        ]
    },
    "resource_allocation_index": {
        "file": "metrics.rs",
        "function": "resource_allocation_index",
        "errors": [
            {
                "doc_line": 7,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "one",
                    "type": "NodeT",
                    "desc": "Integer ID of the first node"
                },
                {
                    "name": "two",
                    "type": "NodeT",
                    "desc": "Integer ID of the second node"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "References",
                "content": "[T. Zhou, L. Lu, Y.-C. Zhang.\nPredicting missing links via local information.\nEur. Phys. J. B 71 (2009) 623.](http://arxiv.org/pdf/0901.0553.pdf)\n"
            },
            {
                "name": "Implementation details",
                "content": "Since the Resource Allocation Index is only defined for graph not\ncontaining node traps (nodes without any outbound edge) and\nmust support all kind of graphs, the sinks node are excluded from\nthe computation because they would result in an infinity.\n"
            },
            {
                "name": "Example",
                "content": "```rust\n"
            },
            {
                "name": "let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                "content": "println!(\"The Resource Allocation Index between node 1 and node 2 is {}\", graph.resource_allocation_index(1, 2).unwrap());\n```\n"
            }
        ]
    },
    "remove_components": {
        "file": "remove.rs",
        "function": "remove_components",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_names",
                    "type": "Option<Vec<String>>",
                    "desc": "The name of the nodes of which components to keep"
                },
                {
                    "name": "node_types",
                    "type": "Option<Vec<Option<String>>>",
                    "desc": "The types of the nodes of which components to keep"
                },
                {
                    "name": "edge_types",
                    "type": "Option<Vec<Option<String>>>",
                    "desc": "The types of the edges of which components to keep"
                },
                {
                    "name": "minimum_component_size",
                    "type": "Option<NodeT>",
                    "desc": "Optional, Minimum size of the components to keep"
                },
                {
                    "name": "top_k_components",
                    "type": "Option<NodeT>",
                    "desc": "Optional, number of components to keep sorted by number of nodes"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show the loading bar"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "set_directed": {
        "file": "edge_file_writer.rs",
        "function": "set_directed",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "Option<bool>",
                    "desc": "Whether to write out the graph as directed or not"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "set_name": {
        "file": "setters.rs",
        "function": "set_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "name",
                    "type": "String",
                    "desc": "Name of the graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "invalidate_report": {
        "file": "setters.rs",
        "function": "invalidate_report",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_inplace_all_edge_types": {
        "file": "setters.rs",
        "function": "set_inplace_all_edge_types",
        "errors": [
            {
                "doc_line": 7,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type",
                    "type": "S",
                    "desc": "The edge type to assing to all the edges"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edges.\n* If the graph is a multigraph.\n"
            }
        ]
    },
    "set_all_edge_types": {
        "file": "setters.rs",
        "function": "set_all_edge_types",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type",
                    "type": "S",
                    "desc": "The edge type to assing to all the edges"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar in the case of a multigraph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "set_inplace_all_node_types": {
        "file": "setters.rs",
        "function": "set_inplace_all_node_types",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type",
                    "type": "S",
                    "desc": "The node type to assing to all the nodes"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "set_all_node_types": {
        "file": "setters.rs",
        "function": "set_all_node_types",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type",
                    "type": "S",
                    "desc": "The node type to assing to all the nodes"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "remove_inplace_node_type_id": {
        "file": "setters.rs",
        "function": "remove_inplace_node_type_id",
        "errors": [
            {
                "doc_line": 8,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_id",
                    "type": "NodeTypeT",
                    "desc": "The node type ID to remove"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n* If the given node type ID does not exists in the graph.\n"
            }
        ]
    },
    "remove_inplace_singleton_node_types": {
        "file": "setters.rs",
        "function": "remove_inplace_singleton_node_types",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n"
            }
        ]
    },
    "remove_inplace_edge_type_id": {
        "file": "setters.rs",
        "function": "remove_inplace_edge_type_id",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_id",
                    "type": "EdgeTypeT",
                    "desc": "The edge type ID to remove"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph is a multigraph.\n* If the graph does not have edge types.\n* If the given edge type ID does not exists in the graph.\n"
            }
        ]
    },
    "remove_inplace_singleton_edge_types": {
        "file": "setters.rs",
        "function": "remove_inplace_singleton_edge_types",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n"
            }
        ]
    },
    "remove_inplace_node_type_name": {
        "file": "setters.rs",
        "function": "remove_inplace_node_type_name",
        "errors": [
            {
                "doc_line": 8,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_name",
                    "type": "&str",
                    "desc": "The node type ID to remove"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n* If the given node type name does not exists in the graph.\n"
            }
        ]
    },
    "remove_node_type_id": {
        "file": "setters.rs",
        "function": "remove_node_type_id",
        "errors": [
            {
                "doc_line": 8,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_id",
                    "type": "NodeTypeT",
                    "desc": "The node type ID to remove"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n* If the given node type ID does not exists in the graph.\n"
            }
        ]
    },
    "remove_singleton_node_types": {
        "file": "setters.rs",
        "function": "remove_singleton_node_types",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n"
            }
        ]
    },
    "remove_node_type_name": {
        "file": "setters.rs",
        "function": "remove_node_type_name",
        "errors": [
            {
                "doc_line": 8,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_name",
                    "type": "&str",
                    "desc": "The node type ID to remove"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n* If the given node type name does not exists in the graph.\n"
            }
        ]
    },
    "remove_inplace_edge_type_name": {
        "file": "setters.rs",
        "function": "remove_inplace_edge_type_name",
        "errors": [
            {
                "doc_line": 8,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_name",
                    "type": "&str",
                    "desc": "The edge type ID to remove"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n* If the given edge type name does not exists in the graph.\n"
            }
        ]
    },
    "remove_edge_type_id": {
        "file": "setters.rs",
        "function": "remove_edge_type_id",
        "errors": [
            {
                "doc_line": 8,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_id",
                    "type": "EdgeTypeT",
                    "desc": "The edge type ID to remove"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n* If the given edge type ID does not exists in the graph.\n"
            }
        ]
    },
    "remove_singleton_edge_types": {
        "file": "setters.rs",
        "function": "remove_singleton_edge_types",
        "errors": [
            {
                "doc_line": 5,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n"
            }
        ]
    },
    "remove_edge_type_name": {
        "file": "setters.rs",
        "function": "remove_edge_type_name",
        "errors": [
            {
                "doc_line": 8,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_name",
                    "type": "&str",
                    "desc": "The edge type ID to remove"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n* If the given edge type name does not exists in the graph.\n"
            }
        ]
    },
    "remove_inplace_node_types": {
        "file": "setters.rs",
        "function": "remove_inplace_node_types",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n"
            }
        ]
    },
    "remove_node_types": {
        "file": "setters.rs",
        "function": "remove_node_types",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n"
            }
        ]
    },
    "remove_inplace_edge_types": {
        "file": "setters.rs",
        "function": "remove_inplace_edge_types",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n* If the graph is a multigraph.\n"
            }
        ]
    },
    "remove_edge_types": {
        "file": "setters.rs",
        "function": "remove_edge_types",
        "errors": [
            {
                "doc_line": 7,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar in the case of a multigraph"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n"
            }
        ]
    },
    "remove_inplace_edge_weights": {
        "file": "setters.rs",
        "function": "remove_inplace_edge_weights",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge weights.\n"
            }
        ]
    },
    "remove_edge_weights": {
        "file": "setters.rs",
        "function": "remove_edge_weights",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge weights.\n"
            }
        ]
    },
    "update_return_weight_transition": {
        "file": "walks.rs",
        "function": "update_return_weight_transition",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "rust_update_explore_weight_transition": {
        "file": "walks.rs",
        "function": "rust_update_explore_weight_transition",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "rust_update_return_explore_weight_transition": {
        "file": "walks.rs",
        "function": "rust_update_return_explore_weight_transition",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "update_explore_weight_transition": {
        "file": "walks.rs",
        "function": "update_explore_weight_transition",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "update_return_explore_weight_transition": {
        "file": "walks.rs",
        "function": "update_return_explore_weight_transition",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_update_explore_weight_transition": {
        "file": "walks.rs",
        "function": "test_update_explore_weight_transition",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_update_return_explore_weight_transition": {
        "file": "walks.rs",
        "function": "test_update_return_explore_weight_transition",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "test_update_return_weight_transition": {
        "file": "walks.rs",
        "function": "test_update_return_weight_transition",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_weighted_transitions": {
        "file": "walks.rs",
        "function": "get_edge_weighted_transitions",
        "errors": [
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'probabilistic_indices'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "min_edge_id",
                    "type": "EdgeT",
                    "desc": "The minimum edge id"
                },
                {
                    "name": "max_edge_id",
                    "type": "EdgeT",
                    "desc": "The maximum edge id"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "update_node_transition": {
        "file": "walks.rs",
        "function": "update_node_transition",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node",
                    "type": "NodeT",
                    "desc": "Source node"
                },
                {
                    "name": "transition",
                    "type": "&mut Vec<WeightT>",
                    "desc": "Vector of transitions to update"
                },
                {
                    "name": "destinations",
                    "type": "impl Iterator<Item = NodeT>",
                    "desc": "Iterator of the destinations"
                },
                {
                    "name": "change_node_type_weight",
                    "type": "ParamsT",
                    "desc": "The weight to multiply the transition by if there is a change of node type"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_transition": {
        "file": "walks.rs",
        "function": "get_node_transition",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* `node`: NodeT, the previous node from which to compute the transitions, if this is bigger that the number of nodes it will panic.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": 5,
                "msg": "The argument line '* `walk_weights`: WalkWeights, the weights for the weighted random walks.' (doc_line: 5) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'probabilistic_indices'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'max_edge_id'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'destinations'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'min_edge_id'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'walk_weights'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_transition": {
        "file": "walks.rs",
        "function": "get_edge_transition",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument 'edge' does not exists in the current method. The available args are ['src', 'dst', 'edge_id', 'walk_weights', 'min_edge_id', 'max_edge_id', 'destinations', 'previous_destinations', 'probabilistic_indices', 'has_selfloop']."
            },
            {
                "doc_line": 5,
                "msg": "The argument 'weights' does not exists in the current method. The available args are ['src', 'dst', 'edge_id', 'walk_weights', 'min_edge_id', 'max_edge_id', 'destinations', 'previous_destinations', 'probabilistic_indices', 'has_selfloop']."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'previous_destinations'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'src'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'edge_id'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'walk_weights'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'probabilistic_indices'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'destinations'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'has_selfloop'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'min_edge_id'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'dst'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'max_edge_id'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "extract_uniform_node": {
        "file": "walks.rs",
        "function": "extract_uniform_node",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* `node`: NodeT, the previous node from which to compute the transitions.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": 5,
                "msg": "The argument line '* `random_state`: u64, the random_state to use for extracting the node.' (doc_line: 5) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'random_state'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "extract_node": {
        "file": "walks.rs",
        "function": "extract_node",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* `node`: NodeT, the previous node from which to compute the transitions.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": 5,
                "msg": "The argument line '* `random_state`: usize, the random_state to use for extracting the node.' (doc_line: 5) is not in the standard format."
            },
            {
                "doc_line": 6,
                "msg": "The argument line '* `walk_weights`: WalkWeights, the weights for the weighted random walks.' (doc_line: 6) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'probabilistic_indices'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'max_edge_id'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'destinations'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'random_state'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'min_edge_id'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'walk_weights'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "extract_edge": {
        "file": "walks.rs",
        "function": "extract_edge",
        "errors": [
            {
                "doc_line": 7,
                "msg": "The argument type 'NodeT' of 'random_state' does not match the function declaration which is 'u64'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'random_state'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "Current source node id"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": "Current destination node id"
                },
                {
                    "name": "edge",
                    "type": "EdgeT",
                    "desc": "Current edge id"
                },
                {
                    "name": "walk_weights",
                    "type": "&WalkWeights",
                    "desc": "Struct with the weights to use to update the transitions"
                },
                {
                    "name": "min_edge_id",
                    "type": "EdgeT",
                    "desc": "Minimum edge id to sample for given destination node id"
                },
                {
                    "name": "max_edge_id",
                    "type": "EdgeT",
                    "desc": "Maximum edge id to sample for given destination node id"
                },
                {
                    "name": "destinations",
                    "type": "&[NodeT]",
                    "desc": "Current destinations slice"
                },
                {
                    "name": "previous_destinations",
                    "type": "&[NodeT]",
                    "desc": "Previous destination slice"
                },
                {
                    "name": "probabilistic_indices",
                    "type": "&Option<Vec<u64>>",
                    "desc": "Probabilistic indices, used when max neighbours is provided"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_random_walks": {
        "file": "walks.rs",
        "function": "iter_random_walks",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "quantity",
                    "type": "NodeT",
                    "desc": "Number of random walk to compute"
                },
                {
                    "name": "parameters",
                    "type": "&'a WalksParameters",
                    "desc": "the weighted walks parameters"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_complete_walks": {
        "file": "walks.rs",
        "function": "iter_complete_walks",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "parameters",
                    "type": "&'a WalksParameters",
                    "desc": "the weighted walks parameters"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_walk": {
        "file": "walks.rs",
        "function": "iter_walk",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument type 'WalksParameters' of 'parameters' does not match the function declaration which is '&'a WalksParameters'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'to_node'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'quantity'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'parameters'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "single_walk": {
        "file": "walks.rs",
        "function": "single_walk",
        "errors": [
            {
                "doc_line": 6,
                "msg": "The argument line '* node: NodeT - Node from where to start the random walks.' (doc_line: 6) is not in the standard format."
            },
            {
                "doc_line": 7,
                "msg": "The argument line '* `random_state`: usize, the random_state to use for extracting the nodes and edges.' (doc_line: 7) is not in the standard format."
            },
            {
                "doc_line": 8,
                "msg": "The argument type 'SingleWalkParameters' of 'parameters' does not match the function declaration which is '&SingleWalkParameters'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'random_state'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'parameters'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "uniform_walk": {
        "file": "walks.rs",
        "function": "uniform_walk",
        "errors": [
            {
                "doc_line": 6,
                "msg": "The argument line '* node: NodeT - Node from where to start the random walks.' (doc_line: 6) is not in the standard format."
            },
            {
                "doc_line": 7,
                "msg": "The argument type 'usize' of 'random_state' does not match the function declaration which is 'u64'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'random_state'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "walk_length",
                    "type": "u64",
                    "desc": "Length of the random walk"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "encode_edge": {
        "file": "compression.rs",
        "function": "encode_edge",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "src",
                    "type": "NodeT",
                    "desc": "The source node ID"
                },
                {
                    "name": "dst",
                    "type": "NodeT",
                    "desc": "The destination node ID"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "encode_max_edge": {
        "file": "compression.rs",
        "function": "encode_max_edge",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "decode_edge": {
        "file": "compression.rs",
        "function": "decode_edge",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge",
                    "type": "u64",
                    "desc": "The edge value to decode"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_bits": {
        "file": "compression.rs",
        "function": "get_node_bits",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_max_encodable_edge_number": {
        "file": "compression.rs",
        "function": "get_max_encodable_edge_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_bipartite_edges": {
        "file": "edge_lists.rs",
        "function": "get_bipartite_edges",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "removed_existing_edges",
                    "type": "Option<bool>",
                    "desc": "Whether to filter out the existing edges. By default, true"
                },
                {
                    "name": "first_nodes_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Optional set of nodes to use to create the first set of nodes of the graph"
                },
                {
                    "name": "second_nodes_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Optional set of nodes to use to create the second set of nodes of the graph"
                },
                {
                    "name": "first_node_types_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Optional set of node types to create the first set of nodes of the graph"
                },
                {
                    "name": "second_node_types_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Optional set of node types to create the second set of nodes of the graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_bipartite_edge_names": {
        "file": "edge_lists.rs",
        "function": "get_bipartite_edge_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "removed_existing_edges",
                    "type": "Option<bool>",
                    "desc": "Whether to filter out the existing edges. By default, true"
                },
                {
                    "name": "first_nodes_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Optional set of nodes to use to create the first set of nodes of the graph"
                },
                {
                    "name": "second_nodes_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Optional set of nodes to use to create the second set of nodes of the graph"
                },
                {
                    "name": "first_node_types_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Optional set of node types to create the first set of nodes of the graph"
                },
                {
                    "name": "second_node_types_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Optional set of node types to create the second set of nodes of the graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_star_edges": {
        "file": "edge_lists.rs",
        "function": "get_star_edges",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "central_node",
                    "type": "String",
                    "desc": "Name of the node to use as center of the star"
                },
                {
                    "name": "removed_existing_edges",
                    "type": "Option<bool>",
                    "desc": "Whether to filter out the existing edges. By default, true"
                },
                {
                    "name": "star_points_nodes_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Optional set of nodes to use to create the set of star points"
                },
                {
                    "name": "star_points_node_types_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Optional set of node types to create the set of star points"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_star_edge_names": {
        "file": "edge_lists.rs",
        "function": "get_star_edge_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "central_node",
                    "type": "String",
                    "desc": "Name of the node to use as center of the star"
                },
                {
                    "name": "removed_existing_edges",
                    "type": "Option<bool>",
                    "desc": "Whether to filter out the existing edges. By default, true"
                },
                {
                    "name": "star_points_nodes_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Optional set of nodes to use to create the set of star points"
                },
                {
                    "name": "star_points_node_types_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Optional set of node types to create the set of star points"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_clique_edges": {
        "file": "edge_lists.rs",
        "function": "get_clique_edges",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "Option<bool>",
                    "desc": "Whether to return the edges as directed or undirected. By default, equal to the graph"
                },
                {
                    "name": "allow_selfloops",
                    "type": "Option<bool>",
                    "desc": "Whether to allow self-loops in the clique. By default, equal to the graph"
                },
                {
                    "name": "removed_existing_edges",
                    "type": "Option<bool>",
                    "desc": "Whether to filter out the existing edges. By default, true"
                },
                {
                    "name": "allow_node_type_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Node types to include in the clique"
                },
                {
                    "name": "allow_node_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Nodes to include i the clique"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_clique_edge_names": {
        "file": "edge_lists.rs",
        "function": "get_clique_edge_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "Option<bool>",
                    "desc": "Whether to return the edges as directed or undirected. By default, equal to the graph"
                },
                {
                    "name": "allow_selfloops",
                    "type": "Option<bool>",
                    "desc": "Whether to allow self-loops in the clique. By default, equal to the graph"
                },
                {
                    "name": "removed_existing_edges",
                    "type": "Option<bool>",
                    "desc": "Whether to filter out the existing edges. By default, true"
                },
                {
                    "name": "allow_node_type_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Node types to include in the clique"
                },
                {
                    "name": "allow_node_set",
                    "type": "Option<HashSet<String>>",
                    "desc": "Nodes to include i the clique"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "replace": {
        "file": "replace.rs",
        "function": "replace",
        "errors": [
            {
                "doc_line": 9,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_name_mapping",
                    "type": "Option<HashMap<String, String>>",
                    "desc": "The node names to replace"
                },
                {
                    "name": "node_type_name_mapping",
                    "type": "Option<HashMap<String, String>>",
                    "desc": "The node type names to replace"
                },
                {
                    "name": "node_type_names_mapping",
                    "type": "Option<HashMap<Option<Vec<String>>, Option<Vec<String>>>>",
                    "desc": "The node type names (as vectors) to replace"
                },
                {
                    "name": "edge_type_name_mapping",
                    "type": "Option<HashMap<Option<String>, Option<String>>>",
                    "desc": "The edge type names to replace"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the given node names mapping would lead to nodes duplication.\n"
            }
        ]
    },
    "replace_unknown_node_types_with_node_type_name": {
        "file": "replace.rs",
        "function": "replace_unknown_node_types_with_node_type_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_type_names",
                    "type": "Vec<String>",
                    "desc": "The node types to replace the unknown with"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "replace_unknown_edge_types_with_edge_type_name": {
        "file": "replace.rs",
        "function": "replace_unknown_edge_types_with_edge_type_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_type_name",
                    "type": "String",
                    "desc": "The edge type name to replace the unknown with"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "report": {
        "file": "report.rs",
        "function": "report",
        "errors": [
            {
                "doc_line": 18,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);",
                "content": "graph.report();\n```\n"
            }
        ]
    },
    "shared_components_number": {
        "file": "report.rs",
        "function": "shared_components_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "merged_components_number": {
        "file": "report.rs",
        "function": "merged_components_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "nodes_components",
                    "type": "&[NodeT]",
                    "desc": "Slice with the node components"
                },
                {
                    "name": "other",
                    "type": "&Graph",
                    "desc": "Graph from where to extract the edge list"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "overlap_textual_report": {
        "file": "report.rs",
        "function": "overlap_textual_report",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "other",
                    "type": "&Graph",
                    "desc": "graph to create overlap report with"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to shor the loading bars"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "format_list": {
        "file": "report.rs",
        "function": "format_list",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "format_node_list": {
        "file": "report.rs",
        "function": "format_node_list",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "node_list",
                    "type": "&[NodeT]",
                    "desc": "list of nodes to be formatted"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_peculiarities_report_markdown": {
        "file": "report.rs",
        "function": "get_peculiarities_report_markdown",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Arguments",
                "content": "* `verbose`: bool - Whether to show a loading bar in graph operations.\n"
            }
        ]
    },
    "textual_report": {
        "file": "report.rs",
        "function": "textual_report",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show loading bar"
                }
            ],
            "footer": "TODO: UPDATE THIS METHOD!\n"
        },
        "example": {},
        "extra_headers": []
    },
    "get_connected_components_number": {
        "file": "getters.rs",
        "function": "get_connected_components_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show a loading bar or not"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_singleton_nodes_number": {
        "file": "getters.rs",
        "function": "get_singleton_nodes_number",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The graph contains {} singleton nodes\", graph.get_singleton_nodes_number());\n"
        },
        "extra_headers": []
    },
    "get_singleton_node_ids": {
        "file": "getters.rs",
        "function": "get_singleton_node_ids",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The graph singleton node IDs are {:?}.\", graph.get_singleton_node_ids());\n"
        },
        "extra_headers": []
    },
    "get_singleton_node_names": {
        "file": "getters.rs",
        "function": "get_singleton_node_names",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The graph singleton node names are {:?}.\", graph.get_singleton_node_names());\n"
        },
        "extra_headers": []
    },
    "get_singleton_nodes_with_selfloops_number": {
        "file": "getters.rs",
        "function": "get_singleton_nodes_with_selfloops_number",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The graph contains {} singleton nodes with self-loops\", graph.get_singleton_nodes_with_selfloops_number());\n"
        },
        "extra_headers": []
    },
    "get_singleton_with_selfloops_node_ids": {
        "file": "getters.rs",
        "function": "get_singleton_with_selfloops_node_ids",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The graph singleton_with_selfloops node IDs are {:?}.\", graph.get_singleton_with_selfloops_node_ids());\n"
        },
        "extra_headers": []
    },
    "get_singleton_with_selfloops_node_names": {
        "file": "getters.rs",
        "function": "get_singleton_with_selfloops_node_names",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The graph singleton_with_selfloops node names are {:?}.\", graph.get_singleton_with_selfloops_node_names());\n"
        },
        "extra_headers": []
    },
    "get_not_singleton_nodes_number": {
        "file": "getters.rs",
        "function": "get_not_singleton_nodes_number",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The graph contains {} not singleton nodes\", graph.get_not_singleton_nodes_number());\n"
        },
        "extra_headers": []
    },
    "get_density": {
        "file": "getters.rs",
        "function": "get_density",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The graph density is {}\", graph.get_density().unwrap());\n"
        },
        "extra_headers": []
    },
    "get_trap_nodes_rate": {
        "file": "getters.rs",
        "function": "get_trap_nodes_rate",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The Graph rate is {}\", graph.get_trap_nodes_rate());\n"
        },
        "extra_headers": []
    },
    "get_node_degrees_mean": {
        "file": "getters.rs",
        "function": "get_node_degrees_mean",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The mean node degree of the graph is  {}\", graph.get_node_degrees_mean().unwrap());\n"
        },
        "extra_headers": []
    },
    "get_undirected_edges_number": {
        "file": "getters.rs",
        "function": "get_undirected_edges_number",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The number of undirected edges of the graph is  {}\", graph.get_undirected_edges_number());\n"
        },
        "extra_headers": []
    },
    "get_unique_undirected_edges_number": {
        "file": "getters.rs",
        "function": "get_unique_undirected_edges_number",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The number of unique undirected edges of the graph is  {}\", graph.get_unique_undirected_edges_number());\n"
        },
        "extra_headers": []
    },
    "get_edges_number": {
        "file": "getters.rs",
        "function": "get_edges_number",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The number of edges of the graph is  {}\", graph.get_edges_number());\n"
        },
        "extra_headers": []
    },
    "get_unique_edges_number": {
        "file": "getters.rs",
        "function": "get_unique_edges_number",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The number of edges of the graph is  {}\", graph.get_unique_edges_number());\n"
        },
        "extra_headers": []
    },
    "get_node_degrees_median": {
        "file": "getters.rs",
        "function": "get_node_degrees_median",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The median node degree of the graph is  {}\", graph.get_node_degrees_median().unwrap());\n"
        },
        "extra_headers": []
    },
    "get_max_node_degree": {
        "file": "getters.rs",
        "function": "get_max_node_degree",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The maximum node degree of the graph is  {}\", graph.get_max_node_degree().unwrap());\n"
        },
        "extra_headers": []
    },
    "get_min_node_degree": {
        "file": "getters.rs",
        "function": "get_min_node_degree",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The minimum node degree of the graph is  {}\", graph.get_min_node_degree().unwrap());\n"
        },
        "extra_headers": []
    },
    "get_node_degrees_mode": {
        "file": "getters.rs",
        "function": "get_node_degrees_mode",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The mode node degree of the graph is  {}\", graph.get_node_degrees_mode().unwrap());\n"
        },
        "extra_headers": []
    },
    "get_selfloop_number": {
        "file": "getters.rs",
        "function": "get_selfloop_number",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The number of self-loops in the graph is  {}\", graph.get_selfloop_number());\n"
        },
        "extra_headers": []
    },
    "get_unique_selfloop_number": {
        "file": "getters.rs",
        "function": "get_unique_selfloop_number",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The number of unique self-loops in the graph is  {}\", graph.get_unique_selfloop_number());\n"
        },
        "extra_headers": []
    },
    "get_selfloop_nodes_rate": {
        "file": "getters.rs",
        "function": "get_selfloop_nodes_rate",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The rate of self-loops in the graph is  {}\", graph.get_selfloop_nodes_rate().unwrap());\n"
        },
        "extra_headers": []
    },
    "get_name": {
        "file": "getters.rs",
        "function": "get_name",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To the retrieve the name of the current graph instance selfloop_number can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert_eq!(graph.get_name(), \"STRING PPI\".to_string());\nprintln!(\"The name of the current graph is {}.\", graph.get_name());\n"
        },
        "extra_headers": []
    },
    "get_trap_nodes_number": {
        "file": "getters.rs",
        "function": "get_trap_nodes_number",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"There are {} trap nodes in the current graph.\", graph.get_trap_nodes_number());\n"
        },
        "extra_headers": []
    },
    "get_source_node_ids": {
        "file": "getters.rs",
        "function": "get_source_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_source_names": {
        "file": "getters.rs",
        "function": "get_source_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_destination_node_ids": {
        "file": "getters.rs",
        "function": "get_destination_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_destination_names": {
        "file": "getters.rs",
        "function": "get_destination_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_names": {
        "file": "getters.rs",
        "function": "get_node_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_ids": {
        "file": "getters.rs",
        "function": "get_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_type_ids": {
        "file": "getters.rs",
        "function": "get_edge_type_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_unique_edge_type_ids": {
        "file": "getters.rs",
        "function": "get_unique_edge_type_ids",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To retrieve the unique edge type IDs of the graph edges you can use:\n",
            "content": "```rust# let graph_with_edge_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);\n# let graph_without_edge_types = graph::test_utilities::load_ppi(false, false, true, true, false, false);\nassert!(graph_with_edge_types.get_unique_edge_type_ids().is_ok());\nassert!(graph_without_edge_types.get_unique_edge_type_ids().is_err());\nprintln!(\"The graph edge types are {:?}\", graph_with_edge_types.get_unique_edge_type_ids());\n"
        },
        "extra_headers": []
    },
    "get_edge_type_names": {
        "file": "getters.rs",
        "function": "get_edge_type_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_unique_edge_type_names": {
        "file": "getters.rs",
        "function": "get_unique_edge_type_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_weights": {
        "file": "getters.rs",
        "function": "get_edge_weights",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To get an the graph weights you can use:\n",
            "content": "```rust# let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);\n# let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);\nassert!(graph_with_weights.get_edge_weights().is_ok());\nassert!(graph_without_weights.get_edge_weights().is_err());\nprintln!(\"The graph weights are {:?}.\", graph_with_weights.get_edge_weights());\n"
        },
        "extra_headers": []
    },
    "get_min_edge_weight": {
        "file": "getters.rs",
        "function": "get_min_edge_weight",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To get the minimum edge weight you can use:\n",
            "content": "```rust# let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);\n# let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);\nassert!(graph_with_weights.get_min_edge_weight().is_ok());\nassert!(graph_without_weights.get_min_edge_weight().is_err());\nprintln!(\"The graph minimum weight is {:?}.\", graph_with_weights.get_min_edge_weight());\n"
        },
        "extra_headers": []
    },
    "get_max_edge_weight": {
        "file": "getters.rs",
        "function": "get_max_edge_weight",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To get the maximum edge weight you can use:\n",
            "content": "```rust# let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);\n# let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);\nassert!(graph_with_weights.get_max_edge_weight().is_ok());\nassert!(graph_without_weights.get_max_edge_weight().is_err());\nprintln!(\"The graph maximum weight is {:?}.\", graph_with_weights.get_max_edge_weight());\n"
        },
        "extra_headers": []
    },
    "get_node_type_ids": {
        "file": "getters.rs",
        "function": "get_node_type_ids",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To retrieve the node type IDs of the graph nodes you can use:\n",
            "content": "```rust# let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);\n# let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nassert!(graph_with_node_types.get_node_type_ids().is_ok());\nassert!(graph_without_node_types.get_node_type_ids().is_err());\nprintln!(\"The graph node types are {:?}\", graph_with_node_types.get_node_type_ids());\n"
        },
        "extra_headers": []
    },
    "get_node_type_names": {
        "file": "getters.rs",
        "function": "get_node_type_names",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To retrieve the node type names of the graph nodes you can use:\n",
            "content": "```rust# let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);\n# let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nassert!(graph_with_node_types.get_node_type_names().is_ok());\nassert!(graph_without_node_types.get_node_type_names().is_err());\nprintln!(\"The graph node types are {:?}\", graph_with_node_types.get_node_type_names());\n"
        },
        "extra_headers": []
    },
    "get_unique_node_type_ids": {
        "file": "getters.rs",
        "function": "get_unique_node_type_ids",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To retrieve the unique node type IDs of the graph nodes you can use:\n",
            "content": "```rust# let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);\n# let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nassert!(graph_with_node_types.get_unique_node_type_ids().is_ok());\nassert!(graph_without_node_types.get_unique_node_type_ids().is_err());\nprintln!(\"The graph node types are {:?}\", graph_with_node_types.get_unique_node_type_ids());\n"
        },
        "extra_headers": []
    },
    "get_unique_node_type_names": {
        "file": "getters.rs",
        "function": "get_unique_node_type_names",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To retrieve the unique node type names of the graph nodes you can use:\n",
            "content": "```rust# let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);\n# let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);\nassert!(graph_with_node_types.get_unique_node_type_names().is_ok());\nassert!(graph_without_node_types.get_unique_node_type_names().is_err());\nprintln!(\"The graph node types are {:?}\", graph_with_node_types.get_unique_node_type_names());\n"
        },
        "extra_headers": []
    },
    "get_unique_directed_edges_number": {
        "file": "getters.rs",
        "function": "get_unique_directed_edges_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_nodes_mapping": {
        "file": "getters.rs",
        "function": "get_nodes_mapping",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_node_ids": {
        "file": "getters.rs",
        "function": "get_edge_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_node_names": {
        "file": "getters.rs",
        "function": "get_edge_node_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_unknown_node_types_number": {
        "file": "getters.rs",
        "function": "get_unknown_node_types_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_unknown_node_types_rate": {
        "file": "getters.rs",
        "function": "get_unknown_node_types_rate",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_minimum_node_types_number": {
        "file": "getters.rs",
        "function": "get_minimum_node_types_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_singleton_node_types_number": {
        "file": "getters.rs",
        "function": "get_singleton_node_types_number",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n"
            }
        ]
    },
    "get_singleton_node_type_ids": {
        "file": "getters.rs",
        "function": "get_singleton_node_type_ids",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n"
            }
        ]
    },
    "get_singleton_node_type_names": {
        "file": "getters.rs",
        "function": "get_singleton_node_type_names",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n"
            }
        ]
    },
    "get_unknown_edge_types_number": {
        "file": "getters.rs",
        "function": "get_unknown_edge_types_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_unknown_edge_types_rate": {
        "file": "getters.rs",
        "function": "get_unknown_edge_types_rate",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_minimum_edge_types_number": {
        "file": "getters.rs",
        "function": "get_minimum_edge_types_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_singleton_edge_types_number": {
        "file": "getters.rs",
        "function": "get_singleton_edge_types_number",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n"
            }
        ]
    },
    "get_singleton_edge_type_ids": {
        "file": "getters.rs",
        "function": "get_singleton_edge_type_ids",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n"
            }
        ]
    },
    "get_singleton_edge_type_names": {
        "file": "getters.rs",
        "function": "get_singleton_edge_type_names",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n"
            }
        ]
    },
    "get_nodes_number": {
        "file": "getters.rs",
        "function": "get_nodes_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_node_connected_component_ids": {
        "file": "getters.rs",
        "function": "get_node_connected_component_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show the loading bar"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_directed_edges_number": {
        "file": "getters.rs",
        "function": "get_directed_edges_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_edge_types_number": {
        "file": "getters.rs",
        "function": "get_edge_types_number",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no edge types in the current graph.\n"
            }
        ]
    },
    "get_node_types_number": {
        "file": "getters.rs",
        "function": "get_node_types_number",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no node types in the current graph.\n"
            }
        ]
    },
    "get_node_degrees": {
        "file": "getters.rs",
        "function": "get_node_degrees",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_not_singletons_node_ids": {
        "file": "getters.rs",
        "function": "get_not_singletons_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_dense_nodes_mapping": {
        "file": "getters.rs",
        "function": "get_dense_nodes_mapping",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_multigraph_edges_number": {
        "file": "getters.rs",
        "function": "get_multigraph_edges_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_cumulative_node_degrees": {
        "file": "getters.rs",
        "function": "get_cumulative_node_degrees",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_unique_source_nodes_number": {
        "file": "getters.rs",
        "function": "get_unique_source_nodes_number",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nprintln!(\"The number of sources of the graph (not trap nodes) is {}\", graph.get_unique_source_nodes_number());\n"
        },
        "extra_headers": []
    },
    "get_edge_type_id_counts_hashmap": {
        "file": "getters.rs",
        "function": "get_edge_type_id_counts_hashmap",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "In order to compute an hashmap of the edge type IDs you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nfor (edge_type_id, count) in graph.get_edge_type_id_counts_hashmap().unwrap().iter() {\nprintln!(\"edge type id {}: count: {}\", edge_type_id, count);\n}\n"
        },
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no edge types in the current graph instance.\n"
            }
        ]
    },
    "get_edge_type_names_counts_hashmap": {
        "file": "getters.rs",
        "function": "get_edge_type_names_counts_hashmap",
        "errors": [
            {
                "doc_line": 8,
                "msg": "In the example there isn't the current method!!!!"
            }
        ],
        "args": {
            "args": []
        },
        "example": {
            "desc": "In order to compute an hashmap of the edge type names you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nfor (edge_type_id, count) in graph.get_edge_type_id_counts_hashmap().unwrap().iter() {\nprintln!(\"edge type name {}: count: {}\", edge_type_id, count);\n}\n"
        },
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no edge types in the current graph instance.\n"
            }
        ]
    },
    "get_node_type_id_counts_hashmap": {
        "file": "getters.rs",
        "function": "get_node_type_id_counts_hashmap",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "In order to compute an hashmap of the node type IDs you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nfor (node_type_id, count) in graph.get_node_type_id_counts_hashmap().unwrap().iter() {\nprintln!(\"node type id {}: count: {}\", node_type_id, count);\n}\n"
        },
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no node types in the current graph instance.\n"
            }
        ]
    },
    "get_node_type_names_counts_hashmap": {
        "file": "getters.rs",
        "function": "get_node_type_names_counts_hashmap",
        "errors": [
            {
                "doc_line": 8,
                "msg": "In the example there isn't the current method!!!!"
            }
        ],
        "args": {
            "args": []
        },
        "example": {
            "desc": "In order to compute an hashmap of the node type names you can use:\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nfor (node_type_id, count) in graph.get_node_type_id_counts_hashmap().unwrap().iter() {\nprintln!(\"node type name {}: count: {}\", node_type_id, count);\n}\n"
        },
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no node types in the current graph instance.\n"
            }
        ]
    },
    "normalize_value": {
        "file": "vocabulary.rs",
        "function": "normalize_value",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "unchecked_insert": {
        "file": "vocabulary.rs",
        "function": "unchecked_insert",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "value",
                    "type": "String",
                    "desc": "The value to be inserted"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "insert": {
        "file": "vocabulary.rs",
        "function": "insert",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument type 'String' of 'value' does not match the function declaration which is 'S'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'value'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "build_reverse_mapping": {
        "file": "node_type_vocabulary.rs",
        "function": "build_reverse_mapping",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the terms mapping is found to be not dense.\n"
            }
        ]
    },
    "is_empty": {
        "file": "edge_type_vocabulary.rs",
        "function": "is_empty",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "unchecked_translate": {
        "file": "edge_type_vocabulary.rs",
        "function": "unchecked_translate",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "id",
                    "type": "EdgeTypeT",
                    "desc": "Id to be translated"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "translate": {
        "file": "edge_type_vocabulary.rs",
        "function": "translate",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "id",
                    "type": "EdgeTypeT",
                    "desc": "Id to be translated"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get": {
        "file": "edge_type_vocabulary.rs",
        "function": "get",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "key",
                    "type": "&str",
                    "desc": "the key whose Id is to be retrieved"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "keys": {
        "file": "edge_type_vocabulary.rs",
        "function": "keys",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "contains_key": {
        "file": "vocabulary.rs",
        "function": "contains_key",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "key",
                    "type": "&str",
                    "desc": "the key to check existance of"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "len": {
        "file": "edge_type_vocabulary.rs",
        "function": "len",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_numeric_ids": {
        "file": "edge_type_vocabulary.rs",
        "function": "set_numeric_ids",
        "errors": [
            {
                "doc_line": 3,
                "msg": "The argument line '* numeric_ids: bool - Whether to load the IDs as numeric' (doc_line: 3) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'numeric_ids'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "compute_hash": {
        "file": "hash.rs",
        "function": "compute_hash",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "eq": {
        "file": "hash.rs",
        "function": "eq",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "from_structs": {
        "file": "edge_type_vocabulary.rs",
        "function": "from_structs",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "build_counts": {
        "file": "edge_type_vocabulary.rs",
        "function": "build_counts",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "unchecked_insert_values": {
        "file": "node_type_vocabulary.rs",
        "function": "unchecked_insert_values",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "maybe_values",
                    "type": "Option<Vec<S>>",
                    "desc": "The values to be inserted"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "insert_values": {
        "file": "node_type_vocabulary.rs",
        "function": "insert_values",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "maybe_values",
                    "type": "Option<Vec<S>>",
                    "desc": "The values to be inserted"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "is_multilabel": {
        "file": "node_type_vocabulary.rs",
        "function": "is_multilabel",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "min_node_type_count": {
        "file": "node_type_vocabulary.rs",
        "function": "min_node_type_count",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_unknown_count": {
        "file": "edge_type_vocabulary.rs",
        "function": "get_unknown_count",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "unchecked_translate_vector": {
        "file": "node_type_vocabulary.rs",
        "function": "unchecked_translate_vector",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "ids",
                    "type": "Vec<NodeTypeT>",
                    "desc": "Node Type IDs to be translated"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "translate_vector": {
        "file": "node_type_vocabulary.rs",
        "function": "translate_vector",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "ids",
                    "type": "Vec<NodeTypeT>",
                    "desc": "Node Type IDs to be translated"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "set_skip_node_types_if_unavailable": {
        "file": "node_file_reader.rs",
        "function": "set_skip_node_types_if_unavailable",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* skip_node_types_if_unavailable: Option<bool> - Whether to skip node_types if they are not available.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'skip_node_types_if_unavailable'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_might_contain_singleton_nodes": {
        "file": "node_file_reader.rs",
        "function": "set_might_contain_singleton_nodes",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "might_contain_singletons",
                    "type": "Option<bool>",
                    "desc": "Whether this graph has singletons"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "set_default_node_type": {
        "file": "node_file_reader.rs",
        "function": "set_default_node_type",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* default_node_type: Option<String> - The node type to use when node type is missing.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'default_node_type'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_numeric_node_type_ids": {
        "file": "node_file_reader.rs",
        "function": "set_numeric_node_type_ids",
        "errors": [
            {
                "doc_line": 4,
                "msg": "The argument line '* numeric_node_type_ids: Option<bool> - Whether to convert numeric node type Ids to Node Type Ids.' (doc_line: 4) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'numeric_node_type_ids'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "set_node_types_separator": {
        "file": "node_file_reader.rs",
        "function": "set_node_types_separator",
        "errors": [
            {
                "doc_line": 13,
                "msg": "The argument line '* node_types_separator: Option<String> - The separator to use for the node types column.' (doc_line: 13) is not in the standard format."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node_types_separator'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "has_node_types": {
        "file": "getters_boolean.rs",
        "function": "has_node_types",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "from_option_structs": {
        "file": "edge_type_vocabulary.rs",
        "function": "from_option_structs",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "min_edge_type_count": {
        "file": "edge_type_vocabulary.rs",
        "function": "min_edge_type_count",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_node_ids": {
        "file": "iters.rs",
        "function": "iter_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unique_node_type_ids": {
        "file": "iters.rs",
        "function": "iter_unique_node_type_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_node_type_counts": {
        "file": "iters.rs",
        "function": "iter_node_type_counts",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unique_node_type_ids_and_counts": {
        "file": "iters.rs",
        "function": "iter_unique_node_type_ids_and_counts",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unique_node_type_names": {
        "file": "iters.rs",
        "function": "iter_unique_node_type_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unique_node_type_names_and_counts": {
        "file": "iters.rs",
        "function": "iter_unique_node_type_names_and_counts",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unique_edge_type_ids": {
        "file": "iters.rs",
        "function": "iter_unique_edge_type_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_edge_type_counts": {
        "file": "iters.rs",
        "function": "iter_edge_type_counts",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unique_edge_type_ids_and_counts": {
        "file": "iters.rs",
        "function": "iter_unique_edge_type_ids_and_counts",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unique_edge_type_names_and_counts": {
        "file": "iters.rs",
        "function": "iter_unique_edge_type_names_and_counts",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unique_edge_type_names": {
        "file": "iters.rs",
        "function": "iter_unique_edge_type_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "par_iter_node_ids": {
        "file": "iters.rs",
        "function": "par_iter_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_node_degrees": {
        "file": "iters.rs",
        "function": "iter_node_degrees",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "par_iter_node_degrees": {
        "file": "iters.rs",
        "function": "par_iter_node_degrees",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_connected_node_ids": {
        "file": "iters.rs",
        "function": "iter_connected_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_singleton_node_ids": {
        "file": "iters.rs",
        "function": "iter_singleton_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_singleton_node_names": {
        "file": "iters.rs",
        "function": "iter_singleton_node_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_singleton_with_selfloops_node_ids": {
        "file": "iters.rs",
        "function": "iter_singleton_with_selfloops_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_singleton_with_selfloops_node_names": {
        "file": "iters.rs",
        "function": "iter_singleton_with_selfloops_node_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_singleton_node_type_ids": {
        "file": "iters.rs",
        "function": "iter_singleton_node_type_ids",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no node types in the graph.\n"
            }
        ]
    },
    "iter_singleton_edge_type_ids": {
        "file": "iters.rs",
        "function": "iter_singleton_edge_type_ids",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no edge types in the graph.\n"
            }
        ]
    },
    "iter_singleton_node_type_names": {
        "file": "iters.rs",
        "function": "iter_singleton_node_type_names",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no node types in the graph.\n"
            }
        ]
    },
    "iter_singleton_edge_type_names": {
        "file": "iters.rs",
        "function": "iter_singleton_edge_type_names",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If there are no edge types in the graph.\n"
            }
        ]
    },
    "iter_source_node_ids": {
        "file": "iters.rs",
        "function": "iter_source_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_edge_weights": {
        "file": "iters.rs",
        "function": "iter_edge_weights",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To get an iterator over the edges weights you can use:\n",
            "content": "```rust# let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);\n# let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);\nassert!(graph_with_weights.iter_edge_weights().is_ok());\nassert!(graph_without_weights.iter_edge_weights().is_err());\nprintln!(\"The graph weights are {:?}.\", graph_with_weights.iter_edge_weights().unwrap().collect::<Vec<_>>());\n"
        },
        "extra_headers": []
    },
    "par_iter_edge_weights": {
        "file": "iters.rs",
        "function": "par_iter_edge_weights",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To get an iterator over the edges weights you can use:\n",
            "content": "```rust# use rayon::iter::ParallelIterator;\n# let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);\n# let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);\nassert!(graph_with_weights.iter_edge_weights().is_ok());\nassert!(graph_without_weights.iter_edge_weights().is_err());\nprintln!(\"The graph weights are {:?}.\", graph_with_weights.par_iter_edge_weights().unwrap().collect::<Vec<_>>());\n"
        },
        "extra_headers": []
    },
    "par_iter_source_node_ids": {
        "file": "iters.rs",
        "function": "par_iter_source_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_destination_node_ids": {
        "file": "iters.rs",
        "function": "iter_destination_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "par_iter_destination_node_ids": {
        "file": "iters.rs",
        "function": "par_iter_destination_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_node_ids_and_node_type_ids": {
        "file": "iters.rs",
        "function": "iter_node_ids_and_node_type_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "par_iter_node_ids_and_node_type_ids": {
        "file": "iters.rs",
        "function": "par_iter_node_ids_and_node_type_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_node_names_and_node_type_names": {
        "file": "iters.rs",
        "function": "iter_node_names_and_node_type_names",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "iter_edge_ids": {
        "file": "iters.rs",
        "function": "iter_edge_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_edges": {
        "file": "iters.rs",
        "function": "iter_edges",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "par_iter_edge_ids": {
        "file": "iters.rs",
        "function": "par_iter_edge_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "par_iter_edges": {
        "file": "iters.rs",
        "function": "par_iter_edges",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_edge_node_ids_and_edge_type_id": {
        "file": "iters.rs",
        "function": "iter_edge_node_ids_and_edge_type_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_edge_node_names_and_edge_type_name": {
        "file": "iters.rs",
        "function": "iter_edge_node_names_and_edge_type_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "par_iter_edge_node_names_and_edge_type_name": {
        "file": "iters.rs",
        "function": "par_iter_edge_node_names_and_edge_type_name",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "par_iter_edge_node_ids_and_edge_type_id": {
        "file": "iters.rs",
        "function": "par_iter_edge_node_ids_and_edge_type_id",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "par_iter_edge_node_names_and_edge_type_name_and_edge_weight": {
        "file": "iters.rs",
        "function": "par_iter_edge_node_names_and_edge_type_name_and_edge_weight",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_edge_node_names_and_edge_type_name_and_edge_weight": {
        "file": "iters.rs",
        "function": "iter_edge_node_names_and_edge_type_name_and_edge_weight",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "par_iter_edge_node_ids_and_edge_type_id_and_edge_weight": {
        "file": "iters.rs",
        "function": "par_iter_edge_node_ids_and_edge_type_id_and_edge_weight",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_edge_node_ids_and_edge_type_id_and_edge_weight": {
        "file": "iters.rs",
        "function": "iter_edge_node_ids_and_edge_type_id_and_edge_weight",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unique_edge_node_ids": {
        "file": "iters.rs",
        "function": "iter_unique_edge_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to filter out the undirected edges"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "iter_unique_source_node_ids": {
        "file": "iters.rs",
        "function": "iter_unique_source_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "has_nodes": {
        "file": "getters_boolean.rs",
        "function": "has_nodes",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To check if the graph has nodes you can use:\n",
            "content": "```rust# let graph_with_nodes = graph::test_utilities::load_ppi(true, true, true, true, false, false);\n# let empty_graph = graph::test_utilities::load_empty_graph(false);\nassert!(graph_with_nodes.has_nodes());\nassert!(!empty_graph.has_nodes());\n"
        },
        "extra_headers": []
    },
    "has_edges": {
        "file": "getters_boolean.rs",
        "function": "has_edges",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "desc": "To check if the current graph has edges you can use:\n",
            "content": "```rust# let graph_with_edges = graph::test_utilities::load_ppi(true, true, true, true, false, false);\n# let empty_graph = graph::test_utilities::load_empty_graph(false);\nassert!(graph_with_edges.has_edges());\nassert!(!empty_graph.has_edges());\n"
        },
        "extra_headers": []
    },
    "has_trap_nodes": {
        "file": "getters_boolean.rs",
        "function": "has_trap_nodes",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nif graph.has_trap_nodes(){\nprintln!(\"There are {} trap nodes in the current graph.\", graph.get_trap_nodes_number());\n} else {\nprintln!(\"There are no trap nodes in the current graph.\");\n}\n"
        },
        "extra_headers": []
    },
    "is_directed": {
        "file": "getters_boolean.rs",
        "function": "is_directed",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rustlet directed_string_ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert!(directed_string_ppi.is_directed());\nlet undirected_string_ppi = graph::test_utilities::load_ppi(true, true, true, false, false, false);\nassert!(!undirected_string_ppi.is_directed());\n"
        },
        "extra_headers": []
    },
    "has_selfloops": {
        "file": "getters_boolean.rs",
        "function": "has_selfloops",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rustlet string_ppi_with_selfloops = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nassert!(string_ppi_with_selfloops.has_selfloops());\nlet string_ppi_without_selfloops = graph::test_utilities::load_ppi(true, false, true, true, false, true);\nassert!(!string_ppi_without_selfloops.has_selfloops());\n"
        },
        "extra_headers": []
    },
    "has_singleton_nodes": {
        "file": "getters_boolean.rs",
        "function": "has_singleton_nodes",
        "errors": [],
        "args": {
            "args": []
        },
        "example": {
            "content": "```rust# let graph_with_singletons = graph::test_utilities::load_ppi(true, true, true, false, false, false);\nassert!(graph_with_singletons.has_singleton_nodes());\nlet graph_without_singletons = graph_with_singletons.drop_singleton_nodes(false);\nassert!(!graph_without_singletons.has_singleton_nodes());\n"
        },
        "extra_headers": []
    },
    "has_singleton_nodes_with_selfloops": {
        "file": "getters_boolean.rs",
        "function": "has_singleton_nodes_with_selfloops",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "has_multilabel_node_types": {
        "file": "getters_boolean.rs",
        "function": "has_multilabel_node_types",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n"
            }
        ]
    },
    "has_unknown_node_types": {
        "file": "getters_boolean.rs",
        "function": "has_unknown_node_types",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n"
            }
        ]
    },
    "has_unknown_edge_types": {
        "file": "getters_boolean.rs",
        "function": "has_unknown_edge_types",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n"
            }
        ]
    },
    "has_homogeneous_node_types": {
        "file": "getters_boolean.rs",
        "function": "has_homogeneous_node_types",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n"
            }
        ]
    },
    "has_homogeneous_edge_types": {
        "file": "getters_boolean.rs",
        "function": "has_homogeneous_edge_types",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n"
            }
        ]
    },
    "has_singleton_node_types": {
        "file": "getters_boolean.rs",
        "function": "has_singleton_node_types",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n"
            }
        ]
    },
    "has_node_oddities": {
        "file": "getters_boolean.rs",
        "function": "has_node_oddities",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "has_node_types_oddities": {
        "file": "getters_boolean.rs",
        "function": "has_node_types_oddities",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have node types.\n"
            }
        ]
    },
    "has_singleton_edge_types": {
        "file": "getters_boolean.rs",
        "function": "has_singleton_edge_types",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n"
            }
        ]
    },
    "has_edge_types_oddities": {
        "file": "getters_boolean.rs",
        "function": "has_edge_types_oddities",
        "errors": [
            {
                "doc_line": 2,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n"
            }
        ]
    },
    "is_multigraph": {
        "file": "getters_boolean.rs",
        "function": "is_multigraph",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "from_sorted_csv": {
        "file": "from_csv.rs",
        "function": "from_sorted_csv",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_file_reader",
                    "type": "EdgeFileReader",
                    "desc": "Reader of the edge file"
                },
                {
                    "name": "node_file_reader",
                    "type": "Option<NodeFileReader>",
                    "desc": "Reader of the node file"
                },
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether the graph is to be read as directed or undirected"
                },
                {
                    "name": "directed_edge_list",
                    "type": "bool",
                    "desc": "Whether to read the edge list as directed"
                },
                {
                    "name": "edges_number",
                    "type": "usize",
                    "desc": "Number of edges of the graph"
                },
                {
                    "name": "nodes_number",
                    "type": "NodeT",
                    "desc": "Number of the nodes of the graph"
                },
                {
                    "name": "name",
                    "type": "S",
                    "desc": "Name of the graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "from_unsorted_csv": {
        "file": "from_csv.rs",
        "function": "from_unsorted_csv",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edge_file_reader",
                    "type": "EdgeFileReader",
                    "desc": "Reader of the edge file"
                },
                {
                    "name": "node_file_reader",
                    "type": "Option<NodeFileReader>",
                    "desc": "Reader of the node file"
                },
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether the graph is to be read as directed or undirected"
                },
                {
                    "name": "directed_edge_list",
                    "type": "bool",
                    "desc": "Whether to read the edge list as directed"
                },
                {
                    "name": "name",
                    "type": "S",
                    "desc": "The name for the graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "hash_float": {
        "file": "hash.rs",
        "function": "hash_float",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "hash": {
        "file": "hash.rs",
        "function": "hash",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "check_numeric_ids_compatibility": {
        "file": "constructors.rs",
        "function": "check_numeric_ids_compatibility",
        "errors": [
            {
                "doc_line": 10,
                "msg": "The example section is missing or in the wrong order."
            }
        ],
        "args": {
            "args": [
                {
                    "name": "has_nodes_list",
                    "type": "bool",
                    "desc": "Whether the graph has a node list"
                },
                {
                    "name": "numeric_node_ids",
                    "type": "bool",
                    "desc": "Whether the node IDs should be loaded as integers"
                },
                {
                    "name": "numeric_edge_node_ids",
                    "type": "bool",
                    "desc": "Whether the edge node IDs should be loaded as integers"
                }
            ]
        },
        "example": {},
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the given combination of numeric nodes is not feaseable.\n"
            }
        ]
    },
    "parse_node_ids": {
        "file": "constructors.rs",
        "function": "parse_node_ids",
        "errors": [
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'nodes'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'ignore_duplicated_nodes'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node_list_is_correct'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'nodes_iter'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [],
            "desc": "nodes_iter: impl Iterator<Item = Result<(String, Option<Vec<String>>), String>> + 'a,\nIterator over the node list.\nignore_duplicated_nodes: bool,\nWhether to just ignore the duplicated node types.\nnode_list_is_correct: bool,\nParameter to pinky promise that the node list is correct.\nIf you provide a broken node list to this method while promising\nthat the node list is correct, be prepared to deal with the fallout.\nThis parameter is mainly meant to be used internally when creating\ngraphs that CANNOT BE BROKEN by design. If you use this parameter\nfrom any of the bindings, be SURE that the node list is actually\ncorrect.\nWe assume that any provided node list is broken until disproved.\nnodes: &'b mut Vocabulary<NodeT>,\nVocabulary of the nodes to be populated.\n"
        },
        "example": {},
        "extra_headers": []
    },
    "parse_node_type_ids": {
        "file": "constructors.rs",
        "function": "parse_node_type_ids",
        "errors": [
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node_list_is_correct'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'nodes_iter'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'node_types_vocabulary'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [],
            "desc": "nodes_iter: impl Iterator<Item = Result<(NodeT, Option<Vec<String>>), String>> + 'a,\nIterator over the node list.\nnode_list_is_correct: bool,\nParameter to pinky promise that the node list is correct.\nIf you provide a broken node list to this method while promising\nthat the node list is correct, be prepared to deal with the fallout.\nThis parameter is mainly meant to be used internally when creating\ngraphs that CANNOT BE BROKEN by design. If you use this parameter\nfrom any of the bindings, be SURE that the node list is actually\ncorrect.\nWe assume that any provided node list is broken until disproved.\nnode_types_vocabulary: &'b mut NodeTypeVocabulary,\nNode types vocabulary to be populated.\n"
        },
        "example": {},
        "extra_headers": []
    },
    "parse_edges_node_ids": {
        "file": "constructors.rs",
        "function": "parse_edges_node_ids",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "parse_edge_type_ids_vocabulary": {
        "file": "constructors.rs",
        "function": "parse_edge_type_ids_vocabulary",
        "errors": [
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'edge_list_is_correct'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'edge_types'."
            },
            {
                "doc_line": "~",
                "msg": "Missing the documentation for the argument 'edges_iter'."
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [],
            "desc": "edges_iter: impl Iterator<Item = Result<(NodeT, NodeT, Option<String>, Option<WeightT>), String>> + 'a,\nIterator over the edge node names list.\nedge_list_is_correct: bool,\nParameter to pinky promise that the edge list is correct.\nIf you provide a broken edge list to this method while promising\nthat the edge list is correct, be prepared to deal with the fallout.\nThis parameter is mainly meant to be used internally when creating\ngraphs that CANNOT BE BROKEN by design. If you use this parameter\nfrom any of the bindings, be SURE that the edge list is actually\ncorrect.\nWe assume that any provided edge list is broken until disproved.\nedge_types: &'b mut Vocabulary<EdgeTypeT>,\nVocabulary of the edge types to be populated.\n"
        },
        "example": {},
        "extra_headers": []
    },
    "parse_sorted_edges": {
        "file": "constructors.rs",
        "function": "parse_sorted_edges",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "parse_unsorted_quadruples": {
        "file": "constructors.rs",
        "function": "parse_unsorted_quadruples",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "parse_integer_unsorted_edges": {
        "file": "constructors.rs",
        "function": "parse_integer_unsorted_edges",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "parse_string_unsorted_edges": {
        "file": "constructors.rs",
        "function": "parse_string_unsorted_edges",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "build_edges": {
        "file": "constructors.rs",
        "function": "build_edges",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "parse_nodes": {
        "file": "constructors.rs",
        "function": "parse_nodes",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "parse_string_edges": {
        "file": "constructors.rs",
        "function": "parse_string_edges",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "parse_integer_edges": {
        "file": "constructors.rs",
        "function": "parse_integer_edges",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "from_integer_sorted": {
        "file": "constructors.rs",
        "function": "from_integer_sorted",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "from_string_unsorted": {
        "file": "constructors.rs",
        "function": "from_string_unsorted",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edges_iterator",
                    "type": "impl Iterator<Item = Result<StringQuadruple, String>>",
                    "desc": "Iterator on the edge list composed of strings"
                },
                {
                    "name": "nodes_iterator",
                    "type": "Option<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>>>",
                    "desc": "Option of an iterator on the node list composed of strings"
                },
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether the edge list should be loaded as directed or undirected"
                },
                {
                    "name": "directed_edge_list",
                    "type": "bool",
                    "desc": "Whether the edge list is expressed as directed. If this is an undirected graph, we expect a directed edge list to contain edges in BOTH directions"
                },
                {
                    "name": "name",
                    "type": "S",
                    "desc": "The name of the graph"
                },
                {
                    "name": "ignore_duplicated_nodes",
                    "type": "bool",
                    "desc": "Whether to ignore and skip the detected duplicated node names or to raise an error"
                },
                {
                    "name": "node_list_is_correct",
                    "type": "bool",
                    "desc": "Whether the user pinky promises that the node list is correct. This feature will lead to panics if used improperly by an over-optimistic user. Enable this flag only if you are sure you are correct"
                },
                {
                    "name": "ignore_duplicated_edges",
                    "type": "bool",
                    "desc": "Whether to ignore and skip the detected duplicated edges or to raise an error"
                },
                {
                    "name": "edge_list_is_correct",
                    "type": "bool",
                    "desc": "Whether the user pinky promises that the edge list is correct. This feature will lead to panics if used improperly by an over-optimistic user. Enable this flag only if you are sure you are correct"
                },
                {
                    "name": "numeric_edge_type_ids",
                    "type": "bool",
                    "desc": "Whether the edge type IDs should be loaded as numeric, casting them to integers. The range of edge type IDs MUST be dense"
                },
                {
                    "name": "numeric_node_ids",
                    "type": "bool",
                    "desc": "Whether the node IDs should be loaded as numeric, casting them to integers. The range of node IDs MUST be dense"
                },
                {
                    "name": "numeric_edge_node_ids",
                    "type": "bool",
                    "desc": "Whether the edge node IDs should be loaded as numeric, casting them to integers. The range of edge node IDs MUST be dense"
                },
                {
                    "name": "numeric_node_types_ids",
                    "type": "bool",
                    "desc": "Whether the node type IDs should be loaded as numeric, casting them to integers. The range of node type IDs MUST be dense"
                },
                {
                    "name": "has_node_types",
                    "type": "bool",
                    "desc": "Whether the graph has node types"
                },
                {
                    "name": "has_edge_types",
                    "type": "bool",
                    "desc": "Whether the graph has edge types"
                },
                {
                    "name": "has_edge_weights",
                    "type": "bool",
                    "desc": "Whether the graph has edge weights"
                },
                {
                    "name": "might_contain_singletons",
                    "type": "bool",
                    "desc": "Whether the graph is KNOWN to have or not singleton nodes. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct"
                },
                {
                    "name": "might_contain_singletons_with_selfloops",
                    "type": "bool",
                    "desc": "Whether the graph is KNOWN to have or not singleton nodes with selfloops. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct"
                },
                {
                    "name": "might_contain_trap_nodes",
                    "type": "bool",
                    "desc": "Whether the graph is KNOWN to have or not trap nodes. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether we should show loading bars while building the graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "from_integer_unsorted": {
        "file": "constructors.rs",
        "function": "from_integer_unsorted",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edges_iterator",
                    "type": "impl Iterator<Item = Result<(NodeT, NodeT, Option<NodeTypeT>, Option<WeightT>), String>>",
                    "desc": "Iterator over the egde node IDs"
                },
                {
                    "name": "nodes",
                    "type": "Vocabulary<NodeT>",
                    "desc": "Vocabulary of the node IDs"
                },
                {
                    "name": "node_types",
                    "type": "Option<NodeTypeVocabulary>",
                    "desc": "Option of the vocabulary of the node type IDs"
                },
                {
                    "name": "edge_types_vocabulary",
                    "type": "Option<Vocabulary<EdgeTypeT>>",
                    "desc": "Option of the Vocabulary of the edge type IDs"
                },
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether to load the graph as directed or undirected"
                },
                {
                    "name": "name",
                    "type": "String",
                    "desc": "Name of the graph"
                },
                {
                    "name": "ignore_duplicated_edges",
                    "type": "bool",
                    "desc": "Whether to ignore and skip the detected duplicated edges or to raise an error"
                },
                {
                    "name": "has_edge_types",
                    "type": "bool",
                    "desc": "Whether the graph has edge types"
                },
                {
                    "name": "has_edge_weights",
                    "type": "bool",
                    "desc": "Whether the graph has edge weights"
                },
                {
                    "name": "might_contain_singletons",
                    "type": "bool",
                    "desc": "Whether the graph is KNOWN to have or not singleton nodes. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct"
                },
                {
                    "name": "might_contain_singletons_with_selfloops",
                    "type": "bool",
                    "desc": "Whether the graph is KNOWN to have or not singleton nodes with selfloops. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct"
                },
                {
                    "name": "might_contain_trap_nodes",
                    "type": "bool",
                    "desc": "Whether the graph is KNOWN to have or not trap nodes. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show theloading bars while loading the graph"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "from_string_sorted": {
        "file": "constructors.rs",
        "function": "from_string_sorted",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "edges_iterator",
                    "type": "impl Iterator<Item = Result<StringQuadruple, String>>",
                    "desc": "Iterator on the edge list composed of strings"
                },
                {
                    "name": "nodes_iterator",
                    "type": "Option<impl Iterator<Item = Result<(String, Option<Vec<String>>), String>>>",
                    "desc": "Option of an iterator on the node list composed of strings"
                },
                {
                    "name": "directed",
                    "type": "bool",
                    "desc": "Whether the edge list should be loaded as directed or undirected"
                },
                {
                    "name": "directed_edge_list",
                    "type": "bool",
                    "desc": "Whether the edge list is expressed as directed. If this is an undirected graph, we expect a directed edge list to contain edges in BOTH directions"
                },
                {
                    "name": "name",
                    "type": "S",
                    "desc": "The name of the graph"
                },
                {
                    "name": "ignore_duplicated_nodes",
                    "type": "bool",
                    "desc": "Whether to ignore and skip the detected duplicated node names or to raise an error"
                },
                {
                    "name": "node_list_is_correct",
                    "type": "bool",
                    "desc": "Whether the user pinky promises that the node list is correct. This feature will lead to panics if used improperly by an over-optimistic user. Enable this flag only if you are sure you are correct"
                },
                {
                    "name": "ignore_duplicated_edges",
                    "type": "bool",
                    "desc": "Whether to ignore and skip the detected duplicated edges or to raise an error"
                },
                {
                    "name": "edge_list_is_correct",
                    "type": "bool",
                    "desc": "Whether the user pinky promises that the edge list is correct. This feature will lead to panics if used improperly by an over-optimistic user. Enable this flag only if you are sure you are correct"
                },
                {
                    "name": "edges_number",
                    "type": "usize",
                    "desc": "Exact number of edges in the graph"
                },
                {
                    "name": "nodes_number",
                    "type": "NodeT",
                    "desc": "Exact number of nodes in the graph"
                },
                {
                    "name": "numeric_edge_type_ids",
                    "type": "bool",
                    "desc": "Whether the edge type IDs should be loaded as numeric, casting them to integers. The range of edge type IDs MUST be dense"
                },
                {
                    "name": "numeric_node_ids",
                    "type": "bool",
                    "desc": "Whether the node IDs should be loaded as numeric, casting them to integers. The range of node IDs MUST be dense"
                },
                {
                    "name": "numeric_edge_node_ids",
                    "type": "bool",
                    "desc": "Whether the edge node IDs should be loaded as numeric, casting them to integers. The range of edge node IDs MUST be dense"
                },
                {
                    "name": "numeric_node_types_ids",
                    "type": "bool",
                    "desc": "Whether the node type IDs should be loaded as numeric, casting them to integers. The range of node type IDs MUST be dense"
                },
                {
                    "name": "has_node_types",
                    "type": "bool",
                    "desc": "Whether the graph has node types"
                },
                {
                    "name": "has_edge_types",
                    "type": "bool",
                    "desc": "Whether the graph has edge types"
                },
                {
                    "name": "has_edge_weights",
                    "type": "bool",
                    "desc": "Whether the graph has edge weights"
                },
                {
                    "name": "might_contain_singletons",
                    "type": "bool",
                    "desc": "Whether the graph is KNOWN to have or not singleton nodes. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct"
                },
                {
                    "name": "might_contain_singletons_with_selfloops",
                    "type": "bool",
                    "desc": "Whether the graph is KNOWN to have or not singleton nodes with selfloops. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct"
                },
                {
                    "name": "might_contain_trap_nodes",
                    "type": "bool",
                    "desc": "Whether the graph is KNOWN to have or not trap nodes. Beware that improper use of this flag might lead to panics. Enable this flag only if you are sure you are correct"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "sample_negatives": {
        "file": "holdouts.rs",
        "function": "sample_negatives",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "random_state",
                    "type": "EdgeT",
                    "desc": "random_state to use to reproduce negative edge set"
                },
                {
                    "name": "negatives_number",
                    "type": "EdgeT",
                    "desc": "Number of negatives edges to include"
                },
                {
                    "name": "seed_graph",
                    "type": "Option<&Graph>",
                    "desc": "Optional graph to use to filter the negative edges. The negative edges generated when this variable is provided will always have a node within this graph"
                },
                {
                    "name": "only_from_same_component",
                    "type": "bool",
                    "desc": "Whether to sample negative edges only from nodes that are from the same component"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show the loading bar"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "get_holdouts_elements_number": {
        "file": "holdouts.rs",
        "function": "get_holdouts_elements_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "get_holdouts_edges_number": {
        "file": "holdouts.rs",
        "function": "get_holdouts_edges_number",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "edge_holdout": {
        "file": "holdouts.rs",
        "function": "edge_holdout",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Arguments"
            },
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": []
        },
        "example": {},
        "extra_headers": []
    },
    "connected_holdout": {
        "file": "holdouts.rs",
        "function": "connected_holdout",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "random_state",
                    "type": "EdgeT",
                    "desc": "The random_state to use for the holdout"
                },
                {
                    "name": "train_size",
                    "type": "f64",
                    "desc": "Rate target to reserve for training"
                },
                {
                    "name": "edge_types",
                    "type": "Option<Vec<Option<String>>>",
                    "desc": "Edge types to be selected for in the validation set"
                },
                {
                    "name": "include_all_edge_types",
                    "type": "bool",
                    "desc": "Whether to include all the edges between two nodes"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show the loading bar"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "random_holdout": {
        "file": "holdouts.rs",
        "function": "random_holdout",
        "errors": [
            {
                "doc_line": 0,
                "msg": "Missing Example"
            }
        ],
        "args": {
            "args": [
                {
                    "name": "random_state",
                    "type": "EdgeT",
                    "desc": "The random_state to use for the holdout"
                },
                {
                    "name": "train_size",
                    "type": "f64",
                    "desc": "rate target to reserve for training"
                },
                {
                    "name": "include_all_edge_types",
                    "type": "bool",
                    "desc": "Whether to include all the edges between two nodes"
                },
                {
                    "name": "edge_types",
                    "type": "Option<Vec<Option<String>>>",
                    "desc": "The edges to include in validation set"
                },
                {
                    "name": "min_number_overlaps",
                    "type": "Option<EdgeT>",
                    "desc": "The minimum number of overlaps to include the edge into the validation set"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show the loading bar"
                }
            ]
        },
        "example": {},
        "extra_headers": []
    },
    "node_label_holdout": {
        "file": "holdouts.rs",
        "function": "node_label_holdout",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "train_size",
                    "type": "f64",
                    "desc": "rate target to reserve for training"
                },
                {
                    "name": "use_stratification",
                    "type": "bool",
                    "desc": "Whether to use node-label stratification"
                },
                {
                    "name": "random_state",
                    "type": "EdgeT",
                    "desc": "The random_state to use for the holdout"
                }
            ]
        },
        "example": {
            "desc": "This example create an 80-20 split of the nodes in the graph\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nlet (train, test) = graph.node_label_holdout(0.8, true, 0xbad5eed).unwrap();\n"
        },
        "extra_headers": []
    },
    "edge_label_holdout": {
        "file": "holdouts.rs",
        "function": "edge_label_holdout",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "train_size",
                    "type": "f64",
                    "desc": "rate target to reserve for training"
                },
                {
                    "name": "use_stratification",
                    "type": "bool",
                    "desc": "Whether to use edge-label stratification"
                },
                {
                    "name": "random_state",
                    "type": "EdgeT",
                    "desc": "The random_state to use for the holdout"
                }
            ]
        },
        "example": {
            "desc": "This example creates an 80-20 split of the edges mantaining the edge label ratios\nin train and test.\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nlet (train, test) = graph.edge_label_holdout(0.8, true, 0xbad5eed).unwrap();\n"
        },
        "extra_headers": [
            {
                "name": "Raises",
                "content": "* If the graph does not have edge types.\n* If stratification is required but the graph has singleton edge types.\n"
            }
        ]
    },
    "random_subgraph": {
        "file": "holdouts.rs",
        "function": "random_subgraph",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "random_state",
                    "type": "usize",
                    "desc": "Random random_state to use"
                },
                {
                    "name": "nodes_number",
                    "type": "NodeT",
                    "desc": "Number of nodes to extract"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show the loading bar"
                }
            ]
        },
        "example": {
            "desc": "this generates a random subgraph with 1000 nodes.\n",
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nlet random_graph = graph.random_subgraph(0xbad5eed, 1000, true).unwrap();\n"
        },
        "extra_headers": []
    },
    "kfold": {
        "file": "holdouts.rs",
        "function": "kfold",
        "errors": [],
        "args": {
            "args": [
                {
                    "name": "k",
                    "type": "EdgeT",
                    "desc": "The number of folds"
                },
                {
                    "name": "k_index",
                    "type": "u64",
                    "desc": "Which fold to use for the validation"
                },
                {
                    "name": "edge_types",
                    "type": "Option<Vec<Option<String>>>",
                    "desc": "Edge types to be selected when computing the folds (All the edge types not listed here will be always be used in the training set)"
                },
                {
                    "name": "random_state",
                    "type": "EdgeT",
                    "desc": "The random_state (seed) to use for the holdout"
                },
                {
                    "name": "verbose",
                    "type": "bool",
                    "desc": "Whether to show the loading bar"
                }
            ]
        },
        "example": {
            "content": "```rust# let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);\nfor i in 0..5 {\nlet (train, test) = graph.kfold(5, i, None, 0xbad5eed, true).unwrap();\n// Run the training\n}\n",
            "footer": "If We pass a vector of edge types, the K-fold will be executed only on the edges which match\nthat type. All the other edges will always appear in the traning set.\n"
        },
        "extra_headers": []
    }
}