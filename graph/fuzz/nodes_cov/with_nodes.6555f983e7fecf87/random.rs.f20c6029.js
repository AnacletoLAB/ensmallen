var data = {lines:[
{"lineNum":"    1","line":"use super::types::*;"},
{"lineNum":"    2","line":"use ::core::cmp::Ordering;"},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"// global static seed, this could be moved inside a struct"},
{"lineNum":"    5","line":"// WARNING"},
{"lineNum":"    6","line":"// the current implementation is not thread safe because we"},
{"lineNum":"    7","line":"// mutate a shared state between threads without any locks."},
{"lineNum":"    8","line":"// This should not create any problem since we do not need"},
{"lineNum":"    9","line":"// a strong PRNG so for speed sake it\'s intentionally let"},
{"lineNum":"   10","line":"// this way."},
{"lineNum":"   11","line":"// The only real problem could be that we lose determinism"},
{"lineNum":"   12","line":"static mut GLOBAL_SEED: [u64; 4] = ["},
{"lineNum":"   13","line":"    6591408588322595484,"},
{"lineNum":"   14","line":"    5451729388608518856,"},
{"lineNum":"   15","line":"    8913376598984957243,"},
{"lineNum":"   16","line":"    17912695770704705270,"},
{"lineNum":"   17","line":"];"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"#[inline(always)]"},
{"lineNum":"   20","line":"fn rotl(x: u64, k: u64) -> u64 {","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   21","line":"    (x << k) | (x >> (64 - k))","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   22","line":"}"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"#[inline(always)]"},
{"lineNum":"   25","line":"pub fn xorshiro256plus() -> f64 {"},
{"lineNum":"   26","line":"    // based on xorshiro256+ which seems to be the fastest floating point generator"},
{"lineNum":"   27","line":"    // http://prng.di.unimi.it/xoshiro256plus.c"},
{"lineNum":"   28","line":"    // the conversion from u64 to f64 is taken from:"},
{"lineNum":"   29","line":"    // http://prng.di.unimi.it/"},
{"lineNum":"   30","line":"    // the informations about the structure of a f64 was taken from IEEE 754"},
{"lineNum":"   31","line":"    // https://standards.ieee.org/content/ieee-standards/en/standard/754-2019.html"},
{"lineNum":"   32","line":"    // https://en.wikipedia.org/wiki/Double-precision_floating-point_format"},
{"lineNum":"   33","line":"    // if this is still a bottleneck we can consider to implement"},
{"lineNum":"   34","line":"    // http://prng.di.unimi.it/xoshiro256+-vect-speed.c"},
{"lineNum":"   35","line":"    // which exploits avx to generate in parallel 8 random numbers and fill a"},
{"lineNum":"   36","line":"    // cache with it"},
{"lineNum":"   37","line":"    unsafe {"},
{"lineNum":"   38","line":"        // normal xorshiro implementation"},
{"lineNum":"   39","line":"        let (result, _): (u64, bool) = GLOBAL_SEED[0].overflowing_add(GLOBAL_SEED[3]);","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"        let t: u64 = GLOBAL_SEED[1] << 17;","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"        GLOBAL_SEED[2] ^= GLOBAL_SEED[0];","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   44","line":"        GLOBAL_SEED[3] ^= GLOBAL_SEED[1];","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   45","line":"        GLOBAL_SEED[1] ^= GLOBAL_SEED[2];","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   46","line":"        GLOBAL_SEED[0] ^= GLOBAL_SEED[3];","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"        GLOBAL_SEED[2] ^= t;","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"        GLOBAL_SEED[3] = rotl(GLOBAL_SEED[3], 45);","class":"linePartCov","hits":"1","possible_hits":"2",},
{"lineNum":"   51","line":"        // method proposed by vigna on http://prng.di.unimi.it/"},
{"lineNum":"   52","line":"        let v: u64 = (result >> 11) | (1023 << 52);","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   53","line":"        let r: f64 = f64::from_le_bytes(v.to_le_bytes());","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   54","line":"        r - 1f64","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   55","line":"    }"},
{"lineNum":"   56","line":"}","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"pub fn sample(weights: &[WeightT]) -> usize {","class":"linePartCov","hits":"1","possible_hits":"3",},
{"lineNum":"   59","line":"    if weights.len() == 1{","class":"linePartCov","hits":"1","possible_hits":"2",},
{"lineNum":"   60","line":"        return 0;","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   61","line":"    }"},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"    let mut cumulative_sum: Vec<f64> = Vec::with_capacity(weights.len());","class":"linePartCov","hits":"1","possible_hits":"2",},
{"lineNum":"   64","line":"    let mut total_weight = 0f64;","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   65","line":"    for w in weights {","class":"linePartCov","hits":"1","possible_hits":"4",},
{"lineNum":"   66","line":"        total_weight += w;","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   67","line":"        cumulative_sum.push(total_weight);","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   68","line":"    }","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"    let frnd = xorshiro256plus();","class":"linePartCov","hits":"1","possible_hits":"2",},
{"lineNum":"   71","line":"    let rnd: f64 = frnd * cumulative_sum[cumulative_sum.len() - 1];","class":"linePartCov","hits":"1","possible_hits":"2",},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"    // Find the first item which has a weight *higher* than the chosen weight."},
{"lineNum":"   74","line":"    let result = match cumulative_sum","class":"linePartCov","hits":"1","possible_hits":"3",},
{"lineNum":"   75","line":"        .binary_search_by(|w| {","class":"linePartCov","hits":"1","possible_hits":"3",},
{"lineNum":"   76","line":"            if *w <= rnd {","class":"linePartCov","hits":"1","possible_hits":"2",},
{"lineNum":"   77","line":"                Ordering::Less","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   78","line":"            } else {"},
{"lineNum":"   79","line":"                Ordering::Greater","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   80","line":"            }"},
{"lineNum":"   81","line":"        })","class":"linePartCov","hits":"1","possible_hits":"3",},
{"lineNum":"   82","line":"    {"},
{"lineNum":"   83","line":"        Ok(g) => g,","class":"linePartCov","hits":"1","possible_hits":"2",},
{"lineNum":"   84","line":"        Err(g) => {","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   85","line":"            g //min(g, weights.len() - 1)","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   86","line":"        }"},
{"lineNum":"   87","line":"    };","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"    if result >= weights.len() {","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   90","line":"        panic!(","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   91","line":"            \"Sampling Error: weights: {:?} cumsum: {:?} frnd: {} rnd: {} result: {}\",","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   92","line":"            weights, cumulative_sum, frnd, rnd, result"},
{"lineNum":"   93","line":"        )"},
{"lineNum":"   94","line":"    }"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"    result","class":"lineCov","hits":"1","possible_hits":"1",},
{"lineNum":"   97","line":"}","class":"linePartCov","hits":"1","possible_hits":"4",},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "with_nodes", "date" : "2020-06-22 09:48:45", "instrumented" : 40, "covered" : 38,};
var merged_data = [];
