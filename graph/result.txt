#![feature(prelude_import)]
//! Ensmallen its an efficient graph manipulation library.
//!
//! # Example:
//!
//! ```rust
//! use graph::{EdgeFileReader, Graph};
//! let edges_reader = EdgeFileReader::new("tests/data/test_components.csv",).unwrap()
//!     .set_separator(Some(",")).unwrap()
//!     .set_verbose(Some(false))
//!     .set_numeric_node_ids(Some(true))
//!     .set_header(Some(false));
//!  
//! let g = Graph::from_sorted_csv(edges_reader, None, false, false, 6, 6, "Graph").unwrap();
//!
//!
//! ```
//! # Definitions
//! * `edge`: an arch between to nodes
//! * `selfloop`: An edge which source and destination are equal
//! * `singleton`: A node with in degree and out degree 0
//! * `singleton_with_selfloop`: A node which has only selfloops
//! * `connected_node`: a node which is nor a `singleton` nor a `singleton_with_selfloops`.
#![warn(unused_macros)]
#![feature(is_sorted)]
#![feature(map_first_last)]
#![type_length_limit = "3764086"]
#![feature(option_result_unwrap_unchecked)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
mod method_caller {
    //! # Method Caller
    //! Aka Map with benefits
    //!
    //! This is a way to be able to call different functions that acts on the same state
    //! during a parallel iteration. It's conceptually similar to a parallel scan.
    //!
    //! ```rust
    //!
    //!     // implemnet the sturct with context usize
    //!    impl_struct_func!(Funzioni usize);
    //!
    //!    // Implement the methods we want to be abel to call
    //!    // these must use the following primitives to access the context:
    //!    // self.get_mutable_write, self.get_mutable_read, self.get_immutable
    //!    // get_mutable_read and get_immutable are conceptually identical but
    //!    // get_immutable is ~40 times faster, but can be called IFF you have a
    //!    // guarantee that no-one is ever writing to the context.
    //!    impl Funzioni {
    //!        pub fn parse(&mut self, value: usize) -> u8 {
    //!            let c = self.get_mutable_write();
    //!
    //!            *c = c.wrapping_add(1);
    //!            (value.wrapping_add(*c)) as _
    //!        }
    //!
    //!        pub fn check(&mut self, value: usize) -> u8 {
    //!            let c = *self.get_immutable();
    //!            (value.wrapping_add(c)) as _
    //!        }
    //!    }
    //!
    //!    fn main() {
    //!        for x in vec![true, false] {
    //!
    //!            let mut f = Funzioni::new(100);
    //!
    //!            let method_f = if x {
    //!                Funzioni::parse
    //!            } else {
    //!                Funzioni::check
    //!            };
    //!
    //!
    //!            let res: u8 = (0..100_000_000)
    //!                .into_par_iter()
    //!                .map(|x| x as usize)
    //!                .method_caller(method_f, &mut f)
    //!                .sum();
    //!
    //!            println!("{:?}", res);
    //!            println!("{:?}", f.context);
    //!            println!("");
    //!        }
    //!    }
    //! ```
    use super::*;
    use rayon::iter::plumbing::*;
    use rayon::iter::Map;
    use rayon::prelude::*;
    use std::iter::Iterator;
    pub(crate) struct MethodCaller<T, R, S, I: ParallelIterator<Item = T>> {
        base: I,
        method: fn(&mut S, T) -> R,
        context: usize,
    }
    impl<T, R, S, I: ParallelIterator<Item = T>> MethodCaller<T, R, S, I> {
        fn new(base: I, method: fn(&mut S, T) -> R, context: usize) -> MethodCaller<T, R, S, I> {
            MethodCaller {
                base,
                method,
                context,
            }
        }
    }
    impl<T, R: Send, S, I: ParallelIterator<Item = T>> ParallelIterator for MethodCaller<T, R, S, I> {
        type Item = R;
        fn drive_unindexed<C>(self, consumer: C) -> C::Result
        where
            C: UnindexedConsumer<Self::Item>,
        {
            let consumer1 = MethodCallerConsumer::new(consumer, self.method, self.context);
            self.base.drive_unindexed(consumer1)
        }
        fn opt_len(&self) -> Option<usize> {
            self.base.opt_len()
        }
    }
    struct MethodCallerConsumer<T, R, S, C> {
        base: C,
        method: fn(&mut S, T) -> R,
        context: usize,
    }
    impl<T, R, S, C> MethodCallerConsumer<T, R, S, C> {
        fn new(
            base: C,
            method: fn(&mut S, T) -> R,
            context: usize,
        ) -> MethodCallerConsumer<T, R, S, C> {
            MethodCallerConsumer {
                base,
                method,
                context,
            }
        }
    }
    impl<T, R, S, C> Consumer<T> for MethodCallerConsumer<T, R, S, C>
    where
        C: Consumer<R>,
    {
        type Folder = MethodCallerFolder<T, R, S, C::Folder>;
        type Reducer = C::Reducer;
        type Result = C::Result;
        fn split_at(self, index: usize) -> (Self, Self, Self::Reducer) {
            let (left, right, reducer) = self.base.split_at(index);
            (
                MethodCallerConsumer::new(left, self.method.clone(), self.context.clone()),
                MethodCallerConsumer::new(right, self.method.clone(), self.context.clone()),
                reducer,
            )
        }
        fn into_folder(self) -> Self::Folder {
            MethodCallerFolder {
                base: self.base.into_folder(),
                method: self.method.clone(),
                context: self.context.clone(),
            }
        }
        fn full(&self) -> bool {
            self.base.full()
        }
    }
    impl<T, R, S, C> UnindexedConsumer<T> for MethodCallerConsumer<T, R, S, C>
    where
        C: UnindexedConsumer<R>,
    {
        fn split_off_left(&self) -> Self {
            MethodCallerConsumer::new(self.base.split_off_left(), self.method, self.context)
        }
        fn to_reducer(&self) -> Self::Reducer {
            self.base.to_reducer()
        }
    }
    struct MethodCallerFolder<T, R, S, C> {
        base: C,
        method: fn(&mut S, T) -> R,
        context: usize,
    }
    impl<T, R, S, C> Folder<T> for MethodCallerFolder<T, R, S, C>
    where
        C: Folder<R>,
    {
        type Result = C::Result;
        fn consume(self, item: T) -> Self {
            let context = unsafe { &mut *(self.context as *mut S) };
            let mapped_item = (self.method)(context, item);
            MethodCallerFolder {
                base: self.base.consume(mapped_item),
                method: self.method,
                context: self.context,
            }
        }
        fn consume_iter<I>(mut self, iter: I) -> Self
        where
            I: IntoIterator<Item = T>,
        {
            let context = self.context;
            let method = self.method;
            self.base = self.base.consume_iter(iter.into_iter().map(|item| {
                let call_self = unsafe { &mut *(context as *mut S) };
                (method)(call_self, item)
            }));
            self
        }
        fn complete(self) -> C::Result {
            self.base.complete()
        }
        fn full(&self) -> bool {
            self.base.full()
        }
    }
    pub(crate) trait OrOps<T, R, S> {
        fn method_caller(
            self,
            method: fn(&mut S, T) -> R,
            context: &mut S,
        ) -> MethodCaller<T, R, S, Self>
        where
            Self: ParallelIterator<Item = T>,
        {
            MethodCaller::new(self, method, context as *const S as usize)
        }
    }
    impl<T, R, S, J: ?Sized> OrOps<T, R, S> for J where J: ParallelIterator<Item = T> {}
}
pub(crate) use method_caller::*;
mod vocabulary {
    use super::types::*;
    use std::collections::hash_map::Entry;
    use std::collections::HashMap;
    use std::ops::Range;
    pub enum Vocabulary<IndexT: ToFromUsize> {
        String {
            map: HashMap<String, IndexT>,
            reverse_map: Vec<String>,
        },
        Numeric {
            range: Range<usize>,
            count: usize,
        },
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<IndexT: ::core::fmt::Debug + ToFromUsize> ::core::fmt::Debug for Vocabulary<IndexT> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Vocabulary::String {
                    map: ref __self_0,
                    reverse_map: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "String");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "map", &&(*__self_0));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "reverse_map",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Vocabulary::Numeric {
                    range: ref __self_0,
                    count: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Numeric");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "range",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "count",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<IndexT: ::core::clone::Clone + ToFromUsize> ::core::clone::Clone for Vocabulary<IndexT> {
        #[inline]
        fn clone(&self) -> Vocabulary<IndexT> {
            match (&*self,) {
                (&Vocabulary::String {
                    map: ref __self_0,
                    reverse_map: ref __self_1,
                },) => Vocabulary::String {
                    map: ::core::clone::Clone::clone(&(*__self_0)),
                    reverse_map: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&Vocabulary::Numeric {
                    range: ref __self_0,
                    count: ref __self_1,
                },) => Vocabulary::Numeric {
                    range: ::core::clone::Clone::clone(&(*__self_0)),
                    count: ::core::clone::Clone::clone(&(*__self_1)),
                },
            }
        }
    }
    impl<IndexT: ToFromUsize> ::core::marker::StructuralPartialEq for Vocabulary<IndexT> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<IndexT: ::core::cmp::PartialEq + ToFromUsize> ::core::cmp::PartialEq for Vocabulary<IndexT> {
        #[inline]
        fn eq(&self, other: &Vocabulary<IndexT>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Vocabulary::String {
                                map: ref __self_0,
                                reverse_map: ref __self_1,
                            },
                            &Vocabulary::String {
                                map: ref __arg_1_0,
                                reverse_map: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (
                            &Vocabulary::Numeric {
                                range: ref __self_0,
                                count: ref __self_1,
                            },
                            &Vocabulary::Numeric {
                                range: ref __arg_1_0,
                                count: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Vocabulary<IndexT>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Vocabulary::String {
                                map: ref __self_0,
                                reverse_map: ref __self_1,
                            },
                            &Vocabulary::String {
                                map: ref __arg_1_0,
                                reverse_map: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (
                            &Vocabulary::Numeric {
                                range: ref __self_0,
                                count: ref __self_1,
                            },
                            &Vocabulary::Numeric {
                                range: ref __arg_1_0,
                                count: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    /// # Constructors
    impl<IndexT: ToFromUsize> Vocabulary<IndexT> {
        pub fn new() -> Vocabulary<IndexT> {
            Vocabulary::String {
                map: HashMap::new(),
                reverse_map: Vec::new(),
            }
        }
        pub fn with_capacity(capacity: usize) -> Vocabulary<IndexT> {
            Vocabulary::String {
                map: HashMap::with_capacity(capacity),
                reverse_map: Vec::with_capacity(capacity),
            }
        }
        pub fn from_range(range: Range<IndexT>) -> Vocabulary<IndexT> {
            Vocabulary::Numeric {
                range: Range {
                    start: IndexT::to_usize(range.start),
                    end: IndexT::to_usize(range.end),
                },
                count: 0,
            }
        }
        pub fn from_reverse_map(mut reverse_map: Vec<String>) -> Result<Vocabulary<IndexT>> {
            let map = reverse_map
                .iter()
                .cloned()
                .enumerate()
                .map(|(i, x)| (x, IndexT::from_usize(i)))
                .collect::<HashMap<String, IndexT>>();
            if map.len() != reverse_map.len() {
                reverse_map.sort_unstable();
                let duplicates = reverse_map
                    .into_iter()
                    .scan(None, |last_object, object| {
                        let result = if (*last_object)
                            .as_ref()
                            .map_or(false, |&last_object| last_object == object)
                        {
                            None
                        } else {
                            Some(object)
                        };
                        (*last_object).insert(object);
                        result
                    })
                    .collect::<Vec<String>>();
                return Err({
                    let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1_formatted (& ["Duplicated values found while building the vocabulary!\nSpecifically the duplicated values are:\n" , "."] , & match (& duplicates ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , } , & [:: core :: fmt :: rt :: v1 :: Argument { position : 0usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 4u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Implied , width : :: core :: fmt :: rt :: v1 :: Count :: Is (4usize) , } , }])) ;
                    res
                });
            }
            Ok(Vocabulary::String { map, reverse_map })
        }
    }
    impl<IndexT: ToFromUsize> Vocabulary<IndexT> {
        fn normalize_value(&self, value: &str) -> Result<(String, IndexT)> {
            Ok(match self {
                Vocabulary::Numeric { .. } => {
                    let parsed_value = value.parse::<usize>().map_err(|_| {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["The given ID `", "` is not a numeric positive integer."],
                            &match (&value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                    let string_parsed_value = parsed_value.to_string();
                    if value != string_parsed_value {
                        return Err({
                            let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The given ID is numeric but is not symmetric.\nSpecifically, " , " != " , " where the first value is the user\'s one and the second one is the result of parsing the value as an  integer and casting back to string."] , & match (& value , & string_parsed_value) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , })) ;
                            res
                        });
                    }
                    (string_parsed_value, IndexT::from_usize(parsed_value))
                }
                Vocabulary::String { map, .. } => {
                    (value.to_string(), IndexT::from_usize(map.len()))
                }
            })
        }
        /// Returns id of given value inserted.
        ///
        /// # Arguments
        ///
        /// * `value`: String - The value to be inserted.
        pub unsafe fn unchecked_insert(&mut self, value: String) -> IndexT {
            match self {
                Vocabulary::String { map, reverse_map } => {
                    let current_length = map.len();
                    *map.entry(value)
                        .or_insert_with_key(|value| IndexT::from_usize(current_length))
                }
                Vocabulary::Numeric { range, count } => {
                    let value = value.parse::<usize>().unwrap_unchecked();
                    range.end = std::cmp::max(range.end, value);
                    *count += 1;
                    IndexT::from_usize(value - range.start)
                }
            }
        }
        /// Returns id of given value inserted.
        ///
        /// # Arguments
        ///
        /// * `value`: String - The value to be inserted.
        pub fn insert<S: AsRef<str>>(&mut self, value: S) -> Result<(IndexT, bool)> {
            let value = value.as_ref();
            if value.is_empty() {
                return Err(
                    "The given value is empty, we cannot insert an empty value into the vocabulary"
                        .to_string(),
                );
            }
            let (normalized_value, index) = self.normalize_value(value)?;
            match self {
                Vocabulary::String { map, reverse_map } => Ok(match map.entry(normalized_value) {
                    Entry::Occupied(extracted_index) => (*extracted_index.get(), true),
                    Entry::Vacant(vacant_entry) => (*vacant_entry.insert(index), false),
                }),
                Vocabulary::Numeric { range, count } => {
                    let value = unsafe { value.parse::<usize>().unwrap_unchecked() };
                    if value < range.start {
                        return Err ("The given numeric id is smaller than the minimum given on construction." . to_string ()) ;
                    }
                    range.end = range.end.max(value);
                    *count += 1;
                    Ok((IndexT::from_usize(value - range.start), false))
                }
            }
        }
        /// Compute the reverse mapping vector for fast decoding
        pub fn build(&mut self) -> Result<()> {
            match self {
                Vocabulary::Numeric { range, count } => {
                    let len = range.end - range.start;
                    if len == *count {
                        Ok(())
                    } else {
                        Err({
                            let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The given numeric values were not dense or they contained duplicates.Specifically this vocabulary was initialized with the range " , ".." , " which has " , " values, but insert was called " , " times. To be dense these values must match."] , & match (& range . start , & range . end , & len , & count) { (arg0 , arg1 , arg2 , arg3) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg3 , :: core :: fmt :: Display :: fmt)] , })) ;
                            res
                        })
                    }
                }
                Vocabulary::String { map, reverse_map } => {
                    if !reverse_map.is_empty() {
                        {
                            ::std::rt::begin_panic("Build reverse mapping called multiple times!")
                        };
                    }
                    *reverse_map = ::alloc::vec::from_elem("".to_string(), map.len());
                    for (k, v) in map.iter() {
                        if *v >= IndexT::from_usize(map.len()) {
                            return Err({
                                let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The given set of values is not dense. Found the tuple k:" , " v:" , " which has index bigger than the number of elements in the map " , "."] , & match (& k , & v , & map . len ()) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt)] , })) ;
                                res
                            });
                        }
                        if !reverse_map[IndexT::to_usize(*v)].is_empty() {
                            {
                                :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["During the building of the reverse mapping, one of the elements of the reverse mapping was attempted to be assigned multiple times. This means that in the map there are multiple nodes with the same id.\nIn the past this was caused by improper handling of numeric node id.\nIn this case, the value is " , " and its index is " , "."] , & match (& k , & v) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , }))
                            };
                        }
                        reverse_map[IndexT::to_usize(*v)] = k.clone();
                    }
                    Ok(())
                }
            }
        }
        /// Returns whether the value is empty or not.
        pub fn is_empty(&self) -> bool {
            match self {
                Vocabulary::String { map, .. } => map.is_empty(),
                Vocabulary::Numeric { range, .. } => range.is_empty(),
            }
        }
        /// Returns string name of given id.
        ///
        /// # Arguments
        ///
        /// * `id`: IndexT - Id to be translated.
        pub fn unchecked_translate(&self, id: IndexT) -> String {
            match self {
                Vocabulary::String { reverse_map, .. } => reverse_map[IndexT::to_usize(id)].clone(),
                Vocabulary::Numeric { .. } => {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&id,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
            }
        }
        /// Returns option with string name of given id.
        ///
        /// # Arguments
        ///
        /// * `id`: IndexT - Id to be translated.
        pub fn translate(&self, id: IndexT) -> Result<String> {
            match self {
                Vocabulary::String { reverse_map, .. } => match reverse_map
                    .get(IndexT::to_usize(id))
                {
                    Some(name) => Ok(name.clone()),
                    None => {
                        Err("The requested ID is not available in current dictionary.".to_string())
                    }
                },
                Vocabulary::Numeric { range, .. } => {
                    if range.contains(&IndexT::to_usize(id)) {
                        Ok({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[""],
                                &match (&id,) {
                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                        arg0,
                                        ::core::fmt::Display::fmt,
                                    )],
                                },
                            ));
                            res
                        })
                    } else {
                        Err(
                            "The requested id is over the range of the current numeric vocabulary."
                                .to_string(),
                        )
                    }
                }
            }
        }
        /// Return the id of given key.
        ///
        /// # Arguments
        ///
        /// * `key`: &str - the key whose Id is to be retrieved.
        pub fn get(&self, key: &str) -> Option<IndexT> {
            match self {
                Vocabulary::String { map, .. } => map.get(key).map(|x| *x),
                Vocabulary::Numeric { range, .. } => {
                    let id = unsafe { key.parse::<usize>().unwrap_unchecked() };
                    if range.contains(&id) {
                        Some(IndexT::from_usize(id))
                    } else {
                        None
                    }
                }
            }
        }
        /// Return vector of keys of the map.
        pub fn keys(&self) -> Vec<String> {
            match self {
                Vocabulary::String { map, reverse_map } => reverse_map.clone(),
                Vocabulary::Numeric { range, .. } => range
                    .map(|i| {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&i,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })
                    .collect::<_>(),
            }
        }
        /// Return boolean representing if given key is present.
        ///
        /// # Arguments
        ///
        /// * `key`: &str - the key to check existance of.
        pub fn contains_key(&self, key: &str) -> bool {
            match self {
                Vocabulary::String { map, .. } => map.contains_key(key),
                Vocabulary::Numeric { range, .. } => {
                    range.contains(&unsafe { key.parse::<usize>().unwrap_unchecked() })
                }
            }
        }
        /// Return length of the vocabulary.
        pub fn len(&self) -> usize {
            match self {
                Vocabulary::String { map, .. } => map.len(),
                Vocabulary::Numeric { range, .. } => range.end - range.start,
            }
        }
        /// Convert the current vocabulary to a string one.
        pub fn to_string_vocabulary(&mut self) {
            match self {
                Vocabulary::String { .. } => {}
                Vocabulary::Numeric { range, .. } => {
                    *self = Vocabulary::String {
                        map: range
                            .map(|i| {
                                (
                                    {
                                        let res =
                                            ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                                &[""],
                                                &match (&i,) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ));
                                        res
                                    },
                                    IndexT::from_usize(i),
                                )
                            })
                            .collect(),
                        reverse_map: range
                            .map(|i| {
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &[""],
                                    &match (&i,) {
                                        (arg0,) => [::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        )],
                                    },
                                ));
                                res
                            })
                            .collect(),
                    }
                }
            }
        }
        /// Removegiven values from the vocabulary
        ///
        /// # Arguments
        /// * `type_ids_to_remove`: Vec<IndexT> - The values to be removed.
        ///
        /// # Safety
        /// This method will panic if you try to remove values that do not exist
        /// in the current vocabulary.
        pub unsafe fn unchecked_remove_values(
            &mut self,
            type_ids_to_remove: Vec<IndexT>,
        ) -> Vec<Option<usize>> {
            let result = match self {
                Vocabulary::Numeric { range, count } => {
                    type_ids_to_remove.sort();
                    let mut min = range.start;
                    let mut i = 0;
                    while type_ids_to_remove[i] == IndexT::from_usize(min) {
                        min += 1;
                        i += 1;
                    }
                    let mut max = range.end;
                    let mut j = type_ids_to_remove.len() - 1;
                    while type_ids_to_remove[j] == IndexT::from_usize(max) {
                        max += 1;
                        j -= 1;
                    }
                    if i == j {
                        let new_range = min..max;
                        let result = range
                            .map(|i| {
                                if new_range.contains(&i) {
                                    Some(i - min)
                                } else {
                                    None
                                }
                            })
                            .collect::<Vec<Option<usize>>>();
                        *self = Vocabulary::Numeric {
                            range: new_range,
                            count: max - min,
                        };
                        result
                    } else {
                        self.to_string_vocabulary();
                        self.unchecked_remove_values(type_ids_to_remove)
                    }
                }
                Vocabulary::String { map, reverse_map } => {
                    let new_type_ids_map = (0..reverse_map.len())
                        .scan(0, |offset, type_id| {
                            if type_ids_to_remove.contains(&IndexT::from_usize(type_id)) {
                                *offset += 1;
                                return Some(None);
                            }
                            Some(Some(type_id - *offset))
                        })
                        .collect::<Vec<_>>();
                    *map = map
                        .iter()
                        .filter_map(|(key, val)| {
                            new_type_ids_map[IndexT::to_usize(*val)]
                                .map(|x| (key.clone(), IndexT::from_usize(x)))
                        })
                        .collect();
                    reverse_map.clear();
                    self.build().unwrap();
                    new_type_ids_map
                }
            };
            result
        }
    }
}
pub use self::vocabulary::Vocabulary;
mod node_type_vocabulary {
    use super::*;
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};
    pub struct NodeTypeVocabulary {
        /// This is the vector with the node types of each node
        /// Moreover, for the node x it's node type is ids[x]
        /// it's an option since the node might not have the node type
        /// and it contains a vector since we support multiple node types
        /// on the same node
        pub ids: Vec<Option<Vec<NodeTypeT>>>,
        pub vocabulary: Vocabulary<NodeTypeT>,
        pub counts: Vec<NodeT>,
        pub min_count: NodeT,
        pub max_count: NodeT,
        /// Maximum number of node type given to any node.
        /// TODO: update this value in a way that is always correct and minimal.
        pub max_multilabel_count: NodeTypeT,
        pub unknown_count: NodeT,
        pub multilabel: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for NodeTypeVocabulary {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                NodeTypeVocabulary {
                    ids: ref __self_0_0,
                    vocabulary: ref __self_0_1,
                    counts: ref __self_0_2,
                    min_count: ref __self_0_3,
                    max_count: ref __self_0_4,
                    max_multilabel_count: ref __self_0_5,
                    unknown_count: ref __self_0_6,
                    multilabel: ref __self_0_7,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "NodeTypeVocabulary");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "ids",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "vocabulary",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "counts",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "min_count",
                        &&(*__self_0_3),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "max_count",
                        &&(*__self_0_4),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "max_multilabel_count",
                        &&(*__self_0_5),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "unknown_count",
                        &&(*__self_0_6),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "multilabel",
                        &&(*__self_0_7),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for NodeTypeVocabulary {
        #[inline]
        fn clone(&self) -> NodeTypeVocabulary {
            match *self {
                NodeTypeVocabulary {
                    ids: ref __self_0_0,
                    vocabulary: ref __self_0_1,
                    counts: ref __self_0_2,
                    min_count: ref __self_0_3,
                    max_count: ref __self_0_4,
                    max_multilabel_count: ref __self_0_5,
                    unknown_count: ref __self_0_6,
                    multilabel: ref __self_0_7,
                } => NodeTypeVocabulary {
                    ids: ::core::clone::Clone::clone(&(*__self_0_0)),
                    vocabulary: ::core::clone::Clone::clone(&(*__self_0_1)),
                    counts: ::core::clone::Clone::clone(&(*__self_0_2)),
                    min_count: ::core::clone::Clone::clone(&(*__self_0_3)),
                    max_count: ::core::clone::Clone::clone(&(*__self_0_4)),
                    max_multilabel_count: ::core::clone::Clone::clone(&(*__self_0_5)),
                    unknown_count: ::core::clone::Clone::clone(&(*__self_0_6)),
                    multilabel: ::core::clone::Clone::clone(&(*__self_0_7)),
                },
            }
        }
    }
    impl NodeTypeVocabulary {
        fn compute_hash(&self) -> u64 {
            let mut hasher = DefaultHasher::new();
            self.hash(&mut hasher);
            hasher.finish()
        }
    }
    impl PartialEq for NodeTypeVocabulary {
        fn eq(&self, other: &Self) -> bool {
            self.compute_hash() == other.compute_hash()
        }
    }
    impl Default for NodeTypeVocabulary {
        fn default() -> NodeTypeVocabulary {
            NodeTypeVocabulary {
                ids: Vec::new(),
                vocabulary: Vocabulary::default(),
                counts: Vec::new(),
                min_count: 0,
                max_count: 0,
                max_multilabel_count: 0,
                unknown_count: NodeT::from_usize(0),
                multilabel: false,
            }
        }
    }
    impl NodeTypeVocabulary {
        pub fn from_structs(
            ids: Vec<Option<Vec<NodeTypeT>>>,
            vocabulary: Option<Vocabulary<NodeTypeT>>,
        ) -> Option<NodeTypeVocabulary> {
            match vocabulary {
                Some(vocab) => {
                    let multilabel = ids
                        .iter()
                        .any(|node_types| node_types.as_ref().map_or(false, |nts| nts.len() > 1));
                    let mut vocabvec = NodeTypeVocabulary {
                        ids,
                        vocabulary: vocab,
                        counts: Vec::new(),
                        min_count: 0,
                        max_count: 0,
                        max_multilabel_count: 0,
                        unknown_count: NodeT::from_usize(0),
                        multilabel,
                    };
                    vocabvec.build_counts();
                    Some(vocabvec)
                }
                None => None,
            }
        }
        pub fn build_counts(&mut self) {
            let mut counts = ::alloc::vec::from_elem(NodeT::from_usize(0), self.vocabulary.len());
            for index in self.ids.iter() {
                match index {
                    Some(values) => {
                        values.iter().for_each(|value| {
                            counts[NodeTypeT::to_usize(*value)] += NodeT::from_usize(1)
                        });
                    }
                    None => self.unknown_count += NodeT::from_usize(1),
                }
            }
            self.counts = counts;
            self.update_min_max_count();
        }
        fn update_min_max_count(&mut self) {
            self.min_count = self.counts.iter().cloned().min().unwrap_or(0);
            self.max_count = self.counts.iter().cloned().max().unwrap_or(0);
        }
        /// Computes the reverse terms mapping.
        ///
        /// # Raises
        /// * If the terms mapping is found to be not dense.
        pub fn build_reverse_mapping(&mut self) -> Result<()> {
            self.vocabulary.build_reverse_mapping()
        }
        /// Returns ids of given values inserted.
        ///
        /// This method will crash if improper parameters are used.
        ///
        /// # Arguments
        ///
        /// * `maybe_values`: Option<Vec<S>> - The values to be inserted.
        pub unsafe fn unchecked_insert_values<S: AsRef<str> + Into<String> + std::fmt::Debug>(
            &mut self,
            maybe_values: Option<Vec<S>>,
        ) -> Option<Vec<NodeTypeT>> {
            match maybe_values {
                Some(values) => {
                    let ids = values
                        .into_iter()
                        .map(|value| self.vocabulary.unchecked_insert(value.into()))
                        .collect::<Vec<NodeTypeT>>();
                    self.multilabel = self.multilabel || ids.len() > 1;
                    self.max_multilabel_count =
                        self.max_multilabel_count.max(ids.len() as NodeTypeT);
                    self.ids.push(Some(ids.clone()));
                    Some(ids)
                }
                None => {
                    self.ids.push(None);
                    None
                }
            }
        }
        /// Returns ids of given values inserted.
        ///
        /// # Arguments
        ///
        /// * `maybe_values`: Option<Vec<S>> - The values to be inserted.
        pub fn insert_values<S: AsRef<str> + std::fmt::Debug>(
            &mut self,
            maybe_values: Option<Vec<S>>,
        ) -> Result<Option<Vec<NodeTypeT>>> {
            Ok(match maybe_values {
                Some(values) => {
                    if values.is_empty() {
                        return Err("The given node types vector is empty.".to_owned());
                    }
                    let mut ids = values
                        .iter()
                        .map(|value| {
                            self.vocabulary
                                .insert(value.as_ref())
                                .map(|values| values.0)
                        })
                        .collect::<Result<Vec<NodeTypeT>>>()?;
                    ids.sort_unstable();
                    if ids[..ids.len() - 1]
                        .iter()
                        .zip(ids[1..].iter())
                        .any(|(a, b)| a == b)
                    {
                        return Err({
                            let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Node with duplicated node types was provided.\nSpecifically the node types vector of the node is " , " "] , & match (& values ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , })) ;
                            res
                        });
                    }
                    self.multilabel = self.multilabel || ids.len() > 1;
                    self.max_multilabel_count =
                        self.max_multilabel_count.max(ids.len() as NodeTypeT);
                    self.ids.push(Some(ids.clone()));
                    Some(ids)
                }
                None => {
                    self.ids.push(None);
                    None
                }
            })
        }
        /// Returns whether the vocabulary is empty or not.
        pub fn is_empty(&self) -> bool {
            self.vocabulary.is_empty()
        }
        /// Returns whether the node types are multi-label or not.
        pub fn is_multilabel(&self) -> bool {
            self.multilabel
        }
        /// Returns number of minimum node-count.
        pub fn get_minimum_node_type_count(&self) -> NodeT {
            self.min_count
        }
        /// Returns number of maximum node-count.
        pub fn get_maximum_node_type_count(&self) -> NodeT {
            self.max_count
        }
        /// Returns number of maximum multilabel count.
        ///
        /// This value is the maximum number of multilabel counts
        /// that appear in any given node in the graph.
        pub fn get_maximum_multilabel_count(&self) -> NodeTypeT {
            self.max_multilabel_count
        }
        /// Returns number of unknown nodes.
        pub fn get_unknown_count(&self) -> NodeT {
            self.unknown_count
        }
        /// Returns string name of given id.
        ///
        /// # Arguments
        ///
        /// * `id`: NodeTypeT - Node Type ID to be translated.
        pub fn unchecked_translate(&self, id: NodeTypeT) -> String {
            self.vocabulary.unchecked_translate(id)
        }
        /// Returns string name of given id.
        ///
        /// # Arguments
        ///
        /// * `id`: NodeTypeT - Node Type ID to be translated.
        pub fn translate(&self, id: NodeTypeT) -> Result<String> {
            self.vocabulary.translate(id)
        }
        /// Returns string name of given id.
        ///
        /// # Arguments
        ///
        /// * `ids`: Vec<NodeTypeT> - Node Type IDs to be translated.
        pub fn unchecked_translate_vector(&self, ids: Vec<NodeTypeT>) -> Vec<String> {
            ids.into_iter()
                .map(|id| self.unchecked_translate(id))
                .collect()
        }
        /// Returns string name of given id.
        ///
        /// # Arguments
        ///
        /// * `ids`: Vec<NodeTypeT> - Node Type IDs to be translated.
        pub fn translate_vector(&self, ids: Vec<NodeTypeT>) -> Result<Vec<String>> {
            ids.into_iter().map(|id| self.translate(id)).collect()
        }
        /// Return the id of given key.
        ///
        /// # Arguments
        ///
        /// * `key`: &str - the key whose Id is to be retrieved.
        pub fn get(&self, key: &str) -> Option<&NodeTypeT> {
            self.vocabulary.get(key)
        }
        /// Return vector of keys of the map.
        pub fn keys(&self) -> Vec<String> {
            self.vocabulary.keys()
        }
        /// Return length of the vocabulary.    
        pub fn len(&self) -> usize {
            self.counts.len()
        }
        /// Set whether to load IDs as numeric.
        ///
        /// # Arguments
        /// * numeric_ids: bool - Whether to load the IDs as numeric
        ///
        pub fn set_numeric_ids(mut self, numeric_ids: bool) -> NodeTypeVocabulary {
            self.vocabulary = self.vocabulary.set_numeric_ids(numeric_ids);
            self
        }
        /// Remove a node type from the vocabulary
        ///
        /// # Safety
        /// If any of the given values to be removed to not exist in the vocabulary
        /// this method will panic.
        pub unsafe fn unchecked_remove_values(
            &mut self,
            node_type_ids_to_remove: Vec<NodeTypeT>,
        ) -> Vec<Option<usize>> {
            self.counts = self
                .counts
                .iter()
                .enumerate()
                .filter_map(|(i, v)| {
                    if !node_type_ids_to_remove.contains(&(i as NodeTypeT)) {
                        Some(*v)
                    } else {
                        None
                    }
                })
                .collect();
            self.update_min_max_count();
            self.vocabulary
                .unchecked_remove_values(node_type_ids_to_remove)
        }
    }
}
pub use self::node_type_vocabulary::NodeTypeVocabulary;
mod edge_type_vocabulary {
    use super::*;
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};
    impl EdgeTypeVocabulary {
        fn compute_hash(&self) -> u64 {
            let mut hasher = DefaultHasher::new();
            self.hash(&mut hasher);
            hasher.finish()
        }
    }
    impl PartialEq for EdgeTypeVocabulary {
        fn eq(&self, other: &Self) -> bool {
            self.compute_hash() == other.compute_hash()
        }
    }
    pub struct EdgeTypeVocabulary {
        pub ids: Vec<Option<EdgeTypeT>>,
        pub vocabulary: Vocabulary<EdgeTypeT>,
        pub counts: Vec<EdgeT>,
        pub unknown_count: EdgeT,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for EdgeTypeVocabulary {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                EdgeTypeVocabulary {
                    ids: ref __self_0_0,
                    vocabulary: ref __self_0_1,
                    counts: ref __self_0_2,
                    unknown_count: ref __self_0_3,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "EdgeTypeVocabulary");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "ids",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "vocabulary",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "counts",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "unknown_count",
                        &&(*__self_0_3),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for EdgeTypeVocabulary {
        #[inline]
        fn clone(&self) -> EdgeTypeVocabulary {
            match *self {
                EdgeTypeVocabulary {
                    ids: ref __self_0_0,
                    vocabulary: ref __self_0_1,
                    counts: ref __self_0_2,
                    unknown_count: ref __self_0_3,
                } => EdgeTypeVocabulary {
                    ids: ::core::clone::Clone::clone(&(*__self_0_0)),
                    vocabulary: ::core::clone::Clone::clone(&(*__self_0_1)),
                    counts: ::core::clone::Clone::clone(&(*__self_0_2)),
                    unknown_count: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl EdgeTypeVocabulary {
        pub fn default() -> EdgeTypeVocabulary {
            EdgeTypeVocabulary {
                ids: Vec::new(),
                vocabulary: Vocabulary::default(),
                counts: Vec::new(),
                unknown_count: EdgeT::from_usize(0),
            }
        }
        pub fn from_structs(
            ids: Vec<Option<EdgeTypeT>>,
            vocabulary: Vocabulary<EdgeTypeT>,
        ) -> EdgeTypeVocabulary {
            let mut vocabvec = EdgeTypeVocabulary {
                ids,
                vocabulary,
                counts: Vec::new(),
                unknown_count: EdgeT::from_usize(0),
            };
            vocabvec.build_counts();
            vocabvec
        }
        pub fn from_option_structs(
            ids: Option<Vec<Option<EdgeTypeT>>>,
            vocabulary: Option<Vocabulary<EdgeTypeT>>,
        ) -> Option<EdgeTypeVocabulary> {
            if let (Some(ids), Some(vocabulary)) = (ids, vocabulary) {
                Some(EdgeTypeVocabulary::from_structs(ids, vocabulary))
            } else {
                None
            }
        }
        pub fn build_counts(&mut self) {
            self.counts = ::alloc::vec::from_elem(EdgeT::from_usize(0), self.vocabulary.len());
            for index in self.ids.iter() {
                match index {
                    Some(value) => {
                        self.counts[*value as usize] += 1;
                    }
                    None => self.unknown_count += EdgeT::from_usize(1),
                }
            }
        }
        /// Returns whether the value is empty or not.
        pub fn is_empty(&self) -> bool {
            self.vocabulary.is_empty()
        }
        /// Returns string name of given id.
        ///
        /// # Arguments
        ///
        /// * `id`: EdgeTypeT - Id to be translated.
        pub fn unchecked_translate(&self, id: EdgeTypeT) -> String {
            self.vocabulary.unchecked_translate(id)
        }
        /// Returns string name of given id.
        ///
        /// # Arguments
        ///
        /// * `id`: EdgeTypeT - Id to be translated.
        pub fn translate(&self, id: EdgeTypeT) -> Result<String> {
            self.vocabulary.translate(id)
        }
        /// Return the id of given key.
        ///
        /// # Arguments
        ///
        /// * `key`: &str - the key whose Id is to be retrieved.
        pub fn get(&self, key: &str) -> Option<&EdgeTypeT> {
            self.vocabulary.get(key)
        }
        /// Return vector of keys of the map.
        pub fn keys(&self) -> Vec<String> {
            self.vocabulary.keys()
        }
        /// Return length of the vocabulary.    
        pub fn len(&self) -> usize {
            self.counts.len()
        }
        /// Set whether to load IDs as numeric.
        ///
        /// # Arguments
        /// * numeric_ids: bool - Whether to load the IDs as numeric
        ///
        pub fn set_numeric_ids(mut self, numeric_ids: bool) -> EdgeTypeVocabulary {
            self.vocabulary = self.vocabulary.set_numeric_ids(numeric_ids);
            self
        }
        /// Returns number of unknown edges.
        pub fn get_unknown_count(&self) -> EdgeT {
            self.unknown_count
        }
        /// Returns number of minimum edge-count.
        pub fn min_edge_type_count(&self) -> EdgeT {
            *self.counts.iter().min().unwrap_or(&0)
        }
        /// Remove a edge type from the vocabulary
        ///
        /// # Safety
        /// If any of the given values to be removed to not exist in the vocabulary
        /// this method will panic.
        pub unsafe fn unchecked_remove_values(
            &mut self,
            edge_type_ids_to_remove: Vec<EdgeTypeT>,
        ) -> Vec<Option<usize>> {
            self.counts = self
                .counts
                .iter()
                .enumerate()
                .filter_map(|(i, v)| {
                    if !edge_type_ids_to_remove.contains(&(i as EdgeTypeT)) {
                        Some(*v)
                    } else {
                        None
                    }
                })
                .collect();
            self.vocabulary
                .unchecked_remove_values(edge_type_ids_to_remove)
        }
    }
}
pub use self::edge_type_vocabulary::EdgeTypeVocabulary;
mod csv_file_writer {
    use super::*;
    use indicatif::ProgressIterator;
    use std::{fs::File, io::prelude::*, io::BufWriter};
    /// Structure that saves the common parameters for reading csv files.
    ///
    /// # Attributes
    /// * path: String - The path where to save the file. E.g. "/tmp/test.csv"
    /// * `verbose`: bool - If the progress bars and logging must be displayed.
    /// * separator: String - The separator to use, usually, this is "\t" for tsv and "," for csv.
    /// * header: bool - If the file (will / must) have the header with the titles of the columns.
    pub struct CSVFileWriter {
        pub(crate) path: String,
        pub(crate) verbose: bool,
        pub(crate) separator: String,
        pub(crate) header: bool,
    }
    /// # Builder methods
    impl CSVFileWriter {
        /// Return new CSVFileWriter object.
        ///
        /// # Arguments
        ///
        /// * path: String - Path where to store/load the file.
        ///
        pub fn new<S: Into<String>>(path: S) -> CSVFileWriter {
            CSVFileWriter {
                path: path.into(),
                verbose: true,
                separator: "\t".to_string(),
                header: true,
            }
        }
        /// Write given rows iterator to file.
        ///
        /// # Arguments
        ///
        /// * `lines_number`: u64 - Number of lines to expect to write out.
        /// * `header`: Vec<String> - The header to write out, if so required.
        /// * `values`: impl Iterator<Item = Vec<String>> - Iterator of rows to write out.
        pub(crate) fn write_lines(
            &self,
            lines_number: usize,
            header: Vec<String>,
            values: impl Iterator<Item = Vec<String>>,
        ) -> Result<()> {
            let pb = get_loading_bar(self.verbose, "Writing to file", lines_number);
            let file = match File::create(self.path.clone()) {
                Ok(f) => Ok(f),
                Err(_) => Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Cannot open in writing the file "],
                        &match (&self.path,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }),
            }?;
            let mut stream = BufWriter::new(file);
            if self.header {
                let mut line = header.join(&self.separator);
                line.push('\n');
                match stream.write(line.as_bytes()) {
                    Ok(_) => Ok(()),
                    Err(_) => Err(
                        "Cannot write the header. There might have been an I/O error.".to_string(),
                    ),
                }?;
            }
            for (i, value) in values.progress_with(pb).enumerate() {
                let mut line = value.join(&self.separator);
                line.push('\n');
                match stream.write(line.as_bytes()) {
                    Ok(_) => Ok(()),
                    Err(_) => Err({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[
                                "Cannot write the ",
                                " line. There might have been an I/O error.",
                            ],
                            &match (&i,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    }),
                }?;
            }
            match stream.flush() {
                Ok(_) => Ok(()),
                Err(_) => {
                    Err("Unable to close file. There might have been an I/O error.".to_string())
                }
            }
        }
    }
    /// Return formatted vector of rows.
    ///
    /// # Arguments
    ///
    /// * `number_of_columns`: usize - Total number of columns to renderize.
    /// * `pairs`: Vec<(String, usize)> - Vector of tuples of column names and their position.
    pub(crate) fn compose_lines(
        number_of_columns: usize,
        pairs: Vec<(String, usize)>,
    ) -> Vec<String> {
        let mut values = ::alloc::vec::from_elem("".to_string(), number_of_columns);
        for (name, pos) in pairs {
            values[pos] = name
        }
        values
    }
}
pub(crate) use self::csv_file_writer::compose_lines;
pub use self::csv_file_writer::CSVFileWriter;
mod csv_file_reader {
    use super::*;
    use indicatif::ParallelProgressIterator;
    use itertools::Itertools;
    use rayon::iter::{ParallelBridge, ParallelIterator};
    use std::{fs::File, io::prelude::*, io::BufReader};
    use crate::utils::get_loading_bar;
    /// Structure that saves the common parameters for reading csv files.
    pub struct CSVFileReader {
        /// The of the file to read. E.g. "/tmp/test.csv"
        pub(crate) path: String,
        /// If the progress bars and logging must be displayed.
        pub(crate) verbose: bool,
        /// The separator to use, usually, this is "\t" for tsv and "," for csv.
        pub(crate) separator: String,
        /// If the file (will / must) have the header with the titles of the columns
        pub(crate) header: bool,
        /// When reading, how many lines to skip before starting to read the file.
        pub(crate) rows_to_skip: usize,
        /// Whether the program should raise an exception or not when the file contains duplicated edges / nodes.
        pub(crate) ignore_duplicates: bool,
        /// Whether the user pinky promises that the csv is not malformed and thus it
        /// can be loaded without additional checks, hence going faster.
        pub(crate) csv_is_correct: bool,
        /// Pinky promise that the file is well made.
        pub(crate) max_rows_number: Option<u64>,
        /// if the program should stop reading after a certain number of rows.
        pub(crate) comment_symbol: Option<String>,
        /// The name of the list that is being loaded.
        pub(crate) list_name: String,
        /// The name of graph that is being loaded.
        pub(crate) graph_name: String,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CSVFileReader {
        #[inline]
        fn clone(&self) -> CSVFileReader {
            match *self {
                CSVFileReader {
                    path: ref __self_0_0,
                    verbose: ref __self_0_1,
                    separator: ref __self_0_2,
                    header: ref __self_0_3,
                    rows_to_skip: ref __self_0_4,
                    ignore_duplicates: ref __self_0_5,
                    csv_is_correct: ref __self_0_6,
                    max_rows_number: ref __self_0_7,
                    comment_symbol: ref __self_0_8,
                    list_name: ref __self_0_9,
                    graph_name: ref __self_0_10,
                } => CSVFileReader {
                    path: ::core::clone::Clone::clone(&(*__self_0_0)),
                    verbose: ::core::clone::Clone::clone(&(*__self_0_1)),
                    separator: ::core::clone::Clone::clone(&(*__self_0_2)),
                    header: ::core::clone::Clone::clone(&(*__self_0_3)),
                    rows_to_skip: ::core::clone::Clone::clone(&(*__self_0_4)),
                    ignore_duplicates: ::core::clone::Clone::clone(&(*__self_0_5)),
                    csv_is_correct: ::core::clone::Clone::clone(&(*__self_0_6)),
                    max_rows_number: ::core::clone::Clone::clone(&(*__self_0_7)),
                    comment_symbol: ::core::clone::Clone::clone(&(*__self_0_8)),
                    list_name: ::core::clone::Clone::clone(&(*__self_0_9)),
                    graph_name: ::core::clone::Clone::clone(&(*__self_0_10)),
                },
            }
        }
    }
    /// # Builder methods
    impl CSVFileReader {
        /// Return new CSVFileReader object.
        ///
        /// # Arguments
        ///
        /// * path: String - Path where to store/load the file.
        /// * list_name: String - Name of the list that is being loaded.
        ///
        pub fn new<S: Into<String>>(path: S, list_name: String) -> Result<CSVFileReader> {
            let path = path.into();
            match File::open(&path) {
                Ok(_) => Ok(CSVFileReader {
                    path,
                    verbose: true,
                    separator: "\t".to_string(),
                    header: true,
                    rows_to_skip: 0,
                    ignore_duplicates: true,
                    csv_is_correct: false,
                    max_rows_number: None,
                    comment_symbol: None,
                    list_name,
                    graph_name: "Graph".to_string(),
                }),
                Err(_) => Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Cannot open the file at "],
                        &match (&path,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }),
            }
        }
        fn get_buffer_reader(&self) -> Result<BufReader<File>> {
            let file = File::open(&self.path);
            file.map_or_else(
                |_| {
                    Err({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Cannot open the file at "],
                            &match (&self.path,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })
                },
                |file| Ok(BufReader::new(file)),
            )
        }
        /// Read the whole file and return how many rows it has.
        pub(crate) fn count_rows(&self) -> Result<usize> {
            Ok(std::cmp::min(
                self.get_buffer_reader()?.lines().count(),
                self.max_rows_number.unwrap_or(u64::MAX) as usize,
            ))
        }
        /// Return list of components of the header.
        pub fn get_header(&self) -> Result<Vec<String>> {
            if let Some(first_line) = self.get_lines_iterator(false)?.next() {
                Ok(first_line?
                    .split(&self.separator)
                    .map(|s| s.to_string())
                    .collect::<Vec<String>>())
            } else {
                Err("The given file has no lines!".to_string())
            }
        }
        pub fn get_lines_iterator(
            &self,
            skip_header: bool,
        ) -> Result<impl Iterator<Item = Result<String>> + '_> {
            let rows_to_skip = match skip_header { true => match (self . rows_to_skip as u64) . checked_add (self . header as u64) { Some (v) => Ok (v) , None => Err ("This overflow was caused because rows to skip = 2**64 - 1and header is set to true which causes to skip one extra line.Do you **really** want to skip 18446744073709551615 lines? Bad person. Bad.") , } ? , false => self . rows_to_skip as u64 , } as usize ;
            Ok (self . get_buffer_reader () ? . lines () . map (| line | match line { Ok (l) => Ok (l) , Err (_) => Err ("There might have been an I/O error or the line could contains bytes that are not valid UTF-8" . to_string ()) , }) . filter_ok (move | line | ! line . is_empty () && match & self . comment_symbol { Some (cs) => ! line . starts_with (cs) , _ => true , }) . skip (rows_to_skip))
        }
        /// Return elements of the first line not to be skipped.
        pub fn get_elements_per_line(&self) -> Result<usize> {
            let first_line = self.get_lines_iterator(true)?.next();
            match first_line { Some (fl) => { match fl { Ok (f) => { Ok (f . matches (& self . separator) . count () + 1) } Err (_) => Err ("There might have been an I/O error or the line could contains bytes that are not valid UTF-8" . to_string ()) , } } None => Err ("Unable to read the first non skipped line of the file.\nThe file has possibly less than the expected amount of lines" . to_string ()) , }
        }
        /// Return iterator that read a CSV file rows.
        pub(crate) fn read_lines(
            &self,
        ) -> Result<impl ParallelIterator<Item = Result<Vec<Option<String>>>> + '_> {
            let pb = get_loading_bar(
                self.verbose,
                {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Reading ", "\'s "],
                        &match (&self.graph_name, &self.list_name) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                }
                .as_ref(),
                if self.verbose { self.count_rows()? } else { 0 },
            );
            let number_of_elements_per_line = self.get_elements_per_line()?;
            Ok(self
                .get_lines_iterator(true)?
                .take(self.max_rows_number.unwrap_or(u64::MAX) as usize)
                .par_bridge()
                .progress_with(pb)
                .map(move |line| match line {
                    Ok(line) => {
                        let mut elements: Vec<Option<String>> = line
                            .split(&self.separator)
                            .map(|element| match element.is_empty() {
                                true => None,
                                false => Some(element.to_string()),
                            })
                            .collect();
                        elements.resize(number_of_elements_per_line, None);
                        Ok(elements)
                    }
                    Err(e) => Err(e),
                }))
        }
        /// Return number of the given column in header.
        ///
        /// # Arguments
        ///
        /// * column_name: String - Column to get the number of.
        ///
        pub fn get_column_number(&self, column_name: String) -> Result<usize> {
            let header = self.get_header()?;
            match header.iter().position(|x| *x == column_name) {
                Some(column_number) => Ok(column_number),
                None => Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["The column \'", "\' is not present in the header\n"],
                        &match (&column_name, &header) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                            ],
                        },
                    ));
                    res
                }),
            }
        }
    }
}
pub use self::csv_file_reader::CSVFileReader;
mod node_file_reader {
    use rayon::iter::ParallelIterator;
    use super::*;
    /// Structure that saves the reader specific to writing and reading a nodes csv file.
    ///
    /// # Attributes
    /// * reader: CSVFile - The common reader for reading and writing a csv.
    /// * default_node_type: Option<String> - The node type to use if a node has node type or its node type is "".
    /// * nodes_column_number: Option<usize> - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.
    /// * node_types_separator: Option<String> - Separator to split the node types.
    /// * node_types_column_number: Option<usize> - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.
    /// * numeric_node_ids: bool - Whether to load the node IDs as numeric.
    /// * numeric_node_type_ids: bool - Whether to load the node type IDs as numeric.
    /// * skip_node_types_if_unavailable: bool - Whether to skip attempting to load the node types if column is unavailable.
    ///
    pub struct NodeFileReader {
        pub(crate) reader: CSVFileReader,
        pub(crate) default_node_type: Option<String>,
        pub(crate) nodes_column_number: Option<usize>,
        pub(crate) node_types_separator: Option<String>,
        pub(crate) node_types_column_number: Option<usize>,
        pub(crate) numeric_node_ids: bool,
        pub(crate) numeric_node_type_ids: bool,
        pub(crate) skip_node_types_if_unavailable: bool,
        pub(crate) might_contain_singletons: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for NodeFileReader {
        #[inline]
        fn clone(&self) -> NodeFileReader {
            match *self {
                NodeFileReader {
                    reader: ref __self_0_0,
                    default_node_type: ref __self_0_1,
                    nodes_column_number: ref __self_0_2,
                    node_types_separator: ref __self_0_3,
                    node_types_column_number: ref __self_0_4,
                    numeric_node_ids: ref __self_0_5,
                    numeric_node_type_ids: ref __self_0_6,
                    skip_node_types_if_unavailable: ref __self_0_7,
                    might_contain_singletons: ref __self_0_8,
                } => NodeFileReader {
                    reader: ::core::clone::Clone::clone(&(*__self_0_0)),
                    default_node_type: ::core::clone::Clone::clone(&(*__self_0_1)),
                    nodes_column_number: ::core::clone::Clone::clone(&(*__self_0_2)),
                    node_types_separator: ::core::clone::Clone::clone(&(*__self_0_3)),
                    node_types_column_number: ::core::clone::Clone::clone(&(*__self_0_4)),
                    numeric_node_ids: ::core::clone::Clone::clone(&(*__self_0_5)),
                    numeric_node_type_ids: ::core::clone::Clone::clone(&(*__self_0_6)),
                    skip_node_types_if_unavailable: ::core::clone::Clone::clone(&(*__self_0_7)),
                    might_contain_singletons: ::core::clone::Clone::clone(&(*__self_0_8)),
                },
            }
        }
    }
    impl NodeFileReader {
        /// Return new NodeFileReader object.
        ///
        /// # Arguments
        ///
        /// * reader: CSVFileParameters - Path where to store/load the file.
        ///
        pub fn new<S: Into<String>>(path: S) -> Result<NodeFileReader> {
            Ok(NodeFileReader {
                reader: CSVFileReader::new(path, "node list".to_owned())?,
                default_node_type: None,
                nodes_column_number: None,
                node_types_separator: None,
                node_types_column_number: None,
                numeric_node_ids: false,
                numeric_node_type_ids: false,
                skip_node_types_if_unavailable: false,
                might_contain_singletons: true,
            })
        }
        /// Set the column of the nodes.
        ///
        /// # Arguments
        ///
        /// * nodes_column: Option<String> - The nodes column to use for the file.
        ///
        pub fn set_nodes_column<S: Into<String>>(
            mut self,
            nodes_column: Option<S>,
        ) -> Result<NodeFileReader> {
            if let Some(column) = nodes_column {
                let column = column.into();
                if column.is_empty() {
                    return Err("The given node column is empty.".to_owned());
                }
                self.nodes_column_number = Some(self.reader.get_column_number(column)?);
            }
            Ok(self)
        }
        /// Set the column_number of the nodes.
        ///
        /// # Arguments
        ///
        /// * nodes_column_number: Option<usize> - The nodes column_number to use for the file.
        ///t
        pub fn set_nodes_column_number(
            mut self,
            nodes_column_number: Option<usize>,
        ) -> NodeFileReader {
            self.nodes_column_number = nodes_column_number;
            self
        }
        /// Set the name of the graph to be loaded.
        ///
        /// # Arguments
        ///
        /// * graph_name: String - The name of the graph to be loaded.
        ///
        pub(crate) fn set_graph_name(mut self, graph_name: String) -> NodeFileReader {
            self.reader.graph_name = graph_name;
            self
        }
        /// Set the column of the nodes.
        ///
        /// # Arguments
        ///
        /// * node_types_column: Option<String> - The node types column to use for the file.
        ///
        pub fn set_node_types_column<S: Into<String>>(
            mut self,
            nodes_type_column: Option<S>,
        ) -> Result<NodeFileReader> {
            if let Some(column) = nodes_type_column {
                let column = column.into();
                if column.is_empty() {
                    return Err("The given node types column is empty.".to_owned());
                }
                match self.reader.get_column_number(column) {
                    Ok(ecn) => {
                        self.node_types_column_number = Some(ecn);
                    }
                    Err(e) => {
                        if !self.skip_node_types_if_unavailable {
                            return Err(e);
                        }
                    }
                }
            }
            Ok(self)
        }
        /// Set the column_number of the nodes.
        ///
        /// # Arguments
        ///
        /// * node_types_column_number: Option<usize> - The node types column_number to use for the file.
        ///
        pub fn set_node_types_column_number(
            mut self,
            node_types_column_number: Option<usize>,
        ) -> NodeFileReader {
            self.node_types_column_number = node_types_column_number;
            self
        }
        /// Set whether to automatically skip node_types if they are not avaitable instead of raising an exception.
        ///
        /// # Arguments
        ///
        /// * skip_node_types_if_unavailable: Option<bool> - Whether to skip node_types if they are not available.
        ///
        pub fn set_skip_node_types_if_unavailable(
            mut self,
            skip_node_types_if_unavailable: Option<bool>,
        ) -> Result<NodeFileReader> {
            if let Some(skip) = skip_node_types_if_unavailable {
                self.skip_node_types_if_unavailable = skip;
            }
            Ok(self)
        }
        /// Set whether you pinky promise that this graph has singletons or not.
        ///
        /// # Arguments
        ///
        /// * `might_contain_singletons`: Option<bool> - Whether this graph has singletons.
        ///
        pub fn set_might_contain_singleton_nodes(
            mut self,
            might_contain_singletons: Option<bool>,
        ) -> Result<NodeFileReader> {
            if let Some(skip) = might_contain_singletons {
                self.might_contain_singletons = skip;
            }
            Ok(self)
        }
        /// Set the comment symbol to use to skip the lines.
        ///
        /// # Arguments
        ///
        /// * comment_symbol: Option<String> - if the reader should ignore or not duplicated edges.
        ///
        pub fn set_comment_symbol(
            mut self,
            comment_symbol: Option<String>,
        ) -> Result<NodeFileReader> {
            if let Some(cs) = comment_symbol {
                if cs.is_empty() {
                    return Err("The given comment symbol is empty.".to_string());
                }
                self.reader.comment_symbol = Some(cs);
            }
            Ok(self)
        }
        /// Set whether the CSV is expected to be well written.
        ///
        /// # Arguments
        ///
        /// * csv_is_correct: Option<bool> - Whether you pinky swear the node list is correct.
        ///
        pub fn set_csv_is_correct(mut self, csv_is_correct: Option<bool>) -> NodeFileReader {
            if let Some(cic) = csv_is_correct {
                self.reader.csv_is_correct = cic;
            }
            self
        }
        /// Set the default node type.
        ///
        /// # Arguments
        ///
        /// * default_node_type: Option<String> - The node type to use when node type is missing.
        ///
        pub fn set_default_node_type<S: Into<String>>(
            mut self,
            default_node_type: Option<S>,
        ) -> NodeFileReader {
            self.default_node_type = default_node_type.map(|val| val.into());
            self
        }
        /// Set the verbose.
        ///
        /// # Arguments
        ///
        /// * `verbose`: Option<bool> - Whether to show the loading bar or not.
        ///
        pub fn set_verbose(mut self, verbose: Option<bool>) -> NodeFileReader {
            if let Some(v) = verbose {
                self.reader.verbose = v;
            }
            self
        }
        /// Set the numeric_id.
        ///
        /// # Arguments
        ///
        /// * numeric_node_type_ids: Option<bool> - Whether to convert numeric node type Ids to Node Type Ids.
        ///
        pub fn set_numeric_node_type_ids(
            mut self,
            numeric_node_type_ids: Option<bool>,
        ) -> NodeFileReader {
            if let Some(nnti) = numeric_node_type_ids {
                self.numeric_node_type_ids = nnti;
            }
            self
        }
        /// Set the numeric_id.
        ///
        /// # Arguments
        ///
        /// * numeric_node_ids: Option<bool> - Whether to convert numeric node type Ids to Node Type Ids.
        ///
        pub fn set_numeric_node_ids(mut self, numeric_node_ids: Option<bool>) -> NodeFileReader {
            if let Some(nni) = numeric_node_ids {
                self.numeric_node_ids = nni;
            }
            self
        }
        /// Set the ignore_duplicates.
        ///
        /// # Arguments
        ///
        /// * ignore_duplicates: Option<bool> - Whether to ignore detected duplicates or raise exception.
        ///
        pub fn set_ignore_duplicates(mut self, ignore_duplicates: Option<bool>) -> NodeFileReader {
            if let Some(v) = ignore_duplicates {
                self.reader.ignore_duplicates = v;
            }
            self
        }
        /// Set the separator.
        ///
        /// # Arguments
        ///
        /// * separator: Option<String> - The separator to use for the file.
        ///
        pub fn set_separator<S: Into<String>>(
            mut self,
            separator: Option<S>,
        ) -> Result<NodeFileReader> {
            if let Some(sep) = separator {
                let sep = sep.into();
                if sep.is_empty() {
                    return Err("The separator cannot be empty.".to_owned());
                }
                self.reader.separator = sep;
            }
            Ok(self)
        }
        /// Set the node types separator.
        ///
        /// In the following example we show a column of node IDs and
        /// a column of node types.
        ///
        /// ```bash
        /// node_id_columns node_types
        /// node_A node_type_1|node_type_2
        /// node_B node_type_2
        /// ```  
        ///
        /// # Arguments
        ///
        /// * node_types_separator: Option<String> - The separator to use for the node types column.
        ///
        pub fn set_node_types_separator<S: Into<String>>(
            mut self,
            node_types_separator: Option<S>,
        ) -> Result<NodeFileReader> {
            if let Some(sep) = node_types_separator {
                let sep = sep.into();
                if sep.is_empty() {
                    return Err("The node type separator cannot be empty.".to_owned());
                }
                self.node_types_separator = Some(sep);
            }
            Ok(self)
        }
        /// Set the header.
        ///
        /// # Arguments
        ///
        /// * header: Option<bool> - Whether to expect an header or not.
        ///
        pub fn set_header(mut self, header: Option<bool>) -> NodeFileReader {
            if let Some(v) = header {
                self.reader.header = v;
            }
            self
        }
        /// Set number of rows to be skipped when starting to read file.
        ///
        /// # Arguments
        ///
        /// * rows_to_skip: Option<bool> - Whether to show the loading bar or not.
        ///
        pub fn set_rows_to_skip(mut self, rows_to_skip: Option<usize>) -> NodeFileReader {
            if let Some(v) = rows_to_skip {
                self.reader.rows_to_skip = v;
            }
            self
        }
        /// Set the maximum number of rows to load from the file
        ///
        /// # Arguments
        ///
        /// * max_rows_number: Option<u64> - The edge type to use when edge type is missing.
        ///
        pub fn set_max_rows_number(mut self, max_rows_number: Option<u64>) -> NodeFileReader {
            self.reader.max_rows_number = max_rows_number;
            self
        }
        /// Return boolean representing if the node types exist.
        pub fn has_node_types(&self) -> bool {
            self.default_node_type.is_some() || self.node_types_column_number.is_some()
        }
        /// Return iterator of the lines of the node file.
        pub fn read_lines(
            &self,
        ) -> Result<impl ParallelIterator<Item = Result<(String, Option<Vec<String>>)>> + '_>
        {
            if [self.nodes_column_number, self.node_types_column_number]
                .iter()
                .all(|val| val.is_none())
            {
                return Err("Neither nodes ID column or node types column were given!".to_string());
            }
            if self.nodes_column_number == self.node_types_column_number {
                return Err("The node column is the same as the node type one.".to_string());
            }
            let expected_number_of_elements = self.reader.get_elements_per_line()?;
            for column in [self.nodes_column_number, self.node_types_column_number]
                .iter()
                .filter_map(|maybe_column| *maybe_column)
            {
                if column >= expected_number_of_elements {
                    return Err({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[
                                "A column number passed was ",
                                " but the first parsable line has ",
                                " values.",
                            ],
                            &match (&column, &expected_number_of_elements) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ],
                            },
                        ));
                        res
                    });
                }
            }
            Ok(self.reader.read_lines()?.enumerate().map(
                move |(line_number, values)| match values {
                    Ok(vals) => {
                        let node_name = match self.nodes_column_number {
                            Some(column) => match vals[column].to_owned() {
                                Some(node_name) => node_name,
                                None => {
                                    return Err(
                                        "One of the provided node IDs is empty or None.".to_owned()
                                    )
                                }
                            },
                            None => line_number.to_string(),
                        };
                        let maybe_node_types_string = match self.node_types_column_number {
                            Some(column) => match vals[column].to_owned() {
                                Some(node_type) => Some(node_type),
                                None => self.default_node_type.clone(),
                            },
                            None => self.default_node_type.clone(),
                        };
                        let node_types = match maybe_node_types_string {
                            Some(string) => match &self.node_types_separator {
                                Some(sep) => Some(string.split(sep).map(String::from).collect()),
                                None => Some(<[_]>::into_vec(box [string])),
                            },
                            None => None,
                        };
                        Ok((node_name, node_types))
                    }
                    Err(e) => Err(e),
                },
            ))
        }
    }
}
pub use self::node_file_reader::NodeFileReader;
mod node_file_writer {
    use super::*;
    /// Structure that saves the writer specific to writing and reading a nodes csv file.
    ///
    /// # Attributes
    /// * writer: CSVFileWriter - The common writer for readin and writing a csv.
    /// * nodes_column: String - The name of the nodes names column. This parameter is mutually exclusive with nodes_column_number.
    /// * nodes_column_number: usize - The rank of the column with the nodes names. This parameter is mutually exclusive with nodes_column.
    /// * node_types_column: String - The name of the nodes type column. This parameter is mutually exclusive with node_types_column_number.
    /// * node_types_column_number: usize - The rank of the column with the nodes types. This parameter is mutually exclusive with node_types_column.
    /// * node_types_separator: String - Separator to split the node types.
    pub struct NodeFileWriter {
        pub(crate) writer: CSVFileWriter,
        pub(crate) nodes_column: String,
        pub(crate) node_types_column: String,
        pub(crate) nodes_column_number: usize,
        pub(crate) node_types_column_number: usize,
        pub(crate) node_types_separator: String,
    }
    impl NodeFileWriter {
        /// Return new NodeFileWriter object.
        ///
        /// # Arguments
        ///
        /// * path: String - Path where to store/load the file.
        ///
        pub fn new<S: Into<String>>(path: S) -> NodeFileWriter {
            NodeFileWriter {
                writer: CSVFileWriter::new(path),
                nodes_column: "id".to_string(),
                nodes_column_number: 0,
                node_types_column: "category".to_string(),
                node_types_column_number: 1,
                node_types_separator: "".to_string(),
            }
        }
        /// Set the column of the nodes.
        ///
        /// # Arguments
        ///
        /// * nodes_column: Option<String> - The nodes column to use for the file.
        ///
        pub fn set_nodes_column<S: Into<String>>(
            mut self,
            nodes_column: Option<S>,
        ) -> NodeFileWriter {
            if let Some(column) = nodes_column {
                self.nodes_column = column.into();
            }
            self
        }
        /// Set the column of the nodes.
        ///
        /// # Arguments
        ///
        /// * node_types_column: Option<String> - The node types column to use for the file.
        ///
        pub fn set_node_types_column<S: Into<String>>(
            mut self,
            nodes_type_column: Option<S>,
        ) -> NodeFileWriter {
            if let Some(column) = nodes_type_column {
                self.node_types_column = column.into();
            }
            self
        }
        /// Set the column_number of the nodes.
        ///
        /// # Arguments
        ///
        /// * nodes_column_number: Option<usize> - The nodes column_number to use for the file.
        ///
        pub fn set_nodes_column_number(
            mut self,
            nodes_column_number: Option<usize>,
        ) -> NodeFileWriter {
            if let Some(column) = nodes_column_number {
                self.nodes_column_number = column;
            }
            self
        }
        /// Set the column_number of the nodes.
        ///
        /// # Arguments
        ///
        /// * node_types_column_number: Option<usize> - The node types column_number to use for the file.
        ///
        pub fn set_node_types_column_number(
            mut self,
            node_types_column_number: Option<usize>,
        ) -> NodeFileWriter {
            if let Some(v) = node_types_column_number {
                self.node_types_column_number = v;
            }
            self
        }
        /// Set the verbose.
        ///
        /// # Arguments
        ///
        /// * `verbose`: Option<bool> - Whether to show the loading bar or not.
        ///
        pub fn set_verbose(mut self, verbose: Option<bool>) -> NodeFileWriter {
            if let Some(v) = verbose {
                self.writer.verbose = v;
            }
            self
        }
        /// Set the separator.
        ///
        /// # Arguments
        ///
        /// * separator: Option<String> - The separator to use for the file.
        ///
        pub fn set_separator<S: Into<String>>(mut self, separator: Option<S>) -> NodeFileWriter {
            if let Some(v) = separator {
                self.writer.separator = v.into();
            }
            self
        }
        /// Set the header.
        ///
        /// # Arguments
        ///
        /// * header: Option<bool> - Whether to write out an header or not.
        ///
        pub fn set_header(mut self, header: Option<bool>) -> NodeFileWriter {
            if let Some(v) = header {
                self.writer.header = v;
            }
            self
        }
        /// Write nodes to file.
        ///
        /// # Arguments
        ///
        /// * `graph`: &Graph, reference to graph to use.
        pub fn dump(&self, graph: &Graph) -> Result<()> {
            let mut header =
                <[_]>::into_vec(box [(self.nodes_column.clone(), self.nodes_column_number)]);
            if graph.has_node_types() {
                header.push((
                    self.node_types_column.clone(),
                    self.node_types_column_number,
                ));
            }
            let number_of_columns = 1 + header.iter().map(|(_, i)| i).max().unwrap();
            self.writer.write_lines(
                graph.get_nodes_number() as usize,
                compose_lines(number_of_columns, header),
                (0..graph.get_nodes_number()).map(|node_id| {
                    let mut line = <[_]>::into_vec(box [(
                        graph.nodes.unchecked_translate(node_id),
                        self.nodes_column_number,
                    )]);
                    if graph.has_node_types() {
                        line.push((
                            match graph.get_node_type_names_from_node_id(node_id).unwrap() {
                                Some(values) => values.join(&self.node_types_separator),
                                None => "".to_string(),
                            },
                            self.node_types_column_number,
                        ));
                    }
                    compose_lines(number_of_columns, line)
                }),
            )
        }
    }
}
pub use self::node_file_writer::NodeFileWriter;
mod edge_file_reader {
    use rayon::iter::ParallelIterator;
    use super::*;
    /// Structure that saves the reader specific to writing and reading a nodes csv file.
    ///
    /// # Attributes
    pub struct EdgeFileReader {
        pub(crate) reader: CSVFileReader,
        pub(crate) sources_column_number: usize,
        pub(crate) destinations_column_number: usize,
        pub(crate) edge_types_column_number: Option<usize>,
        pub(crate) default_edge_type: Option<String>,
        pub(crate) weights_column_number: Option<usize>,
        pub(crate) default_weight: Option<WeightT>,
        pub(crate) skip_selfloops: bool,
        pub(crate) numeric_edge_type_ids: bool,
        pub(crate) numeric_node_ids: bool,
        pub(crate) skip_weights_if_unavailable: bool,
        pub(crate) skip_edge_types_if_unavailable: bool,
        pub(crate) might_contain_singletons_with_selfloops: bool,
        pub(crate) might_contain_trap_nodes: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for EdgeFileReader {
        #[inline]
        fn clone(&self) -> EdgeFileReader {
            match *self {
                EdgeFileReader {
                    reader: ref __self_0_0,
                    sources_column_number: ref __self_0_1,
                    destinations_column_number: ref __self_0_2,
                    edge_types_column_number: ref __self_0_3,
                    default_edge_type: ref __self_0_4,
                    weights_column_number: ref __self_0_5,
                    default_weight: ref __self_0_6,
                    skip_selfloops: ref __self_0_7,
                    numeric_edge_type_ids: ref __self_0_8,
                    numeric_node_ids: ref __self_0_9,
                    skip_weights_if_unavailable: ref __self_0_10,
                    skip_edge_types_if_unavailable: ref __self_0_11,
                    might_contain_singletons_with_selfloops: ref __self_0_12,
                    might_contain_trap_nodes: ref __self_0_13,
                } => EdgeFileReader {
                    reader: ::core::clone::Clone::clone(&(*__self_0_0)),
                    sources_column_number: ::core::clone::Clone::clone(&(*__self_0_1)),
                    destinations_column_number: ::core::clone::Clone::clone(&(*__self_0_2)),
                    edge_types_column_number: ::core::clone::Clone::clone(&(*__self_0_3)),
                    default_edge_type: ::core::clone::Clone::clone(&(*__self_0_4)),
                    weights_column_number: ::core::clone::Clone::clone(&(*__self_0_5)),
                    default_weight: ::core::clone::Clone::clone(&(*__self_0_6)),
                    skip_selfloops: ::core::clone::Clone::clone(&(*__self_0_7)),
                    numeric_edge_type_ids: ::core::clone::Clone::clone(&(*__self_0_8)),
                    numeric_node_ids: ::core::clone::Clone::clone(&(*__self_0_9)),
                    skip_weights_if_unavailable: ::core::clone::Clone::clone(&(*__self_0_10)),
                    skip_edge_types_if_unavailable: ::core::clone::Clone::clone(&(*__self_0_11)),
                    might_contain_singletons_with_selfloops: ::core::clone::Clone::clone(
                        &(*__self_0_12),
                    ),
                    might_contain_trap_nodes: ::core::clone::Clone::clone(&(*__self_0_13)),
                },
            }
        }
    }
    impl EdgeFileReader {
        /// Return new EdgeFileReader object.
        ///
        /// # Arguments
        ///
        /// * reader: CSVFilereader - Path where to store/load the file.
        ///
        pub fn new<S: Into<String>>(path: S) -> Result<EdgeFileReader> {
            Ok(EdgeFileReader {
                reader: CSVFileReader::new(path, "edge list".to_owned())?,
                sources_column_number: 0,
                destinations_column_number: 1,
                edge_types_column_number: None,
                default_edge_type: None,
                weights_column_number: None,
                default_weight: None,
                skip_selfloops: false,
                numeric_edge_type_ids: false,
                numeric_node_ids: false,
                skip_weights_if_unavailable: false,
                skip_edge_types_if_unavailable: false,
                might_contain_singletons_with_selfloops: true,
                might_contain_trap_nodes: true,
            })
        }
        /// Set the column of the source nodes.
        ///
        /// # Arguments
        ///
        /// * sources_column: Option<String> - The source nodes column to use for the file.
        ///
        pub fn set_sources_column<S: Into<String>>(
            mut self,
            sources_column: Option<S>,
        ) -> Result<EdgeFileReader> {
            if let Some(column) = sources_column {
                let column = column.into();
                if column.is_empty() {
                    return Err("The given node types column is empty.".to_owned());
                }
                match self.reader.get_column_number(column) {
                    Ok(ecn) => {
                        self = self.set_sources_column_number(Some(ecn))?;
                    }
                    Err(e) => {
                        if !self.skip_edge_types_if_unavailable {
                            return Err(e);
                        }
                    }
                }
            }
            Ok(self)
        }
        /// Set the column_number of the nodes.
        ///
        /// # Arguments
        ///
        /// * sources_column_number: Option<usize> - The sources column number to use for the file.
        ///
        pub fn set_sources_column_number(
            mut self,
            sources_column_number: Option<usize>,
        ) -> Result<EdgeFileReader> {
            if let Some(column) = sources_column_number {
                let expected_elements = self.reader.get_elements_per_line()?;
                if column >= expected_elements {
                    return Err({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[
                                "The source column number passed was ",
                                " but the first parsable line has ",
                                " values.",
                            ],
                            &match (&column, &expected_elements) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ],
                            },
                        ));
                        res
                    });
                }
                self.sources_column_number = column;
            }
            Ok(self)
        }
        /// Set the column of the nodes.
        ///
        /// # Arguments
        ///
        /// * destination_column: Option<String> - The node types column to use for the file.
        ///
        pub fn set_destinations_column<S: Into<String>>(
            mut self,
            destinations_column: Option<S>,
        ) -> Result<EdgeFileReader> {
            if let Some(column) = destinations_column {
                let column = column.into();
                if column.is_empty() {
                    return Err("The given node types column is empty.".to_owned());
                }
                match self.reader.get_column_number(column) {
                    Ok(ecn) => {
                        self = self.set_destinations_column_number(Some(ecn))?;
                    }
                    Err(e) => {
                        if !self.skip_edge_types_if_unavailable {
                            return Err(e);
                        }
                    }
                }
            }
            Ok(self)
        }
        /// Set the column_number of the nodes.
        ///
        /// # Arguments
        ///
        /// * destinations_column_number: Option<usize> - The destinations column number to use for the file.
        ///
        pub fn set_destinations_column_number(
            mut self,
            destinations_column_number: Option<usize>,
        ) -> Result<EdgeFileReader> {
            if let Some(column) = destinations_column_number {
                let expected_elements = self.reader.get_elements_per_line()?;
                if column >= expected_elements {
                    return Err({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[
                                "The destinations column number passed was ",
                                " but the first parsable line has ",
                                " values.",
                            ],
                            &match (&column, &expected_elements) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ],
                            },
                        ));
                        res
                    });
                }
                self.destinations_column_number = column;
            }
            Ok(self)
        }
        /// Set the column of the nodes.
        ///
        /// # Arguments
        ///
        /// * destination_column: Option<String> - The node types column to use for the file.
        ///
        pub fn set_edge_types_column<S: Into<String>>(
            mut self,
            edge_type_column: Option<S>,
        ) -> Result<EdgeFileReader> {
            if let Some(column) = edge_type_column {
                let column = column.into();
                if column.is_empty() {
                    return Err("The given node types column is empty.".to_owned());
                }
                match self.reader.get_column_number(column) {
                    Ok(ecn) => {
                        self = self.set_edge_types_column_number(Some(ecn))?;
                    }
                    Err(e) => {
                        if !self.skip_edge_types_if_unavailable {
                            return Err(e);
                        }
                    }
                }
            }
            Ok(self)
        }
        /// Set the column_number of the nodes.
        ///
        /// # Arguments
        ///
        /// * edge_types_column_number: Option<usize> - The edge_types column number to use for the file.
        ///
        pub fn set_edge_types_column_number(
            mut self,
            edge_types_column_number: Option<usize>,
        ) -> Result<EdgeFileReader> {
            if let Some(etcn) = &edge_types_column_number {
                let expected_elements = self.reader.get_elements_per_line()?;
                if *etcn >= expected_elements {
                    if !self.skip_edge_types_if_unavailable {
                        return Err({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "The edge types column number passed was ",
                                    " but the first parsable line has ",
                                    " values.",
                                ],
                                &match (&etcn, &expected_elements) {
                                    (arg0, arg1) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                    ],
                                },
                            ));
                            res
                        });
                    }
                } else {
                    self.edge_types_column_number = edge_types_column_number;
                }
            }
            Ok(self)
        }
        /// Set the column of the edge weights.
        ///
        /// # Arguments
        ///
        /// * weights_column: Option<String> - The edge weights column to use for the file.
        ///
        pub fn set_weights_column<S: Into<String>>(
            mut self,
            weights_column: Option<S>,
        ) -> Result<EdgeFileReader> {
            if let Some(column) = weights_column {
                let column = column.into();
                if column.is_empty() {
                    return Err("The given edge weights column is empty.".to_owned());
                }
                match self.reader.get_column_number(column) {
                    Ok(wcn) => {
                        self = self.set_weights_column_number(Some(wcn))?;
                    }
                    Err(e) => {
                        if !self.skip_weights_if_unavailable {
                            return Err(e);
                        }
                    }
                }
            }
            Ok(self)
        }
        /// Set the column_number of the nodes.
        ///
        /// # Arguments
        ///
        /// * weights_column_number: Option<usize> - The weights column number to use for the file.
        ///
        pub fn set_weights_column_number(
            mut self,
            weights_column_number: Option<usize>,
        ) -> Result<EdgeFileReader> {
            if let Some(wcn) = &weights_column_number {
                let expected_elements = self.reader.get_elements_per_line()?;
                if *wcn >= expected_elements {
                    if !self.skip_edge_types_if_unavailable {
                        return Err({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "The weights column number passed was ",
                                    " but the first parsable line has ",
                                    " values.",
                                ],
                                &match (&wcn, &expected_elements) {
                                    (arg0, arg1) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                    ],
                                },
                            ));
                            res
                        });
                    }
                } else {
                    self.weights_column_number = weights_column_number;
                }
            }
            Ok(self)
        }
        /// Set whether to automatically skip weights if they are not avaitable instead of raising an exception.
        ///
        /// # Arguments
        ///
        /// * skip_weights_if_unavailable: Option<bool> - Whether to skip weights if they are not available.
        ///
        pub fn set_skip_weights_if_unavailable(
            mut self,
            skip_weights_if_unavailable: Option<bool>,
        ) -> EdgeFileReader {
            if let Some(skip) = skip_weights_if_unavailable {
                self.skip_weights_if_unavailable = skip;
            }
            self
        }
        /// Set whether to automatically skip edge types if they are not avaitable instead of raising an exception.
        ///
        /// # Arguments
        ///
        /// * skip_edge_types_if_unavailable: Option<bool> - Whether to skip edge types if they are not available.
        ///
        pub fn set_skip_edge_types_if_unavailable(
            mut self,
            skip_edge_types_if_unavailable: Option<bool>,
        ) -> EdgeFileReader {
            if let Some(skip) = skip_edge_types_if_unavailable {
                self.skip_edge_types_if_unavailable = skip;
            }
            self
        }
        /// Set the default default_weight.
        ///
        /// # Arguments
        ///
        /// * default_weight: Option<WeightT> - The default_weight to use when default_weight is missing.
        ///
        pub fn set_default_weight(mut self, default_weight: Option<WeightT>) -> EdgeFileReader {
            self.default_weight = default_weight;
            self
        }
        /// Set the name of the graph to be loaded.
        ///
        /// # Arguments
        ///
        /// * graph_name: String - The name of the graph to be loaded.
        ///
        pub(crate) fn set_graph_name(mut self, graph_name: String) -> EdgeFileReader {
            self.reader.graph_name = graph_name;
            self
        }
        /// Set the default edge type.
        ///
        /// # Arguments
        ///
        /// * default_edge_type: Option<String> - The edge type to use when edge type is missing.
        ///
        pub fn set_default_edge_type<S: Into<String>>(
            mut self,
            default_edge_type: Option<S>,
        ) -> EdgeFileReader {
            self.default_edge_type = default_edge_type.map(|val| val.into());
            self
        }
        /// Set whether should ignore or not selfloops.
        ///
        /// # Arguments
        ///
        /// * `skip_selfloops`: Option<bool> - Whether should ignore or not selfloops.
        ///
        pub fn set_skip_selfloops(mut self, skip_selfloops: Option<bool>) -> EdgeFileReader {
            if let Some(ssl) = skip_selfloops {
                self.skip_selfloops = ssl;
                self.might_contain_singletons_with_selfloops = !ssl;
            }
            self
        }
        /// Set whether the CSV is expected to be well written.
        ///
        /// # Arguments
        ///
        /// * csv_is_correct: Option<bool> - Whether you pinky swear the edge list is correct.
        ///
        pub fn set_csv_is_correct(mut self, csv_is_correct: Option<bool>) -> EdgeFileReader {
            if let Some(cic) = csv_is_correct {
                self.reader.csv_is_correct = cic;
            }
            self
        }
        /// Set the comment symbol to use to skip the lines.
        ///
        /// # Arguments
        ///
        /// * comment_symbol: Option<String> - if the reader should ignore or not duplicated edges.
        ///
        pub fn set_comment_symbol(
            mut self,
            comment_symbol: Option<String>,
        ) -> Result<EdgeFileReader> {
            if let Some(cs) = comment_symbol {
                if cs.is_empty() {
                    return Err("The given comment symbol is empty.".to_string());
                }
                self.reader.comment_symbol = Some(cs);
            }
            Ok(self)
        }
        /// Set the verbose.
        ///
        /// # Arguments
        ///
        /// * `verbose`: Option<bool> - Whether to show the loading bar or not.
        ///
        pub fn set_verbose(mut self, verbose: Option<bool>) -> EdgeFileReader {
            if let Some(v) = verbose {
                self.reader.verbose = v;
            }
            self
        }
        /// Set whether you pinky promise that this graph has singletons with self-loops or not.
        ///
        /// # Arguments
        ///
        /// * `might_contain_singletons_with_selfloops`: Option<bool> - Whether this graph has singletons with self-loops.
        ///
        pub fn set_might_contain_singletons_with_selfloops(
            mut self,
            might_contain_singletons_with_selfloops: Option<bool>,
        ) -> EdgeFileReader {
            if let Some(skip) = might_contain_singletons_with_selfloops {
                self.might_contain_singletons_with_selfloops = !self.skip_selfloops && skip;
            }
            self
        }
        /// Set whether you pinky promise that this graph has trap nodes or not.
        ///
        /// # Arguments
        ///
        /// * `might_contain_trap_nodes`: Option<bool> - Whether this graph has trap nodes with self-loops.
        ///
        pub fn set_might_contain_trap_nodes(
            mut self,
            might_contain_trap_nodes: Option<bool>,
        ) -> EdgeFileReader {
            if let Some(skip) = might_contain_trap_nodes {
                self.might_contain_trap_nodes = skip;
            }
            self
        }
        ///
        /// * numeric_id: Option<bool> - Whether to convert numeric Ids to Node Id.
        ///
        pub fn set_numeric_edge_type_ids(
            mut self,
            numeric_edge_type_ids: Option<bool>,
        ) -> EdgeFileReader {
            if let Some(neti) = numeric_edge_type_ids {
                self.numeric_edge_type_ids = neti;
            }
            self
        }
        /// Set the numeric_id.
        ///
        /// # Arguments
        ///
        /// * numeric_id: Option<bool> - Whether to convert numeric Ids to Node Id.
        ///
        pub fn set_numeric_node_ids(mut self, numeric_node_ids: Option<bool>) -> EdgeFileReader {
            if let Some(nni) = numeric_node_ids {
                self.numeric_node_ids = nni;
            }
            self
        }
        /// Set the ignore_duplicates.
        ///
        /// # Arguments
        ///
        /// * ignore_duplicates: Option<bool> - Whether to ignore detected duplicates or raise exception.
        ///
        pub fn set_ignore_duplicates(mut self, ignore_duplicates: Option<bool>) -> EdgeFileReader {
            if let Some(v) = ignore_duplicates {
                self.reader.ignore_duplicates = v;
            }
            self
        }
        /// Set the separator.
        ///
        /// # Arguments
        ///
        /// * separator: Option<String> - The separator to use for the file.
        ///
        pub fn set_separator<S: Into<String>>(
            mut self,
            separator: Option<S>,
        ) -> Result<EdgeFileReader> {
            if let Some(sep) = separator {
                let sep = sep.into();
                if sep.is_empty() {
                    return Err("The separator cannot be empty.".to_owned());
                }
                self.reader.separator = sep;
            }
            Ok(self)
        }
        /// Set the header.
        ///
        /// # Arguments
        ///
        /// * header: Option<bool> - Whether to expect an header or not.
        ///
        pub fn set_header(mut self, header: Option<bool>) -> EdgeFileReader {
            if let Some(v) = header {
                self.reader.header = v;
            }
            self
        }
        /// Set number of rows to be skipped when starting to read file.
        ///
        /// # Arguments
        ///
        /// * rows_to_skip: Option<bool> - Whether to show the loading bar or not.
        ///
        pub fn set_rows_to_skip(mut self, rows_to_skip: Option<usize>) -> EdgeFileReader {
            if let Some(v) = rows_to_skip {
                self.reader.rows_to_skip = v;
            }
            self
        }
        /// Set the maximum number of rows to load from the file
        ///
        /// # Arguments
        ///
        /// * max_rows_number: Option<u64> - The edge type to use when edge type is missing.
        ///
        pub fn set_max_rows_number(mut self, max_rows_number: Option<u64>) -> EdgeFileReader {
            self.reader.max_rows_number = max_rows_number;
            self
        }
        /// Return boolean representing if the edge types exist.
        pub fn has_edge_types(&self) -> bool {
            self.default_edge_type.is_some() || self.edge_types_column_number.is_some()
        }
        /// Return boolean representing if the weight types exist.
        pub fn has_edge_weights(&self) -> bool {
            self.default_weight.is_some() || self.weights_column_number.is_some()
        }
        /// Parse a single line (vecotr of strings already splitted)
        /// # Arguments
        ///
        /// * vals: Vec<String> - Vector of the values of the line to be parsed
        fn parse_edge_line(&self, vals: Vec<Option<String>>) -> Result<StringQuadruple> {
            let maybe_source_node_name = vals[self.sources_column_number].clone();
            let maybe_destination_node_name = vals[self.destinations_column_number].clone();
            if maybe_source_node_name.is_none() || maybe_destination_node_name.is_none() {
                return Err("Either the source or destination node ID are undefined.".to_string());
            }
            let source_node_name = maybe_source_node_name.unwrap();
            let destination_node_name = maybe_destination_node_name.unwrap();
            let maybe_edge_types_string = match self.edge_types_column_number {
                Some(column) => match vals[column].to_owned() {
                    Some(edge_type) => Some(edge_type),
                    None => self.default_edge_type.clone(),
                },
                None => self.default_edge_type.clone(),
            };
            let maybe_weight_string = match self.weights_column_number {
                Some(column) => match vals[column].to_owned() {
                    Some(w) => Some(parse_weight(w)?),
                    None => self.default_weight,
                },
                None => self.default_weight,
            };
            Ok((
                source_node_name,
                destination_node_name,
                maybe_edge_types_string,
                maybe_weight_string,
            ))
        }
        /// Return iterator of rows of the edge file.
        pub fn read_lines(
            &self,
        ) -> Result<impl ParallelIterator<Item = Result<StringQuadruple>> + '_> {
            if self.destinations_column_number == self.sources_column_number {
                return Err("The destinations column is the same as the sources one.".to_string());
            }
            if Some(self.destinations_column_number) == self.weights_column_number {
                return Err("The destinations column is the same as the weights one.".to_string());
            }
            if Some(self.sources_column_number) == self.weights_column_number {
                return Err("The sources column is the same as the weights one.".to_string());
            }
            if Some(self.sources_column_number) == self.edge_types_column_number {
                return Err("The sources column is the same as the edge types one.".to_string());
            }
            if Some(self.destinations_column_number) == self.edge_types_column_number {
                return Err(
                    "The destinations column is the same as the edge types one.".to_string()
                );
            }
            if self.weights_column_number.is_some()
                && self.weights_column_number == self.edge_types_column_number
            {
                return Err("The weights column is the same as the edge types one.".to_string());
            }
            let expected_elements = self.reader.get_elements_per_line()?;
            if self.sources_column_number >= expected_elements {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "The sources column number passed was ",
                            " but the first parsable line has ",
                            " values.",
                        ],
                        &match (&self.sources_column_number, &expected_elements) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                });
            }
            if self.destinations_column_number >= expected_elements {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "The destinations column number passed was ",
                            " but the first parsable line has ",
                            " values.",
                        ],
                        &match (&self.destinations_column_number, &expected_elements) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                });
            }
            Ok(self
                .reader
                .read_lines()?
                .map(move |values| match values {
                    Ok(vals) => self.parse_edge_line(vals),
                    Err(e) => Err(e),
                })
                .filter(move |edge| match edge {
                    Ok((source_node_name, destination_node_name, _, _)) => {
                        !self.skip_selfloops || source_node_name != destination_node_name
                    }
                    Err(e) => true,
                }))
        }
    }
}
pub use self::edge_file_reader::EdgeFileReader;
mod edge_file_writer {
    use super::*;
    /// Structure that saves the reader specific to writing and reading a nodes csv file.
    ///
    /// # Attributes
    pub struct EdgeFileWriter {
        pub(crate) writer: CSVFileWriter,
        pub(crate) sources_column: String,
        pub(crate) sources_column_number: usize,
        pub(crate) destinations_column: String,
        pub(crate) destinations_column_number: usize,
        pub(crate) edge_types_column: String,
        pub(crate) edge_types_column_number: usize,
        pub(crate) weights_column: String,
        pub(crate) weights_column_number: usize,
        pub(crate) numeric_node_ids: bool,
        pub(crate) directed: Option<bool>,
    }
    impl EdgeFileWriter {
        /// Return new EdgeFileWriter object.
        ///
        /// # Arguments
        ///
        /// * path: String - Path where to store/load the file.
        ///
        pub fn new<S: Into<String>>(path: S) -> EdgeFileWriter {
            EdgeFileWriter {
                writer: CSVFileWriter::new(path),
                sources_column: "subject".to_string(),
                sources_column_number: 0,
                destinations_column: "object".to_string(),
                destinations_column_number: 1,
                edge_types_column: "label".to_string(),
                edge_types_column_number: 2,
                weights_column: "weight".to_string(),
                weights_column_number: 3,
                numeric_node_ids: false,
                directed: None,
            }
        }
        /// Set the column of the source nodes.
        ///
        /// # Arguments
        ///
        /// * sources_column: Option<String> - The source nodes column to use for the file.
        ///
        pub fn set_sources_column<S: Into<String>>(
            mut self,
            sources_column: Option<S>,
        ) -> EdgeFileWriter {
            if let Some(column) = sources_column {
                self.sources_column = column.into();
            }
            self
        }
        /// Set the column of the source nodes.
        ///
        /// # Arguments
        ///
        /// * sources_column_number: Option<String> - The source nodes column to use for the file.
        ///
        pub fn set_sources_column_number(
            mut self,
            sources_column_number: Option<usize>,
        ) -> EdgeFileWriter {
            if let Some(column_number) = sources_column_number {
                self.sources_column_number = column_number;
            }
            self
        }
        /// Set the column of the nodes.
        ///
        /// # Arguments
        ///
        /// * destinations_column: Option<String> - The node types column to use for the file.
        ///
        pub fn set_destinations_column<S: Into<String>>(
            mut self,
            destinations_column: Option<S>,
        ) -> EdgeFileWriter {
            if let Some(column) = destinations_column {
                self.destinations_column = column.into();
            }
            self
        }
        /// Set the column of the nodes.
        ///
        /// # Arguments
        ///
        /// * destinations_column_number: Option<String> - The node types column to use for the file.
        ///
        pub fn set_destinations_column_number(
            mut self,
            destinations_column_number: Option<usize>,
        ) -> EdgeFileWriter {
            if let Some(column_number) = destinations_column_number {
                self.destinations_column_number = column_number;
            }
            self
        }
        /// Set the column of the nodes.
        ///
        /// # Arguments
        ///
        /// * edge_types_column: Option<String> - The node types column to use for the file.
        ///
        pub fn set_edge_types_column<S: Into<String>>(
            mut self,
            edge_type_column: Option<S>,
        ) -> EdgeFileWriter {
            if let Some(column) = edge_type_column {
                self.edge_types_column = column.into();
            }
            self
        }
        /// Set the column of the nodes.
        ///
        /// # Arguments
        ///
        /// * edge_types_column_number: Option<usize> - The node types column to use for the file.
        ///
        pub fn set_edge_types_column_number(
            mut self,
            edge_type_column_number: Option<usize>,
        ) -> EdgeFileWriter {
            if let Some(column_number) = edge_type_column_number {
                self.edge_types_column_number = column_number;
            }
            self
        }
        /// Set the column of the nodes.
        ///
        /// # Arguments
        ///
        /// * weights_column: Option<String> - The node types column to use for the file.
        ///
        pub fn set_weights_column<S: Into<String>>(
            mut self,
            weights_column: Option<S>,
        ) -> EdgeFileWriter {
            if let Some(column) = weights_column {
                self.weights_column = column.into();
            }
            self
        }
        /// Set the column of the nodes.
        ///
        /// # Arguments
        ///
        /// * weights_column_number: Option<usize> - The node types column to use for the file.
        ///
        pub fn set_weights_column_number(
            mut self,
            weights_column_number: Option<usize>,
        ) -> EdgeFileWriter {
            if let Some(column_number) = weights_column_number {
                self.weights_column_number = column_number;
            }
            self
        }
        /// Set the verbose.
        ///
        /// # Arguments
        ///
        /// * `verbose`: Option<bool> - Whether to show the loading bar or not.
        ///
        pub fn set_verbose(mut self, verbose: Option<bool>) -> EdgeFileWriter {
            if let Some(v) = verbose {
                self.writer.verbose = v;
            }
            self
        }
        /// Set the numeric_id.
        ///
        /// # Arguments
        ///
        /// * numeric_id: Option<bool> - Whether to convert numeric Ids to Node Id.
        ///
        pub fn set_numeric_node_ids(mut self, numeric_node_ids: Option<bool>) -> EdgeFileWriter {
            if let Some(nni) = numeric_node_ids {
                self.numeric_node_ids = nni;
            }
            self
        }
        /// Set the separator.
        ///
        /// # Arguments
        ///
        /// * separator: Option<String> - The separator to use for the file.
        ///
        pub fn set_separator<S: Into<String>>(mut self, separator: Option<S>) -> EdgeFileWriter {
            if let Some(v) = separator {
                self.writer.separator = v.into();
            }
            self
        }
        /// Set the header.
        ///
        /// # Arguments
        ///
        /// * header: Option<bool> - Whether to write out an header or not.
        ///
        pub fn set_header(mut self, header: Option<bool>) -> EdgeFileWriter {
            if let Some(v) = header {
                self.writer.header = v;
            }
            self
        }
        /// Set the directed.
        ///
        /// # Arguments
        ///
        /// * `directed`: Option<bool> - Whether to write out the graph as directed or not.
        ///
        pub fn set_directed(mut self, directed: Option<bool>) -> EdgeFileWriter {
            self.directed = directed;
            self
        }
        /// Write edge file.
        ///  
        /// # Arguments
        ///
        /// * `graph`: &Graph - the graph to write out.
        pub fn dump(&self, graph: &Graph) -> Result<()> {
            let directed: bool = self.directed.unwrap_or_else(|| graph.is_directed());
            let mut header = <[_]>::into_vec(box [
                (self.sources_column.clone(), self.sources_column_number),
                (
                    self.destinations_column.clone(),
                    self.destinations_column_number,
                ),
            ]);
            if graph.has_edge_types() {
                header.push((
                    self.edge_types_column.clone(),
                    self.edge_types_column_number,
                ));
            }
            if graph.has_edge_weights() {
                header.push((self.weights_column.clone(), self.weights_column_number));
            }
            let number_of_columns = 1 + header.iter().map(|(_, i)| i).max().unwrap();
            self.writer.write_lines(
                graph.get_directed_edges_number() as usize,
                compose_lines(number_of_columns, header),
                graph
                    .iter_edge_node_ids_and_edge_type_id_and_edge_weight(directed)
                    .map(|(_, src, dst, edge_type, weight)| {
                        let mut line = <[_]>::into_vec(box [
                            (
                                match self.numeric_node_ids {
                                    true => src.to_string(),
                                    false => graph.nodes.unchecked_translate(src),
                                },
                                self.sources_column_number,
                            ),
                            (
                                match self.numeric_node_ids {
                                    true => dst.to_string(),
                                    false => graph.nodes.unchecked_translate(dst),
                                },
                                self.destinations_column_number,
                            ),
                        ]);
                        if let Some(ets) = &graph.edge_types {
                            line.push((
                                edge_type.map_or("".to_string(), |et| ets.unchecked_translate(et)),
                                self.edge_types_column_number,
                            ));
                        }
                        if let Some(w) = weight {
                            line.push((w.to_string(), self.weights_column_number));
                        }
                        compose_lines(number_of_columns, line)
                    }),
            )
        }
    }
}
pub use self::edge_file_writer::EdgeFileWriter;
mod compression {
    use super::*;
    #[inline(always)]
    pub(crate) fn encode_edge(src: NodeT, dst: NodeT, node_bits: u8) -> EdgeT {
        ((src as EdgeT) << node_bits) | dst as EdgeT
    }
    #[inline(always)]
    pub(crate) fn encode_max_edge(node: NodeT, node_bits: u8) -> EdgeT {
        ((node as EdgeT) << node_bits) | node as EdgeT
    }
    #[inline(always)]
    pub(crate) fn decode_edge(edge: u64, node_bits: u8, node_bit_mask: u64) -> (NodeT, NodeT) {
        (
            (edge >> node_bits) as NodeT,
            (edge & node_bit_mask) as NodeT,
        )
    }
    #[inline(always)]
    pub(crate) fn get_node_bits(top_node: NodeT) -> u8 {
        (1.0 + top_node as f64).log2().ceil() as u8
    }
    impl Graph {
        #[inline(always)]
        /// Return edge value corresponding to given node IDs.
        ///
        /// # Arguments
        /// * `src`: NodeT - The source node ID.
        /// * `dst`: NodeT - The destination node ID.
        pub fn encode_edge(&self, src: NodeT, dst: NodeT) -> u64 {
            encode_edge(src, dst, self.node_bits)
        }
        #[inline(always)]
        /// Returns source and destination nodes corresponding to given edge ID.
        ///
        /// # Arguments
        /// * `edge`: u64 - The edge value to decode.
        pub fn decode_edge(&self, edge: u64) -> (NodeT, NodeT) {
            decode_edge(edge, self.node_bits, self.node_bit_mask)
        }
        /// Return maximum encodable edge number.
        pub fn get_max_encodable_edge_number(&self) -> EdgeT {
            encode_max_edge(
                self.get_nodes_number(),
                get_node_bits(self.get_nodes_number()),
            )
        }
    }
}
mod from_csv {
    use super::*;
    impl Graph {
        /// Return graph renderized from given files.
        ///
        /// # Arguments
        ///
        /// * `edge_file_reader`: EdgeFileReader - Reader of the edge file.
        /// * `node_file_reader`: Option<NodeFileReader> - Reader of the node file.
        /// * `directed`: bool - Whether the graph is to be read as directed or undirected.
        /// * `directed_edge_list`: bool - Whether to read the edge list as directed.
        /// * `edges_number`: usize - Number of edges of the graph.
        /// * `nodes_number`: NodeT - Number of the nodes of the graph.
        /// * `name`: S - Name of the graph.
        ///
        pub fn from_sorted_csv<S: Clone + Into<String>>(
            mut edge_file_reader: EdgeFileReader,
            mut node_file_reader: Option<NodeFileReader>,
            directed: bool,
            directed_edge_list: bool,
            edges_number: usize,
            nodes_number: NodeT,
            name: S,
        ) -> Result<Graph> {
            edge_file_reader = edge_file_reader.set_graph_name(name.clone().into());
            node_file_reader = node_file_reader.map(|nfr| nfr.set_graph_name(name.clone().into()));
            Graph::from_string_sorted(
                edge_file_reader.read_lines()?,
                node_file_reader
                    .as_ref()
                    .map_or(Ok::<_, String>(None), |nfr| Ok(Some(nfr.read_lines()?)))?,
                directed,
                directed_edge_list,
                name,
                node_file_reader
                    .as_ref()
                    .map_or(false, |nfr| nfr.reader.ignore_duplicates),
                node_file_reader
                    .as_ref()
                    .map_or(false, |nfr| nfr.reader.csv_is_correct),
                edge_file_reader.reader.ignore_duplicates,
                edge_file_reader.reader.csv_is_correct,
                edges_number,
                nodes_number,
                edge_file_reader.numeric_edge_type_ids,
                node_file_reader
                    .as_ref()
                    .map_or(false, |nfr| nfr.numeric_node_ids),
                edge_file_reader.numeric_node_ids,
                node_file_reader
                    .as_ref()
                    .map_or(false, |nfr| nfr.numeric_node_type_ids),
                node_file_reader
                    .as_ref()
                    .map_or(false, |nfr| nfr.has_node_types()),
                edge_file_reader.has_edge_types(),
                edge_file_reader.has_edge_weights(),
                true,
                node_file_reader
                    .as_ref()
                    .map_or(false, |nfr| nfr.might_contain_singletons),
                edge_file_reader.might_contain_singletons_with_selfloops,
                edge_file_reader.might_contain_trap_nodes,
            )
        }
        /// Return graph renderized from given files.
        ///
        /// # Arguments
        ///
        /// * `edge_file_reader`: EdgeFileReader - Reader of the edge file.
        /// * `node_file_reader`: Option<NodeFileReader> - Reader of the node file.
        /// * `directed`: bool - Whether the graph is to be read as directed or undirected.
        /// * `directed_edge_list`: bool - Whether to read the edge list as directed.
        /// * `name`: S - The name for the graph.
        pub fn from_unsorted_csv<S: Clone + Into<String>>(
            mut edge_file_reader: EdgeFileReader,
            mut node_file_reader: Option<NodeFileReader>,
            directed: bool,
            directed_edge_list: bool,
            name: S,
        ) -> Result<Graph> {
            edge_file_reader = edge_file_reader.set_graph_name(name.clone().into());
            node_file_reader = node_file_reader.map(|nfr| nfr.set_graph_name(name.clone().into()));
            Graph::from_string_unsorted(
                edge_file_reader.read_lines()?,
                node_file_reader
                    .as_ref()
                    .map_or(Ok::<_, String>(None), |nfr| Ok(Some(nfr.read_lines()?)))?,
                directed,
                directed_edge_list,
                name,
                node_file_reader
                    .as_ref()
                    .map_or(false, |nfr| nfr.reader.ignore_duplicates),
                node_file_reader
                    .as_ref()
                    .map_or(false, |nfr| nfr.reader.csv_is_correct),
                edge_file_reader.reader.ignore_duplicates,
                edge_file_reader.reader.csv_is_correct,
                edge_file_reader.numeric_edge_type_ids,
                node_file_reader
                    .as_ref()
                    .map_or(false, |nfr| nfr.numeric_node_ids),
                edge_file_reader.numeric_node_ids,
                node_file_reader
                    .as_ref()
                    .map_or(false, |nfr| nfr.numeric_node_type_ids),
                node_file_reader
                    .as_ref()
                    .map_or(false, |nfr| nfr.has_node_types()),
                edge_file_reader.has_edge_types(),
                edge_file_reader.has_edge_weights(),
                true,
                node_file_reader
                    .as_ref()
                    .map_or(false, |nfr| nfr.might_contain_singletons),
                edge_file_reader.might_contain_singletons_with_selfloops,
                edge_file_reader.might_contain_trap_nodes,
                edge_file_reader.reader.verbose,
            )
        }
    }
}
pub(crate) use self::compression::*;
mod validators {
    use super::*;
    /// # Validators
    /// The naming convention we follow is:
    /// * `/validate_(.+)/`
    /// * `/must_have_(.+)/`
    /// * `/must_be_(.+)/`
    /// * `/must_not_be_(.+)/`
    impl Graph {
        /// Validates provided node ID.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - node ID to validate.
        ///
        /// # Example
        /// In order to validate a given node ID, you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(graph.validate_node_id(0).is_ok());
        /// assert!(graph.validate_node_id(100000000).is_err());
        /// ```
        ///
        /// # Raises
        /// * If the given node ID does not exists in the graph.
        pub fn validate_node_id(&self, node_id: NodeT) -> Result<NodeT> {
            if node_id >= self.get_nodes_number() {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "The given node id (",
                            ") is higher than the number of nodes within the graph (",
                            ").",
                        ],
                        &match (&node_id, &self.get_nodes_number()) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                });
            }
            Ok(node_id)
        }
        /// Validates all provided node IDs.
        ///
        /// # Arguments
        /// * `node_ids`: Vec<NodeT> - node IDs to validate.
        ///
        /// # Example
        /// In order to validate the given node IDs, you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(graph.validate_node_ids(vec![0, 1, 2]).is_ok());
        /// assert!(graph.validate_node_ids(vec![100000000, u32::MAX]).is_err());
        /// ```
        ///
        /// # Raises
        /// * If any of the given node ID does not exists in the graph.
        pub fn validate_node_ids(&self, node_ids: Vec<NodeT>) -> Result<Vec<NodeT>> {
            node_ids
                .into_iter()
                .map(|node_id| self.validate_node_id(node_id))
                .collect()
        }
        /// Validates provided edge ID.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - Edge ID to validate.
        ///
        /// # Example
        /// In order to validate a given edge ID, you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(graph.validate_edge_id(0).is_ok());
        /// assert!(graph.validate_edge_id(10000000000).is_err());
        /// ```
        ///
        /// # Raises
        /// * If the given edge ID does not exists in the graph.
        pub fn validate_edge_id(&self, edge_id: EdgeT) -> Result<EdgeT> {
            if edge_id >= self.get_directed_edges_number() {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "The given edge id (",
                            ") is higher than the number of edges within the graph (",
                            ").",
                        ],
                        &match (&edge_id, &self.get_directed_edges_number()) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                });
            }
            Ok(edge_id)
        }
        /// Validates provided edge IDs.
        ///
        /// # Arguments
        /// * `edge_ids`: Vec<EdgeT> - Edge IDs to validate.
        ///
        /// # Example
        /// In order to validate a given edge ID, you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(graph.validate_edge_ids(vec![0, 1, 2]).is_ok());
        /// assert!(graph.validate_edge_ids(vec![10000000000, u64::MAX]).is_err());
        /// ```
        ///
        /// # Raises
        /// * If any of the given edge ID does not exists in the graph.
        pub fn validate_edge_ids(&self, edge_ids: Vec<EdgeT>) -> Result<Vec<EdgeT>> {
            edge_ids
                .into_iter()
                .map(|edge_id| self.validate_edge_id(edge_id))
                .collect()
        }
        /// Raises an error if the graph contains unknown node types.
        ///
        /// # Raises
        /// * If the graph does not contain node types.
        /// * If the graph contains unknown node types.
        pub fn must_not_contain_unknown_node_types(&self) -> Result<()> {
            if self.has_unknown_node_types()? {
                return Err("The graph contains unknown node types.".to_string());
            }
            Ok(())
        }
        /// Raises an error if the graph contains unknown edge types.
        ///
        /// # Raises
        /// * If the graph does not contain edge types.
        /// * If the graph contains unknown edge types.
        pub fn must_not_contain_unknown_edge_types(&self) -> Result<()> {
            if self.has_unknown_edge_types()? {
                return Err("The graph contains unknown edge types.".to_string());
            }
            Ok(())
        }
        /// Validates provided node type ID.
        ///
        /// # Arguments
        /// * `node_type_id`: Option<NodeTypeT> - Node type ID to validate.
        ///
        /// # Example
        /// In order to validate a given node type ID, you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(graph.validate_node_type_id(Some(0)).is_ok());
        /// assert!(graph.validate_node_type_id(Some(1000)).is_err());
        /// ```
        ///
        /// # Raises
        /// * If the given node type ID does not exists in the graph.
        pub fn validate_node_type_id(
            &self,
            node_type_id: Option<NodeTypeT>,
        ) -> Result<Option<NodeTypeT>> {
            self . get_node_types_number () . and_then (| node_types_number | { node_type_id . map_or_else (| | if ! self . has_unknown_node_types () ? { Err ("An unknown node type was given but the graph does not contain unknown node types." . to_string ()) } else { Ok (None) } , | nti | { if node_types_number <= nti { Err ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Given node type ID " , " is bigger than number of node types in the graph " , "."] , & match (& nti , & node_types_number) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , })) ; res }) } else { Ok (Some (nti)) } }) })
        }
        /// Validates provided node type IDs.
        ///
        /// # Arguments
        /// * `node_type_ids`: Vec<Option<NodeTypeT>> - Vector of node type IDs to validate.
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn validate_node_type_ids(
            &self,
            node_type_ids: Vec<Option<NodeTypeT>>,
        ) -> Result<Vec<Option<NodeTypeT>>> {
            self.must_have_node_types()?;
            node_type_ids
                .into_iter()
                .map(|node_type| self.validate_node_type_id(node_type))
                .collect()
        }
        /// Validates provided edge type ID.
        ///
        /// # Arguments
        /// * `edge_type_id`: Option<EdgeTypeT> - edge type ID to validate.
        ///
        /// # Example
        /// In order to validate a given edge type ID, you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(graph.validate_edge_type_id(Some(0)).is_ok());
        /// assert!(graph.validate_edge_type_id(Some(1000)).is_err());
        /// ```
        ///
        /// # Raises
        /// * If the given edge type ID does not exists in the graph.
        pub fn validate_edge_type_id(
            &self,
            edge_type_id: Option<EdgeTypeT>,
        ) -> Result<Option<EdgeTypeT>> {
            self . get_edge_types_number () . and_then (| edge_types_number | { edge_type_id . map_or_else (| | if ! self . has_unknown_edge_types () ? { Err ("An unknown edge type was given but the graph does not contain unknown edge types." . to_string ()) } else { Ok (None) } , | eti | { if edge_types_number <= eti { Err ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Given edge type ID " , " is bigger than number of edge types in the graph " , "."] , & match (& eti , & edge_types_number) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , })) ; res }) } else { Ok (Some (eti)) } }) })
        }
        /// Validates provided edge type IDs.
        ///
        /// # Arguments
        /// * `edge_type_ids`: Vec<Option<EdgeTypeT>> - Vector of edge type IDs to validate.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn validate_edge_type_ids(
            &self,
            edge_type_ids: Vec<Option<EdgeTypeT>>,
        ) -> Result<Vec<Option<EdgeTypeT>>> {
            self.must_have_edge_types()?;
            edge_type_ids
                .into_iter()
                .map(|edge_type| self.validate_edge_type_id(edge_type))
                .collect()
        }
        /// Raises an error if the graph does not have node types.
        ///
        /// # Example
        /// In order to validate a graph instance, you can use:
        ///
        /// ```rust
        /// # let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// # let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// assert!(graph_with_node_types.must_have_node_types().is_ok());
        /// assert!(graph_without_node_types.must_have_node_types().is_err());
        /// ```
        ///
        /// # Raises
        /// * If the graph does not contain node types.
        pub fn must_have_node_types(&self) -> Result<&NodeTypeVocabulary> {
            if !self.has_node_types() {
                return Err("The current graph instance does not have node types.".to_string());
            }
            Ok(self.node_types.as_ref().unwrap())
        }
        /// Raises an error if the graph does not have edge types.
        ///
        /// # Example
        /// In order to validate a graph instance, you can use:
        ///
        /// ```rust
        /// # let graph_with_edge_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// # let graph_without_edge_types = graph::test_utilities::load_ppi(false, false, true, true, false, false);
        /// assert!(graph_with_edge_types.must_have_edge_types().is_ok());
        /// assert!(graph_without_edge_types.must_have_edge_types().is_err());
        /// ```
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn must_have_edge_types(&self) -> Result<&EdgeTypeVocabulary> {
            if !self.has_edge_types() {
                return Err("The current graph instance does not have edge types.".to_string());
            }
            Ok(self.edge_types.as_ref().unwrap())
        }
        /// Raises an error if the graph does not have edge types.
        ///
        /// # Example
        /// In order to validate a graph instance, you can use:
        ///
        /// ```rust
        /// # let undirecte_graph = graph::test_utilities::load_ppi(false, false, false, false, false, false);
        /// # let directed_graph = graph::test_utilities::load_ppi(false, false, true, true, false, false);
        /// assert!(undirecte_graph.must_be_undirected().is_ok());
        /// assert!(directed_graph.must_be_undirected().is_err());
        /// ```
        ///
        /// # Raises
        /// * If the graph is directed.
        pub fn must_be_undirected(&self) -> Result<()> {
            if self.is_directed() {
                return Err("The current graph instance is not undirected.".to_string());
            }
            Ok(())
        }
        /// Raises an error if the graph does not have edge types.
        ///
        /// # Example
        /// In order to validate a graph instance, you can use:
        ///
        /// ```rust
        /// # let multigraph = graph::test_utilities::load_ppi(false, true, false, false, false, false);
        /// # let homogeneous = graph::test_utilities::load_ppi(false, false, false, false, false, false);
        /// assert!(multigraph.must_be_multigraph().is_ok());
        /// assert!(homogeneous.must_be_multigraph().is_err());
        /// ```
        ///
        /// # Raises
        /// * If the graph is not a multigraph.
        pub fn must_be_multigraph(&self) -> Result<()> {
            if !self.is_multigraph() {
                return Err(
                    "The current graph instance must be a multigraph to run this method."
                        .to_string(),
                );
            }
            Ok(())
        }
        /// Raises an error if the graph does not have edge types.
        ///
        /// # Example
        /// In order to validate a graph instance, you can use:
        ///
        /// ```rust
        /// # let multigraph = graph::test_utilities::load_ppi(false, true, false, false, false, false);
        /// # let homogeneous = graph::test_utilities::load_ppi(false, false, false, false, false, false);
        /// assert!(multigraph.must_not_be_multigraph().is_err());
        /// assert!(homogeneous.must_not_be_multigraph().is_ok());
        /// ```
        ///
        /// # Raises
        /// * If the graph is a multigraph.
        pub fn must_not_be_multigraph(&self) -> Result<()> {
            if self.is_multigraph() {
                return Err(
                    "The current graph instance must not be a multigraph to run this method."
                        .to_string(),
                );
            }
            Ok(())
        }
        /// Raises an error if the graph does not have weights.
        ///
        /// # Example
        /// In order to validate a graph instance, you can use:
        ///
        /// ```rust
        /// # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);
        /// # let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);
        /// assert!(graph_with_weights.must_have_edge_weights().is_ok());
        /// assert!(graph_without_weights.must_have_edge_weights().is_err());
        /// ```
        ///
        /// # Raises
        /// * If the graph does not have edge weights.
        pub fn must_have_edge_weights(&self) -> Result<&Vec<WeightT>> {
            if !self.has_edge_weights() {
                return Err("The current graph instance does not have weights.".to_string());
            }
            Ok(self.weights.as_ref().unwrap())
        }
        /// Raises an error if the graph does not have known node types.
        ///
        /// # Raises
        /// * If the graph does not contain any known node types.
        pub fn must_have_known_node_types(&self) -> Result<()> {
            if !self.has_known_node_types()? {
                return Err(
                    "The current graph instance does contain any known node type.".to_string(),
                );
            }
            Ok(())
        }
        /// Raises an error if the graph does not have unknown node types.
        ///
        /// # Raises
        /// * If the graph does not contain any unknown node types.
        pub fn must_have_unknown_node_types(&self) -> Result<()> {
            if !self.has_unknown_node_types()? {
                return Err ("The current graph instance does contain any unknown node type.\nPossibly you have forgotten to execute a node-label holdout?" . to_string ()) ;
            }
            Ok(())
        }
        /// Raises an error if the graph does not have known edge types.
        ///
        /// # Raises
        /// * If the graph does not contain any known edge types.
        pub fn must_have_known_edge_types(&self) -> Result<()> {
            if !self.has_known_edge_types()? {
                return Err(
                    "The current graph instance does contain any known edge type.".to_string(),
                );
            }
            Ok(())
        }
        /// Raises an error if the graph does not have unknown edge types.
        ///
        /// # Raises
        /// * If the graph does not contain any unknown edge types.
        pub fn must_have_unknown_edge_types(&self) -> Result<()> {
            if !self.has_unknown_edge_types()? {
                return Err ("The current graph instance does contain any unknown edge type.\nPossibly you have forgotten to execute a edge-label holdout?" . to_string ()) ;
            }
            Ok(())
        }
        /// Raises an error if the graph does not have weights.
        ///
        /// # Example
        /// In order to validate a graph instance, you can use:
        ///
        /// ```rust
        /// # let graph_with_weights = graph::test_utilities::load_ppi(true, true, true, false, false, false);
        /// let normalized = graph_with_weights.get_weighted_symmetric_normalized_transformed_graph(Some(false)).unwrap();
        /// assert!(graph_with_weights.must_have_edge_weights_representing_probabilities().is_err());
        /// assert!(normalized.must_have_edge_weights_representing_probabilities().is_ok());
        /// ```
        ///
        /// # Raises
        /// * If the graph does not have edge weights.
        pub fn must_have_edge_weights_representing_probabilities(&self) -> Result<&Vec<WeightT>> {
            if !self.has_edge_weights_representing_probabilities()? {
                return Err ("The current graph instance does not contain weights representing probabilities." . to_string ()) ;
            }
            Ok(self.weights.as_ref().unwrap())
        }
        /// Raises an error if the graph has negative edge weights.
        ///
        /// # Example
        /// In order to validate a graph instance, you can use:
        ///
        /// ```rust
        /// # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, false, false, false);
        /// # let graph_with_negative_weights = graph_with_weights.get_laplacian_transformed_graph(Some(false));
        /// assert!(graph_with_weights.must_have_positive_edge_weights().is_ok());
        /// assert!(graph_with_negative_weights.must_have_positive_edge_weights().is_err());
        /// ```
        ///
        /// # Raises
        /// * If the graph does not contain edge weights.
        /// * If the graph contains negative edge weights.
        pub fn must_have_positive_edge_weights(&self) -> Result<&Vec<WeightT>> {
            if self.has_negative_edge_weights()? {
                return Err(
                    "The current graph instance contains negative edge weights.".to_string()
                );
            }
            Ok(self.weights.as_ref().unwrap())
        }
        /// Raises an error if the graph contains zero weighted degree.
        ///
        /// # Raises
        /// * If the graph does not have edges.
        pub fn must_not_contain_weighted_singleton_nodes(&self) -> Result<()> {
            if self.has_weighted_singleton_nodes()? {
                return Err ("The current graph instance contains weighted singleton nodes, that is nodes with weighted degree zero." . to_string ()) ;
            }
            Ok(())
        }
        /// Raises an error if the graph has a maximal weighted
        ///
        /// # Example
        /// In order to validate a graph instance, you can use:
        ///
        /// ```rust
        /// # let graph_with_edges = graph::test_utilities::load_ppi(false, false, true, true, false, false);
        /// # let graph_without_edges = graph::test_utilities::load_empty_graph(false);
        /// assert!(graph_with_edges.must_have_edges().is_ok());
        /// assert!(graph_without_edges.must_have_edges().is_err());
        /// ```
        ///
        /// # Raises
        /// * If the graph does not have edges.
        pub fn must_have_edges(&self) -> Result<()> {
            if !self.has_edges() {
                return Err("The current graph instance does not have any edge.".to_string());
            }
            Ok(())
        }
        /// Raises an error if the graph does not have any node.
        ///
        /// # Example
        /// In order to validate a graph instance, you can use:
        ///
        /// ```rust
        /// # let graph_with_nodes = graph::test_utilities::load_ppi(false, false, true, true, false, false);
        /// # let graph_without_nodes = graph::test_utilities::load_empty_graph(false);
        /// assert!(graph_with_nodes.must_have_nodes().is_ok());
        /// assert!(graph_without_nodes.must_have_nodes().is_err());
        /// ```
        ///
        /// # Raises
        /// * If the graph does not have nodes.
        pub fn must_have_nodes(&self) -> Result<()> {
            if !self.has_nodes() {
                return Err("The current graph instance does not have any node.".to_string());
            }
            Ok(())
        }
    }
}
pub use self::validators::*;
mod getters_boolean {
    use super::*;
    /// # Boolean Getters
    /// The naming convention we follow is:
    /// * `/has_(.+)/`
    /// * `/is_(.+)/`
    ///
    /// The naming convention for unchecked methods follows:
    /// * `/has_unchecked_(.+)/`
    /// * `/is_unchecked_(.+)/`.
    impl Graph {
        /// Return if graph has name that is not the default one.
        ///
        /// TODO: use a default for the default graph name!
        pub fn has_default_graph_name(&self) -> bool {
            self.get_name() == "Graph"
        }
        /// Return if the graph has any nodes.
        ///
        /// # Example
        /// To check if the graph has nodes you can use:
        /// ```rust
        /// # let graph_with_nodes = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// # let empty_graph = graph::test_utilities::load_empty_graph(false);
        /// assert!(graph_with_nodes.has_nodes());
        /// assert!(!empty_graph.has_nodes());
        /// ```
        ///
        pub fn has_nodes(&self) -> bool {
            self.get_nodes_number() > 0
        }
        /// Return if the graph has any edges.
        ///
        /// # Example
        /// To check if the current graph has edges you can use:
        /// ```rust
        /// # let graph_with_edges = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// # let empty_graph = graph::test_utilities::load_empty_graph(false);
        /// assert!(graph_with_edges.has_edges());
        /// assert!(!empty_graph.has_edges());
        /// ```
        ///
        pub fn has_edges(&self) -> bool {
            self.get_edges_number() > 0
        }
        /// Return whether the graph has trap nodes.
        ///
        /// # Example
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// if graph.has_trap_nodes(){
        ///     println!("There are {} trap nodes in the current graph.", graph.get_trap_nodes_number());
        /// } else {
        ///     println!("There are no trap nodes in the current graph.");
        /// }
        /// ```
        ///
        pub fn has_trap_nodes(&self) -> bool {
            self.get_trap_nodes_number() > 0
        }
        /// Returns boolean representing if graph is directed.
        ///
        /// # Example
        /// ```rust
        /// let directed_string_ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(directed_string_ppi.is_directed());
        /// let undirected_string_ppi = graph::test_utilities::load_ppi(true, true, true, false, false, false);
        /// assert!(!undirected_string_ppi.is_directed());
        /// ```
        ///
        pub fn is_directed(&self) -> bool {
            self.directed
        }
        /// Returns boolean representing whether graph has weights.
        ///
        /// # Example
        /// ```rust
        /// let weights_string_ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(weights_string_ppi.has_edge_weights());
        /// let unweights_string_ppi = graph::test_utilities::load_ppi(true, true, false, true, false, false);
        /// assert!(!unweights_string_ppi.has_edge_weights());
        /// ```
        ///
        pub fn has_edge_weights(&self) -> bool {
            self.weights.is_some()
        }
        /// Returns whether graph has weights that can represent probabilities.
        ///
        /// # Example
        /// ```rust
        /// # let graph_with_weights = graph::test_utilities::load_ppi(true, true, true, false, false, false);
        /// assert!(!graph_with_weights.has_edge_weights_representing_probabilities().unwrap());
        /// let normalized = graph_with_weights.get_weighted_symmetric_normalized_transformed_graph(Some(false)).unwrap();
        /// assert!(normalized.has_edge_weights_representing_probabilities().unwrap());
        /// ```
        ///
        pub fn has_edge_weights_representing_probabilities(&self) -> Result<bool> {
            Ok(self.get_mininum_edge_weight()? > 0.0 && self.get_maximum_edge_weight()? <= 1.0)
        }
        /// Returns whether a graph has one or more weighted singleton nodes.
        ///
        /// A weighted singleton node is a node whose weighted node degree is 0.
        ///
        /// # Raises
        /// * If the graph does not contain edge weights.
        pub fn has_weighted_singleton_nodes(&self) -> Result<bool> {
            Ok(self.get_weighted_singleton_nodes_number()? > 0)
        }
        /// Returns whether the graph has constant weights.
        ///
        /// # Implementative details
        /// If the minimum edge weight is closer than the maximum edge weight
        /// then the f32 epsilon we consider the weights functionally constant.
        ///
        /// # Raises
        /// * If the graph does not contain edge weights.
        pub fn has_constant_edge_weights(&self) -> Result<bool> {
            Ok(
                (self.get_maximum_edge_weight()? - self.get_mininum_edge_weight()?).abs()
                    < WeightT::EPSILON,
            )
        }
        /// Returns boolean representing whether graph has negative weights.
        ///
        /// # Example
        /// ```rust
        /// let weights_string_ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(weights_string_ppi.has_edge_weights());
        /// let unweights_string_ppi = graph::test_utilities::load_ppi(true, true, false, true, false, false);
        /// assert!(!unweights_string_ppi.has_edge_weights());
        /// ```
        ///
        /// # Raises
        /// * If the graph does not contain weights.
        pub fn has_negative_edge_weights(&self) -> Result<bool> {
            self.get_mininum_edge_weight()
                .map(|min_edge_weight| min_edge_weight < 0.0)
        }
        /// Returns boolean representing whether graph has edge types.
        ///
        /// # Example
        /// ```rust
        /// let string_ppi_with_edge_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(string_ppi_with_edge_types.has_edge_types());
        /// let string_ppi_without_edge_types = graph::test_utilities::load_ppi(true, false, true, true, false, false);
        /// assert!(!string_ppi_without_edge_types.has_edge_types());
        /// ```
        ///
        pub fn has_edge_types(&self) -> bool {
            self.edge_types.is_some()
        }
        /// Returns boolean representing if graph has self-loops.
        ///
        /// # Example
        /// ```rust
        /// let string_ppi_with_selfloops = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(string_ppi_with_selfloops.has_selfloops());
        /// let string_ppi_without_selfloops = graph::test_utilities::load_ppi(true, false, true, true, false, true);
        /// assert!(!string_ppi_without_selfloops.has_selfloops());
        /// ```
        ///
        pub fn has_selfloops(&self) -> bool {
            self.selfloop_number > 0
        }
        /// Returns boolean representing if nodes which are nor singletons nor
        /// singletons with selfloops.
        ///
        /// # Example
        /// ```rust
        /// # let graph_with_singletons = graph::test_utilities::load_ppi(true, true, true, false, false, false);
        /// assert!(graph_with_singletons.has_disconnected_nodes());
        /// let graph_without_singletons = graph_with_singletons.drop_singleton_nodes(Some(false));
        /// assert!(!graph_without_singletons.has_disconnected_nodes());
        /// ```
        pub fn has_disconnected_nodes(&self) -> bool {
            self.get_disconnected_nodes_number() > 0
        }
        /// Returns boolean representing if graph has singletons.
        ///
        /// # Example
        /// ```rust
        /// # let graph_with_singletons = graph::test_utilities::load_ppi(true, true, true, false, false, false);
        /// assert!(graph_with_singletons.has_singleton_nodes());
        /// let graph_without_singletons = graph_with_singletons.drop_singleton_nodes(Some(false));
        /// assert!(!graph_without_singletons.has_singleton_nodes());
        /// ```
        pub fn has_singleton_nodes(&self) -> bool {
            self.get_singleton_nodes_number() > 0
        }
        /// Returns boolean representing if graph has singletons.
        pub fn has_singleton_nodes_with_selfloops(&self) -> bool {
            self.get_singleton_nodes_with_selfloops_number() > 0
        }
        /// Returns whether the graph is connected.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show the loading bar while computing the connected components, if necessary.
        pub fn is_connected(&self, verbose: Option<bool>) -> bool {
            self.get_nodes_number() <= 1
                || !self.has_singleton_nodes()
                    && !self.has_singleton_nodes_with_selfloops()
                    && self.get_connected_components_number(verbose).0 == 1
        }
        /// Returns boolean representing if graph has node types.
        pub fn has_node_types(&self) -> bool {
            self.node_types.is_some()
        }
        /// Returns boolean representing if graph has multilabel node types.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        pub fn has_multilabel_node_types(&self) -> Result<bool> {
            self.must_have_node_types()
                .map(|node_types| node_types.is_multilabel())
        }
        /// Returns whether there are unknown node types.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        pub fn has_unknown_node_types(&self) -> Result<bool> {
            Ok(self.get_unknown_node_types_number()? > 0)
        }
        /// Returns whether there are known node types.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        pub fn has_known_node_types(&self) -> Result<bool> {
            Ok(self.get_known_node_types_number()? > 0)
        }
        /// Returns whether there are unknown edge types.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        pub fn has_unknown_edge_types(&self) -> Result<bool> {
            Ok(self.get_unknown_edge_types_number()? > 0)
        }
        /// Returns whether there are known edge types.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        pub fn has_known_edge_types(&self) -> Result<bool> {
            Ok(self.get_known_edge_types_number()? > 0)
        }
        /// Returns whether the nodes have an homogenous node type.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        pub fn has_homogeneous_node_types(&self) -> Result<bool> {
            Ok(self.get_node_types_number()? == 1)
        }
        /// Returns whether the edges have an homogenous edge type.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        pub fn has_homogeneous_edge_types(&self) -> Result<bool> {
            Ok(self.get_edge_types_number()? == 1)
        }
        /// Returns whether there is at least singleton node type, that is a node type that only appears once.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        pub fn has_singleton_node_types(&self) -> Result<bool> {
            Ok(self.get_minimum_node_types_number()? == 1)
        }
        /// Return whether the graph has any known node-related graph oddities.
        pub fn has_node_oddities(&self) -> bool {
            [
                self.has_singleton_nodes(),
                self.has_singleton_nodes_with_selfloops(),
            ]
            .iter()
            .any(|value| *value)
        }
        /// Return whether the graph has any known node type-related graph oddities.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        pub fn has_node_types_oddities(&self) -> Result<bool> {
            Ok([
                self.has_singleton_node_types()?,
                self.has_homogeneous_node_types()?,
                self.has_unknown_node_types()?,
            ]
            .iter()
            .any(|value| *value))
        }
        /// Returns whether there is at least singleton edge type, that is a edge type that only appears once.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        pub fn has_singleton_edge_types(&self) -> Result<bool> {
            Ok(self.get_minimum_edge_types_number()? == 1)
        }
        /// Return whether the graph has any known edge type-related graph oddities.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        pub fn has_edge_types_oddities(&self) -> Result<bool> {
            Ok([
                self.has_singleton_edge_types()?,
                self.has_homogeneous_edge_types()?,
                self.has_unknown_edge_types()?,
            ]
            .iter()
            .any(|value| *value))
        }
        /// Return if there are multiple edges between two nodes
        pub fn is_multigraph(&self) -> bool {
            self.get_parallel_edges_number() > 0
        }
        /// Returns whether the node IDs are sorted by decreasing outbound node degree.
        ///
        /// # Implications
        /// The implications of having a graph with node IDs sorted by the
        /// outbound node degrees are multiple.
        /// For instance, it makes it possible to create a NCE loss that
        /// is able to better approximate a complete Softmax by sampling
        /// the output labels using a Zipfian distribution, which is what
        /// most graphs follow.
        pub fn has_nodes_sorted_by_decreasing_outbound_node_degree(&self) -> bool {
            self.nodes_are_sorted_by_decreasing_outbound_node_degree
        }
        /// Returns whether the node IDs are sorted by increasing outbound node degree.
        ///
        /// # Implications
        /// The implications of having a graph with node IDs sorted by the
        /// outbound node degrees are multiple.
        /// For instance, it makes it possible to create a NCE loss that
        /// is able to better approximate a complete Softmax by sampling
        /// the output labels using a Zipfian distribution, which is what
        /// most graphs follow.
        pub fn has_nodes_sorted_by_increasing_outbound_node_degree(&self) -> bool {
            self.nodes_are_sorted_by_increasing_outbound_node_degree
        }
    }
}
pub use self::getters_boolean::*;
mod replace {
    use super::*;
    use indicatif::ProgressIterator;
    use itertools::Itertools;
    use log::warn;
    use std::collections::HashMap;
    /// # Replace.
    impl Graph {
        /// Replace given node, node type and edge type names.
        ///
        /// # Arguments
        /// * `node_name_mapping`: Option<HashMap<String, String>> - The node names to replace.
        /// * `node_type_name_mapping`: Option<HashMap<String, String>> - The node type names to replace.
        /// * `node_type_names_mapping`: Option<HashMap<Option<Vec<String>>, Option<Vec<String>>>> - The node type names (as vectors) to replace.
        /// * `edge_type_name_mapping`: Option<HashMap<Option<String>, Option<String>>> - The edge type names to replace.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # Raises
        /// * If the given node names mapping would lead to nodes duplication.
        pub fn replace(
            &self,
            node_name_mapping: Option<HashMap<String, String>>,
            node_type_name_mapping: Option<HashMap<String, String>>,
            node_type_names_mapping: Option<HashMap<Option<Vec<String>>, Option<Vec<String>>>>,
            edge_type_name_mapping: Option<HashMap<Option<String>, Option<String>>>,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            let verbose = verbose.unwrap_or(false);
            if node_type_names_mapping.is_some() && node_type_name_mapping.is_some() {
                return Err ("Using at once node_type_name_mapping and node_type_names_mapping is not supported." . to_string ()) ;
            }
            if let Some(nns) = &node_name_mapping {
                for (original_node_name, new_node_name) in nns.iter() {
                    if *original_node_name == *new_node_name {
                        {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                                :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["The required remapping operation includes remapping between the same node names: " , " => "] , & match (& original_node_name , & new_node_name) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , }) , lvl , & ("graph::replace" , "graph::replace" , "src/replace.rs" , 37u32)) ;
                            }
                        };
                        continue;
                    }
                    if self.has_node_name(new_node_name) {
                        return Err({
                            let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1_formatted (& ["One of the new node names (" , ") already exists in the graph and the required remapping operation (" , " => " , ") would lead to a duplicated node name."] , & match (& new_node_name , & original_node_name) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , } , & [:: core :: fmt :: rt :: v1 :: Argument { position : 0usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Implied , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , } , :: core :: fmt :: rt :: v1 :: Argument { position : 1usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Implied , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , } , :: core :: fmt :: rt :: v1 :: Argument { position : 0usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Implied , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , }])) ;
                            res
                        });
                    }
                }
            }
            let pb_edges = get_loading_bar(
                verbose,
                {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Building edges of graph ", " replacing required attributes"],
                        &match (&self.name,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                .as_ref(),
                self.get_directed_edges_number() as usize,
            );
            let pb_nodes = get_loading_bar(
                verbose,
                {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Building nodes of graph ", " replacing required attributes"],
                        &match (&self.name,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                .as_ref(),
                self.get_nodes_number() as usize,
            );
            Graph::from_string_sorted(
                self.iter_edge_node_names_and_edge_type_name_and_edge_weight(true)
                    .progress_with(pb_edges)
                    .map(|(_, _, src_name, _, dst_name, _, edge_type_name, weight)| {
                        Ok((
                            node_name_mapping
                                .as_ref()
                                .map_or(&src_name, |nns| nns.get(&src_name).unwrap_or(&src_name))
                                .clone(),
                            node_name_mapping
                                .as_ref()
                                .map_or(&dst_name, |nns| nns.get(&dst_name).unwrap_or(&dst_name))
                                .clone(),
                            edge_type_name_mapping
                                .as_ref()
                                .map_or(&edge_type_name, |etns| {
                                    etns.get(&edge_type_name).unwrap_or(&edge_type_name)
                                })
                                .clone(),
                            weight,
                        ))
                    }),
                Some(
                    self.iter_node_names_and_node_type_names()
                        .progress_with(pb_nodes)
                        .map(|(_, node_name, _, node_types)| {
                            Ok((
                                node_name_mapping
                                    .as_ref()
                                    .map_or(&node_name, |nns| {
                                        nns.get(&node_name).unwrap_or(&node_name)
                                    })
                                    .clone(),
                                match (
                                    &node_type_name_mapping,
                                    &node_type_names_mapping,
                                    node_types,
                                ) {
                                    (Some(ntn_mapping), None, Some(nts)) => Some(
                                        nts.into_iter()
                                            .map(|node_type_name| {
                                                ntn_mapping
                                                    .get(&node_type_name)
                                                    .map_or(node_type_name, |new_value| {
                                                        new_value.clone()
                                                    })
                                            })
                                            .unique()
                                            .collect(),
                                    ),
                                    (None, Some(ntns_mapping), node_types) => {
                                        ntns_mapping.get(&node_types).unwrap_or(&node_types).clone()
                                    }
                                    (_, _, node_types) => node_types,
                                },
                            ))
                        }),
                ),
                self.is_directed(),
                true,
                self.get_name(),
                false,
                true,
                true,
                true,
                self.get_directed_edges_number() as usize,
                self.get_nodes_number(),
                false,
                false,
                false,
                false,
                self.has_node_types(),
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                self.has_singleton_nodes(),
                self.has_singleton_nodes_with_selfloops(),
                self.has_trap_nodes(),
            )
        }
        /// Replace unknown node types with given node type.
        ///
        /// # Arguments
        /// * `node_type_names`: Vec<String> - The node types to replace the unknown with.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        pub fn replace_unknown_node_types_with_node_type_name(
            &self,
            node_type_names: Vec<String>,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            if node_type_names
                .iter()
                .any(|node_type_name| node_type_name.is_empty())
            {
                return Err("One or more of the given node types are empty!".to_string());
            }
            self.replace(
                None,
                None,
                Some([(None, Some(node_type_names))].iter().cloned().collect()),
                None,
                verbose,
            )
        }
        /// Replace unknown edge types with given edge type name.
        ///
        /// # Arguments
        /// * `edge_type_name`: String - The edge type name to replace the unknown with.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        pub fn replace_unknown_edge_types_with_edge_type_name(
            &self,
            edge_type_name: String,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            if edge_type_name.is_empty() {
                return Err("The given edge type is empty!".to_string());
            }
            self.replace(
                None,
                None,
                None,
                Some([(None, Some(edge_type_name))].iter().cloned().collect()),
                verbose,
            )
        }
    }
}
pub use self::replace::*;
mod dijkstra {
    use super::*;
    use indicatif::ParallelProgressIterator;
    use num_traits::Zero;
    use rayon::iter::IndexedParallelIterator;
    use rayon::iter::IntoParallelIterator;
    use rayon::iter::ParallelIterator;
    use std::cmp::Ord;
    use std::collections::VecDeque;
    use std::sync::atomic::{AtomicU32, Ordering};
    pub struct ShortestPathsResultBFS {
        distances: Vec<NodeT>,
        predecessors: Option<Vec<NodeT>>,
        eccentricity: NodeT,
        most_distant_node: NodeT,
    }
    impl ShortestPathsResultBFS {
        pub(crate) fn new(
            distances: Vec<NodeT>,
            predecessors: Option<Vec<NodeT>>,
            eccentricity: NodeT,
            most_distant_node: NodeT,
        ) -> ShortestPathsResultBFS {
            ShortestPathsResultBFS {
                distances,
                predecessors,
                eccentricity,
                most_distant_node,
            }
        }
        pub(crate) fn has_path_to_node_id(&self, node_id: NodeT) -> bool {
            self.get_distance_from_node_id(node_id) != NOT_PRESENT
        }
        pub(crate) fn get_distance_from_node_id(&self, node_id: NodeT) -> NodeT {
            self.distances[node_id as usize]
        }
        pub(crate) fn get_parent_from_node_id(&self, node_id: NodeT) -> Option<NodeT> {
            self.predecessors
                .as_ref()
                .map(|predecessors| predecessors[node_id as usize])
        }
        pub(crate) fn get_node_distance(&self, node_id: NodeT) -> NodeT {
            self.distances[node_id as usize]
        }
        /// Returns node at the `len - k` position on minimum path to given destination node.
        ///
        /// # Arguments
        /// * `dst_node_id`: NodeT - The node to start computing predecessors from.
        /// * `k`: NodeT - Steps to go back.
        ///
        /// # Raises
        /// * If the predecessors vector was not requested.
        pub(crate) fn get_kth_point_on_minimum_path(
            &self,
            mut dst_node_id: NodeT,
            k: NodeT,
        ) -> Result<NodeT> {
            if !self.has_path_to_node_id(dst_node_id) {
                return Err("There is no path to the given destination node.".to_string());
            }
            if self.get_eccentricity() < k {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "The current minimum path tree has eccentricity ",
                            ", but the requested number of steps is ",
                            ".",
                        ],
                        &match (&self.get_eccentricity(), &k) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                });
            }
            if let Some(predecessors) = self.predecessors.as_ref() {
                for _ in 0..k {
                    dst_node_id = predecessors[dst_node_id as usize];
                }
                return Ok(dst_node_id);
            }
            Err("Predecessors were not requested and therefore not computed.".to_string())
        }
        pub(crate) fn get_median_point(&self, dst_node_id: NodeT) -> Result<NodeT> {
            if !self.has_path_to_node_id(dst_node_id) {
                return Err("There is no path to the given destination node.".to_string());
            }
            let median_distance = self.get_node_distance(dst_node_id) / 2;
            self.get_kth_point_on_minimum_path(dst_node_id, median_distance)
        }
        pub(crate) fn get_eccentricity(&self) -> NodeT {
            self.eccentricity
        }
        pub(crate) fn get_most_distant_node(&self) -> NodeT {
            self.most_distant_node
        }
        pub(crate) fn into_iter_finite_distances(self) -> impl Iterator<Item = NodeT> {
            self.distances
                .into_iter()
                .filter(|&distance| distance != NOT_PRESENT)
        }
        pub(crate) fn into_par_iter_node_ids_and_finite_distances(
            self,
        ) -> impl ParallelIterator<Item = (NodeT, NodeT)> {
            self.distances
                .into_par_iter()
                .enumerate()
                .filter_map(|(node_id, distance)| {
                    if distance != NOT_PRESENT {
                        Some((node_id as NodeT, distance))
                    } else {
                        None
                    }
                })
        }
        pub(crate) fn into_distances(self) -> Vec<NodeT> {
            self.distances
        }
    }
    pub struct ShortestPathsDjkstra {
        pub(crate) distances: Vec<f64>,
        pub(crate) predecessors: Option<Vec<Option<NodeT>>>,
        pub(crate) dst_node_distance: Option<f64>,
        pub(crate) eccentricity: f64,
        pub(crate) total_distance: f64,
        pub(crate) total_harmonic_distance: f64,
    }
    impl ShortestPathsDjkstra {
        pub(crate) fn new(
            distances: Vec<f64>,
            predecessors: Option<Vec<Option<NodeT>>>,
            dst_node_distance: Option<f64>,
            eccentricity: f64,
            total_distance: f64,
            total_harmonic_distance: f64,
        ) -> ShortestPathsDjkstra {
            ShortestPathsDjkstra {
                distances,
                predecessors,
                dst_node_distance,
                eccentricity,
                total_distance,
                total_harmonic_distance,
            }
        }
    }
    impl Graph {
        /// Returns vector of minimum paths distances and vector of nodes predecessors, if requested.
        ///
        /// # Arguments
        /// * `src_node_id`: NodeT - Root of the tree of minimum paths.
        /// * `maybe_dst_node_id`: Option<NodeT> - Optional target destination. If provided, Dijkstra will stop upon reaching this node.
        /// * `maybe_dst_node_ids`: Option<Vec<NodeT>> - Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.
        /// * `compute_distances`: Option<bool> - Whether to compute the vector of distances.
        /// * `compute_predecessors`: Option<bool> - Whether to compute the vector of predecessors.
        /// * `compute_visited`: Option<bool> - Whether to compute the vector of visited nodes.
        /// * `maximal_depth`: Option<NodeT> - The maximal depth to execute the DFS for.
        ///
        /// # Safety
        /// If any of the given node IDs does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_breath_first_search_from_node_ids(
            &self,
            src_node_id: NodeT,
            dst_node_id: Option<NodeT>,
            compute_predecessors: Option<bool>,
            maximal_depth: Option<NodeT>,
        ) -> ShortestPathsResultBFS {
            let compute_predecessors = compute_predecessors.unwrap_or(true);
            let nodes_number = self.get_nodes_number() as usize;
            let mut found_destination = false;
            let mut predecessors: Option<Vec<NodeT>> = if compute_predecessors {
                let mut predecessors = ::alloc::vec::from_elem(NOT_PRESENT, nodes_number);
                predecessors[src_node_id as usize] = src_node_id;
                Some(predecessors)
            } else {
                None
            };
            let mut distances: Vec<NodeT> = ::alloc::vec::from_elem(NOT_PRESENT, nodes_number);
            distances[src_node_id as usize] = 0;
            let mut eccentricity = 0;
            let mut most_distant_node = src_node_id;
            let mut nodes_to_explore = VecDeque::with_capacity(nodes_number);
            nodes_to_explore.push_back((src_node_id, 0));
            while let Some((node_id, depth)) = nodes_to_explore.pop_front() {
                let new_neighbour_distance = depth + 1;
                if eccentricity < depth {
                    eccentricity = depth;
                    most_distant_node = node_id;
                }
                if let Some(mi) = maximal_depth {
                    if new_neighbour_distance > mi {
                        continue;
                    }
                }
                self.iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)
                    .for_each(|neighbour_node_id| {
                        if found_destination {
                            return;
                        }
                        if distances[neighbour_node_id as usize] == NOT_PRESENT {
                            distances[neighbour_node_id as usize] = new_neighbour_distance;
                            if let Some(predecessors) = predecessors.as_mut() {
                                predecessors[neighbour_node_id as usize] = node_id;
                            }
                            if let Some(dst_node_id) = dst_node_id {
                                if neighbour_node_id == dst_node_id {
                                    found_destination = true;
                                }
                            }
                            nodes_to_explore.push_back((neighbour_node_id, new_neighbour_distance));
                        }
                    });
                if found_destination {
                    break;
                }
            }
            ShortestPathsResultBFS::new(distances, predecessors, eccentricity, most_distant_node)
        }
        /// Returns minimum path node IDs and distance from given node ids.
        ///
        /// # Arguments
        /// * `src_node_id`: NodeT - Source node ID.
        /// * `dst_node_id`: NodeT - Destination node ID.
        /// * `maximal_depth`: Option<NodeT> - The maximal depth to execute the BFS for.
        ///
        /// # Safety
        /// If any of the given node IDs does not exist in the graph the method will panic.
        ///
        /// # Raises
        /// * If the given node is a selfloop.
        /// * If there is no path between the two given nodes.
        pub unsafe fn get_unchecked_minimum_path_node_ids_from_node_ids(
            &self,
            src_node_id: NodeT,
            dst_node_id: NodeT,
            maximal_depth: Option<NodeT>,
        ) -> Result<Vec<NodeT>> {
            if src_node_id == dst_node_id {
                return Err("The minimum path on a selfloop is not defined.".to_string());
            }
            let bfs = self.get_unchecked_breath_first_search_from_node_ids(
                src_node_id,
                Some(dst_node_id),
                None,
                maximal_depth,
            );
            if !bfs.has_path_to_node_id(dst_node_id) {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "There is no path starting from the given source node ",
                            " and reaching the given destination node ",
                            ".",
                        ],
                        &match (&src_node_id, &dst_node_id) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                });
            }
            let path_length = bfs.get_distance_from_node_id(dst_node_id) as usize + 1;
            let mut path = ::alloc::vec::from_elem(0, path_length);
            let mut parent_node_id = dst_node_id;
            (0..path_length).for_each(|index| {
                path[path_length - index - 1] = parent_node_id;
                parent_node_id = bfs.get_parent_from_node_id(parent_node_id).unwrap();
            });
            Ok(path)
        }
        /// Returns minimum path node names from given node ids.
        ///
        /// # Arguments
        /// * `src_node_id`: NodeT - Source node ID.
        /// * `dst_node_id`: NodeT - Destination node ID.
        /// * `maximal_depth`: Option<NodeT> - The maximal depth to execute the BFS for.
        ///
        /// # Safety
        /// If any of the given node IDs does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_minimum_path_node_names_from_node_ids(
            &self,
            src_node_id: NodeT,
            dst_node_id: NodeT,
            maximal_depth: Option<NodeT>,
        ) -> Result<Vec<String>> {
            Ok(self
                .get_unchecked_minimum_path_node_ids_from_node_ids(
                    src_node_id,
                    dst_node_id,
                    maximal_depth,
                )?
                .into_iter()
                .map(|node_id| self.get_unchecked_node_name_from_node_id(node_id))
                .collect())
        }
        /// Returns minimum path node names from given node ids.
        ///
        /// # Arguments
        /// * `src_node_id`: NodeT - Source node ID.
        /// * `dst_node_id`: NodeT - Destination node ID.
        /// * `maximal_depth`: Option<NodeT> - The maximal depth to execute the BFS for.
        ///
        /// # Raises
        /// * If any of the given node IDs do not exist in the current graph.
        pub fn get_minimum_path_node_ids_from_node_ids(
            &self,
            src_node_id: NodeT,
            dst_node_id: NodeT,
            maximal_depth: Option<NodeT>,
        ) -> Result<Vec<NodeT>> {
            Ok(unsafe {
                self.get_unchecked_minimum_path_node_ids_from_node_ids(
                    self.validate_node_id(src_node_id)?,
                    self.validate_node_id(dst_node_id)?,
                    maximal_depth,
                )?
            })
        }
        /// Returns minimum path node names from given node names.
        ///
        /// # Arguments
        /// * `src_node_name`: &str - Source node name.
        /// * `dst_node_name`: &str - Destination node name.
        /// * `maximal_depth`: Option<NodeT> - The maximal depth to execute the BFS for.
        ///
        /// # Raises
        /// * If any of the given node names do not exist in the current graph.
        pub fn get_minimum_path_node_ids_from_node_names(
            &self,
            src_node_name: &str,
            dst_node_name: &str,
            maximal_depth: Option<NodeT>,
        ) -> Result<Vec<NodeT>> {
            Ok(unsafe {
                self.get_unchecked_minimum_path_node_ids_from_node_ids(
                    self.get_node_id_from_node_name(src_node_name)?,
                    self.get_node_id_from_node_name(dst_node_name)?,
                    maximal_depth,
                )?
            })
        }
        /// Returns minimum path node names from given node names.
        ///
        /// # Arguments
        /// * `src_node_name`: &str - Source node name.
        /// * `dst_node_name`: &str - Destination node name.
        /// * `maximal_depth`: Option<NodeT> - The maximal depth to execute the BFS for.
        ///
        /// # Raises
        /// * If any of the given node names do not exist in the current graph.
        pub fn get_minimum_path_node_names_from_node_names(
            &self,
            src_node_name: &str,
            dst_node_name: &str,
            maximal_depth: Option<NodeT>,
        ) -> Result<Vec<String>> {
            Ok(unsafe {
                self.get_unchecked_minimum_path_node_names_from_node_ids(
                    self.get_node_id_from_node_name(src_node_name)?,
                    self.get_node_id_from_node_name(dst_node_name)?,
                    maximal_depth,
                )?
            })
        }
        /// Return vector of the k minimum paths node IDs between given source node and destination node ID.
        ///
        /// # Arguments
        /// * `src_node_id`: NodeT - Source node ID.
        /// * `dst_node_id`: NodeT - Destination node ID.
        /// * `k`: usize - Number of paths to find.
        ///
        /// # Implementative details
        /// This method is not converted to a numpy array because it would have
        /// to be a ragged array, as the different paths have different lengths.
        ///
        /// # Safety
        /// If any of the given node IDs does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_k_shortest_path_node_ids_from_node_ids(
            &self,
            src_node_id: NodeT,
            dst_node_id: NodeT,
            k: usize,
        ) -> Vec<Vec<NodeT>> {
            let nodes_number = self.get_nodes_number() as usize;
            let mut counts = ::alloc::vec::from_elem(0, nodes_number);
            let mut paths = Vec::new();
            let mut nodes_to_explore = VecDeque::with_capacity(nodes_number);
            nodes_to_explore.push_back(<[_]>::into_vec(box [src_node_id]));
            while let Some(path) = nodes_to_explore.pop_front() {
                if counts[dst_node_id as usize] >= k {
                    break;
                }
                let node_id = *path.last().unwrap();
                counts[node_id as usize] += 1;
                if node_id == dst_node_id {
                    paths.push(path);
                    continue;
                }
                if counts[node_id as usize] > k {
                    continue;
                }
                self.iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)
                    .for_each(|neighbour_node_id| {
                        let mut new_path = path.clone();
                        new_path.push(neighbour_node_id);
                        nodes_to_explore.push_back(new_path);
                    });
            }
            paths
        }
        /// Return vector of the k minimum paths node IDs between given source node and destination node ID.
        ///
        /// # Arguments
        /// * `src_node_id`: NodeT - Source node ID.
        /// * `dst_node_id`: NodeT - Destination node ID.
        /// * `maximal_depth`: Option<NodeT> - The maximal depth to execute the BFS for.
        /// * `k`: usize - Number of paths to find.
        ///
        /// # Implementative details
        /// This method is not converted to a numpy array because it would have
        /// to be a ragged array, as the different paths have different lengths.
        ///
        /// # Raises
        /// * If any of the given node IDs does not exist in the graph.
        pub fn get_k_shortest_path_node_ids_from_node_ids(
            &self,
            src_node_id: NodeT,
            dst_node_id: NodeT,
            k: usize,
        ) -> Result<Vec<Vec<NodeT>>> {
            Ok(unsafe {
                self.get_unchecked_k_shortest_path_node_ids_from_node_ids(
                    self.validate_node_id(src_node_id)?,
                    self.validate_node_id(dst_node_id)?,
                    k,
                )
            })
        }
        /// Return vector of the k minimum paths node IDs between given source node and destination node name.
        ///
        /// # Arguments
        /// * `src_node_name`: &str - Source node name.
        /// * `dst_node_name`: &str - Destination node name.
        /// * `k`: usize - Number of paths to find.
        ///
        /// # Implementative details
        /// This method is not converted to a numpy array because it would have
        /// to be a ragged array, as the different paths have different lengths.
        ///
        /// # Raises
        /// * If any of the given node names does not exist in the graph.
        pub fn get_k_shortest_path_node_ids_from_node_names(
            &self,
            src_node_name: &str,
            dst_node_name: &str,
            k: usize,
        ) -> Result<Vec<Vec<NodeT>>> {
            Ok(unsafe {
                self.get_unchecked_k_shortest_path_node_ids_from_node_ids(
                    self.get_node_id_from_node_name(src_node_name)?,
                    self.get_node_id_from_node_name(dst_node_name)?,
                    k,
                )
            })
        }
        /// Return vector of the k minimum paths node names between given source node and destination node name.
        ///
        /// # Arguments
        /// * `src_node_name`: &str - Source node name.
        /// * `dst_node_name`: &str - Destination node name.
        /// * `k`: usize - Number of paths to find.
        ///
        /// # Implementative details
        /// This method is not converted to a numpy array because it would have
        /// to be a ragged array, as the different paths have different lengths.
        ///
        /// # Raises
        /// * If any of the given node names does not exist in the graph.
        pub fn get_k_shortest_path_node_names_from_node_names(
            &self,
            src_node_name: &str,
            dst_node_name: &str,
            k: usize,
        ) -> Result<Vec<Vec<String>>> {
            self.get_k_shortest_path_node_ids_from_node_names(src_node_name, dst_node_name, k)
                .map(|paths| {
                    paths
                        .into_iter()
                        .map(|path| {
                            path.into_iter()
                                .map(|node_id| unsafe {
                                    self.get_unchecked_node_name_from_node_id(node_id)
                                })
                                .collect()
                        })
                        .collect()
                })
        }
        /// Returns unweighted eccentricity of the given node.
        ///
        /// This method will panic if the given node ID does not exists in the graph.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - Node for which to compute the eccentricity.
        ///
        /// # Safety
        /// If any of the given node IDs does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_eccentricity_from_node_id(&self, node_id: NodeT) -> NodeT {
            self.get_unchecked_breath_first_search_from_node_ids(node_id, None, None, None)
                .get_eccentricity()
        }
        /// Returns weighted eccentricity of the given node.
        ///
        /// This method will panic if the given node ID does not exists in the graph.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - Node for which to compute the eccentricity.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        ///
        /// # Safety
        /// If any of the given node IDs does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_weighted_eccentricity_from_node_id(
            &self,
            node_id: NodeT,
            use_edge_weights_as_probabilities: Option<bool>,
        ) -> f64 {
            self.get_unchecked_dijkstra_from_node_ids(
                node_id,
                None,
                None,
                Some(false),
                None,
                use_edge_weights_as_probabilities,
            )
            .eccentricity
        }
        /// Returns unweighted eccentricity of the given node ID.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - Node for which to compute the eccentricity.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        ///
        /// # Raises
        /// * If the given node ID does not exist in the graph.
        pub fn get_eccentricity_from_node_id(&self, node_id: NodeT) -> Result<NodeT> {
            self.validate_node_id(node_id)
                .map(|node_id| unsafe { self.get_unchecked_eccentricity_from_node_id(node_id) })
        }
        /// Returns weighted eccentricity of the given node ID.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - Node for which to compute the eccentricity.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        ///
        /// # Raises
        /// * If the given node ID does not exist in the graph.
        /// * If weights are requested to be treated as probabilities but are not between 0 and 1.
        /// * If the graph contains negative weights.
        pub fn get_weighted_eccentricity_from_node_id(
            &self,
            node_id: NodeT,
            use_edge_weights_as_probabilities: Option<bool>,
        ) -> Result<f64> {
            if let Some(uewap) = use_edge_weights_as_probabilities {
                if uewap {
                    self.must_have_edge_weights_representing_probabilities()?;
                }
            }
            self.must_have_positive_edge_weights()?;
            self.validate_node_id(node_id).map(|node_id| unsafe {
                self.get_unchecked_weighted_eccentricity_from_node_id(
                    node_id,
                    use_edge_weights_as_probabilities,
                )
            })
        }
        /// Returns unweighted eccentricity of the given node name.
        ///
        /// # Arguments
        /// * `node_name`: &str - Node for which to compute the eccentricity.
        ///
        /// # Raises
        /// * If the given node name does not exist in the current graph instance.
        pub fn get_eccentricity_from_node_name(&self, node_name: &str) -> Result<NodeT> {
            self.get_node_id_from_node_name(node_name)
                .map(|node_id| unsafe { self.get_unchecked_eccentricity_from_node_id(node_id) })
        }
        /// Returns weighted eccentricity of the given node name.
        ///
        /// # Arguments
        /// * `node_name`: &str - Node for which to compute the eccentricity.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        ///
        /// # Raises
        /// * If the given node name does not exist in the graph.
        /// * If weights are requested to be treated as probabilities but are not between 0 and 1.
        /// * If the graph contains negative weights.
        pub fn get_weighted_eccentricity_from_node_name(
            &self,
            node_name: &str,
            use_edge_weights_as_probabilities: Option<bool>,
        ) -> Result<f64> {
            if let Some(uewap) = use_edge_weights_as_probabilities {
                if uewap {
                    self.must_have_edge_weights_representing_probabilities()?;
                }
            }
            self.must_have_positive_edge_weights()?;
            self.get_node_id_from_node_name(node_name)
                .map(|node_id| unsafe {
                    self.get_unchecked_weighted_eccentricity_from_node_id(
                        node_id,
                        use_edge_weights_as_probabilities,
                    )
                })
        }
        /// Returns vector of minimum paths distances and vector of nodes predecessors, if requested.
        ///
        /// # Arguments
        /// * `src_node_id`: NodeT - Root of the tree of minimum paths.
        /// * `maybe_dst_node_id`: Option<NodeT> - Optional target destination. If provided, Dijkstra will stop upon reaching this node.
        /// * `maybe_dst_node_ids`: Option<Vec<NodeT>> - Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.
        /// * `compute_predecessors`: bool - Whether to compute the vector of predecessors.
        /// * `maximal_depth`: Option<NodeT> - The maximal number of iterations to execute Dijkstra for.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        ///
        /// # Safety
        /// If any of the given node IDs does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_dijkstra_from_node_ids(
            &self,
            src_node_id: NodeT,
            maybe_dst_node_id: Option<NodeT>,
            mut maybe_dst_node_ids: Option<Vec<NodeT>>,
            compute_predecessors: Option<bool>,
            maximal_depth: Option<NodeT>,
            use_edge_weights_as_probabilities: Option<bool>,
        ) -> ShortestPathsDjkstra {
            let compute_predecessors = compute_predecessors.unwrap_or(true);
            let nodes_number = self.get_nodes_number() as usize;
            let use_edge_weights_as_probabilities =
                use_edge_weights_as_probabilities.unwrap_or(false);
            let mut dst_node_distance = maybe_dst_node_id.map(|_| {
                if use_edge_weights_as_probabilities {
                    0.0
                } else {
                    f64::INFINITY
                }
            });
            let mut predecessors: Option<Vec<Option<NodeT>>> = if compute_predecessors {
                Some(::alloc::vec::from_elem(None, nodes_number))
            } else {
                None
            };
            if self.is_unchecked_disconnected_from_node_id(src_node_id) {
                if use_edge_weights_as_probabilities {
                    return ShortestPathsDjkstra::new(
                        ::alloc::vec::from_elem(0.0, nodes_number),
                        predecessors,
                        dst_node_distance,
                        0.0,
                        0.0,
                        0.0,
                    );
                } else {
                    return ShortestPathsDjkstra::new(
                        ::alloc::vec::from_elem(f64::INFINITY, nodes_number),
                        predecessors,
                        dst_node_distance,
                        f64::INFINITY,
                        f64::INFINITY,
                        0.0,
                    );
                }
            }
            let bfs: Option<ShortestPathsResultBFS> = maximal_depth.map(|md| {
                self.get_unchecked_breath_first_search_from_node_ids(
                    src_node_id,
                    maybe_dst_node_id,
                    None,
                    Some(md),
                )
            });
            let mut nodes_to_explore: DijkstraQueue =
                DijkstraQueue::with_capacity_from_root(nodes_number, src_node_id as usize);
            let mut eccentricity: f64 = 0.0;
            let mut total_distance: f64 = 0.0;
            let mut total_harmonic_distance: f64 = 0.0;
            while let Some(closest_node_id) = nodes_to_explore.pop() {
                eccentricity = eccentricity.max(nodes_to_explore[closest_node_id]);
                total_distance += nodes_to_explore[closest_node_id];
                if nodes_to_explore[closest_node_id] > 0.0 {
                    total_harmonic_distance += if use_edge_weights_as_probabilities {
                        (-nodes_to_explore[closest_node_id]).exp()
                    } else {
                        1.0 / nodes_to_explore[closest_node_id]
                    };
                }
                if maybe_dst_node_id.map_or(false, |dst| dst == closest_node_id as NodeT) {
                    dst_node_distance.insert(if use_edge_weights_as_probabilities {
                        (-nodes_to_explore[closest_node_id]).exp()
                    } else {
                        nodes_to_explore[closest_node_id]
                    });
                    break;
                }
                if let Some(dst_node_ids) = &mut maybe_dst_node_ids {
                    let node_id_idx = dst_node_ids
                        .iter()
                        .position(|x| *x as usize == closest_node_id);
                    if let Some(nii) = node_id_idx {
                        dst_node_ids.remove(nii);
                    }
                    if dst_node_ids.is_empty() {
                        break;
                    }
                }
                self.iter_unchecked_neighbour_node_ids_from_source_node_id(
                    closest_node_id as NodeT,
                )
                .zip(self.iter_unchecked_edge_weights_from_source_node_id(closest_node_id as NodeT))
                .for_each(|(neighbour_node_id, weight)| {
                    if let Some(bfs) = bfs.as_ref() {
                        if !bfs.has_path_to_node_id(neighbour_node_id) {
                            return;
                        }
                    }
                    let new_neighbour_distance = nodes_to_explore[closest_node_id]
                        + if use_edge_weights_as_probabilities {
                            -(weight as f64).ln()
                        } else {
                            weight as f64
                        };
                    if new_neighbour_distance < nodes_to_explore[neighbour_node_id as usize] {
                        if let Some(predecessors) = &mut predecessors {
                            predecessors[neighbour_node_id as usize] =
                                Some(closest_node_id as NodeT);
                        }
                        nodes_to_explore.push(neighbour_node_id as usize, new_neighbour_distance);
                    }
                });
            }
            let mut distances = nodes_to_explore.unwrap();
            if use_edge_weights_as_probabilities {
                distances
                    .iter_mut()
                    .for_each(|distance| *distance = (-*distance).exp());
                eccentricity = (-eccentricity).exp();
                total_distance = (-total_distance).exp();
            }
            ShortestPathsDjkstra {
                distances,
                predecessors,
                dst_node_distance,
                eccentricity,
                total_distance,
                total_harmonic_distance,
            }
        }
        /// Returns minimum path node IDs and distance from given node ids.
        ///
        /// # Arguments
        /// * `src_node_id`: NodeT - Source node ID.
        /// * `dst_node_id`: NodeT - Destination node ID.
        /// * `maximal_depth`: Option<NodeT> - The maximal depth to execute the BFS for.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        /// * `maximal_depth`: Option<NodeT> - The maximal number of iterations to execute Dijkstra for.
        ///
        /// # Safety
        /// If any of the given node IDs does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_weighted_minimum_path_node_ids_from_node_ids(
            &self,
            src_node_id: NodeT,
            dst_node_id: NodeT,
            use_edge_weights_as_probabilities: Option<bool>,
            maximal_depth: Option<NodeT>,
        ) -> (f64, Vec<NodeT>) {
            let dijkstra = self.get_unchecked_dijkstra_from_node_ids(
                src_node_id,
                Some(dst_node_id),
                None,
                Some(true),
                maximal_depth,
                use_edge_weights_as_probabilities,
            );
            let predecessors = dijkstra.predecessors.unwrap();
            let path_length = dijkstra.dst_node_distance.unwrap();
            if let Some(uewp) = use_edge_weights_as_probabilities {
                if uewp && path_length.is_zero() {
                    return (0.0, Vec::new());
                }
            }
            if path_length.is_infinite() {
                return (f64::INFINITY, Vec::new());
            }
            let mut reverse_path = Vec::new();
            let mut parent = dst_node_id;
            loop {
                reverse_path.push(parent);
                if parent == src_node_id {
                    break;
                }
                if let Some(new_parent) = predecessors[parent as usize] {
                    parent = new_parent;
                }
            }
            (path_length, reverse_path.into_iter().rev().collect())
        }
        /// Returns minimum path node names from given node ids.
        ///
        /// # Arguments
        /// * `src_node_id`: NodeT - Source node ID.
        /// * `dst_node_id`: NodeT - Destination node ID.
        /// * `maximal_depth`: Option<NodeT> - The maximal depth to execute the BFS for.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        /// * `maximal_depth`: Option<NodeT> - The maximal number of iterations to execute Dijkstra for.
        ///
        /// # Safety
        /// If any of the given node IDs does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_weighted_minimum_path_node_names_from_node_ids(
            &self,
            src_node_id: NodeT,
            dst_node_id: NodeT,
            use_edge_weights_as_probabilities: Option<bool>,
            maximal_depth: Option<NodeT>,
        ) -> (f64, Vec<String>) {
            let (path_length, path) = self
                .get_unchecked_weighted_minimum_path_node_ids_from_node_ids(
                    src_node_id,
                    dst_node_id,
                    use_edge_weights_as_probabilities,
                    maximal_depth,
                );
            (
                path_length,
                path.into_iter()
                    .map(|node_id| self.get_unchecked_node_name_from_node_id(node_id))
                    .collect(),
            )
        }
        /// Returns minimum path node names from given node ids.
        ///
        /// # Arguments
        /// * `src_node_id`: NodeT - Source node ID.
        /// * `dst_node_id`: NodeT - Destination node ID.
        /// * `maximal_depth`: Option<NodeT> - The maximal depth to execute the BFS for.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        /// * `maximal_depth`: Option<NodeT> - The maximal number of iterations to execute Dijkstra for.
        ///
        /// # Raises
        /// * If any of the given node IDs do not exist in the current graph.
        pub fn get_weighted_minimum_path_node_ids_from_node_ids(
            &self,
            src_node_id: NodeT,
            dst_node_id: NodeT,
            use_edge_weights_as_probabilities: Option<bool>,
            maximal_depth: Option<NodeT>,
        ) -> Result<(f64, Vec<NodeT>)> {
            self.must_have_positive_edge_weights()?;
            if let Some(uewp) = use_edge_weights_as_probabilities {
                if uewp {
                    self.must_have_edge_weights_representing_probabilities()?;
                }
            }
            Ok(unsafe {
                self.get_unchecked_weighted_minimum_path_node_ids_from_node_ids(
                    self.validate_node_id(src_node_id)?,
                    self.validate_node_id(dst_node_id)?,
                    use_edge_weights_as_probabilities,
                    maximal_depth,
                )
            })
        }
        /// Returns minimum path node names from given node names.
        ///
        /// # Arguments
        /// * `src_node_name`: &str - Source node name.
        /// * `dst_node_name`: &str - Destination node name.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        /// * `maximal_depth`: Option<NodeT> - The maximal number of iterations to execute Dijkstra for.
        ///
        /// # Raises
        /// * If any of the given node names do not exist in the current graph.
        pub fn get_weighted_minimum_path_node_ids_from_node_names(
            &self,
            src_node_name: &str,
            dst_node_name: &str,
            use_edge_weights_as_probabilities: Option<bool>,
            maximal_depth: Option<NodeT>,
        ) -> Result<(f64, Vec<NodeT>)> {
            self.must_have_positive_edge_weights()?;
            if let Some(uewp) = use_edge_weights_as_probabilities {
                if uewp {
                    self.must_have_edge_weights_representing_probabilities()?;
                }
            }
            Ok(unsafe {
                self.get_unchecked_weighted_minimum_path_node_ids_from_node_ids(
                    self.get_node_id_from_node_name(src_node_name)?,
                    self.get_node_id_from_node_name(dst_node_name)?,
                    use_edge_weights_as_probabilities,
                    maximal_depth,
                )
            })
        }
        /// Returns minimum path node names from given node names.
        ///
        /// # Arguments
        /// * `src_node_name`: &str - Source node name.
        /// * `dst_node_name`: &str - Destination node name.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        /// * `maximal_depth`: Option<NodeT> - The maximal number of iterations to execute Dijkstra for.
        ///
        /// # Raises
        /// * If any of the given node names do not exist in the current graph.
        pub fn get_weighted_minimum_path_node_names_from_node_names(
            &self,
            src_node_name: &str,
            dst_node_name: &str,
            use_edge_weights_as_probabilities: Option<bool>,
            maximal_depth: Option<NodeT>,
        ) -> Result<(f64, Vec<String>)> {
            self.must_have_positive_edge_weights()?;
            if let Some(uewp) = use_edge_weights_as_probabilities {
                if uewp {
                    self.must_have_edge_weights_representing_probabilities()?;
                }
            }
            Ok(unsafe {
                self.get_unchecked_weighted_minimum_path_node_names_from_node_ids(
                    self.get_node_id_from_node_name(src_node_name)?,
                    self.get_node_id_from_node_name(dst_node_name)?,
                    use_edge_weights_as_probabilities,
                    maximal_depth,
                )
            })
        }
        /// Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.
        ///
        /// # Arguments
        /// * `src_node_id`: NodeT - Node ID root of the tree of minimum paths.
        /// * `compute_predecessors`: Option<bool> - Whether to compute the vector of predecessors.
        /// * `maximal_depth`: Option<NodeT> - The maximal number of iterations to execute the DFS for.
        ///
        /// # Raises
        /// * If the given source node ID does not exist in the current graph.
        /// * If the given optional destination node ID does not exist in the current graph.
        pub fn get_breath_first_search_from_node_ids(
            &self,
            src_node_id: NodeT,
            dst_node_id: Option<NodeT>,
            compute_predecessors: Option<bool>,
            maximal_depth: Option<NodeT>,
        ) -> Result<ShortestPathsResultBFS> {
            self.validate_node_id(src_node_id)?;
            unsafe {
                Ok(self.get_unchecked_breath_first_search_from_node_ids(
                    src_node_id,
                    dst_node_id,
                    compute_predecessors,
                    maximal_depth,
                ))
            }
        }
        /// Returns vector of minimum paths distances and vector of nodes predecessors from given source node ID and optional destination node ID.
        ///
        /// # Arguments
        /// * `src_node_id`: NodeT - Node ID root of the tree of minimum paths.
        /// * `maybe_dst_node_id`: Option<NodeT> - Optional target destination. If provided, Dijkstra will stop upon reaching this node.
        /// * `maybe_dst_node_ids`: Option<Vec<NodeT>> - Optional target destinations. If provided, Dijkstra will stop upon reaching all of these nodes.
        /// * `compute_predecessors`: Option<bool> - Whether to compute the vector of predecessors.
        /// * `maximal_depth`: Option<NodeT> - The maximal depth to execute the DFS for.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        ///
        /// # Raises
        /// * If the weights are to be used and the graph does not have weights.
        /// * If the given source node ID does not exist in the current graph.
        /// * If the given optional destination node ID does not exist in the current graph.
        /// * If weights are requested to be treated as probabilities but are not between 0 and 1.
        /// * If the graph contains negative weights.
        pub fn get_dijkstra_from_node_ids(
            &self,
            src_node_id: NodeT,
            maybe_dst_node_id: Option<NodeT>,
            maybe_dst_node_ids: Option<Vec<NodeT>>,
            compute_predecessors: Option<bool>,
            maximal_depth: Option<NodeT>,
            use_edge_weights_as_probabilities: Option<bool>,
        ) -> Result<ShortestPathsDjkstra> {
            self.validate_node_id(src_node_id)?;
            self.must_have_positive_edge_weights()?;
            if let Some(uewap) = use_edge_weights_as_probabilities {
                if uewap {
                    self.must_have_edge_weights_representing_probabilities()?;
                }
            };
            if let Some(dst) = &maybe_dst_node_id {
                self.validate_node_id(*dst)?;
            }
            let maybe_dst_node_ids = maybe_dst_node_ids
                .map_or(Ok::<_, String>(None), |node_ids| {
                    Ok(Some(self.validate_node_ids(node_ids)?))
                })?;
            Ok(unsafe {
                self.get_unchecked_dijkstra_from_node_ids(
                    src_node_id,
                    maybe_dst_node_id,
                    maybe_dst_node_ids,
                    compute_predecessors,
                    maximal_depth,
                    use_edge_weights_as_probabilities,
                )
            })
        }
        /// Returns approximated diameter and tentative low eccentricity node for an UNDIRECTED graph.
        /// This method returns a lowerbound of the diameter by doing the following steps:
        /// * Find the most central node
        /// * Find the most distant node from the most central one (and get a first
        ///    approximation of the diameter lowerbound)
        /// * Get the median node in this path
        /// * Find the most distant node from the median node
        /// * Find the most distant node form the last one, and get the second approx
        ///     of the diameter lowerbound.
        ///
        /// This basically creates a "cross" that spans the graph.
        fn get_four_sweep(&self) -> Result<(NodeT, NodeT)> {
            let most_central_node_id = unsafe { self.get_unchecked_most_central_node_id() };
            let first_candidate_most_eccentric_node_id = unsafe {
                self.get_unchecked_breath_first_search_from_node_ids(
                    most_central_node_id,
                    None,
                    None,
                    None,
                )
                .get_most_distant_node()
            };
            let bfs1 = unsafe {
                self.get_unchecked_breath_first_search_from_node_ids(
                    first_candidate_most_eccentric_node_id,
                    None,
                    Some(true),
                    None,
                )
            };
            let second_candidate_most_eccentric_node_id = unsafe {
                self.get_unchecked_breath_first_search_from_node_ids(
                    bfs1.get_median_point(bfs1.get_most_distant_node())?,
                    None,
                    Some(true),
                    None,
                )
                .get_most_distant_node()
            };
            let bfs2 = unsafe {
                self.get_unchecked_breath_first_search_from_node_ids(
                    second_candidate_most_eccentric_node_id,
                    None,
                    Some(true),
                    None,
                )
            };
            Ok((
                bfs1.get_eccentricity().max(bfs2.get_eccentricity()),
                bfs2.get_median_point(bfs2.get_most_distant_node())?,
            ))
        }
        /// Returns diameter of an UNDIRECTED graph.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # Referencences
        /// This method is based on the algorithm described in ["On computing the diameter of real-world undirected graphs" by Crescenzi et al](https://who.rocq.inria.fr/Laurent.Viennot/road/papers/ifub.pdf).
        fn get_ifub(&self, verbose: Option<bool>) -> Result<f64> {
            if self.is_directed() {
                {
                    :: std :: rt :: begin_panic ("This method is not defined YET for directed graphs! We will add it in the future!")
                }
            }
            let most_central_node_id = unsafe { self.get_unchecked_most_central_node_id() };
            if unsafe { self.is_unchecked_disconnected_from_node_id(most_central_node_id) } {
                return Ok(0.0);
            }
            let (tentative_diameter, low_eccentricity_node) = self.get_four_sweep()?;
            let bfs = unsafe {
                self.get_unchecked_breath_first_search_from_node_ids(
                    low_eccentricity_node,
                    None,
                    None,
                    None,
                )
            };
            if !(tentative_diameter != NodeT::MAX) {
                {
                    ::std::rt::begin_panic("The central node eccentricity cannot be infinite!")
                }
            };
            if !(tentative_diameter != 0) {
                {
                    ::std::rt::begin_panic("The central node eccentricity cannot be zero!")
                }
            };
            let mut node_ids_and_distances = bfs
                .into_par_iter_node_ids_and_finite_distances()
                .filter(|&(_, distance)| tentative_diameter < distance * 2)
                .collect::<Vec<(NodeT, NodeT)>>();
            node_ids_and_distances.sort_by(|(a, _), &(b, _)| b.cmp(a));
            let tentative_diameter = AtomicU32::new(tentative_diameter);
            let pb = get_loading_bar(
                verbose.unwrap_or(true) && node_ids_and_distances.len() > 1,
                "Computing diameter",
                node_ids_and_distances.len(),
            );
            node_ids_and_distances
                .into_par_iter()
                .progress_with(pb)
                .for_each(|(distance, node_id)| unsafe {
                    if tentative_diameter.load(Ordering::Relaxed) < distance * 2 {
                        tentative_diameter.fetch_max(
                            self.get_unchecked_eccentricity_from_node_id(node_id),
                            Ordering::Relaxed,
                        );
                    }
                });
            Ok(tentative_diameter.into_inner() as f64)
        }
        /// Returns diameter of the graph using naive method.
        ///
        /// Note that there exists the non-naive method for undirected graphs
        /// and it is possible to implement a faster method for directed graphs
        /// but we still need to get to it, as it will require an updated
        /// succinct data structure.
        ///
        /// # Arguments
        /// * `ignore_infinity`: Option<bool> - Whether to ignore infinite distances, which are present when in the graph exist multiple components.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # Raises
        /// * If the graph does not contain nodes.
        pub fn get_diameter_naive(
            &self,
            ignore_infinity: Option<bool>,
            verbose: Option<bool>,
        ) -> Result<f64> {
            self.must_have_nodes()?;
            let ignore_infinity = ignore_infinity.unwrap_or(false);
            let verbose = verbose.unwrap_or(true);
            if !self.has_edges() || !ignore_infinity && !self.is_connected(Some(verbose)) {
                return Ok(f64::INFINITY);
            }
            let pb = get_loading_bar(
                verbose,
                "Computing diameter",
                self.get_nodes_number() as usize,
            );
            Ok(self
                .par_iter_node_ids()
                .progress_with(pb)
                .map(|node_id| unsafe { self.get_unchecked_eccentricity_from_node_id(node_id) })
                .filter(|&distance| !ignore_infinity || distance != NOT_PRESENT)
                .max()
                .unwrap_or(0) as f64)
        }
        /// Returns diameter of the graph.
        ///
        /// # Arguments
        /// * `ignore_infinity`: Option<bool> - Whether to ignore infinite distances, which are present when in the graph exist multiple components.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # Raises
        /// * If the graph does not contain nodes.
        ///
        /// TODO! Add better implementation for directed graphs
        /// To make the better implementation for directed graphs we will first
        /// need to make the Elias-Fano encode the directed graph in a better way.
        pub fn get_diameter(
            &self,
            ignore_infinity: Option<bool>,
            verbose: Option<bool>,
        ) -> Result<f64> {
            self.must_have_nodes()?;
            let ignore_infinity = ignore_infinity.unwrap_or(false);
            let verbose = verbose.unwrap_or(true);
            if !self.has_edges() || !ignore_infinity && !self.is_connected(Some(verbose)) {
                return Ok(f64::INFINITY);
            }
            if self.is_directed() {
                self.get_diameter_naive(Some(true), Some(verbose))
            } else {
                self.get_ifub(Some(verbose))
            }
        }
        /// Returns diameter of the graph using naive method.
        ///
        /// Note that there exists the non-naive method for undirected graphs
        /// and it is possible to implement a faster method for directed graphs
        /// but we still need to get to it, as it will require an updated
        /// succinct data structure.
        ///
        /// # Arguments
        /// * `ignore_infinity`: Option<bool> - Whether to ignore infinite distances, which are present when in the graph exist multiple components.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # Raises
        /// * If the graph does not contain nodes.
        /// * If the graph does not have weights.
        /// * If the graph contains negative weights.
        /// * If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.
        ///
        /// TODO! Add better implementation for directed graphs
        /// To make the better implementation for directed graphs we will first
        /// need to make the Elias-Fano encode the directed graph in a better way.
        pub fn get_weighted_diameter_naive(
            &self,
            ignore_infinity: Option<bool>,
            use_edge_weights_as_probabilities: Option<bool>,
            verbose: Option<bool>,
        ) -> Result<f64> {
            self.must_have_nodes()?;
            self.must_have_positive_edge_weights()?;
            let use_edge_weights_as_probabilities =
                use_edge_weights_as_probabilities.unwrap_or(false);
            if use_edge_weights_as_probabilities {
                self.must_have_edge_weights_representing_probabilities()?;
            }
            let ignore_infinity = ignore_infinity.unwrap_or(true);
            let verbose = verbose.unwrap_or(true);
            if !self.has_edges() || !ignore_infinity && !self.is_connected(Some(verbose)) {
                return Ok(if use_edge_weights_as_probabilities {
                    0.0
                } else {
                    f64::INFINITY
                });
            }
            let pb = get_loading_bar(
                verbose,
                "Computing weighted diameter",
                self.get_nodes_number() as usize,
            );
            Ok(self
                .par_iter_node_ids()
                .progress_with(pb)
                .map(|node_id| unsafe {
                    self.get_unchecked_weighted_eccentricity_from_node_id(
                        node_id,
                        Some(use_edge_weights_as_probabilities),
                    )
                })
                .filter(|&distance| {
                    !ignore_infinity
                        || if use_edge_weights_as_probabilities {
                            !distance.is_zero()
                        } else {
                            distance.is_finite()
                        }
                })
                .reduce(|| f64::NEG_INFINITY, f64::max))
        }
        /// Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.
        ///
        /// # Arguments
        /// * `src_node_name`: &str - Node name root of the tree of minimum paths.
        /// * `dst_node_name`: Option<&str> - Destination node name.
        /// * `compute_predecessors`: Option<bool> - Whether to compute the vector of predecessors.
        /// * `maximal_depth`: Option<NodeT> - The maximal depth to execute the DFS for.
        ///
        /// # Raises
        /// * If the weights are to be used and the graph does not have weights.
        /// * If the given source node name does not exist in the current graph.
        /// * If the given optional destination node name does not exist in the current graph.
        pub fn get_breath_first_search_from_node_names(
            &self,
            src_node_name: &str,
            dst_node_name: Option<&str>,
            compute_predecessors: Option<bool>,
            maximal_depth: Option<NodeT>,
        ) -> Result<ShortestPathsResultBFS> {
            unsafe {
                Ok(self.get_unchecked_breath_first_search_from_node_ids(
                    self.get_node_id_from_node_name(src_node_name)?,
                    dst_node_name.map_or(Ok::<_, String>(None), |dst_node_name| {
                        Ok(Some(self.get_node_id_from_node_name(dst_node_name)?))
                    })?,
                    compute_predecessors,
                    maximal_depth,
                ))
            }
        }
        /// Returns vector of minimum paths distances and vector of nodes predecessors from given source node name and optional destination node name.
        ///
        /// # Arguments
        /// * `src_node_name`: &str - Node name root of the tree of minimum paths.
        /// * `maybe_dst_node_name`: Option<&str> - Optional target destination node name. If provided, Dijkstra will stop upon reaching this node.
        /// * `maybe_dst_node_names`: Option<Vec<&str>> - Optional target destination node names. If provided, Dijkstra will stop upon reaching all of these nodes.
        /// * `compute_predecessors`: Option<bool> - Whether to compute the vector of predecessors.
        /// * `maximal_depth`: Option<NodeT> - The maximal depth to execute the DFS for.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        ///
        /// # Raises
        /// * If the weights are to be used and the graph does not have weights.
        /// * If the given source node name does not exist in the current graph.
        /// * If the given optional destination node name does not exist in the current graph.
        pub fn get_dijkstra_from_node_names(
            &self,
            src_node_name: &str,
            maybe_dst_node_name: Option<&str>,
            maybe_dst_node_names: Option<Vec<&str>>,
            compute_predecessors: Option<bool>,
            maximal_depth: Option<NodeT>,
            use_edge_weights_as_probabilities: Option<bool>,
        ) -> Result<ShortestPathsDjkstra> {
            self.get_dijkstra_from_node_ids(
                self.get_node_id_from_node_name(src_node_name)?,
                maybe_dst_node_name.map_or(Ok::<_, String>(None), |dst_node_name| {
                    Ok(Some(self.get_node_id_from_node_name(dst_node_name)?))
                })?,
                maybe_dst_node_names.map_or(Ok::<_, String>(None), |dst_node_names| {
                    Ok(Some(
                        dst_node_names
                            .into_iter()
                            .map(|node_name| self.get_node_id_from_node_name(node_name))
                            .collect::<Result<_>>()?,
                    ))
                })?,
                compute_predecessors,
                maximal_depth,
                use_edge_weights_as_probabilities,
            )
        }
    }
}
pub use self::dijkstra::*;
mod constructors {
    use super::*;
    mod parse_nodes {
        use std::sync::atomic::AtomicU32;
        use rayon::iter::ParallelIterator;
        use super::*;
        fn parse_nodes(
            nodes_iterator: Option<
                impl ParallelIterator<Item = Result<(String, Option<Vec<String>>)>>,
            >,
            nodes_number: Option<NodeT>,
            node_types_vocabulary: Option<Vocabulary<NodeTypeT>>,
            node_list_is_correct: bool,
            numeric_node_ids: bool,
            numeric_node_list_node_type_ids: bool,
            minimum_node_ids: Option<NodeT>,
        ) -> Result<(Vocabulary<NodeT>, Option<NodeTypeVocabulary>)> {
            if !numeric_node_ids && minimum_node_ids.is_some() {
                return Err(
                    "Giving the minimum id is not meaningfull when numeric_ids is false."
                        .to_string(),
                );
            }
            if nodes_iterator.is_none() && node_types_vocabulary.is_some() {
                return Err(
                    "Node types vocabulary was provided but no nodes iterator was given."
                        .to_string(),
                );
            }
            let has_node_types = node_types_vocabulary.is_some();
            if !has_node_types && numeric_node_list_node_type_ids {
                return Err ("The numeric node list node type IDs parameter does not make sense in the context where the node types have not been provided.\nIf the node types within the nodes list are numeric, simply use the numeric node types ids parameter.") ;
            }
            let node_types_method = match (
                has_node_types,
                node_types_vocabulary
                    .as_ref()
                    .map_or(true, |x| x.is_empty()),
                node_list_is_correct,
                numeric_node_list_node_type_ids,
            ) {
                (false, _, _, false) => NodeTypeParser::ignore,
                (true, true, true, false) => NodeTypeParser::parse_strings_unchecked,
                (true, true, false, false) => NodeTypeParser::parse_strings,
                (true, false, true, false) => NodeTypeParser::translate_unchecked,
                (true, false, false, false) => NodeTypeParser::translate,
                (_, _, true, true) => NodeTypeParser::to_numeric_unchecked,
                (_, _, false, true) => NodeTypeParser::to_numeric,
            };
            let mut node_types_vocabulary = node_types_vocabulary.unwrap_or(Vocabulary::new());
            let nodes_iterator = nodes_iterator
                .map(|ni| ni.method_caller(node_types_method, &mut node_types_vocabulary));
            let (nodes_vocabulary, node_types_ids) = match (
                nodes_iterator,
                nodes_number,
                numeric_node_ids,
                minimum_node_ids,
            ) {
                (Some(ni), _, false, None) => {
                    let (nodes_names, node_types_ids): (
                        Vec<String>,
                        Option<Vec<Option<Vec<NodeTypeT>>>>,
                    ) = if has_node_types {
                        let (nodes_names, node_types_ids) = ni.unzip()?;
                        (nodes_names, Some(node_types_ids))
                    } else {
                        (
                            ni.map(|x| x.map_ok(|(name, _)| name)).collect(),
                            node_types_vocabulary,
                        )
                    };
                    (Vocabulary::from_reverse_map(nodes_names), node_types_ids)
                }
                (Some(ni), None, true, _) => {
                    let (min, max, node_types_ids) = if has_node_types {
                        let min = AtomicU32::new(NodeT::MAX);
                        let max = AtomicU32::new(0);
                        let node_type_ids = ni
                            .map(|(node_name, node_type_ids)| {
                                let node_id = node_name.parse::<NodeT>().map_err(|_| {
                                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                        &["The node name \'", "\' cannot be parsed as an integer"],
                                        &match (&node_name,) {
                                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                                arg0,
                                                ::core::fmt::Display::fmt,
                                            )],
                                        },
                                    ));
                                    res
                                })?;
                                min.fetch_min(node_id);
                                max.fetch_max(node_id);
                                Ok(node_type_ids)
                            })
                            .collect::<Result<Vec<Option<Vec<NodeTypeT>>>>>()?;
                        (min.into_inner(), max.into_inner(), Some(node_type_ids))
                    } else {
                        let (min, max) = ni
                            .map(|x| {
                                x.parse::<NodeT>().map_err(|_| {
                                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                        &["The string \'", "\' cannot be parsed as an integer"],
                                        &match (&x,) {
                                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                                arg0,
                                                ::core::fmt::Display::fmt,
                                            )],
                                        },
                                    ));
                                    res
                                })
                            })
                            .map(|x| (x, x))
                            .reduce(|v1, v2| match (v1, v2) {
                                (Ok(min1, max1), Ok(min2, max2)) => {
                                    Ok((min1.min(min2), max1.max(max2)))
                                }
                                (Err(e), _) | (_, Err(e)) => Err(e),
                            })?;
                        (min, max, None)
                    };
                    let minimum_node_ids = minimum_node_ids.unwrap_or(min);
                    if min < minimum_node_ids {
                        return Err ("The given minimum id is bigger than the minimum id found in the iterator") ;
                    }
                    Ok(
                        Vocabulary::from_range(min.min(minimum_node_ids)..max),
                        node_types_ids,
                    )
                }
                (None, Some(ntn), true, None) => Ok(Vocabulary::from_range(0..ntn)),
                (None, Some(ntn), true, Some(min_val)) => {
                    Ok(Vocabulary::from_range(min_val..min_val + ntn))
                }
                (None, Some(ntn), true, _) => {
                    let min = minimum_node_ids.unwrap_or(0);
                    Ok(Vocabulary::from_range(min..min))
                }
                (None, Some(ntn), false, None) => Ok(Vocabulary::with_capacity(ntn)),
                (None, None, false, None) => Ok(Vocabulary::new()),
                _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                    &["internal error: entered unreachable code: "],
                    &match (&"All other cases must be explictily handled.",) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                )),
            };
            (
                nodes_vocabulary,
                node_types_ids
                    .map(|ntis| NodeTypeVocabulary::from_structs(ntis, node_types_vocabulary)),
            )
        }
    }
    pub use parse_nodes::*;
    mod parse_types {
        use super::*;
        use rayon::iter::ParallelIterator;
        use std::str::FromStr;
        pub(crate) fn parse_types<TypeT: FromStr + ToFromUsize>(
            types_iterator: Option<impl ParallelIterator<Item = Result<String>>>,
            types_number: Option<TypeT>,
            numeric_ids: bool,
            minimum_id: Option<TypeT>,
            has_node_types: bool,
        ) -> Result<Option<Vocabulary<TypeT>>> {
            if !has_node_types {
                return Ok(None);
            }
            if !numeric_ids && minimum_id.is_some() {
                return Err("Giving the minimum id is not meaningfull when numeric_ids is false.");
            }
            match (types_iterator, types_number, numeric_ids, minimum_id) {
                (Some(nti), _, false, None) => Vocabulary::from_reverse_map(nti.collect()),
                (Some(nti), None, true, _) => {
                    let (min, max) = nti
                        .map(|x| {
                            x.parse::<TypeT>().map_err(|_| {
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &["The string \'", "\' cannot be parsed as an integer"],
                                    &match (&x,) {
                                        (arg0,) => [::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        )],
                                    },
                                ));
                                res
                            })
                        })
                        .map(|x| (x, x))
                        .reduce(|v1, v2| match (v1, v2) {
                            (Ok(min1, max1), Ok(min2, max2)) => {
                                Ok((min1.min(min2), max1.max(max2)))
                            }
                            (Err(e), _) | (_, Err(e)) => Err(e),
                        })?;
                    let minimum_id = minimum_id.unwrap_or(min);
                    if min < minimum_id {
                        return Err ("The given minimum id is bigger than the minimum id found in the iterator") ;
                    }
                    Ok(Vocabulary::from_range(min.min(minimum_id)..max))
                }
                (None, Some(ntn), true, None) => Ok(Vocabulary::from_range(0..ntn)),
                (None, Some(ntn), true, Some(min_val)) => {
                    Ok(Vocabulary::from_range(min_val..min_val + ntn))
                }
                (None, Some(ntn), true, _) => {
                    let min = minimum_id.unwrap_or(0);
                    Ok(Vocabulary::from_range(min..min))
                }
                (None, Some(ntn), false, None) => Ok(Vocabulary::with_capacity(ntn)),
                (None, None, false, None) => Ok(Vocabulary::new()),
                _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                    &["internal error: entered unreachable code: "],
                    &match (&"All other cases must be explictily handled.",) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                )),
            }
        }
    }
    pub use parse_types::*;
    mod parse_edges {
        use super::*;
        use elias_fano_rust::{ConcurrentEliasFanoBuilder, EliasFano};
        use rayon::prelude::*;
        use std::cmp::Ordering;
        fn parse_unsorted_edges(
            edges_iterators: Option<
                Vec<
                    impl ParallelIterator<Item = Result<(String, String, Option<String>, WeightT)>>,
                >,
            >,
            nodes: Vocabulary<NodeT>,
            edge_types_vocabulary: Option<Vocabulary<EdgeTypeT>>,
            has_edge_types: bool,
            has_edge_weights: bool,
            directed: bool,
            correct: Option<bool>,
            complete: Option<bool>,
            duplicates: Option<bool>,
            expected_edges_number: Option<usize>,
            numeric_edge_list_node_ids: Option<bool>,
            numeric_edge_list_edge_type_ids: Option<bool>,
        ) -> Result<(
            Vocabulary<NodeT>,
            EliasFano,
            Option<EdgeTypeVocabulary>,
            Option<Vec<WeightT>>,
        )> {
            let correct = correct.unwrap_or(false);
            let complete = complete.unwrap_or(false);
            let duplicates = duplicates.unwrap_or(true);
            let numeric_edge_list_node_ids = numeric_edge_list_node_ids.unwrap_or(false);
            let numeric_edge_list_edge_type_ids = numeric_edge_list_edge_type_ids.unwrap_or(false);
            if edges_iterators.as_ref().map_or(true, |ei| ei.is_empty())
                && edge_types_vocabulary.is_some()
            {
                return Err(
                    "Edge types vocabulary was provided but no edge list was given.".to_string(),
                );
            }
            let has_edge_types = edge_types_vocabulary.is_some();
            if !has_edge_types && numeric_edge_list_edge_type_ids {
                return Err ("The numeric node list node type IDs parameter does not make sense in the context where the node types have not been provided.\nIf the node types within the nodes list are numeric, simply use the numeric node types ids parameter." . to_string ()) ;
            }
            let edge_types_method = match (
                has_edge_types,
                edge_types_vocabulary
                    .as_ref()
                    .map_or(true, |x| x.is_empty()),
                correct,
                numeric_edge_list_edge_type_ids,
            ) {
                (false, _, _, false) => EdgeTypeParser::ignore,
                (true, true, true, false) => EdgeTypeParser::parse_strings_unchecked,
                (true, true, false, false) => EdgeTypeParser::parse_strings,
                (true, false, true, false) => EdgeTypeParser::get_unchecked,
                (true, false, false, false) => EdgeTypeParser::get,
                (_, _, true, true) => EdgeTypeParser::to_numeric_unchecked,
                (_, _, false, true) => EdgeTypeParser::to_numeric,
            };
            let node_method = match (nodes.is_empty(), correct, numeric_edge_list_node_ids) {
                (true, true, false) => EdgeNodeNamesParser::parse_strings_unchecked,
                (true, false, false) => EdgeNodeNamesParser::parse_strings,
                (false, true, false) => EdgeNodeNamesParser::get_unchecked,
                (false, false, false) => EdgeNodeNamesParser::get,
                (_, true, true) => EdgeNodeNamesParser::to_numeric_unchecked,
                (_, false, true) => EdgeNodeNamesParser::to_numeric,
            };
            let mut edge_types_vocabulary = edge_types_vocabulary.unwrap_or(Vocabulary::new());
            let (edges, edge_type_ids, weights) =
                match (edges_iterators, has_edge_types, has_edge_weights) {
                    (None, _, _) => {}
                    (Some(eis), true, true) => {
                        let (edges, edge_type_ids, weights) = {
                            let mut edge_type_parser = EdgeTypeParser::new(edge_types_vocabulary);
                            let mut node_parser = EdgeNodeNamesParser::new(nodes);
                            let mut unsorted_edge_list = eis
                                .into_iter()
                                .flat_map(|ei| {
                                    let ei =
                                        ei.method_caller(edge_types_method, &mut edge_type_parser);
                                    let ei = ei.method_caller(node_method, &mut node_parser);
                                    if directed || complete {
                                        ei.map(|line| match line {
                                            Ok((src, dst, edge_type, weight)) => unsafe {
                                                Ok((src, dst, edge_type, weight))
                                            },
                                            Err(e) => Err(e),
                                        })
                                        .collect::<Vec<Result<_>>>()
                                    } else {
                                        ei.flat_map(|line| match line {
                                            Ok((src, dst, edge_type, weight)) => unsafe {
                                                if src == dst {
                                                    <[_]>::into_vec(box [Ok((
                                                        src, dst, edge_type, weight,
                                                    ))])
                                                } else {
                                                    <[_]>::into_vec(box [
                                                        Ok((src, dst, edge_type, weight)),
                                                        Ok((dst, src, edge_type, weight)),
                                                    ])
                                                }
                                            },
                                            Err(e) => <[_]>::into_vec(box [Err(e)]),
                                        })
                                        .collect::<Vec<Result<_>>>()
                                    }
                                })
                                .collect::<Result<Vec<_>>>()?;
                            unsorted_edge_list.par_sort_unstable_by(|v1, v2| {
                                v1.partial_cmp(&v2).unwrap_or(Ordering::Greater)
                            });
                            if duplicates {
                                unsorted_edge_list.dedup_by(|v1, v2| {
                                    v1.partial_cmp(&v2).unwrap_or(Ordering::Greater)
                                        == Ordering::Equal
                                });
                            }
                            let edges_number = unsorted_edge_list.len();
                            let nodes_number = nodes.len();
                            let mut edge_types = ::alloc::vec::from_elem(None, edges_number);
                            let mut weights = ::alloc::vec::from_elem(f64::NAN, edges_number);
                            let node_bits = get_node_bits(nodes_number as NodeT);
                            let maximum_edges_number =
                                encode_max_edge(nodes_number as NodeT, node_bits);
                            let elias_fano_builder = ConcurrentEliasFanoBuilder::new(
                                edges_number as u64,
                                maximum_edges_number,
                            )?;
                            unsorted_edge_list.into_par_iter().enumerate().for_each(
                                |(i, (src, dst, edge_type, weight))| {
                                    elias_fano_builder
                                        .set(i as u64, encode_edge(src, dst, node_bits));
                                    edge_types[i as usize] = edge_type;
                                    weights[i as usize] = weight;
                                },
                            );
                            let edges = elias_fano_builder.build();
                            (edges, edge_types, weights)
                        };
                        (edges, Some(edge_type_ids), Some(weights))
                    }
                    (Some(eis), true, false) => {
                        let (edges, edge_type_ids) = {
                            let mut edge_type_parser = EdgeTypeParser::new(edge_types_vocabulary);
                            let mut node_parser = EdgeNodeNamesParser::new(nodes);
                            let mut unsorted_edge_list = eis
                                .into_iter()
                                .flat_map(|ei| {
                                    let ei =
                                        ei.method_caller(edge_types_method, &mut edge_type_parser);
                                    let ei = ei.method_caller(node_method, &mut node_parser);
                                    if directed || complete {
                                        ei.map(|line| match line {
                                            Ok((src, dst, edge_type, weight)) => unsafe {
                                                Ok((src, dst, edge_type))
                                            },
                                            Err(e) => Err(e),
                                        })
                                        .collect::<Vec<Result<_>>>()
                                    } else {
                                        ei.flat_map(|line| match line {
                                            Ok((src, dst, edge_type, weight)) => unsafe {
                                                if src == dst {
                                                    <[_]>::into_vec(box [Ok((src, dst, edge_type))])
                                                } else {
                                                    <[_]>::into_vec(box [
                                                        Ok((src, dst, edge_type)),
                                                        Ok((dst, src, edge_type)),
                                                    ])
                                                }
                                            },
                                            Err(e) => <[_]>::into_vec(box [Err(e)]),
                                        })
                                        .collect::<Vec<Result<_>>>()
                                    }
                                })
                                .collect::<Result<Vec<_>>>()?;
                            unsorted_edge_list.par_sort_unstable_by(|v1, v2| {
                                v1.partial_cmp(&v2).unwrap_or(Ordering::Greater)
                            });
                            if duplicates {
                                unsorted_edge_list.dedup_by(|v1, v2| {
                                    v1.partial_cmp(&v2).unwrap_or(Ordering::Greater)
                                        == Ordering::Equal
                                });
                            }
                            let edges_number = unsorted_edge_list.len();
                            let nodes_number = nodes.len();
                            let mut edge_types = ::alloc::vec::from_elem(None, edges_number);
                            let node_bits = get_node_bits(nodes_number as NodeT);
                            let maximum_edges_number =
                                encode_max_edge(nodes_number as NodeT, node_bits);
                            let elias_fano_builder = ConcurrentEliasFanoBuilder::new(
                                edges_number as u64,
                                maximum_edges_number,
                            )?;
                            unsorted_edge_list.into_par_iter().enumerate().for_each(
                                |(i, (src, dst, edge_type))| {
                                    elias_fano_builder
                                        .set(i as u64, encode_edge(src, dst, node_bits));
                                    edge_types[i as usize] = edge_type;
                                },
                            );
                            let edges = elias_fano_builder.build();
                            (edges, edge_types)
                        };
                        (edges, Some(edge_type_ids), None)
                    }
                    (Some(eis), false, true) => {
                        let (edges, weights) = {
                            let mut edge_type_parser = EdgeTypeParser::new(edge_types_vocabulary);
                            let mut node_parser = EdgeNodeNamesParser::new(nodes);
                            let mut unsorted_edge_list = eis
                                .into_iter()
                                .flat_map(|ei| {
                                    let ei =
                                        ei.method_caller(edge_types_method, &mut edge_type_parser);
                                    let ei = ei.method_caller(node_method, &mut node_parser);
                                    if directed || complete {
                                        ei.map(|line| match line {
                                            Ok((src, dst, edge_type, weight)) => unsafe {
                                                Ok((src, dst, weight))
                                            },
                                            Err(e) => Err(e),
                                        })
                                        .collect::<Vec<Result<_>>>()
                                    } else {
                                        ei.flat_map(|line| match line {
                                            Ok((src, dst, edge_type, weight)) => unsafe {
                                                if src == dst {
                                                    <[_]>::into_vec(box [Ok((src, dst, weight))])
                                                } else {
                                                    <[_]>::into_vec(box [
                                                        Ok((src, dst, weight)),
                                                        Ok((dst, src, weight)),
                                                    ])
                                                }
                                            },
                                            Err(e) => <[_]>::into_vec(box [Err(e)]),
                                        })
                                        .collect::<Vec<Result<_>>>()
                                    }
                                })
                                .collect::<Result<Vec<_>>>()?;
                            unsorted_edge_list.par_sort_unstable_by(|v1, v2| {
                                v1.partial_cmp(&v2).unwrap_or(Ordering::Greater)
                            });
                            if duplicates {
                                unsorted_edge_list.dedup_by(|v1, v2| {
                                    v1.partial_cmp(&v2).unwrap_or(Ordering::Greater)
                                        == Ordering::Equal
                                });
                            }
                            let edges_number = unsorted_edge_list.len();
                            let nodes_number = nodes.len();
                            let mut weights = ::alloc::vec::from_elem(f64::NAN, edges_number);
                            let node_bits = get_node_bits(nodes_number as NodeT);
                            let maximum_edges_number =
                                encode_max_edge(nodes_number as NodeT, node_bits);
                            let elias_fano_builder = ConcurrentEliasFanoBuilder::new(
                                edges_number as u64,
                                maximum_edges_number,
                            )?;
                            unsorted_edge_list.into_par_iter().enumerate().for_each(
                                |(i, (src, dst, weight))| {
                                    elias_fano_builder
                                        .set(i as u64, encode_edge(src, dst, node_bits));
                                    weights[i as usize] = weight;
                                },
                            );
                            let edges = elias_fano_builder.build();
                            (edges, weights)
                        };
                        (edges, None, Some(weights))
                    }
                    (Some(eis), false, false) => {
                        let (edges,) = {
                            let mut edge_type_parser = EdgeTypeParser::new(edge_types_vocabulary);
                            let mut node_parser = EdgeNodeNamesParser::new(nodes);
                            let mut unsorted_edge_list = eis
                                .into_iter()
                                .flat_map(|ei| {
                                    let ei =
                                        ei.method_caller(edge_types_method, &mut edge_type_parser);
                                    let ei = ei.method_caller(node_method, &mut node_parser);
                                    if directed || complete {
                                        ei.map(|line| match line {
                                            Ok((src, dst, edge_type, weight)) => unsafe {
                                                Ok((src, dst))
                                            },
                                            Err(e) => Err(e),
                                        })
                                        .collect::<Vec<Result<_>>>()
                                    } else {
                                        ei.flat_map(|line| match line {
                                            Ok((src, dst, edge_type, weight)) => unsafe {
                                                if src == dst {
                                                    <[_]>::into_vec(box [Ok((src, dst))])
                                                } else {
                                                    <[_]>::into_vec(box [
                                                        Ok((src, dst)),
                                                        Ok((dst, src)),
                                                    ])
                                                }
                                            },
                                            Err(e) => <[_]>::into_vec(box [Err(e)]),
                                        })
                                        .collect::<Vec<Result<_>>>()
                                    }
                                })
                                .collect::<Result<Vec<_>>>()?;
                            unsorted_edge_list.par_sort_unstable_by(|v1, v2| {
                                v1.partial_cmp(&v2).unwrap_or(Ordering::Greater)
                            });
                            if duplicates {
                                unsorted_edge_list.dedup_by(|v1, v2| {
                                    v1.partial_cmp(&v2).unwrap_or(Ordering::Greater)
                                        == Ordering::Equal
                                });
                            }
                            let edges_number = unsorted_edge_list.len();
                            let nodes_number = nodes.len();
                            let node_bits = get_node_bits(nodes_number as NodeT);
                            let maximum_edges_number =
                                encode_max_edge(nodes_number as NodeT, node_bits);
                            let elias_fano_builder = ConcurrentEliasFanoBuilder::new(
                                edges_number as u64,
                                maximum_edges_number,
                            )?;
                            unsorted_edge_list.into_par_iter().enumerate().for_each(
                                |(i, (src, dst))| {
                                    elias_fano_builder
                                        .set(i as u64, encode_edge(src, dst, node_bits));
                                },
                            );
                            let edges = elias_fano_builder.build();
                            (edges,)
                        };
                        (edges, None, None)
                    }
                };
            Ok((
                nodes,
                edges,
                EdgeTypeVocabulary::from_option_structs(edge_type_ids, Some(edge_types_vocabulary)),
                weights,
            ))
        }
    }
    pub use parse_edges::*;
    mod edge_node_names_parser {
        use super::*;
        use std::sync::{RwLock, RwLockReadGuard, RwLockWriteGuard};
        pub(crate) struct EdgeNodeNamesParser {
            context: Vocabulary<NodeT>,
            lock: RwLock<()>,
        }
        impl EdgeNodeNamesParser {
            pub fn new(context: Vocabulary<NodeT>) -> EdgeNodeNamesParser {
                EdgeNodeNamesParser {
                    context: context,
                    lock: RwLock::new(()),
                }
            }
            #[inline]
            fn get_immutable(&self) -> &Vocabulary<NodeT> {
                &self.context
            }
            #[inline]
            fn get_mutable_read(&mut self) -> (&mut Vocabulary<NodeT>, RwLockReadGuard<'_, ()>) {
                (&mut self.context, self.lock.read().unwrap())
            }
            #[inline]
            fn get_mutable_write(&mut self) -> (&mut Vocabulary<NodeT>, RwLockWriteGuard<'_, ()>) {
                (&mut self.context, self.lock.write().unwrap())
            }
        }
        impl EdgeNodeNamesParser {
            pub fn parse_strings<E, W>(
                &mut self,
                value: Result<(String, String, E, W)>,
            ) -> Result<(NodeT, NodeT, E, W)> {
                let (src_name, dst_name, edge_type_name, weight) = value?;
                let vocabulary = self.get_mutable_write();
                Ok((
                    vocabulary.0.insert(src_name)?.0,
                    vocabulary.0.insert(dst_name)?.0,
                    edge_type_name,
                    weight,
                ))
            }
            pub fn parse_strings_unchecked<E, W>(
                &mut self,
                value: Result<(String, String, E, W)>,
            ) -> Result<(NodeT, NodeT, E, W)> {
                let (src_name, dst_name, edge_type_name, weight) = value?;
                let vocabulary = self.get_mutable_write();
                unsafe {
                    Ok((
                        vocabulary.0.unchecked_insert(src_name),
                        vocabulary.0.unchecked_insert(dst_name),
                        edge_type_name,
                        weight,
                    ))
                }
            }
            pub fn get<E, W>(
                &mut self,
                value: Result<(String, String, E, W)>,
            ) -> Result<(NodeT, NodeT, E, W)> {
                let (src_name, dst_name, edge_type_name, weight) = value?;
                let vocabulary = self.get_immutable();
                Ok((
                    match vocabulary.get(&src_name) {
                        Some(src) => Ok(src),
                        None => Err({
                            let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Found an unknown source node name while reading the edge list.\nSpecifically the unknown source node name is " , ".\nThe edge in question is composed of (" , ", " , ")."] , & match (& src_name , & src_name , & dst_name) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , })) ;
                            res
                        }),
                    }?,
                    match vocabulary.get(&dst_name) {
                        Some(dst) => Ok(dst),
                        None => Err({
                            let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Found an unknown destination node name while reading the edge list.\nSpecifically the unknown destination node name is " , ".\nThe edge in question is composed of (" , ", " , ")."] , & match (& dst_name , & src_name , & dst_name) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , })) ;
                            res
                        }),
                    }?,
                    edge_type_name,
                    weight,
                ))
            }
            pub fn get_unchecked<E, W>(
                &mut self,
                value: Result<(String, String, E, W)>,
            ) -> Result<(NodeT, NodeT, E, W)> {
                let (src_name, dst_name, edge_type_name, weight) = value?;
                let vocabulary = self.get_immutable();
                unsafe {
                    Ok((
                        unsafe { vocabulary.get(&src_name).unwrap_unchecked() },
                        unsafe { vocabulary.get(&dst_name).unwrap_unchecked() },
                        edge_type_name,
                        weight,
                    ))
                }
            }
            pub fn to_numeric<E, W>(
                &mut self,
                value: Result<(String, String, E, W)>,
            ) -> Result<(NodeT, NodeT, E, W)> {
                let (src_name, dst_name, edge_type_name, weight) = value?;
                let vocabulary = self.get_immutable();
                let src_node_id = match src_name.parse::<NodeT>() {
                    Ok(src) => Ok(src),
                    Err(_) => Err({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[
                                "The given source node name ",
                                " cannot be parsed to an integer value.",
                            ],
                            &match (&src_name,) {
                                (arg0,) => {
                                    [::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt)]
                                }
                            },
                        ));
                        res
                    }),
                }?;
                let dst_node_id = match dst_name.parse::<NodeT>() {
                    Ok(dst) => Ok(dst),
                    Err(_) => Err({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[
                                "The given destination node name ",
                                " cannot be parsed to an integer value.",
                            ],
                            &match (&dst_name,) {
                                (arg0,) => {
                                    [::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt)]
                                }
                            },
                        ));
                        res
                    }),
                }?;
                if vocabulary.len() as NodeT <= src_node_id {
                    return Err({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[
                                "The given source node name ",
                                " has a value greater than the number of provided nodes ",
                                ".",
                            ],
                            &match (&src_node_id, &vocabulary.len()) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ],
                            },
                        ));
                        res
                    });
                }
                if vocabulary.len() as NodeT <= dst_node_id {
                    return Err({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[
                                "The given destination node name ",
                                " has a value greater than the number of provided nodes ",
                                ".",
                            ],
                            &match (&dst_node_id, &vocabulary.len()) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ],
                            },
                        ));
                        res
                    });
                }
                Ok((src_node_id, dst_node_id, edge_type_name, weight))
            }
            pub fn to_numeric_unchecked<E, W>(
                &mut self,
                value: Result<(String, String, E, W)>,
            ) -> Result<(NodeT, NodeT, E, W)> {
                let (src_name, dst_name, edge_type_name, weight) = value?;
                let vocabulary = self.get_immutable();
                unsafe {
                    Ok((
                        src_name.parse::<NodeT>().unwrap_unchecked(),
                        dst_name.parse::<NodeT>().unwrap_unchecked(),
                        edge_type_name,
                        weight,
                    ))
                }
            }
        }
    }
    pub use edge_node_names_parser::*;
    mod edge_type_parser {
        use super::*;
        use std::sync::{RwLock, RwLockReadGuard, RwLockWriteGuard};
        pub(crate) struct EdgeTypeParser {
            context: Vocabulary<EdgeTypeT>,
            lock: RwLock<()>,
        }
        impl EdgeTypeParser {
            pub fn new(context: Vocabulary<EdgeTypeT>) -> EdgeTypeParser {
                EdgeTypeParser {
                    context: context,
                    lock: RwLock::new(()),
                }
            }
            #[inline]
            fn get_immutable(&self) -> &Vocabulary<EdgeTypeT> {
                &self.context
            }
            #[inline]
            fn get_mutable_read(
                &mut self,
            ) -> (&mut Vocabulary<EdgeTypeT>, RwLockReadGuard<'_, ()>) {
                (&mut self.context, self.lock.read().unwrap())
            }
            #[inline]
            fn get_mutable_write(
                &mut self,
            ) -> (&mut Vocabulary<EdgeTypeT>, RwLockWriteGuard<'_, ()>) {
                (&mut self.context, self.lock.write().unwrap())
            }
        }
        impl EdgeTypeParser {
            pub fn ignore<T, W>(
                &mut self,
                value: Result<(T, T, Option<String>, W)>,
            ) -> Result<(T, T, Option<EdgeTypeT>, W)> {
                let (src, dst, edge_type_name, weight) = value?;
                Ok((src, dst, None, weight))
            }
            pub fn parse_strings<T, W>(
                &mut self,
                value: Result<(T, T, Option<String>, W)>,
            ) -> Result<(T, T, Option<EdgeTypeT>, W)> {
                let (src, dst, edge_type_name, weight) = value?;
                let vocabulary = self.get_mutable_write();
                Ok((
                    src,
                    dst,
                    Some(
                        vocabulary
                            .0
                            .insert(unsafe { edge_type_name.unwrap_unchecked() })?
                            .0,
                    ),
                    weight,
                ))
            }
            pub fn parse_strings_unchecked<T, W>(
                &mut self,
                value: Result<(T, T, Option<String>, W)>,
            ) -> Result<(T, T, Option<EdgeTypeT>, W)> {
                let (src, dst, edge_type_name, weight) = value?;
                let vocabulary = self.get_mutable_write();
                unsafe {
                    Ok((
                        src,
                        dst,
                        Some(
                            vocabulary
                                .0
                                .unchecked_insert(edge_type_name.unwrap_unchecked()),
                        ),
                        weight,
                    ))
                }
            }
            pub fn get<T, W>(
                &mut self,
                value: Result<(T, T, Option<String>, W)>,
            ) -> Result<(T, T, Option<EdgeTypeT>, W)> {
                let (src, dst, edge_type_name, weight) = value?;
                let vocabulary = self.get_immutable();
                let edge_type_name = unsafe { &edge_type_name.unwrap_unchecked() };
                Ok((
                    src,
                    dst,
                    Some(match vocabulary.get(&edge_type_name) {
                        Some(et) => Ok(et),
                        None => Err({
                            let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1_formatted (& ["Found an unknown edge type while reading the edge list.\nSpecifically the unknown edge type is " , ".\nThe list of the known edge types is "] , & match (& edge_type_name , & vocabulary . keys ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , } , & [:: core :: fmt :: rt :: v1 :: Argument { position : 0usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Implied , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , } , :: core :: fmt :: rt :: v1 :: Argument { position : 1usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 4u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Implied , width : :: core :: fmt :: rt :: v1 :: Count :: Is (4usize) , } , }])) ;
                            res
                        }),
                    }?),
                    weight,
                ))
            }
            pub fn get_unchecked<T, W>(
                &mut self,
                value: Result<(T, T, Option<String>, W)>,
            ) -> Result<(T, T, Option<EdgeTypeT>, W)> {
                let (src, dst, edge_type_name, weight) = value?;
                let vocabulary = self.get_immutable();
                Ok((
                    src,
                    dst,
                    vocabulary.get(&unsafe { edge_type_name.unwrap_unchecked() }),
                    weight,
                ))
            }
            pub fn to_numeric<T, W>(
                &mut self,
                value: Result<(T, T, Option<String>, W)>,
            ) -> Result<(T, T, Option<EdgeTypeT>, W)> {
                let (src, dst, edge_type_name, weight) = value?;
                let vocabulary = self.get_immutable();
                let edge_type_id = match unsafe { edge_type_name.unwrap_unchecked() }
                    .parse::<EdgeTypeT>()
                {
                    Ok(edge_type_id) => Ok::<_, String>(edge_type_id),
                    Err(_) => Err::<_, String>({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[
                                "The given edge type name ",
                                " cannot be parsed to an integer value.",
                            ],
                            &match (&edge_type_name,) {
                                (arg0,) => {
                                    [::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt)]
                                }
                            },
                        ));
                        res
                    }),
                }?;
                if vocabulary.len() as EdgeTypeT <= edge_type_id {
                    return Err({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[
                                "The given edge type name ",
                                " has a value greater than the number of provided nodes ",
                                ".",
                            ],
                            &match (&edge_type_id, &vocabulary.len()) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ],
                            },
                        ));
                        res
                    });
                }
                Ok((src, dst, Some(edge_type_id), weight))
            }
            pub fn to_numeric_unchecked<T, W>(
                &mut self,
                value: Result<(T, T, Option<String>, W)>,
            ) -> Result<(T, T, Option<EdgeTypeT>, W)> {
                let (src, dst, edge_type_name, weight) = value?;
                let vocabulary = self.get_immutable();
                unsafe {
                    Ok((
                        src,
                        dst,
                        Some(
                            unsafe { edge_type_name.unwrap_unchecked() }
                                .parse::<EdgeTypeT>()
                                .unwrap_unchecked(),
                        ),
                        weight,
                    ))
                }
            }
        }
    }
    pub use edge_type_parser::*;
    mod node_type_parser {
        use super::*;
        use std::sync::{RwLock, RwLockReadGuard, RwLockWriteGuard};
        pub(crate) struct NodeTypeParser {
            context: Vocabulary<NodeTypeT>,
            lock: RwLock<()>,
        }
        impl NodeTypeParser {
            pub fn new(context: Vocabulary<NodeTypeT>) -> NodeTypeParser {
                NodeTypeParser {
                    context: context,
                    lock: RwLock::new(()),
                }
            }
            #[inline]
            fn get_immutable(&self) -> &Vocabulary<NodeTypeT> {
                &self.context
            }
            #[inline]
            fn get_mutable_read(
                &mut self,
            ) -> (&mut Vocabulary<NodeTypeT>, RwLockReadGuard<'_, ()>) {
                (&mut self.context, self.lock.read().unwrap())
            }
            #[inline]
            fn get_mutable_write(
                &mut self,
            ) -> (&mut Vocabulary<NodeTypeT>, RwLockWriteGuard<'_, ()>) {
                (&mut self.context, self.lock.write().unwrap())
            }
        }
        impl NodeTypeParser {
            pub fn ignore<N>(
                &mut self,
                value: Result<(N, Option<Vec<String>>)>,
            ) -> Result<(N, Option<Vec<NodeTypeT>>)> {
                Ok((value?.0, None))
            }
            pub fn parse_strings<N>(
                &mut self,
                value: Result<(N, Option<Vec<String>>)>,
            ) -> Result<(N, Option<Vec<NodeTypeT>>)> {
                let (node_name, node_type_names) = value?;
                let vocabulary = self.get_mutable_write();
                Ok((node_name, vocabulary.insert_value(node_type_names)?))
            }
            pub fn parse_strings_unchecked<N>(
                &mut self,
                value: Result<(N, Option<Vec<String>>)>,
            ) -> Result<(N, Option<Vec<NodeTypeT>>)> {
                let (node_name, node_type_names) = value?;
                let vocabulary = self.get_mutable_write();
                Ok((
                    node_name,
                    vocabulary.unchecked_insert_values(node_type_names)?,
                ))
            }
            pub fn get<N>(
                &mut self,
                value: Result<(N, Option<Vec<String>>)>,
            ) -> Result<(N, Option<Vec<NodeTypeT>>)> {
                let (node_name, node_type_names) = value?;
                let vocabulary = self.get_immutable();
                Ok((node_name, vocabulary.get(node_type_names)?))
            }
            pub fn get_unchecked<N>(
                &mut self,
                value: Result<(N, Option<Vec<String>>)>,
            ) -> Result<(N, Option<Vec<NodeTypeT>>)> {
                let (node_name, node_type_names) = value?;
                let vocabulary = self.get_immutable();
                Ok((node_name, unsafe {
                    vocabulary.unchecked_get(node_type_names)?
                }))
            }
            pub fn to_numeric<N>(
                &mut self,
                value: Result<(N, Option<Vec<String>>)>,
            ) -> Result<(N, Option<Vec<NodeTypeT>>)> {
                let (node_name, node_type_names) = value?;
                let vocabulary = self.get_immutable();
                let node_type_ids = node_type_names . map_or (| | Ok (None) , | ntns | { Ok (Some (ntns . into_iter () . map (| node_type_name | { let node_type_id = node_type_name . parse :: < NodeTypeT > () . map_err (| _ | { Err ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The given node type name " , " cannot be parsed to an integer value."] , & match (& node_type_name ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , })) ; res }) }) ? ; if vocabulary . len () as NodeTypeT <= node_type_id { return Err ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The given node type name " , " has a value greater than the number of provided node types " , "."] , & match (& node_type_name , & vocabulary . len ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , })) ; res }) ; } Ok (node_type_id) }) . collect :: < Result < Vec < NodeTypeT > > > () ?)) }) ? ;
                Ok((node_name, node_type_ids))
            }
            pub fn to_numeric_unchecked<N>(
                &mut self,
                value: Result<(N, Option<Vec<String>>)>,
            ) -> Result<(N, Option<Vec<NodeTypeT>>)> {
                let (node_name, node_type_names) = value?;
                let vocabulary = self.get_immutable();
                let node_type_ids = node_type_names.map(|ntns| unsafe {
                    ntns.into_iter()
                        .map(|node_type_name| {
                            node_type_name.parse::<NodeTypeT>().unwrap_unchecked()
                        })
                        .collect::<Vec<NodeTypeT>>()
                })?;
                Ok((node_name, node_type_ids))
            }
        }
    }
    pub use node_type_parser::*;
}
pub mod utils {
    use super::*;
    use indicatif::{ProgressBar, ProgressStyle};
    use rayon::ThreadPool;
    use std::ops::Range;
    use std::sync::atomic::AtomicUsize;
    use std::sync::atomic::Ordering;
    pub fn get_loading_bar(verbose: bool, desc: &str, total_iterations: usize) -> ProgressBar {
        if verbose {
            let pb = ProgressBar::new(total_iterations as u64);
            let candidate_iterations = total_iterations as u64 / 1000;
            let candidate_iterations = candidate_iterations.max(1);
            pb.set_draw_delta(candidate_iterations);
            pb . set_style (ProgressStyle :: default_bar () . template (& { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["" , " {spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] ({pos}/{len}, ETA {eta})"] , & match (& desc ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res })) ;
            pb
        } else {
            ProgressBar::hidden()
        }
    }
    /// Returns a rayon thread pool handling Creation errors.
    ///
    /// Getting a thread pool might return the error "Resource temporarly unavailable"
    /// if the number of processes currently on the system is more than what set in
    /// `ulimit -a`, which by default is 256851.
    ///
    /// Moreover, we return an error if the number of selected CPUS is 1 or less.
    /// Because the algorithms which use the pool requires at least 2 threads, and
    /// we generally provide also an optimized single-thread version.
    pub(crate) fn get_thread_pool() -> Result<(usize, ThreadPool)> {
        let cpu_number = rayon::current_num_threads();
        if cpu_number <= 1 {
            return Err ("Cannot execute the parallel connected_components method when only a single CPU is made available.\nThis might be an erroroneus configuration of the envionment variable RAYON_NUM_THREADS.\nIf you really want to compute the connected components with these configurations, consider using random_spanning_arborescence_kruskal." . to_string ()) ;
        }
        let mut attempts_left = 1_000_000;
        loop {
            match rayon::ThreadPoolBuilder::new()
                .num_threads(cpu_number)
                .build()
            {
                Ok(thread_pool) => return Ok((cpu_number, thread_pool)),
                Err(internal_error) => {
                    if attempts_left == 0 {
                        return Err({
                            let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Unknown error while trying to allocate the thread pool for executing the parallel connected components algorithm.\nIn our experience this happens once in every 100 milions calls\nThe interal error is " , "."] , & match (& internal_error ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , })) ;
                            res
                        });
                    }
                    let delay = std::time::Duration::from_millis(50);
                    std::thread::sleep(delay);
                    attempts_left -= 1;
                }
            }
        }
    }
    /// Validated the provided features.
    ///
    /// Specifically, the features must:
    /// - Be provided for all of the expected elements.
    /// - Be non-empty.
    /// - Be of a consistent size, that is the number of features for each element must be equal.
    ///
    /// # Arguments
    /// * `features`: Vec<Vec<f64>> - The features to validate.
    /// * `expected_elements_number`: usize - The number of expected elements.
    pub(crate) fn validate_features(
        features: &[Vec<f64>],
        expected_elements_number: usize,
    ) -> Result<()> {
        if features.len() != expected_elements_number {
            return Err({
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &[
                        "The expected features vector length was expected to be ",
                        ", but is ",
                        ".",
                    ],
                    &match (&expected_elements_number, &features.len()) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ],
                    },
                ));
                res
            });
        }
        let expected_node_features_length = features.first().unwrap().len();
        if expected_node_features_length == 0 {
            return Err("The node features length must be greater than zero.".to_string());
        }
        for node_features in features.iter() {
            if expected_node_features_length != node_features.len() {
                return Err({
                    let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The node features length needs to be consistent: the expected size was " , " while the found length was " , "."] , & match (& expected_node_features_length , & node_features . len ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , })) ;
                    res
                });
            }
        }
        Ok(())
    }
    /// Return true if the given weight is near to one.
    pub(crate) fn not_one(weight: WeightT) -> bool {
        (weight - 1.0).abs() > WeightT::EPSILON
    }
    impl Graph {
        /// Return vector of edges to be inserted in the holdout.
        pub(crate) fn compute_edge_ids_vector(
            &self,
            edge_id: EdgeT,
            src: NodeT,
            dst: NodeT,
            include_all_edge_types: bool,
        ) -> Vec<EdgeT> {
            if include_all_edge_types {
                let (min_edge_id, max_edge_id) =
                    unsafe { self.get_unchecked_minmax_edge_ids_from_node_ids(src, dst) };
                (min_edge_id..max_edge_id).collect::<Vec<EdgeT>>()
            } else {
                <[_]>::into_vec(box [edge_id])
            }
        }
    }
    /// Return given weight parsed from string to float.
    ///
    /// # Arguments
    ///
    /// * `weight`: String - The weight to be parsed.
    ///
    /// # Example
    /// The weight can be validated as follows:
    /// ```rust
    /// # use graph::utils::parse_weight;
    /// assert!(parse_weight("0.0".to_string()).is_ok());
    /// assert!(parse_weight("-1.0".to_string()).is_ok());
    /// assert!(parse_weight("2.0".to_string()).is_ok());
    /// assert!(parse_weight("2ghgjh.0".to_string()).is_err());
    /// assert_eq!(parse_weight("2.0".to_string()).unwrap(), 2.0);
    /// ```
    ///
    pub fn parse_weight(weight: String) -> Result<WeightT> {
        weight.parse::<WeightT>().map_err(|_| {
            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                &["Cannot parse weight ", " as a float."],
                &match (&weight,) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            ));
            res
        })
    }
    pub trait ArgMax<T> {
        fn argmax(&self) -> Option<(usize, T)>;
    }
    impl<T: PartialOrd + Copy> ArgMax<T> for Vec<T> {
        fn argmax(&self) -> Option<(usize, T)> {
            self.iter()
                .enumerate()
                .fold(None, |current_max, (i, &value)| {
                    current_max.map_or(Some((i, value)), |(j, current_max_value)| {
                        Some(if value > current_max_value {
                            (i, value)
                        } else {
                            (j, current_max_value)
                        })
                    })
                })
        }
    }
}
pub(crate) use self::utils::*;
mod bitmaps {
    use super::*;
    use roaring::RoaringBitmap;
    /// # Drop.
    /// The naming convention we follow is:
    /// * `.*bitmap.*`
    impl Graph {
        /// Return a roaringbitmap with the node ids to keep.
        ///
        /// If both node\_names and node\_types are specified the result will be the
        /// union of both queries.
        ///
        /// # Arguments
        /// * `node_names` - The nodes to keep as strings
        /// * `node_types` - The nodes types to keep as strings
        ///
        pub(crate) fn get_filter_bitmap(
            &self,
            node_names: Option<Vec<String>>,
            node_types: Option<Vec<Option<String>>>,
        ) -> Result<Option<RoaringBitmap>> {
            let mut node_ids = RoaringBitmap::new();
            if let Some(ns) = node_names {
                node_ids.extend(
                    ns.iter()
                        .map(|node_name| self.get_node_id_from_node_name(node_name))
                        .collect::<Result<Vec<NodeT>>>()?,
                );
            }
            if let Some(ndt) = node_types {
                let node_type_ids = self.get_node_type_ids_from_node_type_names(ndt)?;
                node_ids.extend(self.iter_node_ids_and_node_type_ids().filter_map(
                    |(node_id, nts)| {
                        if nts.map_or_else(
                            || node_type_ids.contains(&None),
                            |ns| {
                                ns.into_iter().any(|node_type_name| {
                                    node_type_ids.contains(&Some(node_type_name))
                                })
                            },
                        ) {
                            Some(node_id)
                        } else {
                            None
                        }
                    },
                ));
            }
            Ok(if node_ids.is_empty() {
                None
            } else {
                Some(node_ids)
            })
        }
    }
}
mod centrality {
    use super::*;
    use atomic_float::AtomicF64;
    use indicatif::ParallelProgressIterator;
    use itertools::Itertools;
    use num_traits::pow::Pow;
    use rayon::iter::IndexedParallelIterator;
    use rayon::iter::IntoParallelRefIterator;
    use rayon::iter::{IntoParallelRefMutIterator, ParallelIterator};
    use std::collections::VecDeque;
    use std::sync::atomic::Ordering;
    impl Graph {
        /// Returns iterator over the unweighted degree centrality for all nodes.
        pub fn iter_degree_centrality(&self) -> Result<impl Iterator<Item = f64> + '_> {
            self.must_have_edges()?;
            let max_degree = unsafe { self.get_unchecked_maximum_node_degree() as f64 };
            Ok(self
                .iter_node_degrees()
                .map(move |degree| degree as f64 / max_degree))
        }
        /// Returns iterator over the weighted degree centrality for all nodes.
        pub fn par_iter_weighted_degree_centrality(
            &self,
        ) -> Result<impl IndexedParallelIterator<Item = f64> + '_> {
            self.must_have_edges()?;
            self.must_have_positive_edge_weights()?;
            let weighted_max_degree = self.get_weighted_maximum_node_degree()? as f64;
            Ok(self
                .par_iter_weighted_node_degrees()?
                .map(move |degree| degree as f64 / weighted_max_degree))
        }
        /// Returns vector of unweighted degree centrality for all nodes.
        pub fn get_degree_centrality(&self) -> Result<Vec<f64>> {
            Ok(self.iter_degree_centrality()?.collect())
        }
        /// Returns vector of weighted degree centrality for all nodes.
        pub fn get_weighted_degree_centrality(&self) -> Result<Vec<f64>> {
            Ok(self.par_iter_weighted_degree_centrality()?.collect())
        }
        /// Return closeness centrality of the requested node.
        ///
        /// If the given node ID does not exist in the current graph the method
        /// will panic.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - The node ID whose closeness centrality is to be computed.
        /// * `verbose`: Option<bool> - Whether to show an indicative progress bar.
        ///
        /// # References
        /// The metric is described in [Centrality in Social Networks by Freeman](https://www.bebr.ufl.edu/sites/default/files/Centrality%20in%20Social%20Networks.pdf)
        ///
        /// # Safety
        /// If the given node ID does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_closeness_centrality_from_node_id(
            &self,
            node_id: NodeT,
        ) -> f64 {
            1.0 / self
                .get_unchecked_breath_first_search_from_node_ids(node_id, None, None, None)
                .into_iter_finite_distances()
                .sum::<NodeT>() as f64
        }
        /// Return closeness centrality of the requested node.
        ///
        /// If the given node ID does not exist in the current graph the method
        /// will panic.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - The node ID whose closeness centrality is to be computed.
        /// * `use_edge_weights_as_probabilities`: bool - Whether to treat the edge weights as probabilities.
        ///
        /// # References
        /// The metric is described in [Centrality in Social Networks by Freeman](https://www.bebr.ufl.edu/sites/default/files/Centrality%20in%20Social%20Networks.pdf)
        ///
        /// # Implementative notes
        /// When the user provides the information that the graph contains weights
        /// representing probabilities (which is impossible to detect automatically)
        /// we return instead of `1 / total_distance` directly the total distance,
        /// as `1 / total_distance` when the weights represent a distance basically
        /// represent the probability to sample all those paths. This value is
        /// already captured by the product of the probabilities, which composes
        /// the `total_distance` value when it is known that the graph is composed
        /// of probabilities.
        ///
        /// # Safety
        /// If the given node ID does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_weighted_closeness_centrality_from_node_id(
            &self,
            node_id: NodeT,
            use_edge_weights_as_probabilities: bool,
        ) -> f64 {
            let total_distance = self
                .get_unchecked_dijkstra_from_node_ids(
                    node_id,
                    None,
                    None,
                    Some(false),
                    None,
                    Some(use_edge_weights_as_probabilities),
                )
                .total_distance;
            if use_edge_weights_as_probabilities {
                total_distance
            } else {
                1.0 / total_distance
            }
        }
        /// Return parallel iterator over closeness centrality for all nodes.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show an indicative progress bar.
        ///
        /// # References
        /// The metric is described in [Centrality in Social Networks by Freeman](https://www.bebr.ufl.edu/sites/default/files/Centrality%20in%20Social%20Networks.pdf)
        pub fn par_iter_closeness_centrality(
            &self,
            verbose: Option<bool>,
        ) -> impl ParallelIterator<Item = f64> + '_ {
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Computing closeness centrality",
                self.get_nodes_number() as usize,
            );
            self.par_iter_node_ids()
                .progress_with(pb)
                .map(move |node_id| unsafe {
                    self.get_unchecked_closeness_centrality_from_node_id(node_id)
                })
        }
        /// Return parallel iterator over closeness centrality for all nodes.
        ///
        /// # Arguments
        /// * `use_edge_weights_as_probabilities`: bool - Whether to treat the edge weights as probabilities.
        /// * `verbose`: Option<bool> - Whether to show an indicative progress bar.
        ///
        /// # References
        /// The metric is described in [Centrality in Social Networks by Freeman](https://www.bebr.ufl.edu/sites/default/files/Centrality%20in%20Social%20Networks.pdf)
        ///
        /// # Implementative notes
        /// When the user provides the information that the graph contains weights
        /// representing probabilities (which is impossible to detect automatically)
        /// we return instead of `1 / total_distance` directly the total distance,
        /// as `1 / total_distance` when the weights represent a distance basically
        /// represent the probability to sample all those paths. This value is
        /// already captured by the product of the probabilities, which composes
        /// the `total_distance` value when it is known that the graph is composed
        /// of probabilities.
        ///
        /// # References
        /// The metric is described in [Centrality in Social Networks by Freeman](https://www.bebr.ufl.edu/sites/default/files/Centrality%20in%20Social%20Networks.pdf)
        ///
        /// # Raises
        /// * If the graph does not have weights.
        /// * If the graph contains negative weights.
        /// * If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.
        pub fn par_iter_weighted_closeness_centrality(
            &self,
            use_edge_weights_as_probabilities: Option<bool>,
            verbose: Option<bool>,
        ) -> Result<impl ParallelIterator<Item = f64> + '_> {
            self.must_have_positive_edge_weights()?;
            let use_edge_weights_as_probabilities =
                use_edge_weights_as_probabilities.unwrap_or(false);
            if use_edge_weights_as_probabilities {
                self.must_have_edge_weights_representing_probabilities()?;
            }
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Computing closeness centrality",
                self.get_nodes_number() as usize,
            );
            Ok(self
                .par_iter_node_ids()
                .progress_with(pb)
                .map(move |node_id| unsafe {
                    self.get_unchecked_weighted_closeness_centrality_from_node_id(
                        node_id,
                        use_edge_weights_as_probabilities,
                    )
                }))
        }
        /// Return closeness centrality for all nodes.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show an indicative progress bar.
        ///
        /// # References
        /// The metric is described in [Centrality in Social Networks by Freeman](https://www.bebr.ufl.edu/sites/default/files/Centrality%20in%20Social%20Networks.pdf)
        pub fn get_closeness_centrality(&self, verbose: Option<bool>) -> Vec<f64> {
            self.par_iter_closeness_centrality(verbose).collect()
        }
        /// Return closeness centrality for all nodes.
        ///
        /// # Arguments
        /// * `use_edge_weights_as_probabilities`: bool - Whether to treat the edge weights as probabilities.
        /// * `verbose`: Option<bool> - Whether to show an indicative progress bar.
        ///
        /// # References
        /// The metric is described in [Centrality in Social Networks by Freeman](https://www.bebr.ufl.edu/sites/default/files/Centrality%20in%20Social%20Networks.pdf)
        ///
        /// # Implementative notes
        /// When the user provides the information that the graph contains weights
        /// representing probabilities (which is impossible to detect automatically)
        /// we return instead of `1 / total_distance` directly the total distance,
        /// as `1 / total_distance` when the weights represent a distance basically
        /// represent the probability to sample all those paths. This value is
        /// already captured by the product of the probabilities, which composes
        /// the `total_distance` value when it is known that the graph is composed
        /// of probabilities.
        ///
        /// # Raises
        /// * If the graph does not have weights.
        /// * If the graph contains negative weights.
        /// * If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.
        pub fn get_weighted_closeness_centrality(
            &self,
            use_edge_weights_as_probabilities: Option<bool>,
            verbose: Option<bool>,
        ) -> Result<Vec<f64>> {
            self.par_iter_weighted_closeness_centrality(use_edge_weights_as_probabilities, verbose)
                .map(|x| x.collect())
        }
        /// Return harmonic centrality of the requested node.
        ///
        /// If the given node ID does not exist in the current graph the method
        /// will panic.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - The node ID whose harmonic centrality is to be computed.
        ///
        /// # References
        /// The metric is described in [Axioms for centrality by Boldi and Vigna](https://www.tandfonline.com/doi/abs/10.1080/15427951.2013.865686).
        ///
        /// # Safety
        /// If the given node ID does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_harmonic_centrality_from_node_id(&self, node_id: NodeT) -> f64 {
            self.get_unchecked_breath_first_search_from_node_ids(node_id, None, None, None)
                .into_iter_finite_distances()
                .map(|distance| {
                    if distance != 0 {
                        1.0 / distance as f64
                    } else {
                        0.0
                    }
                })
                .sum()
        }
        /// Return harmonic centrality of the requested node.
        ///
        /// If the given node ID does not exist in the current graph the method
        /// will panic.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - The node ID whose harmonic centrality is to be computed.
        /// * `use_edge_weights_as_probabilities`: bool - Whether to treat the edge weights as probabilities.
        ///
        /// # References
        /// The metric is described in [Axioms for centrality by Boldi and Vigna](https://www.tandfonline.com/doi/abs/10.1080/15427951.2013.865686).
        ///
        /// # Safety
        /// If the given node ID does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_weighted_harmonic_centrality_from_node_id(
            &self,
            node_id: NodeT,
            use_edge_weights_as_probabilities: bool,
        ) -> f64 {
            self.get_unchecked_dijkstra_from_node_ids(
                node_id,
                None,
                None,
                Some(false),
                None,
                Some(use_edge_weights_as_probabilities),
            )
            .total_harmonic_distance
        }
        /// Return parallel iterator over harmonic centrality for all nodes.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show an indicative progress bar.
        ///
        /// # References
        /// The metric is described in [Axioms for centrality by Boldi and Vigna](https://www.tandfonline.com/doi/abs/10.1080/15427951.2013.865686).
        ///
        pub fn par_iter_harmonic_centrality(
            &self,
            verbose: Option<bool>,
        ) -> impl ParallelIterator<Item = f64> + '_ {
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Computing harmonic centrality",
                self.get_nodes_number() as usize,
            );
            self.par_iter_node_ids()
                .progress_with(pb)
                .map(move |node_id| unsafe {
                    self.get_unchecked_harmonic_centrality_from_node_id(node_id)
                })
        }
        /// Return parallel iterator over harmonic centrality for all nodes.
        ///
        /// # Arguments
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        /// * `verbose`: Option<bool> - Whether to show an indicative progress bar.
        ///
        /// # References
        /// The metric is described in [Axioms for centrality by Boldi and Vigna](https://www.tandfonline.com/doi/abs/10.1080/15427951.2013.865686).
        ///
        /// # Raises
        /// * If the graph does not have weights.
        /// * If the graph contains negative weights.
        /// * If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.
        pub fn par_iter_weighted_harmonic_centrality(
            &self,
            use_edge_weights_as_probabilities: Option<bool>,
            verbose: Option<bool>,
        ) -> Result<impl ParallelIterator<Item = f64> + '_> {
            self.must_have_positive_edge_weights()?;
            let use_edge_weights_as_probabilities =
                use_edge_weights_as_probabilities.unwrap_or(false);
            if use_edge_weights_as_probabilities {
                self.must_have_edge_weights_representing_probabilities()?;
            }
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Computing harmonic centrality",
                self.get_nodes_number() as usize,
            );
            Ok(self
                .par_iter_node_ids()
                .progress_with(pb)
                .map(move |node_id| unsafe {
                    self.get_unchecked_weighted_harmonic_centrality_from_node_id(
                        node_id,
                        use_edge_weights_as_probabilities,
                    )
                }))
        }
        /// Return harmonic centrality for all nodes.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show an indicative progress bar.
        ///
        /// # References
        /// The metric is described in [Axioms for centrality by Boldi and Vigna](https://www.tandfonline.com/doi/abs/10.1080/15427951.2013.865686).
        pub fn get_harmonic_centrality(&self, verbose: Option<bool>) -> Vec<f64> {
            self.par_iter_harmonic_centrality(verbose).collect()
        }
        /// Return harmonic centrality for all nodes.
        ///
        /// # Arguments
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        /// * `verbose`: Option<bool> - Whether to show an indicative progress bar.
        ///
        /// # References
        /// The metric is described in [Axioms for centrality by Boldi and Vigna](https://www.tandfonline.com/doi/abs/10.1080/15427951.2013.865686).
        pub fn get_weighted_harmonic_centrality(
            &self,
            use_edge_weights_as_probabilities: Option<bool>,
            verbose: Option<bool>,
        ) -> Result<Vec<f64>> {
            self.par_iter_weighted_harmonic_centrality(use_edge_weights_as_probabilities, verbose)
                .map(|x| x.collect())
        }
        /// Returns vector of stress centrality for all nodes.
        ///
        /// # Arguments
        /// * `normalize`: Option<bool> - Whether to normalize the values. By default, it is false.
        /// * `verbose`: Option<bool> - Whether to show a loading bar. By default, it is true.
        ///
        /// # References
        /// The algorithm is implemented as described in [Parallel Algorithms for Evaluating Centrality Indices in Real-World Networks](https://ieeexplore.ieee.org/abstract/document/1690659), by Bader et al.
        ///
        pub fn get_stress_centrality(
            &self,
            normalize: Option<bool>,
            verbose: Option<bool>,
        ) -> Vec<f64> {
            if !self.has_nodes() {
                return Vec::new();
            }
            let normalize = normalize.unwrap_or(false);
            let verbose = verbose.unwrap_or(true);
            let nodes_number = self.get_nodes_number() as usize;
            let centralities: Vec<AtomicF64> =
                self.iter_node_ids().map(|_| AtomicF64::new(0.0)).collect();
            let factor = if self.is_directed() { 1.0 } else { 2.0 };
            let pb = get_loading_bar(verbose, "Computing stress centralities", nodes_number);
            self.par_iter_node_ids()
                .progress_with(pb)
                .for_each(|src_node_id| {
                    let mut stack: Vec<NodeT> = Vec::new();
                    let mut node_lists: Vec<Vec<NodeT>> =
                        self.iter_node_ids().map(|_| Vec::new()).collect();
                    let mut shortest_path_counts = ::alloc::vec::from_elem(0, nodes_number);
                    shortest_path_counts[src_node_id as usize] = 1;
                    let mut distance_from_root = ::alloc::vec::from_elem(u64::MAX, nodes_number);
                    distance_from_root[src_node_id as usize] = 0;
                    let mut nodes_to_visit: VecDeque<NodeT> = VecDeque::new();
                    nodes_to_visit.push_back(src_node_id);
                    while !nodes_to_visit.is_empty() {
                        let current_node_id = nodes_to_visit.pop_front().unwrap();
                        stack.push(current_node_id);
                        unsafe {
                            self.iter_unchecked_neighbour_node_ids_from_source_node_id(
                                current_node_id,
                            )
                        }
                        .for_each(|neighbour_node_id| {
                            if distance_from_root[neighbour_node_id as usize] == u64::MAX {
                                nodes_to_visit.push_back(neighbour_node_id);
                                distance_from_root[neighbour_node_id as usize] =
                                    distance_from_root[current_node_id as usize] + 1;
                            }
                            if distance_from_root[neighbour_node_id as usize]
                                == distance_from_root[current_node_id as usize] + 1
                            {
                                shortest_path_counts[neighbour_node_id as usize] +=
                                    shortest_path_counts[current_node_id as usize];
                                node_lists[neighbour_node_id as usize].push(current_node_id);
                            }
                        });
                    }
                    let mut dependencies = ::alloc::vec::from_elem(0.0, nodes_number);
                    stack.into_iter().rev().for_each(|current_node_id| {
                        node_lists[current_node_id as usize].iter().for_each(
                            |&neighbour_node_id| {
                                dependencies[neighbour_node_id as usize] +=
                                    shortest_path_counts[neighbour_node_id as usize] as f64
                                        * (1.0 + dependencies[current_node_id as usize]);
                            },
                        );
                        if current_node_id != src_node_id {
                            centralities[current_node_id as usize].fetch_add(
                                dependencies[current_node_id as usize] / factor,
                                Ordering::SeqCst,
                            );
                        }
                    });
                });
            let mut centralities =
                unsafe { std::mem::transmute::<Vec<AtomicF64>, Vec<f64>>(centralities) };
            if normalize {
                let (min_centrality, max_centrality) =
                    centralities.iter().cloned().minmax().into_option().unwrap();
                let delta = max_centrality - min_centrality;
                centralities.par_iter_mut().for_each(|value| {
                    *value = (*value - min_centrality) / delta;
                });
            }
            centralities
        }
        /// Returns vector of betweenness centrality for all nodes.
        ///
        /// # Arguments
        /// * `normalize`: Option<bool> - Whether to normalize the values. By default, it is false.
        /// * `verbose`: Option<bool> - Whether to show a loading bar. By default, it is true.
        ///
        /// # References
        /// The algorithm is implemented as described in [Parallel Algorithms for Evaluating Centrality Indices in Real-World Networks](https://ieeexplore.ieee.org/abstract/document/1690659), by Bader et al.
        ///
        /// TODO: I think this method can be bettered for the undirected case.
        pub fn get_betweenness_centrality(
            &self,
            normalize: Option<bool>,
            verbose: Option<bool>,
        ) -> Vec<f64> {
            if !self.has_nodes() {
                return Vec::new();
            }
            let normalize = normalize.unwrap_or(false);
            let verbose = verbose.unwrap_or(true);
            let nodes_number = self.get_nodes_number() as usize;
            let centralities: Vec<AtomicF64> =
                self.iter_node_ids().map(|_| AtomicF64::new(0.0)).collect();
            let factor = if self.is_directed() { 1.0 } else { 2.0 };
            let pb = get_loading_bar(verbose, "Computing betweennes centralities", nodes_number);
            self.par_iter_node_ids()
                .progress_with(pb)
                .for_each(|src_node_id| {
                    let mut stack: Vec<NodeT> = Vec::new();
                    let mut node_lists: Vec<Vec<NodeT>> =
                        self.iter_node_ids().map(|_| Vec::new()).collect();
                    let mut shortest_path_counts = ::alloc::vec::from_elem(0, nodes_number);
                    shortest_path_counts[src_node_id as usize] = 1;
                    let mut distance_from_root = ::alloc::vec::from_elem(u64::MAX, nodes_number);
                    distance_from_root[src_node_id as usize] = 0;
                    let mut nodes_to_visit: VecDeque<NodeT> = VecDeque::new();
                    nodes_to_visit.push_back(src_node_id);
                    while !nodes_to_visit.is_empty() {
                        let current_node_id = nodes_to_visit.pop_front().unwrap();
                        stack.push(current_node_id);
                        unsafe {
                            self.iter_unchecked_neighbour_node_ids_from_source_node_id(
                                current_node_id,
                            )
                        }
                        .for_each(|neighbour_node_id| {
                            if distance_from_root[neighbour_node_id as usize] == u64::MAX {
                                nodes_to_visit.push_back(neighbour_node_id);
                                distance_from_root[neighbour_node_id as usize] =
                                    distance_from_root[current_node_id as usize] + 1;
                            }
                            if distance_from_root[neighbour_node_id as usize]
                                == distance_from_root[current_node_id as usize] + 1
                            {
                                shortest_path_counts[neighbour_node_id as usize] +=
                                    shortest_path_counts[current_node_id as usize];
                                node_lists[neighbour_node_id as usize].push(current_node_id);
                            }
                        });
                    }
                    let mut dependencies = ::alloc::vec::from_elem(0.0, nodes_number);
                    stack.into_iter().rev().for_each(|current_node_id| {
                        node_lists[current_node_id as usize].iter().for_each(
                            |&neighbour_node_id| {
                                dependencies[neighbour_node_id as usize] +=
                                    shortest_path_counts[neighbour_node_id as usize] as f64
                                        / shortest_path_counts[current_node_id as usize] as f64
                                        * (1.0 + dependencies[current_node_id as usize]);
                            },
                        );
                        if current_node_id != src_node_id {
                            centralities[current_node_id as usize].fetch_add(
                                dependencies[current_node_id as usize] / factor,
                                Ordering::SeqCst,
                            );
                        }
                    });
                });
            let mut centralities =
                unsafe { std::mem::transmute::<Vec<AtomicF64>, Vec<f64>>(centralities) };
            if normalize {
                let (min_centrality, max_centrality) =
                    centralities.iter().cloned().minmax().into_option().unwrap();
                let delta = max_centrality - min_centrality;
                centralities.par_iter_mut().for_each(|value| {
                    *value = (*value - min_centrality) / delta;
                });
            }
            centralities
        }
        /// Returns vector with unweighted eigenvector centrality.
        ///
        /// # Arguments
        /// * `maximum_iterations_number`: Option<usize> - The maximum number of iterations to consider.
        /// * `tollerance`: Option<f64> - The maximum error tollerance for convergence.
        pub fn get_eigenvector_centrality(
            &self,
            maximum_iterations_number: Option<usize>,
            tollerance: Option<f64>,
        ) -> Result<Vec<f64>> {
            let maximum_iterations_number = maximum_iterations_number.unwrap_or(1000);
            let tollerance = tollerance.unwrap_or(1e-6) * self.get_nodes_number() as f64;
            if tollerance < f64::EPSILON {
                return Err(
                    "The tollerance must be a non-zero positive value bigger than epislon (1e-16)."
                        .to_string(),
                );
            }
            let mut centralities: Vec<AtomicF64> = self
                .iter_node_ids()
                .map(|_| AtomicF64::new(1.0 / self.get_nodes_number() as f64))
                .collect();
            let mut last_centralities = ::alloc::vec::from_elem(
                1.0 / self.get_nodes_number() as f64,
                self.get_nodes_number() as usize,
            );
            for _ in 0..maximum_iterations_number {
                self.par_iter_node_ids().for_each(|src| {
                    unsafe { self.iter_unchecked_neighbour_node_ids_from_source_node_id(src) }
                        .for_each(|dst| {
                            centralities[dst as usize]
                                .fetch_add(last_centralities[src as usize], Ordering::Relaxed);
                        });
                });
                let norm: f64 = centralities
                    .par_iter()
                    .map(|centrality| centrality.load(Ordering::Relaxed).pow(2))
                    .sum::<f64>()
                    .sqrt();
                centralities.par_iter_mut().for_each(|centrality| {
                    centrality
                        .fetch_update(Ordering::Relaxed, Ordering::Relaxed, |x| Some(x / norm))
                        .unwrap();
                });
                let updated_centrality = centralities
                    .iter()
                    .map(|centrality| centrality.load(Ordering::Relaxed))
                    .collect::<Vec<f64>>();
                let differences = updated_centrality
                    .par_iter()
                    .zip(last_centralities.par_iter())
                    .map(|(centrality, old_centrality)| (centrality - old_centrality).abs())
                    .sum::<f64>();
                if differences < tollerance {
                    return Ok(updated_centrality);
                }
                last_centralities = updated_centrality;
            }
            Err({
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &["Unable to reach convergence in ", " iterations."],
                    &match (&maximum_iterations_number,) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ));
                res
            })
        }
        /// Returns vector with unweighted eigenvector centrality.
        ///
        /// # Arguments
        /// * `maximum_iterations_number`: Option<usize> - The maximum number of iterations to consider.
        /// * `tollerance`: Option<f64> - The maximum error tollerance for convergence.
        pub fn get_weighted_eigenvector_centrality(
            &self,
            maximum_iterations_number: Option<usize>,
            tollerance: Option<f64>,
        ) -> Result<Vec<f64>> {
            self.must_have_positive_edge_weights()?;
            let maximum_iterations_number = maximum_iterations_number.unwrap_or(1000);
            let tollerance = tollerance.unwrap_or(1e-6) * self.get_nodes_number() as f64;
            if tollerance < f64::EPSILON {
                return Err(
                    "The tollerance must be a non-zero positive value bigger than epsilon (1e-16)."
                        .to_string(),
                );
            }
            let mut centralities: Vec<AtomicF64> = self
                .iter_node_ids()
                .map(|_| AtomicF64::new(1.0 / self.get_nodes_number() as f64))
                .collect();
            let mut last_centralities = ::alloc::vec::from_elem(
                1.0 / self.get_nodes_number() as f64,
                self.get_nodes_number() as usize,
            );
            for _ in 0..maximum_iterations_number {
                self.par_iter_node_ids().for_each(|src| {
                    unsafe { self.iter_unchecked_neighbour_node_ids_from_source_node_id(src) }
                        .for_each(|dst| unsafe {
                            centralities[dst as usize].fetch_add(
                                last_centralities[src as usize]
                                    * self.get_unchecked_edge_weight_from_node_ids(src, dst) as f64,
                                Ordering::Relaxed,
                            );
                        });
                });
                let norm: f64 = centralities
                    .par_iter()
                    .map(|centrality| centrality.load(Ordering::Relaxed).pow(2))
                    .sum::<f64>()
                    .sqrt();
                centralities.par_iter_mut().for_each(|centrality| {
                    centrality
                        .fetch_update(Ordering::Relaxed, Ordering::Relaxed, |x| Some(x / norm))
                        .unwrap();
                });
                let updated_centrality = centralities
                    .iter()
                    .map(|centrality| centrality.load(Ordering::Relaxed))
                    .collect::<Vec<f64>>();
                let differences = updated_centrality
                    .par_iter()
                    .zip(last_centralities.par_iter())
                    .map(|(centrality, old_centrality)| (centrality - old_centrality).abs())
                    .sum::<f64>();
                if differences < tollerance {
                    return Ok(updated_centrality);
                }
                last_centralities = updated_centrality;
            }
            Err({
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &["Unable to reach convergence in ", " iterations."],
                    &match (&maximum_iterations_number,) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ));
                res
            })
        }
    }
}
mod dense {
    use std::cell::UnsafeCell;
    use rayon::iter::ParallelIterator;
    use super::*;
    impl Graph {
        /// Returns binary dense adjacency matrix.
        ///
        /// Beware of using this method on big graphs!
        /// It'll use all of your RAM!
        ///
        /// # Implementative notes
        /// On multigraphs this method will ignore multi-edges and treat
        /// those occurrences as would an homogeneous graph.
        pub fn get_dense_binary_adjacency_matrix(&self) -> Vec<Vec<bool>> {
            let mut ajacency = ::alloc::vec::from_elem(
                ::alloc::vec::from_elem(false, self.get_nodes_number() as usize),
                self.get_nodes_number() as usize,
            );
            let thread_ajacency = ThreadDataRaceAware {
                value: UnsafeCell::new(&mut ajacency),
            };
            self.par_iter_edge_node_ids(true)
                .for_each(|(_, src, dst)| unsafe {
                    (*thread_ajacency.value.get())[src as usize][dst as usize] = true;
                });
            ajacency
        }
        /// Returns binary weighted adjacency matrix.
        ///
        /// Beware of using this method on big graphs!
        /// It'll use all of your RAM!
        ///
        /// # Arguments
        /// * `weight`: Option<WeightT> - The weight value to use for absent edges. By default, `0.0`.
        ///
        /// # Implementative notes
        /// On multigraphs this method will ignore multi-edges and treat
        /// those occurrences as would an homogeneous graph.
        ///
        /// # Raises
        /// * If the graph does not have edge weights.
        pub fn get_dense_weighted_adjacency_matrix(
            &self,
            weight: Option<WeightT>,
        ) -> Result<Vec<Vec<WeightT>>> {
            self.must_have_edge_weights()?;
            let weight = weight.unwrap_or(0.0);
            let mut ajacency = ::alloc::vec::from_elem(
                ::alloc::vec::from_elem(weight, self.get_nodes_number() as usize),
                self.get_nodes_number() as usize,
            );
            let thread_ajacency = ThreadDataRaceAware {
                value: UnsafeCell::new(&mut ajacency),
            };
            self.par_iter_edge_node_ids_and_edge_weight()?.for_each(
                |(_, src, dst, weight)| unsafe {
                    (*thread_ajacency.value.get())[src as usize][dst as usize] = weight;
                },
            );
            Ok(ajacency)
        }
    }
}
mod edge_lists {
    use super::*;
    use itertools::Itertools;
    use rayon::iter::IntoParallelRefIterator;
    use rayon::iter::ParallelIterator;
    use std::collections::HashSet;
    impl Graph {
        /// Return vector of tuple of Node IDs that form the edges of the required bipartite graph.
        ///
        /// # Arguments
        /// * `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.
        /// * `first_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the first set of nodes of the graph.
        /// * `second_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the second set of nodes of the graph.
        /// * `first_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the first set of nodes of the graph.
        /// * `second_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the second set of nodes of the graph.
        pub fn get_bipartite_edges(
            &self,
            removed_existing_edges: Option<bool>,
            first_nodes_set: Option<HashSet<String>>,
            second_nodes_set: Option<HashSet<String>>,
            first_node_types_set: Option<HashSet<String>>,
            second_node_types_set: Option<HashSet<String>>,
        ) -> Result<Vec<Vec<NodeT>>> {
            let removed_existing_edges_unwrapped = removed_existing_edges.unwrap_or(true);
            let (first_nodes, second_nodes): (Vec<NodeT>, Vec<NodeT>) = [
                (first_nodes_set, first_node_types_set),
                (second_nodes_set, second_node_types_set),
            ]
            .iter()
            .map(|(node_set, node_type_set)| {
                self.iter_node_names_and_node_type_names()
                    .filter_map(|(node_id, node_name, _, node_type)| {
                        if let Some(ans) = &node_set {
                            if !ans.contains(&node_name) {
                                return None;
                            }
                        }
                        if let (Some(ants), Some(nt)) = (&node_type_set, &node_type) {
                            if nt
                                .iter()
                                .any(|node_type_name| !ants.contains(node_type_name))
                            {
                                return None;
                            }
                        }
                        Some(node_id)
                    })
                    .collect::<Vec<NodeT>>()
            })
            .collect_tuple()
            .unwrap();
            if first_nodes.is_empty() {
                return Err("The first nodes set of required bipartite graph is empty!".to_owned());
            }
            if second_nodes.is_empty() {
                return Err("The second nodes set of required bipartite graph is empty!".to_owned());
            }
            if first_nodes
                .par_iter()
                .any(|src| second_nodes.binary_search(src).is_ok())
            {
                return Err(
                    "The giving node sets of the required bipartite graph have shared nodes."
                        .to_owned(),
                );
            }
            Ok(first_nodes
                .par_iter()
                .flat_map(|src| {
                    second_nodes
                        .iter()
                        .filter_map(|dst| {
                            if removed_existing_edges_unwrapped
                                && self.has_edge_from_node_ids(*src, *dst)
                            {
                                return None;
                            }
                            Some(<[_]>::into_vec(box [*src, *dst]))
                        })
                        .collect::<Vec<Vec<NodeT>>>()
                })
                .collect())
        }
        /// Return vector of tuple of Node IDs that form the edges of the required bipartite graph.
        ///
        /// # Arguments
        /// * `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.
        /// * `first_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the first set of nodes of the graph.
        /// * `second_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the second set of nodes of the graph.
        /// * `first_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the first set of nodes of the graph.
        /// * `second_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the second set of nodes of the graph.
        pub fn get_bipartite_edge_names(
            &self,
            removed_existing_edges: Option<bool>,
            first_nodes_set: Option<HashSet<String>>,
            second_nodes_set: Option<HashSet<String>>,
            first_node_types_set: Option<HashSet<String>>,
            second_node_types_set: Option<HashSet<String>>,
        ) -> Result<Vec<Vec<String>>> {
            Ok(self
                .get_bipartite_edges(
                    removed_existing_edges,
                    first_nodes_set,
                    second_nodes_set,
                    first_node_types_set,
                    second_node_types_set,
                )?
                .iter()
                .map(|nodes| {
                    nodes
                        .iter()
                        .map(|node| unsafe { self.get_unchecked_node_name_from_node_id(*node) })
                        .collect::<Vec<String>>()
                })
                .collect::<Vec<Vec<String>>>())
        }
        /// Return vector of tuple of Node IDs that form the edges of the required star.
        ///
        /// # Arguments
        /// * `central_node`: String - Name of the node to use as center of the star.
        /// * `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.
        /// * `star_points_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the set of star points.
        /// * `star_points_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the set of star points.
        pub fn get_star_edges(
            &self,
            central_node: String,
            removed_existing_edges: Option<bool>,
            star_points_nodes_set: Option<HashSet<String>>,
            star_points_node_types_set: Option<HashSet<String>>,
        ) -> Result<Vec<Vec<NodeT>>> {
            self.get_bipartite_edges(
                removed_existing_edges,
                Some(
                    <[_]>::into_vec(box [central_node])
                        .into_iter()
                        .collect::<HashSet<String>>(),
                ),
                star_points_nodes_set,
                None,
                star_points_node_types_set,
            )
        }
        /// Return vector of tuple of Node names that form the edges of the required star.
        ///
        /// # Arguments
        /// * `central_node`: String - Name of the node to use as center of the star.
        /// * `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.
        /// * `star_points_nodes_set`: Option<HashSet<String>> - Optional set of nodes to use to create the set of star points.
        /// * `star_points_node_types_set`: Option<HashSet<String>> - Optional set of node types to create the set of star points.
        pub fn get_star_edge_names(
            &self,
            central_node: String,
            removed_existing_edges: Option<bool>,
            star_points_nodes_set: Option<HashSet<String>>,
            star_points_node_types_set: Option<HashSet<String>>,
        ) -> Result<Vec<Vec<String>>> {
            self.get_bipartite_edge_names(
                removed_existing_edges,
                Some(
                    <[_]>::into_vec(box [central_node])
                        .into_iter()
                        .collect::<HashSet<String>>(),
                ),
                star_points_nodes_set,
                None,
                star_points_node_types_set,
            )
        }
        /// Return vector of tuple of Node IDs that form the edges of the required clique.
        ///
        /// # Arguments
        /// * `directed`: Option<bool> - Whether to return the edges as directed or undirected. By default, equal to the graph.
        /// * `allow_selfloops`: Option<bool> - Whether to allow self-loops in the clique. By default, equal to the graph.
        /// * `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.
        /// * `allow_node_type_set`: Option<HashSet<String>> - Node types to include in the clique.
        /// * `allow_node_set`: Option<HashSet<String>> - Nodes to include i the clique.
        pub fn get_clique_edges(
            &self,
            directed: Option<bool>,
            allow_selfloops: Option<bool>,
            removed_existing_edges: Option<bool>,
            allow_node_type_set: Option<HashSet<String>>,
            allow_node_set: Option<HashSet<String>>,
        ) -> Vec<Vec<NodeT>> {
            let directed_unwrapped = directed.unwrap_or(self.directed);
            let allow_selfloops_unwrapped = allow_selfloops.unwrap_or_else(|| self.has_selfloops());
            let removed_existing_edges_unwrapped = removed_existing_edges.unwrap_or(true);
            let nodes: Vec<NodeT> = self
                .iter_node_names_and_node_type_names()
                .filter_map(|(node_id, node_name, _, node_type)| {
                    if let (Some(ants), Some(nt)) = (&allow_node_type_set, &node_type) {
                        if nt
                            .iter()
                            .any(|node_type_name| !ants.contains(node_type_name))
                        {
                            return None;
                        }
                    }
                    if let Some(ans) = &allow_node_set {
                        if !ans.contains(&node_name) {
                            return None;
                        }
                    }
                    Some(node_id)
                })
                .collect();
            nodes
                .par_iter()
                .flat_map(|src| {
                    nodes
                        .iter()
                        .filter_map(|dst| {
                            if !allow_selfloops_unwrapped && src == dst {
                                return None;
                            }
                            if !directed_unwrapped && src > dst {
                                return None;
                            }
                            if removed_existing_edges_unwrapped
                                && self.has_edge_from_node_ids(*src, *dst)
                            {
                                return None;
                            }
                            Some(<[_]>::into_vec(box [*src, *dst]))
                        })
                        .collect::<Vec<Vec<NodeT>>>()
                })
                .collect()
        }
        /// Return vector of tuple of Node names that form the edges of the required clique.
        ///
        /// # Arguments
        /// * `directed`: Option<bool> - Whether to return the edges as directed or undirected. By default, equal to the graph.
        /// * `allow_selfloops`: Option<bool> - Whether to allow self-loops in the clique. By default, equal to the graph.
        /// * `removed_existing_edges`: Option<bool> - Whether to filter out the existing edges. By default, true.
        /// * `allow_node_type_set`: Option<HashSet<String>> - Node types to include in the clique.
        /// * `allow_node_set`: Option<HashSet<String>> - Nodes to include i the clique.
        pub fn get_clique_edge_names(
            &self,
            directed: Option<bool>,
            allow_selfloops: Option<bool>,
            removed_existing_edges: Option<bool>,
            allow_node_type_set: Option<HashSet<String>>,
            allow_node_set: Option<HashSet<String>>,
        ) -> Vec<Vec<String>> {
            self.get_clique_edges(
                directed,
                allow_selfloops,
                removed_existing_edges,
                allow_node_type_set,
                allow_node_set,
            )
            .iter()
            .map(|nodes| {
                nodes
                    .iter()
                    .map(|node| unsafe { self.get_unchecked_node_name_from_node_id(*node) })
                    .collect::<Vec<String>>()
            })
            .collect::<Vec<Vec<String>>>()
        }
    }
}
mod edge_metrics {
    use super::types::*;
    use super::*;
    use num_traits::Pow;
    use num_traits::Zero;
    /// # Properties and measurements of the graph
    impl Graph {
        /// Returns the minumum unweighted preferential attachment score.
        ///
        /// # Safety
        /// If the graph does not contain nodes, the return value will be undefined.
        pub unsafe fn get_unchecked_minimum_preferential_attachment(&self) -> f64 {
            (self.get_unchecked_minimum_node_degree() as f64).pow(2)
        }
        /// Returns the maximum unweighted preferential attachment score.
        ///
        /// # Safety
        /// If the graph does not contain nodes, the return value will be undefined.
        pub unsafe fn get_unchecked_maximum_preferential_attachment(&self) -> f64 {
            (self.get_unchecked_maximum_node_degree() as f64).pow(2)
        }
        /// Returns the minumum weighted preferential attachment score.
        ///
        /// # Safety
        /// If the graph does not contain nodes, the return value will be undefined.
        pub unsafe fn get_unchecked_weighted_minimum_preferential_attachment(&self) -> f64 {
            (self.get_unchecked_weighted_minimum_node_degree() as f64).pow(2)
        }
        /// Returns the maximum weighted preferential attachment score.
        ///
        /// # Safety
        /// If the graph does not contain nodes, the return value will be undefined.
        pub unsafe fn get_unchecked_weighted_maximum_preferential_attachment(&self) -> f64 {
            (self.get_unchecked_weighted_maximum_node_degree() as f64).pow(2)
        }
        /// Returns the unweighted preferential attachment from the given node IDs.
        ///
        /// # Arguments
        /// * `source_node_id`: NodeT - Node ID of the first node.
        /// * `destination_node_id`: NodeT - Node ID of the second node.
        /// * `normalize`: bool - Whether to normalize within 0 to 1.
        ///
        /// # Safety
        /// If either of the provided one and two node IDs are higher than the
        /// number of nodes in the graph.
        pub unsafe fn get_unchecked_preferential_attachment_from_node_ids(
            &self,
            source_node_id: NodeT,
            destination_node_id: NodeT,
            normalize: bool,
        ) -> f64 {
            let mut preferential_attachment_score =
                self.get_unchecked_node_degree_from_node_id(source_node_id) as f64
                    * self.get_unchecked_node_degree_from_node_id(destination_node_id) as f64;
            if normalize {
                let min_preferential_attachment_score =
                    self.get_unchecked_minimum_preferential_attachment();
                let max_preferential_attachment_score =
                    self.get_unchecked_maximum_preferential_attachment();
                preferential_attachment_score = (preferential_attachment_score
                    - min_preferential_attachment_score)
                    / (max_preferential_attachment_score - min_preferential_attachment_score);
            }
            preferential_attachment_score
        }
        /// Returns the unweighted preferential attachment from the given node IDs.
        ///
        /// # Arguments
        ///
        /// * `source_node_id`: NodeT - Node ID of the first node.
        /// * `destination_node_id`: NodeT - Node ID of the second node.
        /// * `normalize`: bool - Whether to normalize by the square of maximum degree.
        ///
        /// # Raises
        /// * If either of the node IDs are higher than the number of nodes in the graph.
        pub fn get_preferential_attachment_from_node_ids(
            &self,
            source_node_id: NodeT,
            destination_node_id: NodeT,
            normalize: bool,
        ) -> Result<f64> {
            Ok(unsafe {
                self.get_unchecked_preferential_attachment_from_node_ids(
                    self.validate_node_id(source_node_id)?,
                    self.validate_node_id(destination_node_id)?,
                    normalize,
                )
            })
        }
        /// Returns the unweighted preferential attachment from the given node names.
        ///
        /// # Arguments
        ///
        /// * `first_node_name`: &str - Node name of the first node.
        /// * `second_node_name`: &str - Node name of the second node.
        /// * `normalize`: bool - Whether to normalize by the square of maximum degree.
        ///
        /// # Raises
        /// * If either of the given node names do not exist in the current graph.
        pub fn get_preferential_attachment_from_node_names(
            &self,
            first_node_name: &str,
            second_node_name: &str,
            normalize: bool,
        ) -> Result<f64> {
            Ok(unsafe {
                self.get_unchecked_preferential_attachment_from_node_ids(
                    self.get_node_id_from_node_name(first_node_name)?,
                    self.get_node_id_from_node_name(second_node_name)?,
                    normalize,
                )
            })
        }
        /// Returns the weighted preferential attachment from the given node IDs.
        ///
        /// # Arguments
        ///
        /// * `source_node_id`: NodeT - Node ID of the first node.
        /// * `destination_node_id`: NodeT - Node ID of the second node.
        /// * `normalize`: bool - Whether to normalize within 0 to 1.
        ///
        /// # Safety
        /// If either of the provided one and two node IDs are higher than the
        /// number of nodes in the graph.
        pub unsafe fn get_unchecked_weighted_preferential_attachment_from_node_ids(
            &self,
            source_node_id: NodeT,
            destination_node_id: NodeT,
            normalize: bool,
        ) -> f64 {
            let mut preferential_attachment_score = self
                .get_unchecked_weighted_node_degree_from_node_id(source_node_id)
                as f64
                * self.get_unchecked_weighted_node_degree_from_node_id(destination_node_id) as f64;
            if normalize {
                let min_preferential_attachment_score =
                    self.get_unchecked_weighted_minimum_preferential_attachment();
                let max_preferential_attachment_score =
                    self.get_unchecked_weighted_maximum_preferential_attachment();
                preferential_attachment_score = (preferential_attachment_score
                    - min_preferential_attachment_score)
                    / (max_preferential_attachment_score - min_preferential_attachment_score);
            }
            preferential_attachment_score
        }
        /// Returns the weighted preferential attachment from the given node IDs.
        ///
        /// # Arguments
        ///
        /// * `source_node_id`: NodeT - Node ID of the first node.
        /// * `destination_node_id`: NodeT - Node ID of the second node.
        /// * `normalize`: bool - Whether to normalize by the square of maximum degree.
        ///
        /// # Raises
        /// * If either of the node IDs are higher than the number of nodes in the graph.
        pub fn get_weighted_preferential_attachment_from_node_ids(
            &self,
            source_node_id: NodeT,
            destination_node_id: NodeT,
            normalize: bool,
        ) -> Result<f64> {
            self.must_have_edge_weights()?;
            Ok(unsafe {
                self.get_unchecked_weighted_preferential_attachment_from_node_ids(
                    self.validate_node_id(source_node_id)?,
                    self.validate_node_id(destination_node_id)?,
                    normalize,
                )
            })
        }
        /// Returns the weighted preferential attachment from the given node names.
        ///
        /// # Arguments
        ///
        /// * `first_node_name`: &str - Node name of the first node.
        /// * `second_node_name`: &str - Node name of the second node.
        /// * `normalize`: bool - Whether to normalize by the square of maximum degree.
        ///
        /// # Raises
        /// * If either of the given node names do not exist in the current graph.
        pub fn get_weighted_preferential_attachment_from_node_names(
            &self,
            first_node_name: &str,
            second_node_name: &str,
            normalize: bool,
        ) -> Result<f64> {
            self.must_have_edge_weights()?;
            Ok(unsafe {
                self.get_unchecked_weighted_preferential_attachment_from_node_ids(
                    self.get_node_id_from_node_name(first_node_name)?,
                    self.get_node_id_from_node_name(second_node_name)?,
                    normalize,
                )
            })
        }
        /// Returns the Jaccard index for the two given nodes from the given node IDs.
        ///
        /// # Arguments
        ///
        /// * `source_node_id`: NodeT - Node ID of the first node.
        /// * `destination_node_id`: NodeT - Node ID of the second node.
        ///
        /// # References
        /// [D. Liben-Nowell, J. Kleinberg.
        /// The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The Jaccard Index between node 1 and node 2 is {}", unsafe{ graph.get_unchecked_jaccard_coefficient_from_node_ids(1, 2) });
        /// ```
        ///
        /// # Safety
        /// If either of the provided one and two node IDs are higher than the
        /// number of nodes in the graph.
        pub unsafe fn get_unchecked_jaccard_coefficient_from_node_ids(
            &self,
            source_node_id: NodeT,
            destination_node_id: NodeT,
        ) -> f64 {
            self.iter_unchecked_neighbour_node_ids_intersection_from_source_node_ids(
                source_node_id,
                destination_node_id,
            )
            .count() as f64
                / self
                    .iter_unchecked_neighbour_node_ids_union_from_source_node_ids(
                        source_node_id,
                        destination_node_id,
                    )
                    .count() as f64
        }
        /// Returns the Jaccard index for the two given nodes from the given node IDs.
        ///
        /// # Arguments
        ///
        /// * `source_node_id`: NodeT - Node ID of the first node.
        /// * `destination_node_id`: NodeT - Node ID of the second node.
        ///
        /// # References
        /// [D. Liben-Nowell, J. Kleinberg.
        /// The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The Jaccard Index between node 1 and node 2 is {}", graph.get_jaccard_coefficient_from_node_ids(1, 2).unwrap());
        /// ```
        ///
        /// # Raises
        /// * If either of the node IDs are higher than the number of nodes in the graph.
        pub fn get_jaccard_coefficient_from_node_ids(
            &self,
            source_node_id: NodeT,
            destination_node_id: NodeT,
        ) -> Result<f64> {
            Ok(unsafe {
                self.get_unchecked_jaccard_coefficient_from_node_ids(
                    self.validate_node_id(source_node_id)?,
                    self.validate_node_id(destination_node_id)?,
                )
            })
        }
        /// Returns the Jaccard index for the two given nodes from the given node names.
        ///
        /// # Arguments
        ///
        /// * `first_node_name`: &str - Node name of the first node.
        /// * `second_node_name`: &str - Node name of the second node.
        ///
        /// # References
        /// [D. Liben-Nowell, J. Kleinberg.
        /// The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)
        ///
        /// # Raises
        /// * If either of the given node names do not exist in the current graph.
        pub fn get_jaccard_coefficient_from_node_names(
            &self,
            first_node_name: &str,
            second_node_name: &str,
        ) -> Result<f64> {
            Ok(unsafe {
                self.get_unchecked_jaccard_coefficient_from_node_ids(
                    self.get_node_id_from_node_name(first_node_name)?,
                    self.get_node_id_from_node_name(second_node_name)?,
                )
            })
        }
        /// Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.
        ///
        /// # Arguments
        ///
        /// * `source_node_id`: NodeT - Node ID of the first node.
        /// * `destination_node_id`: NodeT - Node ID of the second node.
        ///
        /// # Implementation details
        /// Since the Adamic/Adar Index is only defined for graph not containing
        /// node traps (nodes without any outbound edge) and must support all kind
        /// of graphs, the sinks node are excluded from
        /// the computation because they would result in an infinity.
        ///
        /// # References
        /// [D. Liben-Nowell, J. Kleinberg.
        /// The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)
        ///
        /// # Safety
        /// If either of the provided one and two node IDs are higher than the
        /// number of nodes in the graph.
        pub unsafe fn get_unchecked_adamic_adar_index_from_node_ids(
            &self,
            source_node_id: NodeT,
            destination_node_id: NodeT,
        ) -> f64 {
            self.iter_unchecked_neighbour_node_ids_intersection_from_source_node_ids(
                source_node_id,
                destination_node_id,
            )
            .map(|node_id| self.get_unchecked_node_degree_from_node_id(node_id))
            .filter(|&node_degree| node_degree > 1)
            .map(|node_degree| 1.0 / (node_degree as f64).ln())
            .sum()
        }
        /// Returns the Adamic/Adar Index for the given pair of nodes from the given node IDs.
        ///
        /// # Arguments
        ///
        /// * `source_node_id`: NodeT - Node ID of the first node.
        /// * `destination_node_id`: NodeT - Node ID of the second node.
        ///
        /// # Implementation details
        /// Since the Adamic/Adar Index is only defined for graph not containing
        /// node traps (nodes without any outbound edge) and must support all kind
        /// of graphs, the sinks node are excluded from
        /// the computation because they would result in an infinity.
        ///
        /// # References
        /// [D. Liben-Nowell, J. Kleinberg.
        /// The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)
        ///
        /// # Raises
        /// * If either of the node IDs are higher than the number of nodes in the graph.
        pub fn get_adamic_adar_index_from_node_ids(
            &self,
            source_node_id: NodeT,
            destination_node_id: NodeT,
        ) -> Result<f64> {
            Ok(unsafe {
                self.get_unchecked_adamic_adar_index_from_node_ids(
                    self.validate_node_id(source_node_id)?,
                    self.validate_node_id(destination_node_id)?,
                )
            })
        }
        /// Returns the Adamic/Adar Index for the given pair of nodes from the given node names.
        ///
        /// # Arguments
        ///
        /// * `first_node_name`: &str - Node name of the first node.
        /// * `second_node_name`: &str - Node name of the second node.
        ///
        /// # Implementation details
        /// Since the Adamic/Adar Index is only defined for graph not containing
        /// node traps (nodes without any outbound edge) and must support all kind
        /// of graphs, the sinks node are excluded from
        /// the computation because they would result in an infinity.
        ///
        /// # References
        /// [D. Liben-Nowell, J. Kleinberg.
        /// The Link Prediction Problem for Social Networks (2004).](http://www.cs.cornell.edu/home/kleinber/link-pred.pdf)
        ///
        /// # Raises
        /// * If either of the given node names do not exist in the current graph.
        pub fn get_adamic_adar_index_from_node_names(
            &self,
            first_node_name: &str,
            second_node_name: &str,
        ) -> Result<f64> {
            Ok(unsafe {
                self.get_unchecked_adamic_adar_index_from_node_ids(
                    self.get_node_id_from_node_name(first_node_name)?,
                    self.get_node_id_from_node_name(second_node_name)?,
                )
            })
        }
        /// Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.
        ///
        /// # Arguments
        ///
        /// * `source_node_id`: NodeT - Node ID of the first node.
        /// * `destination_node_id`: NodeT - Node ID of the second node.
        ///
        /// # References
        /// [T. Zhou, L. Lu, Y.-C. Zhang.
        /// Predicting missing links via local information.
        /// Eur. Phys. J. B 71 (2009) 623.](http://arxiv.org/pdf/0901.0553.pdf)
        ///
        /// # Implementation details
        /// Since the Resource Allocation Index is only defined for graph not
        /// containing node traps (nodes without any outbound edge) and
        /// must support all kind of graphs, the sinks node are excluded from
        /// the computation because they would result in an infinity.
        ///
        /// # Safety
        /// If either of the provided one and two node IDs are higher than the
        /// number of nodes in the graph.
        pub unsafe fn get_unchecked_resource_allocation_index_from_node_ids(
            &self,
            source_node_id: NodeT,
            destination_node_id: NodeT,
        ) -> f64 {
            self.iter_unchecked_neighbour_node_ids_intersection_from_source_node_ids(
                source_node_id,
                destination_node_id,
            )
            .map(|node_id| self.get_unchecked_node_degree_from_node_id(node_id))
            .filter(|&node_degree| node_degree > 0)
            .map(|node_degree| 1.0 / node_degree as f64)
            .sum()
        }
        /// Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.
        ///
        /// # Arguments
        ///
        /// * `source_node_id`: NodeT - Node ID of the first node.
        /// * `destination_node_id`: NodeT - Node ID of the second node.
        ///
        /// # References
        /// [T. Zhou, L. Lu, Y.-C. Zhang.
        /// Predicting missing links via local information.
        /// Eur. Phys. J. B 71 (2009) 623.](http://arxiv.org/pdf/0901.0553.pdf)
        ///
        /// # Implementation details
        /// Since the Resource Allocation Index is only defined for graph not
        /// containing node traps (nodes without any outbound edge) and
        /// must support all kind of graphs, the sinks node are excluded from
        /// the computation because they would result in an infinity.
        ///
        /// # Safety
        /// If either of the provided one and two node IDs are higher than the
        /// number of nodes in the graph.
        pub unsafe fn get_unchecked_weighted_resource_allocation_index_from_node_ids(
            &self,
            source_node_id: NodeT,
            destination_node_id: NodeT,
        ) -> f64 {
            self.iter_unchecked_neighbour_node_ids_intersection_from_source_node_ids(
                source_node_id,
                destination_node_id,
            )
            .map(|node_id| self.get_unchecked_weighted_node_degree_from_node_id(node_id))
            .filter(|&node_degree| !node_degree.is_zero())
            .map(|node_degree| 1.0 / node_degree as f64)
            .sum()
        }
        /// Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node IDs.
        ///
        /// # Arguments
        ///
        /// * `source_node_id`: NodeT - Node ID of the first node.
        /// * `destination_node_id`: NodeT - Node ID of the second node.
        ///
        /// # References
        /// [T. Zhou, L. Lu, Y.-C. Zhang.
        /// Predicting missing links via local information.
        /// Eur. Phys. J. B 71 (2009) 623.](http://arxiv.org/pdf/0901.0553.pdf)
        ///
        /// # Implementation details
        /// Since the Resource Allocation Index is only defined for graph not
        /// containing node traps (nodes without any outbound edge) and
        /// must support all kind of graphs, the sinks node are excluded from
        /// the computation because they would result in an infinity.
        ///
        /// # Raises
        /// * If either of the node IDs are higher than the number of nodes in the graph.
        pub fn get_resource_allocation_index_from_node_ids(
            &self,
            source_node_id: NodeT,
            destination_node_id: NodeT,
        ) -> Result<f64> {
            Ok(unsafe {
                self.get_unchecked_resource_allocation_index_from_node_ids(
                    self.validate_node_id(source_node_id)?,
                    self.validate_node_id(destination_node_id)?,
                )
            })
        }
        /// Returns the unweighted Resource Allocation Index for the given pair of nodes from the given node names.
        ///
        /// # Arguments
        ///
        /// * `first_node_name`: &str - Node name of the first node.
        /// * `second_node_name`: &str - Node name of the second node.
        ///
        /// # References
        /// [T. Zhou, L. Lu, Y.-C. Zhang.
        /// Predicting missing links via local information.
        /// Eur. Phys. J. B 71 (2009) 623.](http://arxiv.org/pdf/0901.0553.pdf)
        ///
        /// # Implementation details
        /// Since the Resource Allocation Index is only defined for graph not
        /// containing node traps (nodes without any outbound edge) and
        /// must support all kind of graphs, the sinks node are excluded from
        /// the computation because they would result in an infinity.
        ///
        /// # Raises
        /// * If either of the given node names do not exist in the current graph.
        pub fn get_resource_allocation_index_from_node_names(
            &self,
            first_node_name: &str,
            second_node_name: &str,
        ) -> Result<f64> {
            Ok(unsafe {
                self.get_unchecked_resource_allocation_index_from_node_ids(
                    self.get_node_id_from_node_name(first_node_name)?,
                    self.get_node_id_from_node_name(second_node_name)?,
                )
            })
        }
        /// Returns the weighted Resource Allocation Index for the given pair of nodes from the given node IDs.
        ///
        /// # Arguments
        ///
        /// * `source_node_id`: NodeT - Node ID of the first node.
        /// * `destination_node_id`: NodeT - Node ID of the second node.
        ///
        /// # References
        /// [T. Zhou, L. Lu, Y.-C. Zhang.
        /// Predicting missing links via local information.
        /// Eur. Phys. J. B 71 (2009) 623.](http://arxiv.org/pdf/0901.0553.pdf)
        ///
        /// # Implementation details
        /// Since the Resource Allocation Index is only defined for graph not
        /// containing node traps (nodes without any outbound edge) and
        /// must support all kind of graphs, the sinks node are excluded from
        /// the computation because they would result in an infinity.
        ///
        /// # Raises
        /// * If either of the node IDs are higher than the number of nodes in the graph.
        pub fn get_weighted_resource_allocation_index_from_node_ids(
            &self,
            source_node_id: NodeT,
            destination_node_id: NodeT,
        ) -> Result<f64> {
            self.must_have_edge_weights()?;
            Ok(unsafe {
                self.get_unchecked_weighted_resource_allocation_index_from_node_ids(
                    self.validate_node_id(source_node_id)?,
                    self.validate_node_id(destination_node_id)?,
                )
            })
        }
        /// Returns the weighted Resource Allocation Index for the given pair of nodes from the given node names.
        ///
        /// # Arguments
        ///
        /// * `first_node_name`: &str - Node name of the first node.
        /// * `second_node_name`: &str - Node name of the second node.
        ///
        /// # References
        /// [T. Zhou, L. Lu, Y.-C. Zhang.
        /// Predicting missing links via local information.
        /// Eur. Phys. J. B 71 (2009) 623.](http://arxiv.org/pdf/0901.0553.pdf)
        ///
        /// # Implementation details
        /// Since the Resource Allocation Index is only defined for graph not
        /// containing node traps (nodes without any outbound edge) and
        /// must support all kind of graphs, the sinks node are excluded from
        /// the computation because they would result in an infinity.
        ///
        /// # Raises
        /// * If either of the given node names do not exist in the current graph.
        pub fn get_weighted_resource_allocation_index_from_node_names(
            &self,
            first_node_name: &str,
            second_node_name: &str,
        ) -> Result<f64> {
            self.must_have_edge_weights()?;
            Ok(unsafe {
                self.get_unchecked_weighted_resource_allocation_index_from_node_ids(
                    self.get_node_id_from_node_name(first_node_name)?,
                    self.get_node_id_from_node_name(second_node_name)?,
                )
            })
        }
        /// Returns all the implemented edge metrics for the two given node IDs.
        ///
        /// Specifically, the returned values are:
        /// * Adamic Adar
        /// * Jaccard coefficient
        /// * Resource allocation index
        /// * Preferential attachment
        ///
        /// # Arguments
        /// * `source_node_id`: NodeT - Node ID of the first node.
        /// * `destination_node_id`: NodeT - Node ID of the second node.
        /// * `normalize`: bool - Whether to normalize within 0 to 1.
        ///
        /// # Safety
        /// If the given node IDs do not exist in the graph this method will panic.
        pub unsafe fn get_unchecked_all_edge_metrics_from_node_ids(
            &self,
            source_node_id: NodeT,
            destination_node_id: NodeT,
            normalize: bool,
        ) -> Vec<f64> {
            <[_]>::into_vec(box [
                self.get_unchecked_adamic_adar_index_from_node_ids(
                    source_node_id,
                    destination_node_id,
                ),
                self.get_unchecked_jaccard_coefficient_from_node_ids(
                    source_node_id,
                    destination_node_id,
                ),
                self.get_unchecked_resource_allocation_index_from_node_ids(
                    source_node_id,
                    destination_node_id,
                ),
                self.get_unchecked_preferential_attachment_from_node_ids(
                    source_node_id,
                    destination_node_id,
                    normalize,
                ),
            ])
        }
    }
}
mod filters {
    use super::*;
    use indicatif::ProgressIterator;
    impl Graph {
        /// Returns a **NEW** Graph that does not have the required attributes.
        ///
        /// # Arguments
        /// * `node_ids_to_keep`: Option<Vec<NodeT>> - List of node IDs to keep during filtering.
        /// * `node_ids_to_filter`: Option<Vec<NodeT>> - List of node IDs to remove during filtering.
        /// * `node_type_ids_to_keep`: Option<Vec<Option<Vec<NodeTypeT>>>> - List of node type IDs to keep during filtering. The node types must match entirely the given node types vector provided.
        /// * `node_type_ids_to_filter`: Option<Vec<Option<Vec<NodeTypeT>>>> - List of node type IDs to remove during filtering. The node types must match entirely the given node types vector provided.
        /// * `node_type_id_to_keep`: Option<Vec<Option<NodeTypeT>>> - List of node type IDs to keep during filtering. Any of node types must match with one of the node types given.
        /// * `node_type_id_to_filter`: Option<Vec<Option<NodeTypeT>>> - List of node type IDs to remove during filtering. Any of node types must match with one of the node types given.
        /// * `edge_ids_to_keep`: Option<Vec<EdgeT>> - List of edge IDs to keep during filtering.
        /// * `edge_ids_to_filter`: Option<Vec<EdgeT>> - List of edge IDs to remove during filtering.
        /// * `edge_node_ids_to_keep`: Option<Vec<(NodeT, NodeT)>> - List of tuple of node IDs to keep during filtering.
        /// * `edge_node_ids_to_filter`: Option<Vec<(NodeT, NodeT)>> - List of tuple of node IDs to remove during filtering.
        /// * `edge_type_ids_to_keep`: Option<Vec<Option<EdgeTypeT>>> - List of edge type IDs to keep during filtering.
        /// * `edge_type_ids_to_filter`: Option<Vec<Option<EdgeTypeT>>> - List of edge type IDs to remove during filtering.
        /// * `min_edge_weight`: Option<WeightT> - Minimum edge weight. Values lower than this are removed.
        /// * `max_edge_weight`: Option<WeightT> - Maximum edge weight. Values higher than this are removed.
        /// * `filter_singleton_nodes`: Option<bool> - Whether to filter out singleton nodes.
        /// * `filter_singleton_nodes_with_selfloop`: Option<bool> - Whether to filter out singleton nodes with selfloops.
        /// * `filter_selfloops`: Option<bool> - Whether to filter out selfloops.
        /// * `filter_parallel_edges`: Option<bool> - Whether to filter out parallel edges.
        /// * `verbose`: Option<bool> - Whether to show loading bar while building the graphs.
        ///
        /// ## Implementation details
        ///
        /// ### How the collapse of multigraphs is handled
        /// We keep only the first edge when a multigraph is collapsed while removing
        /// the edge types, in the order provided when first reading from the CSV file.
        ///
        /// ### Generation of new singleton nodes when removing edges
        /// Some of the remove operations allowed in this method might lead to the
        /// generation of new singleton nodes that will not be handled within this
        /// function call even if you provide the flag singletons to true, but you
        /// will need to call the method again if you want to get reed of also those
        /// newly created singleton nodes.
        ///
        pub fn filter_from_ids(
            &self,
            node_ids_to_keep: Option<Vec<NodeT>>,
            node_ids_to_filter: Option<Vec<NodeT>>,
            node_type_ids_to_keep: Option<Vec<Option<Vec<NodeTypeT>>>>,
            node_type_ids_to_filter: Option<Vec<Option<Vec<NodeTypeT>>>>,
            node_type_id_to_keep: Option<Vec<Option<NodeTypeT>>>,
            node_type_id_to_filter: Option<Vec<Option<NodeTypeT>>>,
            edge_ids_to_keep: Option<Vec<EdgeT>>,
            edge_ids_to_filter: Option<Vec<EdgeT>>,
            edge_node_ids_to_keep: Option<Vec<(NodeT, NodeT)>>,
            edge_node_ids_to_filter: Option<Vec<(NodeT, NodeT)>>,
            edge_type_ids_to_keep: Option<Vec<Option<EdgeTypeT>>>,
            edge_type_ids_to_filter: Option<Vec<Option<EdgeTypeT>>>,
            min_edge_weight: Option<WeightT>,
            max_edge_weight: Option<WeightT>,
            filter_singleton_nodes: Option<bool>,
            filter_singleton_nodes_with_selfloop: Option<bool>,
            filter_selfloops: Option<bool>,
            filter_parallel_edges: Option<bool>,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            if !self.is_directed() && (edge_ids_to_keep.is_some() || edge_ids_to_filter.is_some()) {
                return Err ("It is not possible to filter by edge ids on an undirected graph as the resulting graph may become a directed graph.\nIf you still want to remove this edges, convert the graph to directed by using `to_directed` or `to_directed_inplace`." . to_string ()) ;
            }
            let filter_singleton_nodes = filter_singleton_nodes.unwrap_or(false);
            let filter_singleton_nodes_with_selfloop =
                filter_singleton_nodes_with_selfloop.unwrap_or(false);
            let filter_selfloops = filter_selfloops.unwrap_or(false);
            let filter_parallel_edges = filter_parallel_edges.unwrap_or(false);
            let verbose = verbose.unwrap_or(true);
            let pb_edges = get_loading_bar(
                verbose,
                {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Building edges of graph ", " without required attributes"],
                        &match (&self.name,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                .as_ref(),
                self.get_directed_edges_number() as usize,
            );
            let pb_nodes = get_loading_bar(
                verbose,
                {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Building nodes of graph ", " without required attributes"],
                        &match (&self.name,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                .as_ref(),
                self.get_nodes_number() as usize,
            );
            let has_node_filters = self.has_nodes()
                && [
                    node_ids_to_keep.is_some(),
                    node_ids_to_filter.is_some(),
                    node_type_ids_to_keep.is_some(),
                    node_type_ids_to_filter.is_some(),
                    node_type_id_to_keep.is_some(),
                    node_type_id_to_filter.is_some(),
                    filter_singleton_nodes && self.has_singleton_nodes(),
                    filter_singleton_nodes_with_selfloop
                        && self.has_singleton_nodes_with_selfloops(),
                ]
                .iter()
                .any(|value| *value);
            let has_edge_filters = self.has_edges()
                && [
                    edge_ids_to_keep.is_some(),
                    edge_ids_to_filter.is_some(),
                    edge_node_ids_to_keep.is_some(),
                    edge_node_ids_to_filter.is_some(),
                    edge_type_ids_to_keep.is_some(),
                    edge_type_ids_to_filter.is_some(),
                    (min_edge_weight.is_some() || max_edge_weight.is_some())
                        && self.has_edge_weights(),
                    filter_selfloops && self.has_selfloops(),
                    filter_parallel_edges && self.is_multigraph(),
                    filter_singleton_nodes_with_selfloop
                        && self.has_singleton_nodes_with_selfloops(),
                ]
                .iter()
                .any(|value| *value);
            let min_edge_weight = min_edge_weight.unwrap_or(WeightT::NEG_INFINITY);
            let max_edge_weight = max_edge_weight.unwrap_or(WeightT::INFINITY);
            let mut last_edge: Option<(NodeT, NodeT)> = None;
            let mut edge_filter = |(edge_id, src, dst, edge_type_id, weight): &(
                EdgeT,
                NodeT,
                NodeT,
                Option<EdgeTypeT>,
                Option<WeightT>,
            )| {
                let result = edge_ids_to_keep
                    .as_ref()
                    .map_or(true, |edge_ids| edge_ids.contains(edge_id))
                    && edge_ids_to_filter
                        .as_ref()
                        .map_or(true, |edge_ids| !edge_ids.contains(edge_id))
                    && (!filter_parallel_edges
                        || last_edge.as_ref().map_or(true, |(last_src, last_dst)| {
                            *last_dst != *dst || *last_src != *src
                        }))
                    && (!filter_selfloops || src != dst)
                    && (!filter_singleton_nodes_with_selfloop
                        || src != dst
                        || !self.is_singleton_with_selfloops_from_node_id(*src))
                    && edge_node_ids_to_keep
                        .as_ref()
                        .map_or(true, |edge_node_ids| {
                            edge_node_ids.contains(&(*src, *dst))
                                || !self.is_directed() && edge_node_ids.contains(&(*dst, *src))
                        })
                    && !edge_node_ids_to_filter
                        .as_ref()
                        .map_or(false, |edge_node_ids| {
                            edge_node_ids.contains(&(*src, *dst))
                                || !self.is_directed() && edge_node_ids.contains(&(*dst, *src))
                        })
                    && edge_type_ids_to_keep
                        .as_ref()
                        .map_or(true, |ntitk| ntitk.contains(edge_type_id))
                    && edge_type_ids_to_filter
                        .as_ref()
                        .map_or(true, |ntitf| !ntitf.contains(edge_type_id))
                    && weight.map_or(true, |weight| {
                        weight >= min_edge_weight && weight <= max_edge_weight
                    });
                last_edge.replace((*src, *dst));
                result
            };
            let node_filter = |(node_id, _, node_type_ids, _): &(
                NodeT,
                String,
                Option<Vec<NodeTypeT>>,
                Option<Vec<String>>,
            )| {
                node_ids_to_keep
                    .as_ref()
                    .map_or(true, |nitk| nitk.contains(node_id))
                    && node_ids_to_filter
                        .as_ref()
                        .map_or(true, |nitf| !nitf.contains(node_id))
                    && node_type_ids_to_keep
                        .as_ref()
                        .map_or(true, |ntitk| ntitk.contains(node_type_ids))
                    && node_type_ids_to_filter
                        .as_ref()
                        .map_or(true, |ntitf| !ntitf.contains(node_type_ids))
                    && node_type_id_to_keep
                        .as_ref()
                        .map_or(true, |ntitk| match node_type_ids {
                            Some(node_type_ids) => node_type_ids
                                .iter()
                                .any(|node_type_id| ntitk.contains(&Some(*node_type_id))),
                            None => ntitk.contains(&None),
                        })
                    && !node_type_id_to_filter
                        .as_ref()
                        .map_or(false, |ntitf| match node_type_ids {
                            Some(node_type_ids) => node_type_ids
                                .iter()
                                .any(|node_type_id| ntitf.contains(&Some(*node_type_id))),
                            None => ntitf.contains(&None),
                        })
                    && !(filter_singleton_nodes
                        && unsafe { self.is_unchecked_singleton_from_node_id(*node_id) })
                    && !(filter_singleton_nodes
                        && filter_selfloops
                        && self.is_singleton_with_selfloops_from_node_id(*node_id))
                    && (!filter_singleton_nodes_with_selfloop
                        || !self.is_singleton_with_selfloops_from_node_id(*node_id))
            };
            let mut edges_number = self.get_directed_edges_number();
            if filter_parallel_edges {
                edges_number -= self.get_parallel_edges_number();
                if filter_selfloops {
                    edges_number -= self.get_unique_selfloop_number() as EdgeT;
                }
            } else if filter_selfloops {
                edges_number -= self.get_selfloop_number();
            }
            match (has_node_filters, has_edge_filters) {
                (false, false) => Ok(self.clone()),
                (false, true) => Graph::from_integer_sorted(
                    self.iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)
                        .progress_with(pb_edges)
                        .filter(edge_filter)
                        .map(|(_, src, dst, edge_type, weight)| Ok((src, dst, edge_type, weight))),
                    edges_number as usize,
                    self.nodes.clone(),
                    self.node_types.clone(),
                    self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                    self.directed,
                    true,
                    self.get_name(),
                    false,
                    self.has_edge_types(),
                    self.has_edge_weights(),
                    false,
                    true,
                    self.has_selfloops() && !filter_selfloops,
                    true,
                ),
                (true, _) => Graph::from_string_unsorted(
                    self.iter_edge_node_names_and_edge_type_name_and_edge_weight(true)
                        .progress_with(pb_edges)
                        .filter(
                            |(edge_id, src, src_name, dst, dst_name, edge_type, _, weight)| unsafe {
                                edge_filter(&(*edge_id, *src, *dst, *edge_type, *weight))
                                    && node_filter(&(
                                        *src,
                                        src_name.clone(),
                                        self.get_unchecked_node_type_id_from_node_id(*src),
                                        None,
                                    ))
                                    && node_filter(&(
                                        *dst,
                                        dst_name.clone(),
                                        self.get_unchecked_node_type_id_from_node_id(*dst),
                                        None,
                                    ))
                            },
                        )
                        .map(|(_, _, src_name, _, dst_name, _, edge_type_name, weight)| {
                            Ok((src_name, dst_name, edge_type_name, weight))
                        }),
                    Some(
                        self.iter_node_names_and_node_type_names()
                            .progress_with(pb_nodes)
                            .filter(node_filter)
                            .map(|(_, node_name, _, node_types)| Ok((node_name, node_types))),
                    ),
                    self.is_directed(),
                    true,
                    self.get_name(),
                    false,
                    true,
                    false,
                    true,
                    false,
                    false,
                    false,
                    false,
                    self.has_node_types(),
                    self.has_edge_types(),
                    self.has_edge_weights(),
                    false,
                    true,
                    self.has_selfloops() && !filter_selfloops,
                    true,
                    verbose,
                ),
            }
        }
        /// Returns a **NEW** Graph that does not have the required attributes.
        ///
        /// # Arguments
        /// * `node_names_to_keep`: Option<Vec<&str>> - List of node names to keep during filtering.
        /// * `node_names_to_filter`: Option<Vec<&str>> - List of node names to remove during filtering.
        /// * `node_type_names_to_keep`: Option<Vec<Option<Vec<&str>>>> - List of node type names to keep during filtering. The node types must match entirely the given node types vector provided.
        /// * `node_type_names_to_filter`: Option<Vec<Option<Vec<&str>>>> - List of node type names to remove during filtering. The node types must match entirely the given node types vector provided.
        /// * `node_type_name_to_keep`: Option<Vec<Option<String>>> - List of node type name to keep during filtering. Any of node types must match with one of the node types given.
        /// * `node_type_name_to_filter`: Option<Vec<Option<String>>> - List of node type name to remove during filtering. Any of node types must match with one of the node types given.
        /// * `edge_node_names_to_keep`: Option<Vec<(&str, &str)>> - List of tuple of node names to keep during filtering.
        /// * `edge_node_names_to_filter`: Option<Vec<(&str, &str)>> - List of tuple of node names to remove during filtering.
        /// * `edge_type_names_to_keep`: Option<Vec<Option<String>>> - List of edge type names to keep during filtering.
        /// * `edge_type_names_to_filter`: Option<Vec<Option<String>>> - List of edge type names to remove during filtering.
        /// * `min_edge_weight`: Option<WeightT> - Minimum edge weight. Values lower than this are removed.
        /// * `max_edge_weight`: Option<WeightT> - Maximum edge weight. Values higher than this are removed.
        /// * `filter_singleton_nodes`: Option<bool> - Whether to filter out singletons.
        /// * `filter_singleton_nodes_with_selfloop`: Option<bool> - Whether to filter out singleton nodes with selfloops.
        /// * `filter_selfloops`: Option<bool> - Whether to filter out selfloops.
        /// * `filter_parallel_edges`: Option<bool> - Whether to filter out parallel edges.
        /// * `verbose`: Option<bool> - Whether to show loading bar while building the graphs.
        ///
        /// ## Implementation details
        ///
        /// ### How the collapse of multigraphs is handled
        /// We keep only the first edge when a multigraph is collapsed while removing
        /// the edge types, in the order provided when first reading from the CSV file.
        ///
        /// ### Generation of new singleton nodes when removing edges
        /// Some of the remove operations allowed in this method might lead to the
        /// generation of new singleton nodes that will not be handled within this
        /// function call even if you provide the flag singletons to true, but you
        /// will need to call the method again if you want to get reed of also those
        /// newly created singleton nodes.
        ///
        pub fn filter_from_names(
            &self,
            node_names_to_keep: Option<Vec<&str>>,
            node_names_to_filter: Option<Vec<&str>>,
            node_type_names_to_keep: Option<Vec<Option<Vec<&str>>>>,
            node_type_names_to_filter: Option<Vec<Option<Vec<&str>>>>,
            node_type_name_to_keep: Option<Vec<Option<String>>>,
            node_type_name_to_filter: Option<Vec<Option<String>>>,
            edge_node_names_to_keep: Option<Vec<(&str, &str)>>,
            edge_node_names_to_filter: Option<Vec<(&str, &str)>>,
            edge_type_names_to_keep: Option<Vec<Option<String>>>,
            edge_type_names_to_filter: Option<Vec<Option<String>>>,
            min_edge_weight: Option<WeightT>,
            max_edge_weight: Option<WeightT>,
            filter_singleton_nodes: Option<bool>,
            filter_singleton_nodes_with_selfloop: Option<bool>,
            filter_selfloops: Option<bool>,
            filter_parallel_edges: Option<bool>,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            self.filter_from_ids(
                node_names_to_keep.map_or(Ok::<_, String>(None), |nntk| {
                    Ok(Some(self.get_node_ids_from_node_names(nntk)?))
                })?,
                node_names_to_filter.map_or(Ok::<_, String>(None), |nntf| {
                    Ok(Some(self.get_node_ids_from_node_names(nntf)?))
                })?,
                node_type_names_to_keep.map_or(Ok::<_, String>(None), |ntntk| {
                    Ok(Some(
                        self.get_multiple_node_type_ids_from_node_type_names(ntntk)?,
                    ))
                })?,
                node_type_names_to_filter.map_or(Ok::<_, String>(None), |ntntf| {
                    Ok(Some(
                        self.get_multiple_node_type_ids_from_node_type_names(ntntf)?,
                    ))
                })?,
                node_type_name_to_keep.map_or(Ok::<_, String>(None), |ntntf| {
                    Ok(Some(self.get_node_type_ids_from_node_type_names(ntntf)?))
                })?,
                node_type_name_to_filter.map_or(Ok::<_, String>(None), |ntntf| {
                    Ok(Some(self.get_node_type_ids_from_node_type_names(ntntf)?))
                })?,
                None,
                None,
                edge_node_names_to_keep.map_or(Ok::<_, String>(None), |enntk| {
                    Ok(Some(self.get_edge_node_ids_from_edge_node_names(enntk)?))
                })?,
                edge_node_names_to_filter.map_or(Ok::<_, String>(None), |enntf| {
                    Ok(Some(self.get_edge_node_ids_from_edge_node_names(enntf)?))
                })?,
                edge_type_names_to_keep.map_or(Ok::<_, String>(None), |etnk| {
                    Ok(Some(self.get_edge_type_ids_from_edge_type_names(etnk)?))
                })?,
                edge_type_names_to_filter.map_or(Ok::<_, String>(None), |etnf| {
                    Ok(Some(self.get_edge_type_ids_from_edge_type_names(etnf)?))
                })?,
                min_edge_weight,
                max_edge_weight,
                filter_singleton_nodes,
                filter_singleton_nodes_with_selfloop,
                filter_selfloops,
                filter_parallel_edges,
                verbose,
            )
        }
        /// Returns new graph without unknown node types and relative nodes.
        ///
        /// Note that this method will remove ALL nodes labeled with unknown node
        /// type!
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        pub fn drop_unknown_node_types(&self, verbose: Option<bool>) -> Graph {
            self.filter_from_ids(
                None,
                None,
                None,
                None,
                None,
                Some(<[_]>::into_vec(box [None])),
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                verbose,
            )
            .unwrap()
        }
        /// Returns new graph without unknown edge types and relative edges.
        ///
        /// Note that this method will remove ALL edges labeled with unknown edge
        /// type!
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        pub fn drop_unknown_edge_types(&self, verbose: Option<bool>) -> Graph {
            self.filter_from_ids(
                None,
                None,
                None,
                None,
                None,
                Some(<[_]>::into_vec(box [None])),
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                verbose,
            )
            .unwrap()
        }
        /// Returns new graph without singleton nodes.
        ///
        /// A node is singleton when does not have neither incoming or outgoing edges.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        pub fn drop_singleton_nodes(&self, verbose: Option<bool>) -> Graph {
            self.filter_from_ids(
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                Some(true),
                None,
                None,
                None,
                verbose,
            )
            .unwrap()
        }
        /// Returns new graph without singleton nodes with selfloops.
        ///
        /// A node is singleton with selfloop when does not have neither incoming or outgoing edges.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        pub fn drop_singleton_nodes_with_selfloops(&self, verbose: Option<bool>) -> Graph {
            self.filter_from_ids(
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                Some(true),
                None,
                None,
                verbose,
            )
            .unwrap()
        }
        /// Returns new graph without disconnected nodes.
        ///
        /// A disconnected node is a node with no connection to any other node.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        pub fn drop_disconnected_nodes(&self, verbose: Option<bool>) -> Graph {
            self.filter_from_ids(
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                Some(true),
                Some(true),
                None,
                None,
                verbose,
            )
            .unwrap()
        }
        /// Returns new graph without selfloops.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        pub fn drop_selfloops(&self, verbose: Option<bool>) -> Graph {
            self.filter_from_ids(
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                Some(true),
                None,
                verbose,
            )
            .unwrap()
        }
        /// Returns new graph without parallel edges.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        pub fn drop_parallel_edges(&self, verbose: Option<bool>) -> Graph {
            self.filter_from_ids(
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                Some(true),
                verbose,
            )
            .unwrap()
        }
    }
}
mod getters {
    use super::*;
    use counter::Counter;
    use log::info;
    use rayon::prelude::*;
    use std::collections::HashMap;
    /// # Getters
    /// The naming convention we follow is:
    /// * `/get_(.+)/`
    ///
    /// The naming convention for unchecked methods follows:
    /// * `/get_(.+)_unchecked/`
    impl Graph {
        /// Returns number a triple with (number of components, number of nodes of the smallest component, number of nodes of the biggest component )
        ///
        /// # Arguments
        ///
        /// * `verbose`: Option<bool> - Whether to show a loading bar or not.
        pub fn get_connected_components_number(
            &self,
            verbose: Option<bool>,
        ) -> (NodeT, NodeT, NodeT) {
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &["Computing connected components number."],
                            &match () {
                                () => [],
                            },
                        ),
                        lvl,
                        &("graph::getters", "graph::getters", "src/getters.rs", 20u32),
                    );
                }
            };
            if self.directed {
                let (_, _, components_number, min_component_size, max_component_size) =
                    self.spanning_arborescence_kruskal(verbose);
                (components_number, min_component_size, max_component_size)
            } else {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        :: log :: __private_api_log (:: core :: fmt :: Arguments :: new_v1 (& ["Executing undirected parallel version of connected components."] , & match () { () => [] , }) , lvl , & ("graph::getters" , "graph::getters" , "src/getters.rs" , 26u32)) ;
                    }
                };
                let (_, components_number, min_component_size, max_component_size) =
                    self.connected_components(verbose).unwrap();
                (components_number, min_component_size, max_component_size)
            }
        }
        /// Returns number of singleton nodes within the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The graph contains {} singleton nodes", graph.get_singleton_nodes_number());
        /// ```
        pub fn get_singleton_nodes_number(&self) -> NodeT {
            self.get_nodes_number()
                - self.get_connected_nodes_number()
                - self.get_singleton_nodes_with_selfloops_number()
        }
        /// Return number of weighted singleton nodes within the graph.
        ///
        /// This number represents the number of nodes that have weighted node
        /// degree equal to 0, which may happen when the graph contains edges
        /// with negative edge weights.
        ///
        /// # Raises
        /// * If the graph does not contain edge weights.
        pub fn get_weighted_singleton_nodes_number(&self) -> Result<NodeT> {
            self.must_have_edge_weights()?;
            Ok(self.weighted_singleton_nodes_number.unwrap())
        }
        /// Returns number of disconnected nodes within the graph.
        /// A Disconnected node is a node which is nor a singleton nor a singleton
        /// with selfloops.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The graph contains {} disconnected nodes", graph.get_disconnected_nodes_number());
        /// ```
        pub fn get_disconnected_nodes_number(&self) -> NodeT {
            self.get_nodes_number() - self.get_connected_nodes_number()
        }
        /// Returns vector of singleton node IDs of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The graph singleton node IDs are {:?}.", graph.get_singleton_node_ids());
        /// ```
        pub fn get_singleton_node_ids(&self) -> Vec<NodeT> {
            self.iter_singleton_node_ids().collect()
        }
        /// Returns vector of singleton node names of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The graph singleton node names are {:?}.", graph.get_singleton_node_names());
        /// ```
        pub fn get_singleton_node_names(&self) -> Vec<String> {
            self.iter_singleton_node_names().collect()
        }
        /// Returns number of singleton nodes with self-loops within the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The graph contains {} singleton nodes with self-loops", graph.get_singleton_nodes_with_selfloops_number());
        /// ```
        pub fn get_singleton_nodes_with_selfloops_number(&self) -> NodeT {
            self.singleton_nodes_with_selfloops_number
        }
        /// Returns vector of singleton_with_selfloops node IDs of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The graph singleton_with_selfloops node IDs are {:?}.", graph.get_singleton_with_selfloops_node_ids());
        /// ```
        pub fn get_singleton_with_selfloops_node_ids(&self) -> Vec<NodeT> {
            self.iter_singleton_nodes_with_selfloops_node_ids()
                .collect()
        }
        /// Returns vector of singleton_with_selfloops node names of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The graph singleton_with_selfloops node names are {:?}.", graph.get_singleton_with_selfloops_node_names());
        /// ```
        pub fn get_singleton_with_selfloops_node_names(&self) -> Vec<String> {
            self.iter_singleton_nodes_with_selfloops_node_names()
                .collect()
        }
        /// Returns number of not singleton nodes within the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The graph contains {} not singleton nodes", graph.get_connected_nodes_number());
        /// ```
        pub fn get_connected_nodes_number(&self) -> NodeT {
            self.connected_nodes_number
        }
        /// Returns density of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The graph density is {}", graph.get_density().unwrap());
        /// ```
        pub fn get_density(&self) -> Result<f64> {
            if !self.has_nodes() {
                return Err("The density of an empty graph is undefined.".to_string());
            }
            if !self.has_edges() {
                return Ok(0.0);
            }
            let nodes_number = self.get_nodes_number() as EdgeT;
            let total_nodes_number = nodes_number
                * match self.has_selfloops() {
                    true => nodes_number,
                    false => nodes_number - 1,
                };
            Ok(self.unique_edges_number as f64 / total_nodes_number as f64)
        }
        /// Returns the traps rate of the graph.
        ///
        /// THIS IS EXPERIMENTAL AND MUST BE PROVEN!
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The Graph rate is {}", graph.get_trap_nodes_rate());
        /// ```
        pub fn get_trap_nodes_rate(&self) -> f64 {
            self.par_iter_node_ids()
                .map(|node_id| unsafe {
                    if !self.is_unchecked_trap_node_from_node_id(node_id) {
                        self.iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)
                            .map(|dst| {
                                self.is_unchecked_trap_node_from_node_id(dst) as usize as f64
                            })
                            .sum::<f64>()
                            / self.get_unchecked_node_degree_from_node_id(node_id) as f64
                    } else {
                        1.0
                    }
                })
                .sum::<f64>()
                / self.get_nodes_number() as f64
        }
        /// Returns unweighted mean node degree of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The mean node degree of the graph is  {}", graph.get_node_degrees_mean().unwrap());
        /// ```
        pub fn get_node_degrees_mean(&self) -> Result<f64> {
            if !self.has_nodes() {
                return Err(
                    "The mean of the node degrees is not defined on an empty graph".to_string(),
                );
            }
            Ok(self.get_directed_edges_number() as f64 / self.get_nodes_number() as f64)
        }
        /// Returns weighted mean node degree of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The mean node degree of the graph is  {}", graph.get_weighted_node_degrees_mean().unwrap());
        /// ```
        pub fn get_weighted_node_degrees_mean(&self) -> Result<f64> {
            Ok(self.get_total_edge_weights()? / self.get_nodes_number() as f64)
        }
        /// Returns number of undirected edges of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The number of undirected edges of the graph is  {}", graph.get_undirected_edges_number());
        /// ```
        pub fn get_undirected_edges_number(&self) -> EdgeT {
            (self.get_directed_edges_number() - self.get_selfloop_number()) / 2
                + self.get_selfloop_number()
        }
        /// Returns number of undirected edges of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The number of unique undirected edges of the graph is  {}", graph.get_unique_undirected_edges_number());
        /// ```
        pub fn get_unique_undirected_edges_number(&self) -> EdgeT {
            (self.unique_edges_number - self.get_unique_selfloop_number() as EdgeT) / 2
                + self.get_unique_selfloop_number() as EdgeT
        }
        /// Returns number of edges of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The number of edges of the graph is  {}", graph.get_edges_number());
        /// ```
        pub fn get_edges_number(&self) -> EdgeT {
            match self.directed {
                true => self.get_directed_edges_number(),
                false => self.get_undirected_edges_number(),
            }
        }
        /// Returns number of unique edges of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The number of edges of the graph is  {}", graph.get_unique_edges_number());
        /// ```
        pub fn get_unique_edges_number(&self) -> EdgeT {
            match self.directed {
                true => self.get_unique_directed_edges_number(),
                false => self.get_unique_undirected_edges_number(),
            }
        }
        /// Returns unweighted median node degree of the graph
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The median node degree of the graph is  {}", graph.get_node_degrees_median().unwrap());
        /// ```
        pub fn get_node_degrees_median(&self) -> Result<NodeT> {
            self.must_have_nodes()?;
            let mut degrees = self.get_node_degrees();
            degrees.par_sort_unstable();
            Ok(degrees[(self.get_nodes_number() / 2) as usize])
        }
        /// Returns weighted median node degree of the graph
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The weighted median node degree of the graph is  {}", graph.get_weighted_node_degrees_median().unwrap());
        /// ```
        pub fn get_weighted_node_degrees_median(&self) -> Result<f64> {
            self.must_have_nodes()?;
            self.must_have_edge_weights()?;
            let mut weighted_degrees = self.get_weighted_node_degrees()?;
            weighted_degrees.par_sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());
            Ok(weighted_degrees[(self.get_nodes_number() / 2) as usize])
        }
        /// Returns maximum unweighted node degree of the graph.
        ///
        /// # Safety
        /// The method will return an undefined value (0) when the graph
        /// does not contain nodes. In those cases the value is not properly
        /// defined.
        pub unsafe fn get_unchecked_maximum_node_degree(&self) -> NodeT {
            self.max_node_degree
        }
        /// Returns maximum weighted node degree of the graph.
        ///
        /// # Safety
        /// This method will cause a panic on graphs without
        /// edge weights.
        pub unsafe fn get_unchecked_weighted_maximum_node_degree(&self) -> f64 {
            self.max_weighted_node_degree.unwrap()
        }
        /// Returns maximum weighted node degree of the graph.
        ///
        /// # Raises
        /// * If the current graph does not contain edge weights.
        pub fn get_weighted_maximum_node_degree(&self) -> Result<f64> {
            self.must_have_edge_weights()?;
            Ok(unsafe { self.get_unchecked_weighted_maximum_node_degree() })
        }
        /// Returns minimum weighted node degree of the graph.
        ///
        /// # Safety
        /// This method will cause a panic on graphs without
        /// edge weights.
        pub unsafe fn get_unchecked_weighted_minimum_node_degree(&self) -> f64 {
            self.max_weighted_node_degree.unwrap()
        }
        /// Returns minimum weighted node degree of the graph.
        ///
        /// # Raises
        /// * If the current graph does not contain edge weights.
        pub fn get_weighted_minimum_node_degree(&self) -> Result<f64> {
            self.must_have_edge_weights()?;
            Ok(unsafe { self.get_unchecked_weighted_minimum_node_degree() })
        }
        /// Returns maximum node degree of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The maximum node degree of the graph is  {}", graph.get_maximum_node_degree().unwrap());
        /// ```
        ///
        /// # Raises
        /// * If the graph does not contain any node (is an empty graph).
        pub fn get_maximum_node_degree(&self) -> Result<NodeT> {
            self.must_have_nodes()
                .map(|_| unsafe { self.get_unchecked_maximum_node_degree() })
        }
        /// Returns maximum node degree of the graph.
        ///
        /// # Safety
        /// This method fails with a panic if the graph does not have any node.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The maximum node degree of the graph is  {}", unsafe{graph.get_unchecked_most_central_node_id()});
        /// ```
        pub unsafe fn get_unchecked_most_central_node_id(&self) -> NodeT {
            self.most_central_node_id
        }
        /// Returns maximum node degree of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The maximum node degree of the graph is  {}", graph.get_most_central_node_id().unwrap());
        /// ```
        pub fn get_most_central_node_id(&self) -> Result<NodeT> {
            self.must_have_nodes()
                .map(|_| unsafe { self.get_unchecked_most_central_node_id() as NodeT })
        }
        /// Returns minimum node degree of the graph.
        ///
        /// # Safety
        /// The method will return an undefined value (NodeT::MAX) when the graph
        /// does not contain nodes. In those cases the value is not properly
        /// defined.
        pub unsafe fn get_unchecked_minimum_node_degree(&self) -> NodeT {
            self.min_node_degree
        }
        /// Returns minimum weighted node degree of the graph.
        pub fn get_weighted_mininum_node_degree(&self) -> Result<f64> {
            self.must_have_edge_weights()?;
            Ok(self.min_weighted_node_degree.unwrap())
        }
        /// Returns minimum node degree of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The minimum node degree of the graph is  {}", graph.get_minimum_node_degree().unwrap());
        /// ```
        ///
        /// # Raises
        /// * If the graph does not contain any node (is an empty graph).
        pub fn get_minimum_node_degree(&self) -> Result<NodeT> {
            self.must_have_nodes()
                .map(|_| unsafe { self.get_unchecked_minimum_node_degree() })
        }
        /// Returns mode node degree of the graph.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The mode node degree of the graph is  {}", graph.get_node_degrees_mode().unwrap());
        /// ```
        pub fn get_node_degrees_mode(&self) -> Result<NodeT> {
            if !self.has_nodes() {
                return Err(
                    "The mode of the node degrees is not defined on an empty graph".to_string(),
                );
            }
            let counter: Counter<NodeT, usize> = Counter::init(self.iter_node_degrees());
            Ok(*counter
                .iter()
                .max_by_key(|&(_, count)| count)
                .map(|(degree, _)| degree)
                .unwrap())
        }
        /// Returns number of self-loops, including also those in eventual multi-edges.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The number of self-loops in the graph is  {}", graph.get_selfloop_number());
        /// ```
        pub fn get_selfloop_number(&self) -> EdgeT {
            self.selfloop_number
        }
        /// Returns number of unique self-loops, excluding those in eventual multi-edges.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The number of unique self-loops in the graph is  {}", graph.get_unique_selfloop_number());
        /// ```
        pub fn get_unique_selfloop_number(&self) -> NodeT {
            self.unique_selfloop_number
        }
        /// Returns rate of self-loops.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The rate of self-loops in the graph is  {}", graph.get_selfloop_nodes_rate().unwrap());
        /// ```
        pub fn get_selfloop_nodes_rate(&self) -> Result<f64> {
            if !self.has_edges() {
                return Err(
                    "The self-loops rate is not defined for graphs without edges.".to_string(),
                );
            }
            Ok(self.get_selfloop_number() as f64 / self.get_directed_edges_number() as f64)
        }
        /// Return name of the graph.
        ///
        /// # Example
        /// To the retrieve the name of the current graph instance selfloop_number can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert_eq!(graph.get_name(), "STRING PPI".to_string());
        /// println!("The name of the current graph is {}.", graph.get_name());
        /// ```
        ///
        pub fn get_name(&self) -> String {
            self.name.clone()
        }
        /// Return the number of traps (nodes without any outgoing edges that are not singletons)
        /// This also includes nodes with only a self-loops, therefore singletons with
        /// only a self-loops are not considered traps because you could make a walk on them.
        ///
        /// # Example
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("There are {} trap nodes in the current graph.", graph.get_trap_nodes_number());
        /// ```
        ///
        pub fn get_trap_nodes_number(&self) -> EdgeT {
            (self.get_connected_nodes_number() + self.get_singleton_nodes_with_selfloops_number()
                - self.get_unique_source_nodes_number()) as EdgeT
        }
        /// Return vector of the non-unique source nodes.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn get_source_node_ids(&self, directed: bool) -> Vec<NodeT> {
            self.par_iter_source_node_ids(directed).collect()
        }
        /// Return vector of the non-unique source nodes names.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn get_source_names(&self, directed: bool) -> Vec<String> {
            self.par_iter_source_node_ids(directed)
                .map(|src| unsafe { self.get_unchecked_node_name_from_node_id(src) })
                .collect()
        }
        /// Return vector on the (non unique) destination nodes of the graph.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn get_destination_node_ids(&self, directed: bool) -> Vec<NodeT> {
            self.par_iter_destination_node_ids(directed).collect()
        }
        /// Return vector of the non-unique destination nodes names.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn get_destination_names(&self, directed: bool) -> Vec<String> {
            self.par_iter_destination_node_ids(directed)
                .map(|dst| unsafe { self.get_unchecked_node_name_from_node_id(dst) })
                .collect()
        }
        /// Return vector with the sorted nodes names.
        pub fn get_node_names(&self) -> Vec<String> {
            self.nodes.reverse_map.clone()
        }
        /// Return vector with the sorted nodes Ids.
        pub fn get_node_ids(&self) -> Vec<NodeT> {
            self.iter_node_ids().collect()
        }
        /// Return the edge types of the edges.
        pub fn get_edge_type_ids(&self) -> Result<Vec<Option<EdgeTypeT>>> {
            self.must_have_edge_types()
                .map(|_| self.edge_types.as_ref().map(|ets| ets.ids.clone()).unwrap())
        }
        /// Return the unique edge type IDs of the graph edges.
        ///
        /// # Example
        /// To retrieve the unique edge type IDs of the graph edges you can use:
        /// ```rust
        /// # let graph_with_edge_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// # let graph_without_edge_types = graph::test_utilities::load_ppi(false, false, true, true, false, false);
        /// assert!(graph_with_edge_types.get_unique_edge_type_ids().is_ok());
        /// assert!(graph_without_edge_types.get_unique_edge_type_ids().is_err());
        /// println!("The graph edge types are {:?}", graph_with_edge_types.get_unique_edge_type_ids());
        /// ```
        ///
        pub fn get_unique_edge_type_ids(&self) -> Result<Vec<EdgeTypeT>> {
            self.iter_unique_edge_type_ids()
                .map(|edge_type_ids| edge_type_ids.collect())
        }
        /// Return the edge types names.
        pub fn get_edge_type_names(&self) -> Result<Vec<Option<String>>> {
            self.must_have_edge_types().map(|_| {
                self.edge_types
                    .as_ref()
                    .map(|ets| {
                        ets.ids
                            .iter()
                            .map(|edge_type_id| unsafe {
                                self.get_unchecked_edge_type_name_from_edge_type_id(*edge_type_id)
                            })
                            .collect()
                    })
                    .unwrap()
            })
        }
        /// Return the edge types names.
        pub fn get_unique_edge_type_names(&self) -> Result<Vec<String>> {
            self.iter_unique_edge_type_names()
                .map(|iter_unique_edge_type_names| iter_unique_edge_type_names.collect())
        }
        /// Return the weights of the graph edges.
        ///
        /// # Example
        /// To get an the graph weights you can use:
        /// ```rust
        /// # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);
        /// # let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);
        /// assert!(graph_with_weights.get_edge_weights().is_ok());
        /// assert!(graph_without_weights.get_edge_weights().is_err());
        /// println!("The graph weights are {:?}.", graph_with_weights.get_edge_weights());
        /// ```
        pub fn get_edge_weights(&self) -> Result<Vec<WeightT>> {
            self.must_have_edge_weights()?;
            Ok(self.weights.clone().unwrap())
        }
        /// Return total edge weights, if graph has weights.
        ///
        /// # Example
        /// To get the total edge weights you can use:
        /// ```rust
        /// # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);
        /// # let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);
        /// assert!(graph_with_weights.get_total_edge_weights().is_ok());
        /// assert!(graph_without_weights.get_total_edge_weights().is_err());
        /// println!("The graph total edge weights is {:?}.", graph_with_weights.get_total_edge_weights());
        /// ```
        ///
        /// # Raises
        /// * If the graph does not contain edge weights.
        pub fn get_total_edge_weights(&self) -> Result<f64> {
            self.must_have_edge_weights()
                .map(|_| self.total_weights.unwrap())
        }
        /// Return the minimum weight, if graph has weights.
        ///
        /// # Example
        /// To get the minimum edge weight you can use:
        /// ```rust
        /// # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);
        /// # let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);
        /// assert!(graph_with_weights.get_mininum_edge_weight().is_ok());
        /// assert!(graph_without_weights.get_mininum_edge_weight().is_err());
        /// println!("The graph minimum weight is {:?}.", graph_with_weights.get_mininum_edge_weight());
        /// ```
        ///
        /// # Raises
        /// * If the graph does not contain edge weights.
        pub fn get_mininum_edge_weight(&self) -> Result<WeightT> {
            self.must_have_edge_weights()
                .map(|_| self.min_edge_weight.unwrap())
        }
        /// Return the maximum weight, if graph has weights.
        ///
        /// # Example
        /// To get the maximum edge weight you can use:
        /// ```rust
        /// # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);
        /// # let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);
        /// assert!(graph_with_weights.get_maximum_edge_weight().is_ok());
        /// assert!(graph_without_weights.get_maximum_edge_weight().is_err());
        /// println!("The graph maximum weight is {:?}.", graph_with_weights.get_maximum_edge_weight());
        /// ```
        ///
        /// # Raises
        /// * If the graph does not contain edge weights.
        pub fn get_maximum_edge_weight(&self) -> Result<WeightT> {
            self.must_have_edge_weights()
                .map(|_| self.max_edge_weight.unwrap())
        }
        /// Return the node types of the graph nodes.
        ///
        /// # Example
        /// To retrieve the node type IDs of the graph nodes you can use:
        /// ```rust
        /// # let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// # let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// assert!(graph_with_node_types.get_node_type_ids().is_ok());
        /// assert!(graph_without_node_types.get_node_type_ids().is_err());
        /// println!("The graph node types are {:?}", graph_with_node_types.get_node_type_ids());
        /// ```
        ///
        pub fn get_node_type_ids(&self) -> Result<Vec<Option<Vec<NodeTypeT>>>> {
            self.must_have_node_types()
                .map(|_| self.node_types.as_ref().map(|nts| nts.ids.clone()).unwrap())
        }
        /// Returns one-hot encoded node types.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        pub fn get_one_hot_encoded_node_types(&self) -> Result<Vec<Vec<bool>>> {
            Ok(self.iter_one_hot_encoded_node_type_ids()?.collect())
        }
        /// Returns one-hot encoded known node types.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        pub fn get_one_hot_encoded_known_node_types(&self) -> Result<Vec<Vec<bool>>> {
            Ok(self.iter_one_hot_encoded_known_node_type_ids()?.collect())
        }
        /// Returns one-hot encoded edge types.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        pub fn get_one_hot_encoded_edge_types(&self) -> Result<Vec<Vec<bool>>> {
            Ok(self.iter_one_hot_encoded_edge_type_ids()?.collect())
        }
        /// Returns one-hot encoded known edge types.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        pub fn get_one_hot_encoded_known_edge_types(&self) -> Result<Vec<Vec<bool>>> {
            Ok(self.iter_one_hot_encoded_known_edge_type_ids()?.collect())
        }
        /// Return the node types names.
        ///
        /// # Example
        /// To retrieve the node type names of the graph nodes you can use:
        /// ```rust
        /// # let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// # let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// assert!(graph_with_node_types.get_node_type_names().is_ok());
        /// assert!(graph_without_node_types.get_node_type_names().is_err());
        /// println!("The graph node types are {:?}", graph_with_node_types.get_node_type_names());
        /// ```
        ///
        pub fn get_node_type_names(&self) -> Result<Vec<Option<Vec<String>>>> {
            self.must_have_node_types().map(|_| {
                self.iter_node_ids()
                    .map(|node_id| unsafe {
                        self.get_unchecked_node_type_names_from_node_id(node_id)
                    })
                    .collect::<Vec<Option<Vec<String>>>>()
            })
        }
        /// Return the unique node type IDs of the graph nodes.
        ///
        /// # Example
        /// To retrieve the unique node type IDs of the graph nodes you can use:
        /// ```rust
        /// # let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// # let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// assert!(graph_with_node_types.get_unique_node_type_ids().is_ok());
        /// assert!(graph_without_node_types.get_unique_node_type_ids().is_err());
        /// println!("The graph node types are {:?}", graph_with_node_types.get_unique_node_type_ids());
        /// ```
        ///
        pub fn get_unique_node_type_ids(&self) -> Result<Vec<NodeTypeT>> {
            self.iter_unique_node_type_ids()
                .map(|iter_unique_node_type_ids| iter_unique_node_type_ids.collect())
        }
        /// Return the unique node types names.
        ///
        /// # Example
        /// To retrieve the unique node type names of the graph nodes you can use:
        /// ```rust
        /// # let graph_with_node_types = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// # let graph_without_node_types = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// assert!(graph_with_node_types.get_unique_node_type_names().is_ok());
        /// assert!(graph_without_node_types.get_unique_node_type_names().is_err());
        /// println!("The graph node types are {:?}", graph_with_node_types.get_unique_node_type_names());
        /// ```
        ///
        pub fn get_unique_node_type_names(&self) -> Result<Vec<String>> {
            self.iter_unique_node_type_names()
                .map(|iter_unique_node_type_names| iter_unique_node_type_names.collect())
        }
        /// Return number of the unique edges in the graph.
        pub fn get_unique_directed_edges_number(&self) -> EdgeT {
            self.unique_edges_number
        }
        /// Return the nodes mapping.
        pub fn get_nodes_mapping(&self) -> HashMap<String, NodeT> {
            self.nodes.map.clone()
        }
        /// Return vector with the sorted edge Ids.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn get_edge_node_ids(&self, directed: bool) -> Vec<Vec<NodeT>> {
            self.par_iter_edge_node_ids(directed)
                .map(|(_, src, dst)| <[_]>::into_vec(box [src, dst]))
                .collect()
        }
        /// Return vector with the sorted edge names.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn get_edge_node_names(&self, directed: bool) -> Vec<(String, String)> {
            self.par_iter_edges(directed)
                .map(|(_, _, src_name, _, dst_name)| (src_name, dst_name))
                .collect()
        }
        /// Returns number of nodes with unknown node type.
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn get_unknown_node_types_number(&self) -> Result<NodeT> {
            self.must_have_node_types()
                .map(|node_types| node_types.get_unknown_count())
        }
        /// Returns the number of node with known node type.
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn get_known_node_types_number(&self) -> Result<NodeT> {
            Ok(self.get_nodes_number() - self.get_unknown_node_types_number()?)
        }
        /// Returns rate of unknown node types over total nodes number.
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn get_unknown_node_types_rate(&self) -> Result<f64> {
            self.get_unknown_node_types_number()
                .map(|unknown_node_types_number| {
                    unknown_node_types_number as f64 / self.get_nodes_number() as f64
                })
        }
        /// Returns rate of known node types over total nodes number.
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn get_known_node_types_rate(&self) -> Result<f64> {
            self.get_known_node_types_number()
                .map(|known_node_types_number| {
                    known_node_types_number as f64 / self.get_nodes_number() as f64
                })
        }
        /// Returns minimum number of node types.
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn get_minimum_node_types_number(&self) -> Result<NodeT> {
            self.must_have_node_types()
                .map(|node_types| node_types.get_minimum_node_type_count())
        }
        /// Returns maximum number of node types.
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn get_maximum_node_types_number(&self) -> Result<NodeT> {
            self.must_have_node_types()
                .map(|node_types| node_types.get_maximum_node_type_count())
        }
        /// Returns number of maximum multilabel count.
        ///
        /// This value is the maximum number of multilabel counts
        /// that appear in any given node in the graph.
        pub fn get_maximum_multilabel_count(&self) -> Result<NodeTypeT> {
            self.must_have_node_types()
                .map(|node_types| node_types.get_maximum_multilabel_count())
        }
        /// Returns number of singleton node types.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        pub fn get_singleton_node_types_number(&self) -> Result<NodeTypeT> {
            self.iter_node_type_counts().map(|iter_node_type_counts| {
                iter_node_type_counts
                    .map(|node_type_count| (node_type_count == 1) as NodeTypeT)
                    .sum()
            })
        }
        /// Returns vector of singleton node types IDs.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        pub fn get_singleton_node_type_ids(&self) -> Result<Vec<NodeTypeT>> {
            self.iter_singleton_node_type_ids()
                .map(|iter_singleton_node_type_ids| iter_singleton_node_type_ids.collect())
        }
        /// Returns vector of singleton node types names.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        pub fn get_singleton_node_type_names(&self) -> Result<Vec<String>> {
            self.iter_singleton_node_type_names()
                .map(|iter_singleton_node_type_names| iter_singleton_node_type_names.collect())
        }
        /// Returns number of unknown edge types.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn get_unknown_edge_types_number(&self) -> Result<EdgeT> {
            self.must_have_edge_types()
                .map(|edge_types| edge_types.get_unknown_count())
        }
        /// Returns edge IDs of the edges with unknown edge types
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn get_edge_ids_with_unknown_edge_types(&self) -> Result<Vec<EdgeT>> {
            self.iter_edge_ids_with_unknown_edge_types()
                .map(|x| x.collect())
        }
        /// Returns edge IDs of the edges with known edge types
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn get_edge_ids_with_known_edge_types(&self) -> Result<Vec<EdgeT>> {
            self.iter_edge_ids_with_known_edge_types()
                .map(|x| x.collect())
        }
        /// Returns edge node IDs of the edges with unknown edge types
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to iterated the edges as a directed or undirected edge list.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn get_edge_node_ids_with_unknown_edge_types(
            &self,
            directed: bool,
        ) -> Result<Vec<(NodeT, NodeT)>> {
            self.iter_edge_node_ids_with_unknown_edge_types(directed)
                .map(|x| x.collect())
        }
        /// Returns edge node IDs of the edges with known edge types
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to iterated the edges as a directed or undirected edge list.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn get_edge_node_ids_with_known_edge_types(
            &self,
            directed: bool,
        ) -> Result<Vec<(NodeT, NodeT)>> {
            self.iter_edge_node_ids_with_known_edge_types(directed)
                .map(|x| x.collect())
        }
        /// Returns edge node names of the edges with unknown edge types
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to iterated the edges as a directed or undirected edge list.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn get_edge_node_names_with_unknown_edge_types(
            &self,
            directed: bool,
        ) -> Result<Vec<(String, String)>> {
            self.iter_edge_node_names_with_unknown_edge_types(directed)
                .map(|x| x.collect())
        }
        /// Returns edge node names of the edges with known edge types
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to iterated the edges as a directed or undirected edge list.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn get_edge_node_names_with_known_edge_types(
            &self,
            directed: bool,
        ) -> Result<Vec<(String, String)>> {
            self.iter_edge_node_names_with_known_edge_types(directed)
                .map(|x| x.collect())
        }
        /// Returns a boolean vector that for each node contains whether it has an
        /// unknown node type.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn get_edge_ids_with_unknown_edge_types_mask(&self) -> Result<Vec<bool>> {
            self.iter_edge_ids_with_unknown_edge_types().map(|x| {
                let mut mask =
                    ::alloc::vec::from_elem(false, self.get_directed_edges_number() as usize);
                x.for_each(|id| {
                    mask[id as usize] = true;
                });
                mask
            })
        }
        /// Returns a boolean vector that for each node contains whether it has an
        /// unknown edge type.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn get_edge_ids_with_known_edge_types_mask(&self) -> Result<Vec<bool>> {
            self.iter_edge_ids_with_known_edge_types().map(|x| {
                let mut mask =
                    ::alloc::vec::from_elem(false, self.get_directed_edges_number() as usize);
                x.for_each(|id| {
                    mask[id as usize] = true;
                });
                mask
            })
        }
        /// Returns node IDs of the nodes with unknown node types
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn get_node_ids_with_unknown_node_types(&self) -> Result<Vec<NodeT>> {
            self.iter_node_ids_with_unknown_node_types()
                .map(|x| x.collect())
        }
        /// Returns node IDs of the nodes with known node types
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn get_node_ids_with_known_node_types(&self) -> Result<Vec<NodeT>> {
            self.iter_node_ids_with_known_node_types()
                .map(|x| x.collect())
        }
        /// Returns node names of the nodes with unknown node types
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn get_node_names_with_unknown_node_types(&self) -> Result<Vec<String>> {
            self.iter_node_names_with_unknown_node_types()
                .map(|x| x.collect())
        }
        /// Returns node names of the nodes with known node types
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn get_node_names_with_known_node_types(&self) -> Result<Vec<String>> {
            self.iter_node_names_with_known_node_types()
                .map(|x| x.collect())
        }
        /// Returns a boolean vector that for each node contains whether it has an
        /// unknown node type.
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn get_node_ids_with_unknown_node_types_mask(&self) -> Result<Vec<bool>> {
            self.iter_node_ids_with_unknown_node_types().map(|x| {
                let mut mask = ::alloc::vec::from_elem(false, self.get_nodes_number() as usize);
                x.for_each(|id| {
                    mask[id as usize] = true;
                });
                mask
            })
        }
        /// Returns a boolean vector that for each node contains whether it has an
        /// known node type.
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn get_node_ids_with_known_node_types_mask(&self) -> Result<Vec<bool>> {
            self.iter_node_ids_with_known_node_types().map(|x| {
                let mut mask = ::alloc::vec::from_elem(false, self.get_nodes_number() as usize);
                x.for_each(|id| {
                    mask[id as usize] = true;
                });
                mask
            })
        }
        /// Returns the number of edge with known edge type.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn get_known_edge_types_number(&self) -> Result<EdgeT> {
            Ok(self.get_directed_edges_number() - self.get_unknown_edge_types_number()?)
        }
        /// Returns rate of unknown edge types over total edges number.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn get_unknown_edge_types_rate(&self) -> Result<f64> {
            self.get_unknown_edge_types_number()
                .map(|unknown_edge_types_number| {
                    unknown_edge_types_number as f64 / self.get_directed_edges_number() as f64
                })
        }
        /// Returns rate of known edge types over total edges number.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn get_known_edge_types_rate(&self) -> Result<f64> {
            self.get_known_edge_types_number()
                .map(|known_edge_types_number| {
                    known_edge_types_number as f64 / self.get_directed_edges_number() as f64
                })
        }
        /// Returns minimum number of edge types.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn get_minimum_edge_types_number(&self) -> Result<EdgeT> {
            self.must_have_edge_types()
                .map(|edge_types| edge_types.min_edge_type_count())
        }
        /// Returns number of singleton edge types.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        pub fn get_singleton_edge_types_number(&self) -> Result<EdgeTypeT> {
            self.iter_edge_type_counts().map(|iter_edge_type_counts| {
                iter_edge_type_counts
                    .map(|edge_type_count| (edge_type_count == 1) as EdgeTypeT)
                    .sum()
            })
        }
        /// Returns vector of singleton edge types IDs.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        pub fn get_singleton_edge_type_ids(&self) -> Result<Vec<EdgeTypeT>> {
            self.iter_singleton_edge_type_ids()
                .map(|iter_singleton_edge_type_ids| iter_singleton_edge_type_ids.collect())
        }
        /// Returns vector of singleton edge types names.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        pub fn get_singleton_edge_type_names(&self) -> Result<Vec<String>> {
            self.iter_singleton_edge_type_names()
                .map(|iter_singleton_edge_type_names| iter_singleton_edge_type_names.collect())
        }
        /// Returns number of nodes in the graph.
        pub fn get_nodes_number(&self) -> NodeT {
            self.nodes.len() as NodeT
        }
        /// Return a vector with the components each node belongs to.
        ///
        /// E.g. If we have two components `[0, 2, 3]` and `[1, 4, 5]` the result will look like
        /// `[0, 1, 0, 0, 1, 1]`
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show the loading bar.
        pub fn get_node_connected_component_ids(&self, verbose: Option<bool>) -> Vec<NodeT> {
            match self.directed {
                true => self.spanning_arborescence_kruskal(verbose).1,
                false => self.connected_components(verbose).unwrap().0,
            }
        }
        /// Returns number of directed edges in the graph.
        pub fn get_directed_edges_number(&self) -> EdgeT {
            self.edges.len() as EdgeT
        }
        /// Returns number of edge types in the graph.
        ///
        /// # Raises
        /// * If there are no edge types in the current graph.
        pub fn get_edge_types_number(&self) -> Result<EdgeTypeT> {
            self.must_have_edge_types()
                .map(|ets| ets.len() as EdgeTypeT)
        }
        /// Returns number of node types in the graph.
        ///
        /// # Raises
        /// * If there are no node types in the current graph.
        pub fn get_node_types_number(&self) -> Result<NodeTypeT> {
            self.must_have_node_types()
                .map(|nts| nts.len() as NodeTypeT)
        }
        /// Returns the unweighted degree of every node in the graph.
        pub fn get_node_degrees(&self) -> Vec<NodeT> {
            self.par_iter_node_degrees().collect()
        }
        /// Returns the weighted degree of every node in the graph.
        pub fn get_weighted_node_degrees(&self) -> Result<Vec<f64>> {
            Ok(self.par_iter_weighted_node_degrees()?.collect())
        }
        /// Return set of nodes that are not singletons.
        pub fn get_not_singletons_node_ids(&self) -> Vec<NodeT> {
            self.iter_connected_node_ids().collect()
        }
        /// Return mapping from instance not trap nodes to dense nodes.
        pub fn get_dense_nodes_mapping(&self) -> HashMap<NodeT, NodeT> {
            self.iter_connected_node_ids()
                .enumerate()
                .map(|(i, node)| (node as NodeT, i as NodeT))
                .collect()
        }
        /// Return number of edges that have multigraph syblings.
        pub fn get_parallel_edges_number(&self) -> EdgeT {
            self.get_directed_edges_number() - self.unique_edges_number
        }
        /// Return vector with node cumulative_node_degrees, that is the comulative node degree.
        pub fn get_cumulative_node_degrees(&self) -> Vec<EdgeT> {
            self.cumulative_node_degrees.as_ref().map_or_else(
                || {
                    self.par_iter_node_ids()
                        .map(|src| unsafe { self.get_unchecked_edge_id_from_node_ids(src + 1, 0) })
                        .collect()
                },
                |cumulative_node_degrees| cumulative_node_degrees.clone(),
            )
        }
        /// Returns number of the source nodes.
        ///
        /// # Example
        ///```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The number of sources of the graph (not trap nodes) is {}", graph.get_unique_source_nodes_number());
        /// ```
        pub fn get_unique_source_nodes_number(&self) -> NodeT {
            self.unique_sources
                .as_ref()
                .map_or(self.get_nodes_number(), |x| x.len() as NodeT)
        }
        /// Returns edge type IDs counts hashmap.
        ///
        /// # Example
        /// In order to compute an hashmap of the edge type IDs you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// for (edge_type_id, count) in graph.get_edge_type_id_counts_hashmap().unwrap().iter() {
        ///     println!("edge type id {}: count: {}", edge_type_id, count);
        /// }
        /// ```
        ///
        /// # Raises
        /// * If there are no edge types in the current graph instance.
        pub fn get_edge_type_id_counts_hashmap(&self) -> Result<HashMap<EdgeTypeT, EdgeT>> {
            self.iter_unique_edge_type_ids_and_counts().map(
                |iter_unique_edge_type_ids_and_counts| {
                    iter_unique_edge_type_ids_and_counts.collect()
                },
            )
        }
        /// Returns edge type names counts hashmap.
        ///
        /// # Example
        /// In order to compute an hashmap of the edge type names you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// for (edge_type_id, count) in graph.get_edge_type_id_counts_hashmap().unwrap().iter() {
        ///     println!("edge type name {}: count: {}", edge_type_id, count);
        /// }
        /// ```
        ///
        /// # Raises
        /// * If there are no edge types in the current graph instance.
        pub fn get_edge_type_names_counts_hashmap(&self) -> Result<HashMap<String, EdgeT>> {
            self.iter_unique_edge_type_names_and_counts().map(
                |iter_unique_edge_type_names_and_counts| {
                    iter_unique_edge_type_names_and_counts.collect()
                },
            )
        }
        /// Returns node type IDs counts hashmap.
        ///
        /// # Example
        /// In order to compute an hashmap of the node type IDs you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// for (node_type_id, count) in graph.get_node_type_id_counts_hashmap().unwrap().iter() {
        ///     println!("node type id {}: count: {}", node_type_id, count);
        /// }
        /// ```
        ///
        /// # Raises
        /// * If there are no node types in the current graph instance.
        pub fn get_node_type_id_counts_hashmap(&self) -> Result<HashMap<NodeTypeT, NodeT>> {
            self.iter_unique_node_type_ids_and_counts().map(
                |iter_unique_node_type_ids_and_counts| {
                    iter_unique_node_type_ids_and_counts.collect()
                },
            )
        }
        /// Returns node type names counts hashmap.
        ///
        /// # Example
        /// In order to compute an hashmap of the node type names you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// for (node_type_id, count) in graph.get_node_type_id_counts_hashmap().unwrap().iter() {
        ///     println!("node type name {}: count: {}", node_type_id, count);
        /// }
        /// ```
        ///
        /// # Raises
        /// * If there are no node types in the current graph instance.
        pub fn get_node_type_names_counts_hashmap(&self) -> Result<HashMap<String, NodeT>> {
            self.iter_unique_node_type_names_and_counts().map(
                |iter_unique_node_type_names_and_counts| {
                    iter_unique_node_type_names_and_counts.collect()
                },
            )
        }
    }
}
mod graph {
    //! A graph representation optimized for executing random walks on huge graphs.
    use super::*;
    use bitvec::prelude::*;
    use elias_fano_rust::EliasFano;
    use rayon::prelude::*;
    use roaring::RoaringBitmap;
    /// A graph representation optimized for executing random walks on huge graphs.
    ///
    /// This class should be initialized using the two constructors:
    /// `graph::Graph::new_directed` or `graph::Graph::new_undirected`
    ///
    /// # Example
    /// Load the graph Cora:
    /// ```rust
    /// use graph::*;
    ///
    /// // Create the edge file reader
    /// let edges_reader = EdgeFileReader::new("tests/data/cora/edges.tsv").unwrap()
    ///     .set_separator(Some("\t")).unwrap()
    ///     .set_verbose(Some(false))
    ///     .set_sources_column(Some("subject")).unwrap()
    ///     .set_destinations_column(Some("object")).unwrap()
    ///     .set_default_weight(Some(1.0))
    ///     .set_edge_types_column(Some("edge_type")).unwrap();
    ///
    /// // Create the node file reader
    /// let nodes_reader = Some(
    ///     NodeFileReader::new("tests/data/cora/nodes.tsv").unwrap()
    ///         .set_separator(Some("\t")).unwrap()
    ///         .set_nodes_column(Some("id")).unwrap()
    ///         .set_verbose(Some(false))
    ///         .set_node_types_column(Some("node_type")).unwrap(),
    /// );
    ///
    /// // Load the graph
    /// let mut cora = Graph::from_unsorted_csv(
    ///     edges_reader,
    ///     nodes_reader,
    ///     false,          // if the graph is Directed
    ///     false,          // if the edge list is Directed
    ///     "Cora".to_string()
    ///    ).unwrap();
    ///
    /// // Enable Speed-ups but it uses more memory.
    /// cora.enable(Some(true), Some(true), Some(true)).unwrap();
    /// ```
    pub struct Graph {
        /// The main datastructure where all the edges are saved
        /// in the endoced form ((src << self.node_bits) | dst) this allows us to do almost every
        /// operation in O(1) without decompressing the data.
        pub(crate) edges: EliasFano,
        /// How many bits are needed to save a node.
        pub(crate) node_bits: u8,
        /// The mask used to extract the dst value form an encoded edge.
        /// This is saved for speed sake. It's equivalent to (1 << self.node_bits) - 1;
        pub(crate) node_bit_mask: u64,
        /// Optional vector of the weights of every edge.
        /// `weights[10]` return the weight of the edge with edge_id 10
        pub(crate) weights: Option<Vec<WeightT>>,
        /// Vocabulary that save the mappings from string to index of every node type
        pub(crate) node_types: Option<NodeTypeVocabulary>,
        /// Vocabulary that save the mappings from string to index of every edge type
        pub(crate) edge_types: Option<EdgeTypeVocabulary>,
        /// Vocabulary that save the mappings from string to index of every node
        pub(crate) nodes: Vocabulary<NodeT>,
        /// if the graph is directed or undirected
        pub(crate) directed: bool,
        /// Number of nodes that have at least a self-loop.
        /// This means that if a nodes has multiples self-loops they will be count as one.
        pub(crate) unique_selfloop_number: NodeT,
        /// Number of self-loop edges. This counts multiple times eventual multi-graph self-loops.
        pub(crate) selfloop_number: EdgeT,
        /// Number of nodes that have at least an edge inbound or outbound.
        pub(crate) connected_nodes_number: NodeT,
        /// Number of singleton nodes that have a self-loop
        pub(crate) singleton_nodes_with_selfloops_number: NodeT,
        /// How many unique edges the graph has (excluding the multi-graph ones)
        pub(crate) unique_edges_number: EdgeT,
        /// Minimum outbound node degree.
        pub(crate) min_node_degree: NodeT,
        /// Maximum outbound node degree.
        pub(crate) max_node_degree: NodeT,
        pub(crate) most_central_node_id: NodeT,
        /// Minimum edge weight. Is None if weights are not defined.
        pub(crate) min_edge_weight: Option<WeightT>,
        /// Maximum edge weight. Is None if weights are not defined.
        pub(crate) max_edge_weight: Option<WeightT>,
        /// Minimum weighted node degree. Is None if weights are not defined.
        pub(crate) min_weighted_node_degree: Option<f64>,
        /// Maximum weighted node degree. Is None if weights are not defined.
        pub(crate) max_weighted_node_degree: Option<f64>,
        pub(crate) total_weights: Option<f64>,
        /// Number of nodes with zero weighted node degree.
        pub(crate) weighted_singleton_nodes_number: Option<NodeT>,
        /// Whether the node IDs are provided sorted by decreasing outbound node degree.
        pub(crate) nodes_are_sorted_by_decreasing_outbound_node_degree: bool,
        /// Whether the node IDs are provided sorted by increasing outbound node degree.
        pub(crate) nodes_are_sorted_by_increasing_outbound_node_degree: bool,
        /// Graph name
        pub(crate) name: String,
        pub(crate) connected_nodes: Option<BitVec<Lsb0, u8>>,
        pub(crate) singleton_nodes_with_selfloops: Option<RoaringBitmap>,
        pub(crate) unique_sources: Option<EliasFano>,
        /// Vector of destinations to execute fast walks if required.
        pub(crate) destinations: Option<Vec<NodeT>>,
        /// Vector of sources to execute fast link prediction sequences if required.
        pub(crate) sources: Option<Vec<NodeT>>,
        /// Vector of cumulative_node_degrees to execute fast walks if required.
        pub(crate) cumulative_node_degrees: Option<Vec<EdgeT>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Graph {
        #[inline]
        fn clone(&self) -> Graph {
            match *self {
                Graph {
                    edges: ref __self_0_0,
                    node_bits: ref __self_0_1,
                    node_bit_mask: ref __self_0_2,
                    weights: ref __self_0_3,
                    node_types: ref __self_0_4,
                    edge_types: ref __self_0_5,
                    nodes: ref __self_0_6,
                    directed: ref __self_0_7,
                    unique_selfloop_number: ref __self_0_8,
                    selfloop_number: ref __self_0_9,
                    connected_nodes_number: ref __self_0_10,
                    singleton_nodes_with_selfloops_number: ref __self_0_11,
                    unique_edges_number: ref __self_0_12,
                    min_node_degree: ref __self_0_13,
                    max_node_degree: ref __self_0_14,
                    most_central_node_id: ref __self_0_15,
                    min_edge_weight: ref __self_0_16,
                    max_edge_weight: ref __self_0_17,
                    min_weighted_node_degree: ref __self_0_18,
                    max_weighted_node_degree: ref __self_0_19,
                    total_weights: ref __self_0_20,
                    weighted_singleton_nodes_number: ref __self_0_21,
                    nodes_are_sorted_by_decreasing_outbound_node_degree: ref __self_0_22,
                    nodes_are_sorted_by_increasing_outbound_node_degree: ref __self_0_23,
                    name: ref __self_0_24,
                    connected_nodes: ref __self_0_25,
                    singleton_nodes_with_selfloops: ref __self_0_26,
                    unique_sources: ref __self_0_27,
                    destinations: ref __self_0_28,
                    sources: ref __self_0_29,
                    cumulative_node_degrees: ref __self_0_30,
                } => Graph {
                    edges: ::core::clone::Clone::clone(&(*__self_0_0)),
                    node_bits: ::core::clone::Clone::clone(&(*__self_0_1)),
                    node_bit_mask: ::core::clone::Clone::clone(&(*__self_0_2)),
                    weights: ::core::clone::Clone::clone(&(*__self_0_3)),
                    node_types: ::core::clone::Clone::clone(&(*__self_0_4)),
                    edge_types: ::core::clone::Clone::clone(&(*__self_0_5)),
                    nodes: ::core::clone::Clone::clone(&(*__self_0_6)),
                    directed: ::core::clone::Clone::clone(&(*__self_0_7)),
                    unique_selfloop_number: ::core::clone::Clone::clone(&(*__self_0_8)),
                    selfloop_number: ::core::clone::Clone::clone(&(*__self_0_9)),
                    connected_nodes_number: ::core::clone::Clone::clone(&(*__self_0_10)),
                    singleton_nodes_with_selfloops_number: ::core::clone::Clone::clone(
                        &(*__self_0_11),
                    ),
                    unique_edges_number: ::core::clone::Clone::clone(&(*__self_0_12)),
                    min_node_degree: ::core::clone::Clone::clone(&(*__self_0_13)),
                    max_node_degree: ::core::clone::Clone::clone(&(*__self_0_14)),
                    most_central_node_id: ::core::clone::Clone::clone(&(*__self_0_15)),
                    min_edge_weight: ::core::clone::Clone::clone(&(*__self_0_16)),
                    max_edge_weight: ::core::clone::Clone::clone(&(*__self_0_17)),
                    min_weighted_node_degree: ::core::clone::Clone::clone(&(*__self_0_18)),
                    max_weighted_node_degree: ::core::clone::Clone::clone(&(*__self_0_19)),
                    total_weights: ::core::clone::Clone::clone(&(*__self_0_20)),
                    weighted_singleton_nodes_number: ::core::clone::Clone::clone(&(*__self_0_21)),
                    nodes_are_sorted_by_decreasing_outbound_node_degree:
                        ::core::clone::Clone::clone(&(*__self_0_22)),
                    nodes_are_sorted_by_increasing_outbound_node_degree:
                        ::core::clone::Clone::clone(&(*__self_0_23)),
                    name: ::core::clone::Clone::clone(&(*__self_0_24)),
                    connected_nodes: ::core::clone::Clone::clone(&(*__self_0_25)),
                    singleton_nodes_with_selfloops: ::core::clone::Clone::clone(&(*__self_0_26)),
                    unique_sources: ::core::clone::Clone::clone(&(*__self_0_27)),
                    destinations: ::core::clone::Clone::clone(&(*__self_0_28)),
                    sources: ::core::clone::Clone::clone(&(*__self_0_29)),
                    cumulative_node_degrees: ::core::clone::Clone::clone(&(*__self_0_30)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Graph {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Graph {
                    edges: ref __self_0_0,
                    node_bits: ref __self_0_1,
                    node_bit_mask: ref __self_0_2,
                    weights: ref __self_0_3,
                    node_types: ref __self_0_4,
                    edge_types: ref __self_0_5,
                    nodes: ref __self_0_6,
                    directed: ref __self_0_7,
                    unique_selfloop_number: ref __self_0_8,
                    selfloop_number: ref __self_0_9,
                    connected_nodes_number: ref __self_0_10,
                    singleton_nodes_with_selfloops_number: ref __self_0_11,
                    unique_edges_number: ref __self_0_12,
                    min_node_degree: ref __self_0_13,
                    max_node_degree: ref __self_0_14,
                    most_central_node_id: ref __self_0_15,
                    min_edge_weight: ref __self_0_16,
                    max_edge_weight: ref __self_0_17,
                    min_weighted_node_degree: ref __self_0_18,
                    max_weighted_node_degree: ref __self_0_19,
                    total_weights: ref __self_0_20,
                    weighted_singleton_nodes_number: ref __self_0_21,
                    nodes_are_sorted_by_decreasing_outbound_node_degree: ref __self_0_22,
                    nodes_are_sorted_by_increasing_outbound_node_degree: ref __self_0_23,
                    name: ref __self_0_24,
                    connected_nodes: ref __self_0_25,
                    singleton_nodes_with_selfloops: ref __self_0_26,
                    unique_sources: ref __self_0_27,
                    destinations: ref __self_0_28,
                    sources: ref __self_0_29,
                    cumulative_node_degrees: ref __self_0_30,
                } => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Graph");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "edges",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "node_bits",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "node_bit_mask",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "weights",
                        &&(*__self_0_3),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "node_types",
                        &&(*__self_0_4),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "edge_types",
                        &&(*__self_0_5),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "nodes",
                        &&(*__self_0_6),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "directed",
                        &&(*__self_0_7),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "unique_selfloop_number",
                        &&(*__self_0_8),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "selfloop_number",
                        &&(*__self_0_9),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "connected_nodes_number",
                        &&(*__self_0_10),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "singleton_nodes_with_selfloops_number",
                        &&(*__self_0_11),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "unique_edges_number",
                        &&(*__self_0_12),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "min_node_degree",
                        &&(*__self_0_13),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "max_node_degree",
                        &&(*__self_0_14),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "most_central_node_id",
                        &&(*__self_0_15),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "min_edge_weight",
                        &&(*__self_0_16),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "max_edge_weight",
                        &&(*__self_0_17),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "min_weighted_node_degree",
                        &&(*__self_0_18),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "max_weighted_node_degree",
                        &&(*__self_0_19),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "total_weights",
                        &&(*__self_0_20),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "weighted_singleton_nodes_number",
                        &&(*__self_0_21),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "nodes_are_sorted_by_decreasing_outbound_node_degree",
                        &&(*__self_0_22),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "nodes_are_sorted_by_increasing_outbound_node_degree",
                        &&(*__self_0_23),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "name",
                        &&(*__self_0_24),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "connected_nodes",
                        &&(*__self_0_25),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "singleton_nodes_with_selfloops",
                        &&(*__self_0_26),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "unique_sources",
                        &&(*__self_0_27),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "destinations",
                        &&(*__self_0_28),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "sources",
                        &&(*__self_0_29),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "cumulative_node_degrees",
                        &&(*__self_0_30),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    /// # Graph utility methods
    impl Graph {
        pub(crate) fn new<S: Into<String>>(
            directed: bool,
            unique_selfloop_number: NodeT,
            selfloop_number: EdgeT,
            connected_nodes_number: NodeT,
            singleton_nodes_with_selfloops_number: NodeT,
            unique_edges_number: EdgeT,
            edges: EliasFano,
            unique_sources: Option<EliasFano>,
            nodes: Vocabulary<NodeT>,
            node_bit_mask: EdgeT,
            node_bits: u8,
            edge_types: Option<EdgeTypeVocabulary>,
            name: S,
            weights: Option<Vec<WeightT>>,
            min_edge_weight: Option<WeightT>,
            max_edge_weight: Option<WeightT>,
            node_types: Option<NodeTypeVocabulary>,
            connected_nodes: Option<BitVec<Lsb0, u8>>,
            singleton_nodes_with_selfloops: Option<RoaringBitmap>,
            min_node_degree: NodeT,
            max_node_degree: NodeT,
            most_central_node_id: NodeT,
            min_weighted_node_degree: Option<f64>,
            max_weighted_node_degree: Option<f64>,
            total_weights: Option<f64>,
            weighted_singleton_nodes_number: Option<NodeT>,
            nodes_are_sorted_by_decreasing_outbound_node_degree: bool,
            nodes_are_sorted_by_increasing_outbound_node_degree: bool,
        ) -> Graph {
            Graph {
                directed,
                unique_selfloop_number,
                selfloop_number,
                connected_nodes_number,
                singleton_nodes_with_selfloops_number,
                unique_edges_number,
                edges,
                unique_sources,
                node_bit_mask,
                node_bits,
                weights,
                min_edge_weight,
                max_edge_weight,
                min_node_degree,
                max_node_degree,
                most_central_node_id,
                node_types: node_types.map(|nts| nts.set_numeric_ids(false)),
                edge_types: edge_types.map(|ets| ets.set_numeric_ids(false)),
                nodes: nodes.set_numeric_ids(false),
                sources: None,
                destinations: None,
                cumulative_node_degrees: None,
                name: name.into(),
                connected_nodes,
                singleton_nodes_with_selfloops,
                min_weighted_node_degree,
                max_weighted_node_degree,
                total_weights,
                weighted_singleton_nodes_number,
                nodes_are_sorted_by_decreasing_outbound_node_degree,
                nodes_are_sorted_by_increasing_outbound_node_degree,
            }
        }
        /// Return whether given graph has any edge overlapping with current graph.
        ///
        /// # Arguments
        ///
        /// * `other`: &Graph - The graph to check against.
        ///
        /// # Example
        /// You can whether two graphs are overlapping as follows:
        /// ```rust
        /// # let ppi = graph::test_utilities::load_ppi(true, true, false, false, false, false);
        /// # let cora = graph::test_utilities::load_cora();
        /// assert!(ppi.overlaps(&ppi).unwrap());
        /// assert!(cora.overlaps(&cora).unwrap());
        /// assert!(!ppi.overlaps(&cora).unwrap());
        /// assert!(!cora.overlaps(&ppi).unwrap());
        /// let (train, test) = ppi.random_holdout(
        ///     0.8,
        ///     Some(42),
        ///     Some(false),
        ///     None,
        ///     None,
        ///     None,
        /// ).unwrap();
        /// assert!(ppi.overlaps(&train).unwrap());
        /// assert!(ppi.overlaps(&test).unwrap());
        /// assert!(train.overlaps(&ppi).unwrap());
        /// assert!(test.overlaps(&ppi).unwrap());
        /// assert!(!train.overlaps(&test).unwrap());
        /// assert!(!test.overlaps(&train).unwrap());
        /// ```
        ///
        /// # Raises
        /// * If a graph is directed and the other is undirected.
        /// * If one of the two graphs has edge weights and the other does not.
        /// * If one of the two graphs has node types and the other does not.
        /// * If one of the two graphs has edge types and the other does not.
        pub fn overlaps(&self, other: &Graph) -> Result<bool> {
            Ok(match self.is_compatible(other)? {
                true => other
                    .par_iter_edge_node_ids_and_edge_type_id(other.directed)
                    .any(|(_, src, dst, et)| {
                        self.has_edge_from_node_ids_and_edge_type_id(src, dst, et)
                    }),
                false => other
                    .par_iter_edge_node_names_and_edge_type_name(other.directed)
                    .any(|(_, _, src_name, _, dst_name, _, edge_type_name)| {
                        self.has_edge_from_node_names_and_edge_type_name(
                            &src_name,
                            &dst_name,
                            edge_type_name.as_deref(),
                        )
                    }),
            })
        }
        /// Return true if given graph edges are all contained within current graph.
        ///
        /// # Arguments
        ///
        /// * `other`: &Graph - The graph to check against.
        ///
        /// # Example
        /// You can whether two graphs contain one another as follows:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, false, false, false, false);
        /// let (train, test) = graph.random_holdout(
        ///     0.8,
        ///     Some(42),
        ///     Some(false),
        ///     None,
        ///     None,
        ///     None,
        /// ).unwrap();
        /// assert!(graph.contains(&train).unwrap());
        /// assert!(graph.contains(&test).unwrap());
        /// assert!(!train.contains(&graph).unwrap());
        /// assert!(!test.contains(&graph).unwrap());
        /// assert!(!train.contains(&test).unwrap());
        /// assert!(!test.contains(&train).unwrap());
        /// ```
        ///
        /// # Raises
        /// * If a graph is directed and the other is undirected.
        /// * If one of the two graphs has edge weights and the other does not.
        /// * If one of the two graphs has node types and the other does not.
        /// * If one of the two graphs has edge types and the other does not.
        pub fn contains(&self, other: &Graph) -> Result<bool> {
            Ok(match self.is_compatible(other)? {
                true => other
                    .par_iter_edge_node_ids_and_edge_type_id(other.directed)
                    .all(|(_, src, dst, et)| {
                        self.has_edge_from_node_ids_and_edge_type_id(src, dst, et)
                    }),
                false => other
                    .par_iter_edge_node_names_and_edge_type_name(other.directed)
                    .all(|(_, _, src_name, _, dst_name, _, edge_type_name)| {
                        self.has_edge_from_node_names_and_edge_type_name(
                            &src_name,
                            &dst_name,
                            edge_type_name.as_deref(),
                        )
                    }),
            })
        }
    }
}
mod hash {
    use super::*;
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};
    #[inline(always)]
    /// Hashing floats is usually a bad idea
    /// But we want to know if any weight changed significantly
    /// THUS we will hash only the order of magnitude and the
    /// first few bits of the mantissa.
    ///
    /// This should be an hash which is kinda robust to float erros.
    fn hash_float<H: Hasher>(x: f32, state: &mut H) {
        let mut hack = u32::from_le_bytes(x.to_le_bytes());
        hack &= 0b11111111111111111111000000000000;
        state.write_u32(hack);
    }
    impl Graph {
        pub fn compute_hash(&self) -> u64 {
            let mut hasher = DefaultHasher::new();
            self.hash(&mut hasher);
            hasher.finish()
        }
    }
    impl PartialEq for Graph {
        fn eq(&self, other: &Self) -> bool {
            self.compute_hash() == other.compute_hash()
        }
    }
    impl Hash for Graph {
        fn hash<H: Hasher>(&self, state: &mut H) {
            self.directed.hash(state);
            self.nodes.hash(state);
            self.edges.hash(state);
            if let Some(ws) = &self.weights {
                for w in ws {
                    hash_float(*w, state);
                }
            }
            if let Some(nt) = &self.node_types {
                nt.hash(state);
            }
            if let Some(et) = &self.edge_types {
                et.hash(state);
            }
        }
    }
    impl<IndexT: ToFromUsize> Hash for Vocabulary<IndexT> {
        fn hash<H: Hasher>(&self, state: &mut H) {
            let mut vector: Vec<(&String, &IndexT)> = self.map.iter().collect();
            vector.sort();
            vector.hash(state);
            self.reverse_map.hash(state);
            self.numeric_ids.hash(state);
        }
    }
    impl Hash for NodeTypeVocabulary {
        fn hash<H: Hasher>(&self, state: &mut H) {
            self.ids.hash(state);
            self.vocabulary.hash(state);
            self.counts.hash(state);
        }
    }
    impl Hash for EdgeTypeVocabulary {
        fn hash<H: Hasher>(&self, state: &mut H) {
            self.ids.hash(state);
            self.vocabulary.hash(state);
            self.counts.hash(state);
        }
    }
}
mod holdouts {
    use super::*;
    use counter::Counter;
    use indicatif::ParallelProgressIterator;
    use indicatif::ProgressIterator;
    use rand::rngs::SmallRng;
    use rand::seq::SliceRandom;
    use rand::SeedableRng;
    use rayon::iter::IndexedParallelIterator;
    use rayon::iter::IntoParallelIterator;
    use rayon::iter::ParallelIterator;
    use roaring::{RoaringBitmap, RoaringTreemap};
    use std::collections::HashSet;
    use vec_rand::xorshift::xorshift as rand_u64;
    use vec_rand::{gen_random_vec, sample_uniform};
    /// # Holdouts.
    impl Graph {
        /// Returns Graph with given amount of negative edges as positive edges.
        ///
        /// The graph generated may be used as a testing negatives partition to be
        /// fed into the argument "graph_to_avoid" of the link_prediction or the
        /// skipgrams algorithm.
        ///
        ///
        /// # Arguments
        ///
        /// * `negatives_number`: EdgeT - Number of negatives edges to include.
        /// * `random_state`: Option<EdgeT> - random_state to use to reproduce negative edge set.
        /// * `seed_graph`: Option<&Graph> - Optional graph to use to filter the negative edges. The negative edges generated when this variable is provided will always have a node within this graph.
        /// * `only_from_same_component`: Option<bool> - Whether to sample negative edges only from nodes that are from the same component.
        /// * `verbose`: Option<bool> - Whether to show the loading bar.
        ///
        pub fn sample_negatives(
            &self,
            negatives_number: EdgeT,
            random_state: Option<EdgeT>,
            seed_graph: Option<&Graph>,
            only_from_same_component: Option<bool>,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            if negatives_number == 0 {
                return Err(String::from("The number of negatives cannot be zero."));
            }
            let only_from_same_component = only_from_same_component.unwrap_or(false);
            let mut random_state = random_state.unwrap_or(0xbadf00d);
            let verbose = verbose.unwrap_or(false);
            let seed_nodes: Option<RoaringBitmap> = if let Some(sg) = &seed_graph {
                if !self.overlaps(&sg)? {
                    return Err(String::from(
                        "The given seed graph does not overlap with the current graph instance.",
                    ));
                }
                Some(
                    sg.iter_node_names_and_node_type_names()
                        .map(|(_, node_name, _, _)| unsafe {
                            self.get_unchecked_node_id_from_node_name(&node_name)
                        })
                        .collect::<RoaringBitmap>(),
                )
            } else {
                None
            };
            let nodes_number = self.get_nodes_number() as EdgeT;
            let (node_components, mut complete_edges_number) = if only_from_same_component {
                let node_components = self.get_node_connected_component_ids(Some(verbose));
                let complete_edges_number: EdgeT = Counter::init(node_components.clone())
                    .into_iter()
                    .map(|(_, nodes_number): (_, &usize)| {
                        let mut edge_number = (*nodes_number * (*nodes_number - 1)) as EdgeT;
                        if !self.is_directed() {
                            edge_number /= 2;
                        }
                        edge_number
                    })
                    .sum();
                (Some(node_components), complete_edges_number)
            } else {
                let mut edge_number = nodes_number * (nodes_number - 1);
                if !self.is_directed() {
                    edge_number /= 2;
                }
                (None, edge_number)
            };
            if self.has_selfloops() {
                complete_edges_number += nodes_number;
            }
            let max_negative_edges = complete_edges_number - self.get_unique_edges_number();
            if negatives_number > max_negative_edges {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "The requested negatives number ",
                            " is more than the number of negative edges that exist in the graph (",
                            ").",
                        ],
                        &match (&negatives_number, &max_negative_edges) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                });
            }
            if negatives_number % 2 == 1 && !self.is_directed() && !self.has_selfloops() {
                return Err({
                    let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The requested negatives number " , " is an odd number and the graph is neither directed nor has selfloops, so it is not possible to sample an odd number of edges."] , & match (& negatives_number ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ;
                    res
                });
            }
            let pb1 = get_loading_bar(
                verbose,
                "Computing negative edges",
                negatives_number as usize,
            );
            random_state = splitmix64(random_state as u64) as EdgeT;
            let mut negative_edges_hashset = HashSet::with_capacity(negatives_number as usize);
            let mut last_length = 0;
            let mut sampling_round: usize = 0;
            while negative_edges_hashset.len() < negatives_number as usize {
                let src_random_state = rand_u64(random_state);
                let dst_random_state = rand_u64(src_random_state);
                random_state = rand_u64(dst_random_state);
                let tmp_tb = get_loading_bar(
                    verbose,
                    {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Negatives sampling round "],
                            &match (&sampling_round,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    }
                    .as_ref(),
                    negatives_number as usize,
                );
                sampling_round += 1;
                let sampled_edge_ids = gen_random_vec(negatives_number as usize, src_random_state)
                    .into_par_iter()
                    .zip(
                        gen_random_vec(negatives_number as usize, dst_random_state).into_par_iter(),
                    )
                    .progress_with(tmp_tb)
                    .filter_map(|(src_seed, dst_seed)| {
                        let src = sample_uniform(nodes_number as u64, src_seed as u64) as NodeT;
                        let dst = sample_uniform(nodes_number as u64, dst_seed as u64) as NodeT;
                        if !self.is_directed() && src > dst {
                            return None;
                        }
                        if !self.has_selfloops() && src == dst {
                            return None;
                        }
                        if let Some(sn) = &seed_nodes {
                            if !sn.contains(src) && !sn.contains(dst) {
                                return None;
                            }
                        }
                        if let Some(ncs) = &node_components {
                            if ncs[src as usize] != ncs[dst as usize] {
                                return None;
                            }
                        }
                        match self.has_edge_from_node_ids(src, dst) {
                            true => None,
                            false => Some(self.encode_edge(src, dst)),
                        }
                    })
                    .collect::<Vec<EdgeT>>();
                let pb3 = get_loading_bar(
                    verbose,
                    {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Inserting negative graph edges (iteration ", ")"],
                            &match (&sampling_round,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    }
                    .as_ref(),
                    negatives_number as usize,
                );
                for edge_id in sampled_edge_ids.iter().progress_with(pb3) {
                    if negative_edges_hashset.len() >= negatives_number as usize {
                        break;
                    }
                    negative_edges_hashset.insert(*edge_id);
                }
                if sampling_round > 50000 {
                    {
                        ::std::rt::begin_panic("Deadlock in sampling negatives!")
                    };
                }
                pb1.inc((negative_edges_hashset.len() - last_length as usize) as u64);
                last_length = negative_edges_hashset.len();
            }
            pb1.finish();
            Graph::from_integer_unsorted(
                negative_edges_hashset.into_par_iter().flat_map(|edge| {
                    let (src, dst) = self.decode_edge(edge);
                    if !self.is_directed() && src != dst {
                        <[_]>::into_vec(box [
                            Ok((src, dst, None, None)),
                            Ok((dst, src, None, None)),
                        ])
                    } else {
                        <[_]>::into_vec(box [Ok((src, dst, None, None))])
                    }
                }),
                self.nodes.clone(),
                self.node_types.clone(),
                None,
                self.directed,
                {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Negative "],
                        &match (&self.name.clone(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                },
                false,
                false,
                false,
                false,
                true,
                self.has_selfloops(),
                true,
                verbose,
            )
        }
        /// Compute the training and validation elements number from the training rate
        ///
        /// # Raises
        /// * If the training size is either greater than one or negative.
        /// * If the graph instance has only one edge.
        /// * If the resulting training edges number is 0.
        /// * If the resulting validation edges number is 0.
        fn get_holdouts_elements_number(
            &self,
            train_size: f64,
            total_elements: usize,
        ) -> Result<(usize, usize)> {
            if train_size <= 0.0 || train_size >= 1.0 {
                return Err(String::from("Train rate must be strictly between 0 and 1."));
            }
            if self.directed && self.get_directed_edges_number() == 1
                || !self.directed && self.get_directed_edges_number() == 2
            {
                return Err (String :: from ("The current graph instance has only one edge. You cannot build an holdout with one edge.")) ;
            }
            let train_elements_number = (total_elements as f64 * train_size) as usize;
            let valid_elements_number = total_elements - train_elements_number;
            if train_elements_number == 0 || train_elements_number >= total_elements {
                return Err(String::from(
                    "The training set has 0 elements! Change the training rate.",
                ));
            }
            if valid_elements_number == 0 {
                return Err(String::from(
                    "The validation set has 0 elements! Change the training rate.",
                ));
            }
            Ok((train_elements_number, valid_elements_number))
        }
        /// Returns training and validation graph.
        ///
        /// # Arguments
        /// * `random_state`: Option<EdgeT> - The random state to reproduce the holdout.
        /// * `validation_edges_number`: EdgeT - The number of edges to reserve for the validation graph.
        /// * `include_all_edge_types`: bool - Whether to include all the edge types in the graph, if the graph is a multigraph.
        /// * `user_condition_for_validation_edges`: impl Fn(EdgeT, NodeT, NodeT, Option<EdgeTypeT>) -> bool - The function to use to put edges in validation set.
        /// * `verbose`: Option<bool> - Whether to show the loading bar or not.
        /// * `train_graph_might_contain_singletons`: bool - Whether it is known that the resulting training graph may have singletons.
        /// * `train_graph_might_contain_singletons_with_selfloops`: bool - Whether it is known that the resulting training graph may have singletons with selfloops.
        ///
        /// # Raises
        /// * If the sampled validation edges are not enough for the required validation edges number.
        fn edge_holdout(
            &self,
            random_state: Option<EdgeT>,
            validation_edges_number: EdgeT,
            include_all_edge_types: bool,
            user_condition_for_validation_edges: impl Fn(EdgeT, NodeT, NodeT, Option<EdgeTypeT>) -> bool,
            verbose: Option<bool>,
            train_graph_might_contain_singletons: bool,
            train_graph_might_contain_singletons_with_selfloops: bool,
        ) -> Result<(Graph, Graph)> {
            let verbose = verbose.unwrap_or(false);
            let random_state = random_state.unwrap_or(0xbadf00d);
            let validation_edges_pb = get_loading_bar(
                verbose,
                "Picking validation edges",
                validation_edges_number as usize,
            );
            let mut rng = SmallRng::seed_from_u64(splitmix64(random_state as u64) as EdgeT);
            let mut edge_indices: Vec<EdgeT> = (0..self.get_directed_edges_number()).collect();
            edge_indices.shuffle(&mut rng);
            let mut valid_edges_bitmap = RoaringTreemap::new();
            let mut last_length = 0;
            for (edge_id, (src, dst, edge_type)) in edge_indices.into_iter().map(|edge_id| {
                (edge_id, unsafe {
                    self.get_unchecked_node_ids_and_edge_type_id_from_edge_id(edge_id)
                })
            }) {
                if !self.directed && src > dst {
                    continue;
                }
                if user_condition_for_validation_edges(edge_id, src, dst, edge_type) {
                    valid_edges_bitmap.extend(self.compute_edge_ids_vector(
                        edge_id,
                        src,
                        dst,
                        include_all_edge_types,
                    ));
                    if !self.directed {
                        valid_edges_bitmap.extend(self.compute_edge_ids_vector(
                            unsafe {
                                self.get_unchecked_edge_id_from_node_ids_and_edge_type_id(
                                    dst, src, edge_type,
                                )
                            },
                            dst,
                            src,
                            include_all_edge_types,
                        ));
                    }
                    validation_edges_pb.inc(valid_edges_bitmap.len() - last_length);
                    last_length = valid_edges_bitmap.len();
                }
                if valid_edges_bitmap.len() >= validation_edges_number {
                    break;
                }
            }
            if valid_edges_bitmap.len() < validation_edges_number {
                let actual_validation_edges_number = valid_edges_bitmap.len();
                return Err({
                    let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["With the given configuration for the holdout, it is not possible to generate a validation set composed of " , " edges from the current graph.\nThe validation set can be composed of at most " , " edges.\n"] , & match (& validation_edges_number , & actual_validation_edges_number) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , })) ;
                    res
                });
            }
            let pb_valid = get_loading_bar(
                verbose,
                "Building the validation graph",
                valid_edges_bitmap.len() as usize,
            );
            let pb_train = get_loading_bar(
                verbose,
                "Building the train graph",
                (self.get_directed_edges_number() - valid_edges_bitmap.len()) as usize,
            );
            Ok ((Graph :: from_integer_sorted ((0 .. self . get_directed_edges_number ()) . filter (| edge_id | ! valid_edges_bitmap . contains (* edge_id)) . progress_with (pb_train) . map (| edge_id | unsafe { Ok (self . get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id (edge_id)) }) , self . get_directed_edges_number () as usize - valid_edges_bitmap . len () as usize , self . nodes . clone () , self . node_types . clone () , self . edge_types . as_ref () . map (| ets | ets . vocabulary . clone ()) , self . directed , true , { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["" , " training"] , & match (& self . name . clone () ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } , true , self . has_edge_types () , self . has_edge_weights () , false , train_graph_might_contain_singletons , train_graph_might_contain_singletons_with_selfloops , true) ? , Graph :: from_integer_sorted (valid_edges_bitmap . iter () . progress_with (pb_valid) . map (| edge_id | unsafe { Ok (self . get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id (edge_id)) }) , valid_edges_bitmap . len () as usize , self . nodes . clone () , self . node_types . clone () , self . edge_types . as_ref () . map (| ets | ets . vocabulary . clone ()) , self . directed , true , { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["" , " testing"] , & match (& self . name . clone () ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } , true , self . has_edge_types () , self . has_edge_weights () , false , true , self . has_selfloops () , true) ?))
        }
        /// Returns holdout for training ML algorithms on the graph structure.
        ///
        /// The holdouts returned are a tuple of graphs. The first one, which
        /// is the training graph, is garanteed to have the same number of
        /// graph components as the initial graph. The second graph is the graph
        /// meant for testing or validation of the algorithm, and has no garantee
        /// to be connected. It will have at most (1-train_size) edges,
        /// as the bound of connectivity which is required for the training graph
        /// may lead to more edges being left into the training partition.
        ///
        /// In the option where a list of edge types has been provided, these
        /// edge types will be those put into the validation set.
        ///
        /// # Arguments
        ///
        /// * `train_size`: f64 - Rate target to reserve for training.
        /// * `random_state`: Option<EdgeT> - The random_state to use for the holdout,
        /// * `edge_types`: Option<Vec<Option<String>>> - Edge types to be selected for in the validation set.
        /// * `include_all_edge_types`: Option<bool> - Whether to include all the edges between two nodes.
        /// * `verbose`: Option<bool> - Whether to show the loading bar.
        ///
        /// # Raises
        /// * If the edge types have been specified but the graph does not have edge types.
        /// * If the required training size is not a real value between 0 and 1.
        /// * If the current graph does not allow for the creation of a spanning tree for the requested training size.
        pub fn connected_holdout(
            &self,
            train_size: f64,
            random_state: Option<EdgeT>,
            edge_types: Option<Vec<Option<String>>>,
            include_all_edge_types: Option<bool>,
            verbose: Option<bool>,
        ) -> Result<(Graph, Graph)> {
            let include_all_edge_types = include_all_edge_types.unwrap_or(false);
            if edge_types.is_some() {
                self.must_have_edge_types()?;
            }
            if train_size <= 0.0 || train_size >= 1.0 {
                return Err(String::from("Train rate must be strictly between 0 and 1."));
            }
            let edge_type_ids = edge_types.map_or(Ok::<_, String>(None), |ets| {
                Ok(Some(
                    self.get_edge_type_ids_from_edge_type_names(ets)?
                        .into_iter()
                        .collect::<HashSet<Option<EdgeTypeT>>>(),
                ))
            })?;
            let tree = self
                .random_spanning_arborescence_kruskal(random_state, edge_type_ids.clone(), verbose)
                .0;
            let edge_factor = if self.is_directed() { 1 } else { 2 };
            let train_edges_number =
                (self.get_directed_edges_number() as f64 * train_size) as usize;
            let mut validation_edges_number =
                (self.get_directed_edges_number() as f64 * (1.0 - train_size)) as EdgeT;
            if let Some(etis) = &edge_type_ids {
                let selected_edges_number: EdgeT = etis
                    .iter()
                    .map(
                        |et| unsafe { self.get_unchecked_edge_count_from_edge_type_id(*et) }
                            as EdgeT,
                    )
                    .sum();
                validation_edges_number =
                    (selected_edges_number as f64 * (1.0 - train_size)) as EdgeT;
            }
            if tree.len() * edge_factor > train_edges_number {
                return Err({
                    let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The given spanning tree of the graph contains " , " edges that is more than the required training edges number " , ".\nThis makes impossible to create a validation set using " , " edges.\nIf possible, you should increase the train_size parameter which is currently equal to " , ".\nThe deny map, by itself, is requiring at least a train rate of " , "."] , & match (& (tree . len () * edge_factor) , & train_edges_number , & validation_edges_number , & train_size , & ((tree . len () * edge_factor) as f64 / train_edges_number as f64)) { (arg0 , arg1 , arg2 , arg3 , arg4) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg3 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg4 , :: core :: fmt :: Display :: fmt)] , })) ;
                    res
                });
            }
            self.edge_holdout(
                random_state,
                validation_edges_number,
                include_all_edge_types,
                |_, src, dst, edge_type| {
                    let is_in_tree = tree.contains(&(src, dst));
                    let singleton_selfloop = self.is_singleton_with_selfloops_from_node_id(src);
                    let correct_edge_type = edge_type_ids
                        .as_ref()
                        .map_or(true, |etis| etis.contains(&edge_type));
                    !is_in_tree && !singleton_selfloop && correct_edge_type
                },
                verbose,
                self.has_singleton_nodes(),
                self.has_singleton_nodes_with_selfloops(),
            )
        }
        /// Returns random holdout for training ML algorithms on the graph edges.
        ///
        /// The holdouts returned are a tuple of graphs. In neither holdouts the
        /// graph connectivity is necessarily preserved. To maintain that, use
        /// the method `connected_holdout`.
        ///
        /// # Arguments
        ///
        /// * `train_size`: f64 - rate target to reserve for training
        /// * `random_state`: Option<EdgeT> - The random_state to use for the holdout,
        /// * `include_all_edge_types`: Option<bool> - Whether to include all the edges between two nodes.
        /// * `edge_types`: Option<Vec<Option<String>>> - The edges to include in validation set.
        /// * `min_number_overlaps`: Option<EdgeT> - The minimum number of overlaps to include the edge into the validation set.
        /// * `verbose`: Option<bool> - Whether to show the loading bar.
        ///
        /// # Raises
        /// * If the edge types have been specified but the graph does not have edge types.
        /// * If the minimum number of overlaps have been specified but the graph is not a multigraph.
        /// * If one or more of the given edge type names is not present in the graph.
        pub fn random_holdout(
            &self,
            train_size: f64,
            random_state: Option<EdgeT>,
            include_all_edge_types: Option<bool>,
            edge_types: Option<Vec<Option<String>>>,
            min_number_overlaps: Option<EdgeT>,
            verbose: Option<bool>,
        ) -> Result<(Graph, Graph)> {
            let include_all_edge_types = include_all_edge_types.unwrap_or(false);
            if edge_types.is_some() {
                self.must_have_edge_types()?;
            }
            let total_edges_number = if include_all_edge_types {
                self.unique_edges_number
            } else {
                self.get_directed_edges_number()
            };
            let (_, validation_edges_number) =
                self.get_holdouts_elements_number(train_size, total_edges_number as usize)?;
            let edge_type_ids = edge_types.map_or(Ok::<_, String>(None), |ets| {
                Ok(Some(
                    self.get_edge_type_ids_from_edge_type_names(ets)?
                        .into_iter()
                        .collect::<HashSet<Option<EdgeTypeT>>>(),
                ))
            })?;
            if min_number_overlaps.is_some() {
                self.must_be_multigraph()?;
            }
            self.edge_holdout(
                random_state,
                validation_edges_number as EdgeT,
                include_all_edge_types,
                |_, src, dst, edge_type| {
                    if !edge_type_ids
                        .as_ref()
                        .map_or(true, |etis| etis.contains(&edge_type))
                    {
                        return false;
                    }
                    if let Some(mno) = min_number_overlaps {
                        if self.get_unchecked_edge_degree_from_node_ids(src, dst) < mno {
                            return false;
                        }
                    }
                    true
                },
                verbose,
                true,
                self.has_selfloops(),
            )
        }
        /// Returns node-label holdout for training ML algorithms on the graph node labels.
        ///
        /// # Arguments
        /// * `train_size`: f64 - rate target to reserve for training,
        /// * `use_stratification`: Option<bool> - Whether to use node-label stratification,
        /// * `random_state`: Option<EdgeT> - The random_state to use for the holdout,
        ///
        /// # Example
        /// This example create an 80-20 split of the nodes in the graph
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        ///   let (train, test) = graph.node_label_holdout(0.8, Some(true), None).unwrap();
        /// ```
        ///
        /// # Raises
        /// * If the graph does not have node types.
        /// * If stratification is requested but the graph has a single node type.
        /// * If stratification is requested but the graph has a multilabel node types.
        pub fn node_label_holdout(
            &self,
            train_size: f64,
            use_stratification: Option<bool>,
            random_state: Option<EdgeT>,
        ) -> Result<(Graph, Graph)> {
            self.must_have_node_types()?;
            let random_state = random_state.unwrap_or(0xbadf00d);
            let use_stratification = use_stratification.unwrap_or(false);
            if use_stratification {
                if self.has_multilabel_node_types()? {
                    return Err ("It is impossible to create a stratified holdout when the graph has multi-label node types." . to_string ()) ;
                }
                if self.has_singleton_node_types()? {
                    return Err ("It is impossible to create a stratified holdout when the graph has node types with cardinality one." . to_string ()) ;
                }
            }
            if self.get_known_node_types_number()? < 2 {
                return Err ("It is not possible to create a node label holdout when the number of nodes with known node type is less than two." . to_string ()) ;
            }
            let node_sets: Vec<Vec<NodeT>> = self
                .node_types
                .as_ref()
                .map(|nts| {
                    if use_stratification {
                        let mut node_sets: Vec<Vec<NodeT>> = ::alloc::vec::from_elem(
                            Vec::new(),
                            self.get_node_types_number().unwrap() as usize,
                        );
                        nts.ids.iter().enumerate().for_each(|(node_id, node_type)| {
                            if let Some(nt) = node_type {
                                node_sets[nt[0] as usize].push(node_id as NodeT);
                            };
                        });
                        node_sets
                    } else {
                        <[_]>::into_vec(box [nts
                            .ids
                            .iter()
                            .enumerate()
                            .filter_map(|(node_id, node_type)| {
                                node_type.as_ref().map(|_| node_id as NodeT)
                            })
                            .collect()])
                    }
                })
                .unwrap();
            let mut rnd = SmallRng::seed_from_u64(splitmix64(random_state as u64));
            let mut train_node_types =
                ::alloc::vec::from_elem(None, self.get_nodes_number() as usize);
            let mut test_node_types =
                ::alloc::vec::from_elem(None, self.get_nodes_number() as usize);
            for mut node_set in node_sets {
                node_set.shuffle(&mut rnd);
                let (train_size, _) =
                    self.get_holdouts_elements_number(train_size, node_set.len())?;
                node_set[..train_size].iter().for_each(|node_id| unsafe {
                    train_node_types[*node_id as usize] =
                        self.get_unchecked_node_type_id_from_node_id(*node_id)
                });
                node_set[train_size..].iter().for_each(|node_id| unsafe {
                    test_node_types[*node_id as usize] =
                        self.get_unchecked_node_type_id_from_node_id(*node_id)
                });
            }
            let mut train_graph = self.clone();
            let mut test_graph = self.clone();
            train_graph.node_types = NodeTypeVocabulary::from_structs(
                train_node_types,
                self.node_types.as_ref().map(|ntv| ntv.vocabulary.clone()),
            );
            test_graph.node_types = NodeTypeVocabulary::from_structs(
                test_node_types,
                self.node_types.as_ref().map(|ntv| ntv.vocabulary.clone()),
            );
            Ok((train_graph, test_graph))
        }
        /// Returns edge-label holdout for training ML algorithms on the graph edge labels.
        /// This is commonly used for edge type prediction tasks.
        ///
        /// This method returns two graphs, the train and the test one.
        /// The edges of the graph will be splitted in the train and test graphs according
        /// to the `train_size` argument.
        ///
        /// If stratification is enabled, the train and test will have the same ratios of
        /// edge types.
        ///
        /// # Arguments
        /// * `train_size`: f64 - rate target to reserve for training,
        /// * `use_stratification`: Option<bool> - Whether to use edge-label stratification,
        /// * `random_state`: Option<EdgeT> - The random_state to use for the holdout,
        ///
        /// # Example
        /// This example creates an 80-20 split of the edges mantaining the edge label ratios
        /// in train and test.
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        ///   let (train, test) = graph.edge_label_holdout(0.8, Some(true), None).unwrap();
        /// ```
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        /// * If stratification is required but the graph has singleton edge types.
        pub fn edge_label_holdout(
            &self,
            train_size: f64,
            use_stratification: Option<bool>,
            random_state: Option<EdgeT>,
        ) -> Result<(Graph, Graph)> {
            if self.get_known_edge_types_number()? < 2 {
                return Err ("It is not possible to create a edge label holdout when the number of edges with known edge type is less than two." . to_string ()) ;
            }
            let use_stratification = use_stratification.unwrap_or(false);
            let random_state = random_state.unwrap_or(0xbadf00d);
            if use_stratification && self.has_singleton_edge_types()? {
                return Err ("It is impossible to create a stratified holdout when the graph has edge types with cardinality one." . to_string ()) ;
            }
            let edge_sets: Vec<Vec<EdgeT>> = self
                .edge_types
                .as_ref()
                .map(|nts| {
                    if use_stratification {
                        let mut edge_sets: Vec<Vec<EdgeT>> = ::alloc::vec::from_elem(
                            Vec::new(),
                            self.get_edge_types_number().unwrap() as usize,
                        );
                        nts.ids.iter().enumerate().for_each(|(edge_id, edge_type)| {
                            if let Some(et) = edge_type {
                                edge_sets[*et as usize].push(edge_id as EdgeT);
                            };
                        });
                        edge_sets
                    } else {
                        <[_]>::into_vec(box [nts
                            .ids
                            .iter()
                            .enumerate()
                            .filter_map(|(edge_id, edge_type)| {
                                edge_type.as_ref().map(|_| edge_id as EdgeT)
                            })
                            .collect()])
                    }
                })
                .unwrap();
            let mut rnd = SmallRng::seed_from_u64(splitmix64(random_state as u64));
            let mut train_edge_types =
                ::alloc::vec::from_elem(None, self.get_directed_edges_number() as usize);
            let mut test_edge_types =
                ::alloc::vec::from_elem(None, self.get_directed_edges_number() as usize);
            for mut edge_set in edge_sets {
                edge_set.shuffle(&mut rnd);
                let (train_size, _) =
                    self.get_holdouts_elements_number(train_size, edge_set.len())?;
                edge_set[..train_size].iter().for_each(|edge_id| {
                    train_edge_types[*edge_id as usize] =
                        unsafe { self.get_unchecked_edge_type_id_from_edge_id(*edge_id) }
                });
                edge_set[train_size..].iter().for_each(|edge_id| {
                    test_edge_types[*edge_id as usize] =
                        unsafe { self.get_unchecked_edge_type_id_from_edge_id(*edge_id) }
                });
            }
            let mut train_graph = self.clone();
            let mut test_graph = self.clone();
            train_graph.edge_types = Some(EdgeTypeVocabulary::from_structs(
                train_edge_types,
                self.edge_types
                    .as_ref()
                    .map(|etv| etv.vocabulary.clone())
                    .unwrap(),
            ));
            test_graph.edge_types = Some(EdgeTypeVocabulary::from_structs(
                test_edge_types,
                self.edge_types
                    .as_ref()
                    .map(|etv| etv.vocabulary.clone())
                    .unwrap(),
            ));
            Ok((train_graph, test_graph))
        }
        /// Returns subgraph with given number of nodes.
        ///
        /// **This method creates a subset of the graph starting from a random node
        /// sampled using given random_state and includes all neighbouring nodes until
        /// the required number of nodes is reached**. All the edges connecting any
        /// of the selected nodes are then inserted into this graph.
        ///
        /// This is meant to execute distributed node embeddings.
        /// It may also sample singleton nodes.
        ///
        /// # Arguments
        /// * `nodes_number`: NodeT - Number of nodes to extract.
        /// * `random_state`: Option<usize> - Random random_state to use.
        /// * `verbose`: Option<bool> - Whether to show the loading bar.
        ///
        /// # Example
        /// this generates a random subgraph with 1000 nodes.
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        ///   let random_graph = graph.random_subgraph(1000, Some(0xbad5eed), Some(true)).unwrap();
        /// ```
        ///
        /// # Raises
        /// * If the requested number of nodes is one or less.
        /// * If the graph has less than the requested number of nodes.
        pub fn random_subgraph(
            &self,
            nodes_number: NodeT,
            random_state: Option<usize>,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            if nodes_number <= 1 {
                return Err(String::from("Required nodes number must be more than 1."));
            }
            let verbose = verbose.unwrap_or(false);
            let random_state = random_state.unwrap_or(0xbadf00d);
            let connected_nodes_number = self.get_connected_nodes_number();
            if nodes_number > connected_nodes_number {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Required number of nodes (",
                            ") is more than available number of nodes (",
                            ") that have edges in current graph.",
                        ],
                        &match (&nodes_number, &connected_nodes_number) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                });
            }
            let pb1 = get_loading_bar(verbose, "Sampling nodes subset", nodes_number as usize);
            let pb2 = get_loading_bar(verbose, "Computing subgraph edges", nodes_number as usize);
            let pb3 = get_loading_bar(
                verbose,
                "Building subgraph",
                self.get_directed_edges_number() as usize,
            );
            let mut rnd = SmallRng::seed_from_u64(splitmix64(random_state as u64) as u64);
            let mut nodes: Vec<NodeT> = (0..self.get_nodes_number()).collect();
            nodes.shuffle(&mut rnd);
            let mut unique_nodes = RoaringBitmap::new();
            let mut stack: Vec<NodeT> = Vec::new();
            'outer: for node in nodes.iter() {
                if self.is_trap_node_from_node_id(*node).unwrap() {
                    continue;
                }
                stack.push(*node);
                while !stack.is_empty() {
                    let src = stack.pop().unwrap();
                    for dst in
                        unsafe { self.iter_unchecked_neighbour_node_ids_from_source_node_id(src) }
                    {
                        if !unique_nodes.contains(dst) && src != dst {
                            stack.push(dst);
                        }
                        unique_nodes.insert(*node);
                        unique_nodes.insert(dst);
                        pb1.inc(2);
                        if unique_nodes.len() as NodeT >= nodes_number {
                            break 'outer;
                        }
                    }
                }
            }
            pb1.finish();
            let edges_bitmap: RoaringTreemap = unique_nodes
                .iter()
                .progress_with(pb2)
                .flat_map(|src| unsafe {
                    let (min_edge_id, max_edge_id) =
                        self.get_unchecked_minmax_edge_ids_from_source_node_id(src);
                    (min_edge_id..max_edge_id)
                        .filter(|edge_id| {
                            unique_nodes.contains(
                                self.get_unchecked_destination_node_id_from_edge_id(*edge_id),
                            )
                        })
                        .collect::<Vec<EdgeT>>()
                })
                .collect();
            Graph::from_integer_sorted(
                edges_bitmap
                    .iter()
                    .progress_with(pb3)
                    .map(|edge_id| unsafe {
                        Ok(self
                            .get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(
                                edge_id,
                            ))
                    }),
                edges_bitmap.len() as usize,
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.directed,
                true,
                {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["", " subgraph"],
                        &match (&self.name.clone(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                },
                false,
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                true,
                self.has_selfloops(),
                true,
            )
        }
        /// Returns train and test graph following kfold validation scheme.
        ///
        /// The edges are splitted into k chunks. The k_index-th chunk is used to build
        /// the validation graph, all the other edges create the training graph.
        ///
        /// # Arguments
        /// * `k`: EdgeT - The number of folds.
        /// * `k_index`: u64 - Which fold to use for the validation.
        /// * `edge_types`: Option<Vec<Option<String>>> - Edge types to be selected when computing the folds (All the edge types not listed here will be always be used in the training set).
        /// * `random_state`: Option<EdgeT> - The random_state (seed) to use for the holdout,
        /// * `verbose`: Option<bool> - Whether to show the loading bar.
        ///
        /// # Example
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// for i in 0..5 {
        ///     let (train, test) = graph.kfold(5, i, None, Some(0xbad5eed), None).unwrap();
        ///     // Run the training
        /// }
        /// ```
        /// If We pass a vector of edge types, the K-fold will be executed only on the edges which match
        /// that type. All the other edges will always appear in the traning set.
        ///
        /// # Raises
        /// * If the number of requested k folds is one or zero.
        /// * If the given k fold index is greater than the number of k folds.
        /// * If edge types have been specified but it's an empty list.
        /// * If the number of k folds is higher than the number of edges in the graph.
        pub fn kfold(
            &self,
            k: EdgeT,
            k_index: u64,
            edge_types: Option<Vec<Option<String>>>,
            random_state: Option<EdgeT>,
            verbose: Option<bool>,
        ) -> Result<(Graph, Graph)> {
            if k <= 1 {
                return Err(String::from(
                    "Cannot do a k-fold with only one or zero folds.",
                ));
            }
            if k_index >= k {
                return Err(String::from(
                    "The index of the k-fold must be strictly less than the number of folds.",
                ));
            }
            let random_state = random_state.unwrap_or(0xbadf00d);
            let mut indices = if let Some(ets) = edge_types {
                if ets.is_empty() {
                    return Err(String::from(
                        "Required edge types must be a non-empty list.",
                    ));
                }
                let edge_type_ids = self
                    .get_edge_type_ids_from_edge_type_names(ets)?
                    .into_iter()
                    .collect::<HashSet<Option<EdgeTypeT>>>();
                self.iter_edge_node_ids_and_edge_type_id(self.directed)
                    .filter_map(|(edge_id, _, _, edge_type)| {
                        if !edge_type_ids.contains(&edge_type) {
                            return None;
                        }
                        Some(edge_id)
                    })
                    .collect::<Vec<EdgeT>>()
            } else {
                self.iter_edge_node_ids(self.directed)
                    .map(|(edge_id, _, _)| edge_id)
                    .collect::<Vec<EdgeT>>()
            };
            if k >= indices.len() as EdgeT {
                return Err(String::from(
                    "Cannot do a number of k-fold greater than the number of available edges.",
                ));
            }
            let mut rng = SmallRng::seed_from_u64(splitmix64(random_state) as EdgeT);
            indices.shuffle(&mut rng);
            let chunk_size = indices.len() as f64 / k as f64;
            let start = (k_index as f64 * chunk_size).ceil() as EdgeT;
            let end = std::cmp::min(
                indices.len() as EdgeT,
                (((k_index + 1) as f64) * chunk_size).ceil() as EdgeT,
            );
            let chunk: RoaringTreemap = indices[start as usize..end as usize]
                .iter()
                .cloned()
                .collect();
            self.edge_holdout(
                Some(random_state),
                end - start,
                false,
                |edge_id, _, _, _| chunk.contains(edge_id),
                verbose,
                true,
                self.has_selfloops(),
            )
        }
    }
}
mod iter_queries {
    use super::*;
    use rayon::prelude::*;
    /// # Iterators
    /// The methods must follow the following naming convenction
    /// * `/iter_(.+?)_from_(.+)/`
    /// * `/iter_(.+?)_from_(.+)_unchecked/`
    /// * `/par_iter_(.+?)_from_(.+)/`
    /// * `/par_iter_(.+?)_from_(.+)_unchecked/`
    impl Graph {
        /// Returns range of the edge ids of edges starting from the given source node.
        ///
        /// # Arguments
        ///
        /// * `src`: NodeT - Source node of the edge.
        ///
        /// # Safety
        /// If the given node ID does not exist in the graph the method will panic.
        pub unsafe fn iter_unchecked_edge_ids_from_source_node_id(
            &self,
            src: NodeT,
        ) -> std::ops::Range<usize> {
            let (min_edge_id, max_edge_id) =
                self.get_unchecked_minmax_edge_ids_from_source_node_id(src);
            min_edge_id as usize..max_edge_id as usize
        }
        /// Returns iterator over the edge weights that have given node ID as source.
        ///
        /// This method assumes that the given source node ID exists in the graph.
        /// Additionally it assumes that the graph has weights.
        /// If either one of the above assumptions are not true, it will panic.
        ///
        /// # Arguments
        /// * `source_node_id`: NodeT - The source node whose weights are to be returned.
        ///
        /// # Safety
        /// If the given node ID does not exist in the graph the method will panic.
        pub unsafe fn iter_unchecked_edge_weights_from_source_node_id(
            &self,
            source_node_id: NodeT,
        ) -> impl Iterator<Item = WeightT> + '_ {
            self.weights
                .as_ref()
                .map(|weights| {
                    weights[self.iter_unchecked_edge_ids_from_source_node_id(source_node_id)]
                        .iter()
                        .cloned()
                })
                .unwrap()
        }
        /// Returns range of the edge ids of edges starting from the given source node.
        ///
        /// # Arguments
        ///
        /// * `src`: NodeT - Source node of the edge.
        ///
        /// # Safety
        /// If the given node ID does not exist in the graph the method will panic.
        pub unsafe fn par_iter_unchecked_edge_ids_from_source_node_id(
            &self,
            src: NodeT,
        ) -> impl ParallelIterator<Item = NodeT> + '_ {
            self.iter_unchecked_edge_ids_from_source_node_id(src)
                .into_par_iter()
                .map(|node_id| node_id as NodeT)
        }
        /// Returns range of multigraph minimum and maximum edge ids with same source and destination nodes and different edge type.
        ///
        /// # Arguments
        ///
        /// * `src`: NodeT - Source node of the edge.
        /// * `dst`: NodeT -  Destination node of the edge.
        ///
        /// # Safety
        /// If any the given node IDs does not exist in the graph the method will panic.
        pub unsafe fn iter_unchecked_edge_ids_from_node_ids(
            &self,
            src: NodeT,
            dst: NodeT,
        ) -> impl Iterator<Item = EdgeT> {
            let (min_edge_id, max_edge_id) =
                self.get_unchecked_minmax_edge_ids_from_node_ids(src, dst);
            min_edge_id..max_edge_id
        }
        /// Return iterator over NodeT of destinations of the given node src.
        ///
        /// # Arguments
        /// * `src`: NodeT - The node whose neighbours are to be retrieved.
        ///
        /// # Safety
        /// If the given node ID does not exist in the graph the method will panic.
        pub unsafe fn iter_unchecked_neighbour_node_ids_from_source_node_id(
            &self,
            src: NodeT,
        ) -> Box<dyn Iterator<Item = NodeT> + Send + '_> {
            match &self.destinations {
                Some(dsts) => Box::new(
                    dsts[self.iter_unchecked_edge_ids_from_source_node_id(src)]
                        .iter()
                        .cloned(),
                ),
                None => Box::new(
                    self.edges
                        .iter_in_range(self.encode_edge(src, 0)..self.encode_edge(src + 1, 0))
                        .map(move |edge| self.decode_edge(edge).1),
                ),
            }
        }
        /// Return iterator over neighbours intersection.
        ///
        /// # Arguments
        /// * `first_src_node_id`: NodeT - The first node whose neighbours are to be retrieved.
        /// * `second_src_node_id`: NodeT - The second node whose neighbours are to be retrieved.
        ///
        /// # Safety
        /// If any of the given node ID does not exist in the graph the method will panic.
        pub unsafe fn iter_unchecked_neighbour_node_ids_intersection_from_source_node_ids(
            &self,
            first_src_node_id: NodeT,
            second_src_node_id: NodeT,
        ) -> impl Iterator<Item = NodeT> + Send + '_ {
            iter_set::intersection(
                self.iter_unchecked_neighbour_node_ids_from_source_node_id(first_src_node_id),
                self.iter_unchecked_neighbour_node_ids_from_source_node_id(second_src_node_id),
            )
        }
        /// Return iterator over neighbours union.
        ///
        /// # Arguments
        /// * `first_src_node_id`: NodeT - The first node whose neighbours are to be retrieved.
        /// * `second_src_node_id`: NodeT - The second node whose neighbours are to be retrieved.
        ///
        /// # Safety
        /// If any of the given node ID does not exist in the graph the method will panic.
        pub unsafe fn iter_unchecked_neighbour_node_ids_union_from_source_node_ids(
            &self,
            first_src_node_id: NodeT,
            second_src_node_id: NodeT,
        ) -> impl Iterator<Item = NodeT> + Send + '_ {
            iter_set::union(
                self.iter_unchecked_neighbour_node_ids_from_source_node_id(first_src_node_id),
                self.iter_unchecked_neighbour_node_ids_from_source_node_id(second_src_node_id),
            )
        }
        /// Return iterator over neighbours difference.
        ///
        /// # Arguments
        /// * `first_src_node_id`: NodeT - The first node whose neighbours are to be retrieved.
        /// * `second_src_node_id`: NodeT - The second node whose neighbours are to be retrieved.
        ///
        /// # Safety
        /// If any of the given node ID does not exist in the graph the method will panic.
        pub unsafe fn iter_unchecked_neighbour_node_ids_difference_from_source_node_ids(
            &self,
            first_src_node_id: NodeT,
            second_src_node_id: NodeT,
        ) -> impl Iterator<Item = NodeT> + Send + '_ {
            iter_set::difference(
                self.iter_unchecked_neighbour_node_ids_from_source_node_id(first_src_node_id),
                self.iter_unchecked_neighbour_node_ids_from_source_node_id(second_src_node_id),
            )
        }
        /// Return iterator over NodeT of destinations of the given node src.
        ///
        /// # Arguments
        /// * `src`: NodeT - The node whose neighbour names are to be retrieved.
        ///
        /// # Safety
        /// If the given node ID does not exist in the graph the method will panic.
        pub unsafe fn iter_unchecked_neighbour_node_names_from_source_node_id(
            &self,
            src: NodeT,
        ) -> impl Iterator<Item = String> + '_ {
            self.iter_unchecked_neighbour_node_ids_from_source_node_id(src)
                .map(move |dst| self.get_unchecked_node_name_from_node_id(dst))
        }
        /// Returns option of range of multigraph minimum and maximum edge ids with same source and destination nodes and different edge type.
        ///
        /// # Arguments
        ///
        /// * `src`: NodeT - Source node id of the edge.
        /// * `dst`: NodeT -  Destination node id of the edge.
        ///
        pub fn iter_edge_ids_from_node_ids(
            &self,
            src: NodeT,
            dst: NodeT,
        ) -> Result<impl Iterator<Item = EdgeT>> {
            let (min_edge_id, max_edge_id) = self.get_minmax_edge_ids_from_node_ids(src, dst)?;
            Ok(min_edge_id..max_edge_id)
        }
        /// Returns iterator over edge IDs and their properties with given edge type.
        ///
        /// # Arguments
        /// * `edge_type_id`: Option<EdgeTypeT> - Edge type ID to extract.
        /// * `directed`: bool - Whether to iterate the edge list as directed or undirected.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        /// * If the given edge type ID does not exist in the graph.
        pub fn iter_edge_node_ids_and_edge_type_id_from_edge_type_id(
            &self,
            edge_type_id: Option<EdgeTypeT>,
            directed: bool,
        ) -> Result<impl Iterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>)> + '_> {
            self.validate_edge_type_id(edge_type_id)
                .map(|edge_type_id| {
                    self.iter_edge_node_ids_and_edge_type_id(directed).filter(
                        move |(_, _, _, this_edge_type_id)| *this_edge_type_id == edge_type_id,
                    )
                })
        }
        /// Returns iterator over node IDs and their properties with given node type.
        ///
        /// # Arguments
        /// * `node_type_id`: Option<NodeTypeT> - node type ID to extract.
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        /// * If the given node type ID does not exist in the graph.
        pub fn iter_node_ids_and_node_type_ids_from_node_type_id(
            &self,
            node_type_id: Option<NodeTypeT>,
        ) -> Result<impl Iterator<Item = (NodeT, Option<Vec<NodeTypeT>>)> + '_> {
            self.validate_node_type_id(node_type_id)
                .map(|node_type_id| {
                    self.iter_node_ids_and_node_type_ids()
                        .filter(move |(_, this_node_type_ids)| {
                            match (this_node_type_ids, &node_type_id) {
                                (Some(tntis), Some(nti)) => tntis.contains(nti),
                                (None, None) => true,
                                _ => false,
                            }
                        })
                })
        }
        /// Returns iterator over node names and their properties with given node type.
        ///
        /// # Arguments
        /// * `node_type_id`: Option<NodeTypeT> - node type ID to extract.
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        /// * If the given node type ID does not exist in the graph.
        pub fn iter_node_names_and_node_type_names_from_node_type_id(
            &self,
            node_type_id: Option<NodeTypeT>,
        ) -> Result<
            impl Iterator<Item = (NodeT, String, Option<Vec<NodeTypeT>>, Option<Vec<String>>)> + '_,
        > {
            self.validate_node_type_id(node_type_id)
                .map(|node_type_id| {
                    self.iter_node_names_and_node_type_names().filter(
                        move |(_, _, this_node_type_ids, _)| match (
                            this_node_type_ids,
                            &node_type_id,
                        ) {
                            (Some(tntis), Some(nti)) => tntis.contains(nti),
                            (None, None) => true,
                            _ => false,
                        },
                    )
                })
        }
        /// Returns iterator over edge node names and their properties with given edge type.
        ///
        /// # Arguments
        /// * `edge_type_id`: Option<EdgeTypeT> - Edge type ID to extract.
        /// * `directed`: bool - Whether to iterate the edge list as directed or undirected.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        /// * If the given edge type ID does not exist in the graph.
        pub fn iter_edge_node_names_and_edge_type_name_from_edge_type_id(
            &self,
            edge_type_id: Option<EdgeTypeT>,
            directed: bool,
        ) -> Result<
            impl Iterator<
                    Item = (
                        EdgeT,
                        NodeT,
                        String,
                        NodeT,
                        String,
                        Option<EdgeTypeT>,
                        Option<String>,
                    ),
                > + '_,
        > {
            self.validate_edge_type_id(edge_type_id)
                .map(|edge_type_id| {
                    self.iter_edge_node_names_and_edge_type_name(directed)
                        .filter(move |(_, _, _, _, _, this_edge_type_id, _)| {
                            *this_edge_type_id == edge_type_id
                        })
                })
        }
    }
}
mod iters {
    use super::*;
    use rayon::prelude::*;
    /// # Iterators
    /// The naming convention for the iterators is:
    /// If the method has the `par_` prefix then it should return a parallel iterator.
    /// By default all the methods retruns both the ids and the name of the item and
    /// if the method has the suffix `_ids` then it will returns **only** the ids.
    /// Therefore, the naming convetions are:
    /// * `/iter_(.+)/`
    /// * `/iter_(.+)_unchecked/`
    /// * `/par_iter_(.+)/`
    /// * `/par_iter_(.+)_unchecked/`
    impl Graph {
        /// Return iterator on the node IDs of the graph.
        pub fn iter_node_ids(&self) -> impl Iterator<Item = NodeT> + '_ {
            0..self.get_nodes_number()
        }
        /// Return parallel iterator on the node of the graph.
        pub fn par_iter_node_ids(&self) -> impl IndexedParallelIterator<Item = NodeT> + '_ {
            (0..self.get_nodes_number()).into_par_iter()
        }
        /// Return iterator on the node names of the graph.
        pub fn iter_node_names(&self) -> impl Iterator<Item = String> + '_ {
            self.iter_node_ids()
                .map(move |node_id| unsafe { self.get_unchecked_node_name_from_node_id(node_id) })
        }
        /// Return parallel iterator on the node names of the graph.
        pub fn par_iter_node_names(&self) -> impl IndexedParallelIterator<Item = String> + '_ {
            self.nodes.reverse_map.par_iter().cloned()
        }
        /// Return iterator on the unique node type IDs of the graph.
        pub fn iter_unique_node_type_ids(&self) -> Result<impl Iterator<Item = NodeTypeT> + '_> {
            Ok(0..self.get_node_types_number()?)
        }
        /// Return iterator on the unique node type IDs counts of the graph.
        pub fn iter_node_type_counts(&self) -> Result<impl Iterator<Item = NodeT> + '_> {
            self.must_have_node_types()
                .map(|node_types| node_types.counts.iter().cloned())
        }
        /// Return iterator on the unique node type IDs and their counts of the graph.
        pub fn iter_unique_node_type_ids_and_counts(
            &self,
        ) -> Result<impl Iterator<Item = (NodeTypeT, NodeT)> + '_> {
            Ok(self
                .iter_unique_node_type_ids()?
                .zip(self.iter_node_type_counts()?))
        }
        /// Return iterator on the unique node type names of the graph.
        pub fn iter_unique_node_type_names(&self) -> Result<impl Iterator<Item = String> + '_> {
            self.must_have_node_types()
                .map(|node_types| node_types.vocabulary.reverse_map.iter().cloned())
        }
        /// Return iterator on the unique node type names and their counts of the graph.
        pub fn iter_unique_node_type_names_and_counts(
            &self,
        ) -> Result<impl Iterator<Item = (String, NodeT)> + '_> {
            Ok(self
                .iter_unique_node_type_names()?
                .zip(self.iter_node_type_counts()?))
        }
        /// Return iterator on the edge type IDs of the graph.
        pub fn iter_unique_edge_type_ids(&self) -> Result<impl Iterator<Item = EdgeTypeT> + '_> {
            Ok(0..self.get_edge_types_number()?)
        }
        /// Return iterator on the unique edge type IDs counts of the graph.
        pub fn iter_edge_type_counts(&self) -> Result<impl Iterator<Item = EdgeT> + '_> {
            self.must_have_edge_types()
                .map(|edge_types| edge_types.counts.iter().cloned())
        }
        /// Return iterator on the unique edge type IDs and their counts of the graph.
        pub fn iter_unique_edge_type_ids_and_counts(
            &self,
        ) -> Result<impl Iterator<Item = (EdgeTypeT, EdgeT)> + '_> {
            Ok(self
                .iter_unique_edge_type_ids()?
                .zip(self.iter_edge_type_counts()?))
        }
        /// Return iterator on the unique edge type names and their counts of the graph.
        pub fn iter_unique_edge_type_names_and_counts(
            &self,
        ) -> Result<impl Iterator<Item = (String, EdgeT)> + '_> {
            Ok(self
                .iter_unique_edge_type_names()?
                .zip(self.iter_edge_type_counts()?))
        }
        /// Return iterator on the unique edge type names of the graph.
        pub fn iter_unique_edge_type_names(&self) -> Result<impl Iterator<Item = String> + '_> {
            self.must_have_edge_types()
                .map(|edge_types| edge_types.vocabulary.reverse_map.iter().cloned())
        }
        /// Return iterator on the unweighted node degrees of the graph.
        ///
        /// Note that with unweighted it is meant that if this graph instance
        /// has weights, the degree will not take them into consideration.
        pub fn iter_node_degrees(&self) -> impl Iterator<Item = NodeT> + '_ {
            self.iter_node_ids()
                .map(move |node| unsafe { self.get_unchecked_node_degree_from_node_id(node) })
        }
        /// Return iterator on the unweighted node degrees of the graph.
        ///
        /// Note that with unweighted it is meant that if this graph instance
        /// has weights, the degree will not take them into consideration.
        pub fn par_iter_node_degrees(&self) -> impl IndexedParallelIterator<Item = NodeT> + '_ {
            self.par_iter_node_ids()
                .map(move |node_id| unsafe { self.get_unchecked_node_degree_from_node_id(node_id) })
        }
        /// Return iterator on the weighted node degrees of the graph.
        ///
        /// Note that with weighted it is meant that if this graph instance
        /// has weights, the degree will be weighted on the edge weight.
        ///
        /// Note that if one or more edges have a negative edge weight,
        /// the resulting node degree may be negative.
        /// This check is **NOT** done by this method, as in some situations
        /// this may be desired by the user.
        pub fn iter_weighted_node_degrees(&self) -> Result<impl Iterator<Item = f64> + '_> {
            self.must_have_edge_weights()?;
            Ok(self.iter_node_ids().map(move |node_id| unsafe {
                self.get_unchecked_weighted_node_degree_from_node_id(node_id)
            }))
        }
        /// Return iterator on the weighted node degrees of the graph.
        ///
        /// Note that with weighted it is meant that if this graph instance
        /// has weights, the degree will not take them into consideration.
        ///
        /// Note that if one or more edges have a negative edge weight,
        /// the resulting node degree may be negative.
        /// This check is **NOT** done by this method, as in some situations
        /// this may be desired by the user.
        pub fn par_iter_weighted_node_degrees(
            &self,
        ) -> Result<impl IndexedParallelIterator<Item = f64> + '_> {
            self.must_have_edge_weights()?;
            Ok(self.par_iter_node_ids().map(move |node_id| unsafe {
                self.get_unchecked_weighted_node_degree_from_node_id(node_id)
            }))
        }
        /// Return iterator on the non-singleton nodes of the graph.
        ///
        /// Note that this includes also the singleton with self-loops and
        /// the trap nodes within this iterator. Only true singleton nodes,
        /// that is, nodes without any edge (both inbound and outbound) are
        /// included.
        ///
        /// Since the following requires to be boxed, we cannot create the
        /// parallel version of this iterator.
        ///
        pub fn iter_connected_node_ids(&self) -> Box<dyn Iterator<Item = NodeT> + '_> {
            match self.connected_nodes.as_ref() {
                Some(nsns) => Box::new(nsns.iter_ones().map(|node_id| node_id as NodeT)),
                _ => Box::new(self.iter_node_ids()),
            }
        }
        /// Return iterator on the singleton nodes IDs of the graph.
        pub fn iter_singleton_node_ids(&self) -> Box<dyn Iterator<Item = NodeT> + '_> {
            match self.connected_nodes.as_ref() {
                Some(nsns) => Box::new(nsns.iter_zeros().map(|node_id| node_id as NodeT)),
                _ => Box::new(::std::iter::empty()),
            }
        }
        /// Return iterator on the singleton nodes names of the graph.
        pub fn iter_singleton_node_names(&self) -> impl Iterator<Item = String> + '_ {
            self.iter_singleton_node_ids()
                .map(move |node_id| unsafe { self.get_unchecked_node_name_from_node_id(node_id) })
        }
        /// Return iterator on the singleton with selfloops node IDs of the graph.
        pub fn iter_singleton_nodes_with_selfloops_node_ids(
            &self,
        ) -> Box<dyn Iterator<Item = NodeT> + '_> {
            match self.singleton_nodes_with_selfloops.as_ref() {
                Some(nsns) => Box::new(nsns.iter()),
                _ => Box::new(::std::iter::empty()),
            }
        }
        /// Return iterator on the singleton with selfloops node names of the graph.
        pub fn iter_singleton_nodes_with_selfloops_node_names(
            &self,
        ) -> impl Iterator<Item = String> + '_ {
            self.iter_singleton_nodes_with_selfloops_node_ids()
                .map(move |node_id| unsafe { self.get_unchecked_node_name_from_node_id(node_id) })
        }
        /// Return iterator on the singleton node type IDs of the graph.
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn iter_singleton_node_type_ids(&self) -> Result<impl Iterator<Item = NodeTypeT> + '_> {
            self.iter_unique_node_type_ids_and_counts().map(
                |iter_unique_node_type_ids_and_counts| {
                    iter_unique_node_type_ids_and_counts.filter_map(|(node_type_id, count)| {
                        if count == 1 {
                            Some(node_type_id)
                        } else {
                            None
                        }
                    })
                },
            )
        }
        /// Return iterator on the singleton edge type IDs of the graph.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn iter_singleton_edge_type_ids(&self) -> Result<impl Iterator<Item = EdgeTypeT> + '_> {
            self.iter_unique_edge_type_ids_and_counts().map(
                |iter_unique_edge_type_ids_and_counts| {
                    iter_unique_edge_type_ids_and_counts.filter_map(|(edge_type_id, count)| {
                        if count == 1 {
                            Some(edge_type_id)
                        } else {
                            None
                        }
                    })
                },
            )
        }
        /// Return iterator on the singleton node type names of the graph.
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn iter_singleton_node_type_names(&self) -> Result<impl Iterator<Item = String> + '_> {
            self.iter_unique_node_type_names_and_counts().map(
                |iter_unique_node_type_names_and_counts| {
                    iter_unique_node_type_names_and_counts.filter_map(|(node_type_id, count)| {
                        if count == 1 {
                            Some(node_type_id)
                        } else {
                            None
                        }
                    })
                },
            )
        }
        /// Return iterator on the singleton edge type names of the graph.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn iter_singleton_edge_type_names(&self) -> Result<impl Iterator<Item = String> + '_> {
            self.iter_unique_edge_type_names_and_counts().map(
                |iter_unique_edge_type_names_and_counts| {
                    iter_unique_edge_type_names_and_counts.filter_map(|(edge_type_id, count)| {
                        if count == 1 {
                            Some(edge_type_id)
                        } else {
                            None
                        }
                    })
                },
            )
        }
        /// Return iterator on the (non unique) source nodes of the graph.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn iter_source_node_ids(&self, directed: bool) -> impl Iterator<Item = NodeT> + '_ {
            self.iter_edge_node_ids(directed)
                .map(move |(_, src, _)| src)
        }
        /// Return iterator on the edges' weights.
        ///
        /// # Example
        /// To get an iterator over the edges weights you can use:
        /// ```rust
        /// # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);
        /// # let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);
        /// assert!(graph_with_weights.iter_edge_weights().is_ok());
        /// assert!(graph_without_weights.iter_edge_weights().is_err());
        /// println!("The graph weights are {:?}.", graph_with_weights.iter_edge_weights().unwrap().collect::<Vec<_>>());
        /// ```
        pub fn iter_edge_weights(&self) -> Result<impl Iterator<Item = WeightT> + '_> {
            self.must_have_edge_weights()?;
            Ok(self.weights.as_ref().map(|ws| ws.iter().cloned()).unwrap())
        }
        /// Return parallel iterator on the edges' weights.
        ///
        /// # Example
        /// To get an iterator over the edges weights you can use:
        /// ```rust
        /// # use rayon::iter::ParallelIterator;
        /// # let graph_with_weights = graph::test_utilities::load_ppi(false, false, true, true, false, false);
        /// # let graph_without_weights = graph::test_utilities::load_ppi(false, false, false, true, false, false);
        /// assert!(graph_with_weights.iter_edge_weights().is_ok());
        /// assert!(graph_without_weights.iter_edge_weights().is_err());
        /// println!("The graph weights are {:?}.", graph_with_weights.par_iter_edge_weights().unwrap().collect::<Vec<_>>());
        /// ```
        pub fn par_iter_edge_weights(
            &self,
        ) -> Result<impl IndexedParallelIterator<Item = WeightT> + '_> {
            self.must_have_edge_weights()?;
            Ok(self
                .weights
                .as_ref()
                .map(|ws| ws.par_iter().cloned())
                .unwrap())
        }
        /// Return parallel iterator on the (non unique) source nodes of the graph.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn par_iter_source_node_ids(
            &self,
            directed: bool,
        ) -> impl ParallelIterator<Item = NodeT> + '_ {
            self.par_iter_edge_node_ids(directed)
                .map(move |(_, src, _)| src)
        }
        /// Return iterator on the (non unique) destination nodes of the graph.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn iter_destination_node_ids(
            &self,
            directed: bool,
        ) -> impl Iterator<Item = NodeT> + '_ {
            self.iter_edge_node_ids(directed)
                .map(move |(_, _, dst)| dst)
        }
        /// Return parallel iterator on the (non unique) destination nodes of the graph.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn par_iter_destination_node_ids(
            &self,
            directed: bool,
        ) -> impl ParallelIterator<Item = NodeT> + '_ {
            self.par_iter_edge_node_ids(directed)
                .map(move |(_, _, dst)| dst)
        }
        /// Return iterator on the node IDs and ther node type IDs.
        pub fn iter_node_ids_and_node_type_ids(
            &self,
        ) -> impl Iterator<Item = (NodeT, Option<Vec<NodeTypeT>>)> + '_ {
            self.iter_node_ids().map(move |node_id| unsafe {
                (
                    node_id,
                    self.get_unchecked_node_type_id_from_node_id(node_id),
                )
            })
        }
        /// Return iterator on the node type IDs.
        ///
        /// # Safety
        /// If the graph does not contain node types, this iterator will be an
        /// iterator over None values.
        pub unsafe fn iter_unchecked_node_type_ids(
            &self,
        ) -> impl Iterator<Item = Option<Vec<NodeTypeT>>> + '_ {
            self.iter_node_ids()
                .map(move |node_id| self.get_unchecked_node_type_id_from_node_id(node_id))
        }
        /// Return iterator on the one-hot encoded node type IDs.
        ///
        /// # Raises
        /// * If the graph does not contain node types.
        pub fn iter_one_hot_encoded_node_type_ids(
            &self,
        ) -> Result<impl Iterator<Item = Vec<bool>> + '_> {
            let node_types_number = self.get_node_types_number()?;
            Ok(unsafe {
                self.iter_unchecked_node_type_ids()
                    .map(move |maybe_node_types| {
                        let mut dummies =
                            ::alloc::vec::from_elem(false, node_types_number as usize);
                        if let Some(node_types) = maybe_node_types {
                            node_types.into_iter().for_each(|node_type| {
                                dummies[node_type as usize] = true;
                            });
                        }
                        dummies
                    })
            })
        }
        /// Return iterator on the known one-hot encoded node type IDs.
        ///
        /// # Raises
        /// * If the graph does not contain node types.
        pub fn iter_one_hot_encoded_known_node_type_ids(
            &self,
        ) -> Result<impl Iterator<Item = Vec<bool>> + '_> {
            let node_types_number = self.get_node_types_number()?;
            Ok(unsafe {
                self.iter_unchecked_node_type_ids()
                    .filter_map(move |maybe_node_types| {
                        if let Some(node_types) = maybe_node_types {
                            let mut dummies =
                                ::alloc::vec::from_elem(false, node_types_number as usize);
                            node_types.into_iter().for_each(|node_type| {
                                dummies[node_type as usize] = true;
                            });
                            Some(dummies)
                        } else {
                            None
                        }
                    })
            })
        }
        /// Return iterator on the node of the graph.
        ///
        /// # Safety
        /// If the graph does not contain node types, this iterator will be an
        /// iterator over None values as node types.
        pub unsafe fn par_iter_unchecked_node_ids_and_node_type_ids(
            &self,
        ) -> impl ParallelIterator<Item = (NodeT, Option<Vec<NodeTypeT>>)> + '_ {
            self.par_iter_node_ids().map(move |node_id| {
                (
                    node_id,
                    self.get_unchecked_node_type_id_from_node_id(node_id),
                )
            })
        }
        /// Return iterator on the node of the graph as Strings.
        pub fn iter_node_names_and_node_type_names(
            &self,
        ) -> impl Iterator<Item = (NodeT, String, Option<Vec<NodeTypeT>>, Option<Vec<String>>)> + '_
        {
            self.iter_node_ids_and_node_type_ids()
                .map(move |(node_id, node_types)| unsafe {
                    (
                        node_id,
                        self.get_unchecked_node_name_from_node_id(node_id),
                        node_types,
                        self.get_unchecked_node_type_names_from_node_id(node_id),
                    )
                })
        }
        /// Return parallell iterator on the node of the graph as Strings.
        pub fn par_iter_node_names_and_node_type_names(
            &self,
        ) -> impl ParallelIterator<Item = (NodeT, String, Option<Vec<NodeTypeT>>, Option<Vec<String>>)>
               + '_ {
            unsafe {
                self.par_iter_unchecked_node_ids_and_node_type_ids().map(
                    move |(node_id, node_types)| {
                        (
                            node_id,
                            self.get_unchecked_node_name_from_node_id(node_id),
                            node_types,
                            self.get_unchecked_node_type_names_from_node_id(node_id),
                        )
                    },
                )
            }
        }
        /// Return iterator on the edges of the graph.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn iter_edge_node_ids(
            &self,
            directed: bool,
        ) -> Box<dyn Iterator<Item = (EdgeT, NodeT, NodeT)> + '_> {
            if self.sources.is_some() && self.destinations.is_some() {
                return Box::new((0..self.get_directed_edges_number()).filter_map(
                    move |edge_id| {
                        let (src, dst) =
                            unsafe { self.get_unchecked_node_ids_from_edge_id(edge_id) };
                        if !directed && src > dst {
                            return None;
                        }
                        Some((edge_id, src, dst))
                    },
                ));
            }
            Box::new(
                self.edges
                    .iter()
                    .enumerate()
                    .filter_map(move |(edge_id, edge)| {
                        let (src, dst) = self.decode_edge(edge);
                        if !directed && src > dst {
                            return None;
                        }
                        Some((edge_id as EdgeT, src, dst))
                    }),
            )
        }
        /// Return iterator on the edges of the graph with the string name.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn iter_edges(
            &self,
            directed: bool,
        ) -> impl Iterator<Item = (EdgeT, NodeT, String, NodeT, String)> + '_ {
            self.iter_edge_node_ids(directed)
                .map(move |(edge_id, src, dst)| unsafe {
                    (
                        edge_id,
                        src,
                        self.get_unchecked_node_name_from_node_id(src),
                        dst,
                        self.get_unchecked_node_name_from_node_id(dst),
                    )
                })
        }
        /// Return iterator on the edges of the graph.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn par_iter_edge_node_ids(
            &self,
            directed: bool,
        ) -> impl ParallelIterator<Item = (EdgeT, NodeT, NodeT)> + '_ {
            self.edges
                .par_iter()
                .enumerate()
                .filter_map(move |(edge_id, edge)| {
                    let (src, dst) = self.decode_edge(edge);
                    if !directed && src > dst {
                        return None;
                    }
                    Some((edge_id as EdgeT, src, dst))
                })
        }
        /// Return iterator on the directed edges of the graph.
        pub fn par_iter_directed_edge_ids(
            &self,
        ) -> impl IndexedParallelIterator<Item = (EdgeT, NodeT, NodeT)> + '_ {
            self.edges
                .par_iter()
                .enumerate()
                .map(move |(edge_id, edge)| {
                    let (src, dst) = self.decode_edge(edge);
                    (edge_id as EdgeT, src, dst)
                })
        }
        /// Return iterator on the edges of the graph with the string name.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn par_iter_edges(
            &self,
            directed: bool,
        ) -> impl ParallelIterator<Item = (EdgeT, NodeT, String, NodeT, String)> + '_ {
            self.par_iter_edge_node_ids(directed)
                .map(move |(edge_id, src, dst)| unsafe {
                    (
                        edge_id,
                        src,
                        self.get_unchecked_node_name_from_node_id(src),
                        dst,
                        self.get_unchecked_node_name_from_node_id(dst),
                    )
                })
        }
        /// Return iterator on the edges node IDs of the graph and their weights.
        ///
        /// # Raises
        /// * If the current graph instance does not contain edge weights.
        pub fn iter_edge_node_ids_and_edge_weight(
            &self,
        ) -> Result<impl Iterator<Item = (EdgeT, NodeT, NodeT, WeightT)> + '_> {
            Ok(self
                .iter_edge_node_ids(true)
                .zip(self.iter_edge_weights()?)
                .map(move |((edge_id, src, dst), weight)| (edge_id, src, dst, weight)))
        }
        /// Return parallel iterator on the edges node IDs of the graph and their weights.
        ///
        /// # Raises
        /// * If the current graph instance does not contain edge weights.
        pub fn par_iter_edge_node_ids_and_edge_weight(
            &self,
        ) -> Result<impl IndexedParallelIterator<Item = (EdgeT, NodeT, NodeT, WeightT)> + '_>
        {
            Ok(self
                .par_iter_directed_edge_ids()
                .zip(self.par_iter_edge_weights()?)
                .map(move |((edge_id, src, dst), weight)| (edge_id, src, dst, weight)))
        }
        /// Return iterator on the edge node IDs of the graph and their edge type ID
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn iter_edge_node_ids_and_edge_type_id(
            &self,
            directed: bool,
        ) -> impl Iterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>)> + '_ {
            self.iter_edge_node_ids(directed)
                .map(move |(edge_id, src, dst)| unsafe {
                    (
                        edge_id,
                        src,
                        dst,
                        self.get_unchecked_edge_type_id_from_edge_id(edge_id),
                    )
                })
        }
        /// Return iterator on the one-hot encoded edge type IDs.
        ///
        /// # Raises
        /// * If the current graph instance does not contain edge types.
        pub fn iter_one_hot_encoded_edge_type_ids(
            &self,
        ) -> Result<impl Iterator<Item = Vec<bool>> + '_> {
            let edge_types_number = self.get_edge_types_number()?;
            Ok(self
                .get_edge_type_ids()?
                .into_iter()
                .map(move |maybe_edge_type| {
                    let mut dummies = ::alloc::vec::from_elem(false, edge_types_number as usize);
                    if let Some(edge_type) = maybe_edge_type {
                        dummies[edge_type as usize] = true;
                    }
                    dummies
                }))
        }
        /// Return iterator on the one-hot encoded known edge type IDs.
        ///
        /// # Raises
        /// * If the current graph instance does not contain edge types.
        pub fn iter_one_hot_encoded_known_edge_type_ids(
            &self,
        ) -> Result<impl Iterator<Item = Vec<bool>> + '_> {
            let edge_types_number = self.get_edge_types_number()?;
            Ok(self
                .get_edge_type_ids()?
                .into_iter()
                .filter_map(move |maybe_edge_type| {
                    if let Some(edge_type) = maybe_edge_type {
                        let mut dummies =
                            ::alloc::vec::from_elem(false, edge_types_number as usize);
                        dummies[edge_type as usize] = true;
                        Some(dummies)
                    } else {
                        None
                    }
                }))
        }
        /// Return iterator on the edges of the graph with the string name.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn iter_edge_node_names_and_edge_type_name(
            &self,
            directed: bool,
        ) -> impl Iterator<
            Item = (
                EdgeT,
                NodeT,
                String,
                NodeT,
                String,
                Option<EdgeTypeT>,
                Option<String>,
            ),
        > + '_ {
            self.iter_edges(directed)
                .map(move |(edge_id, src, src_name, dst, dst_name)| unsafe {
                    let edge_type_id = self.get_unchecked_edge_type_id_from_edge_id(edge_id);
                    (
                        edge_id,
                        src,
                        src_name,
                        dst,
                        dst_name,
                        edge_type_id,
                        self.get_unchecked_edge_type_name_from_edge_type_id(edge_type_id),
                    )
                })
        }
        /// Return iterator on the edges of the graph with the ids and string name.
        /// The result is (edge_id, src, src_name, dst, dst_name, edge_type, edge_type_name)
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn par_iter_edge_node_names_and_edge_type_name(
            &self,
            directed: bool,
        ) -> impl ParallelIterator<
            Item = (
                EdgeT,
                NodeT,
                String,
                NodeT,
                String,
                Option<EdgeTypeT>,
                Option<String>,
            ),
        > + '_ {
            self.par_iter_edges(directed).map(
                move |(edge_id, src, src_name, dst, dst_name)| unsafe {
                    let edge_type_id = self.get_unchecked_edge_type_id_from_edge_id(edge_id);
                    (
                        edge_id,
                        src,
                        src_name,
                        dst,
                        dst_name,
                        edge_type_id,
                        self.get_unchecked_edge_type_name_from_edge_type_id(edge_type_id),
                    )
                },
            )
        }
        /// Return iterator on the edges of the graph.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn par_iter_edge_node_ids_and_edge_type_id(
            &self,
            directed: bool,
        ) -> impl ParallelIterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>)> + '_ {
            self.par_iter_edge_node_ids(directed)
                .map(move |(edge_id, src, dst)| unsafe {
                    (
                        edge_id,
                        src,
                        dst,
                        self.get_unchecked_edge_type_id_from_edge_id(edge_id),
                    )
                })
        }
        /// Return iterator on the edges of the graph with the string name.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn par_iter_edge_node_names_and_edge_type_name_and_edge_weight(
            &self,
            directed: bool,
        ) -> impl ParallelIterator<
            Item = (
                EdgeT,
                NodeT,
                String,
                NodeT,
                String,
                Option<EdgeTypeT>,
                Option<String>,
                Option<WeightT>,
            ),
        > + '_ {
            self . par_iter_edge_node_names_and_edge_type_name (directed) . map (move | (edge_id , src , src_name , dst , dst_name , edge_type , edge_type_name) | unsafe { (edge_id , src , src_name , dst , dst_name , edge_type , edge_type_name , self . get_unchecked_edge_weight_from_edge_id (edge_id)) })
        }
        /// Return iterator on the edges of the graph with the string name.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn iter_edge_node_names_and_edge_type_name_and_edge_weight(
            &self,
            directed: bool,
        ) -> impl Iterator<
            Item = (
                EdgeT,
                NodeT,
                String,
                NodeT,
                String,
                Option<EdgeTypeT>,
                Option<String>,
                Option<WeightT>,
            ),
        > + '_ {
            self.iter_edge_node_names_and_edge_type_name(directed).map(
                move |(edge_id, src, src_name, dst, dst_name, edge_type, edge_type_name)| unsafe {
                    (
                        edge_id,
                        src,
                        src_name,
                        dst,
                        dst_name,
                        edge_type,
                        edge_type_name,
                        self.get_unchecked_edge_weight_from_edge_id(edge_id),
                    )
                },
            )
        }
        /// Return iterator on the edges of the graph with the string name.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn par_iter_edge_node_ids_and_edge_type_id_and_edge_weight(
            &self,
            directed: bool,
        ) -> impl ParallelIterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>)> + '_
        {
            self.par_iter_edge_node_ids_and_edge_type_id(directed).map(
                move |(edge_id, src, dst, edge_type)| unsafe {
                    (
                        edge_id,
                        src,
                        dst,
                        edge_type,
                        self.get_unchecked_edge_weight_from_edge_id(edge_id),
                    )
                },
            )
        }
        /// Return iterator on the edges of the graph including node IDs, edge type and edge weight.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn iter_edge_node_ids_and_edge_type_id_and_edge_weight(
            &self,
            directed: bool,
        ) -> impl Iterator<Item = (EdgeT, NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>)> + '_
        {
            self.iter_edge_node_ids_and_edge_type_id(directed).map(
                move |(edge_id, src, dst, edge_type)| unsafe {
                    (
                        edge_id,
                        src,
                        dst,
                        edge_type,
                        self.get_unchecked_edge_weight_from_edge_id(edge_id),
                    )
                },
            )
        }
        /// Return iterator on the edges of the graph.
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to filter out the undirected edges.
        pub fn iter_unique_edge_node_ids(
            &self,
            directed: bool,
        ) -> Box<dyn Iterator<Item = (NodeT, NodeT)> + '_> {
            if self.sources.is_some() && self.destinations.is_some() {
                return Box::new((0..self.get_directed_edges_number()).filter_map(
                    move |edge_id| unsafe {
                        let (src, dst) = self.get_unchecked_node_ids_from_edge_id(edge_id);
                        if edge_id > 0 {
                            let (last_src, last_dst) =
                                self.get_unchecked_node_ids_from_edge_id(edge_id - 1);
                            if last_src == src && last_dst == dst {
                                return None;
                            }
                        }
                        if !directed && src > dst {
                            return None;
                        }
                        Some((src, dst))
                    },
                ));
            }
            Box::new(self.edges.iter_uniques().filter_map(move |edge| {
                let (src, dst) = self.decode_edge(edge);
                if !directed && src > dst {
                    return None;
                }
                Some((src, dst))
            }))
        }
        /// Return iterator on the unique sources of the graph.
        pub fn iter_unique_source_node_ids(&self) -> Box<dyn Iterator<Item = NodeT> + '_> {
            if let Some(x) = &self.unique_sources {
                return Box::new(x.iter().map(|source| source as NodeT));
            }
            Box::new(self.iter_node_ids())
        }
        /// Returns iterator over edge IDs of the edges with unknown edge types
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn iter_edge_ids_with_unknown_edge_types(
            &self,
        ) -> Result<impl Iterator<Item = EdgeT> + '_> {
            self.must_have_edge_types().map(|edge_types| {
                edge_types
                    .ids
                    .iter()
                    .enumerate()
                    .filter_map(|(edge_id, edge_type_id)| {
                        if edge_type_id.is_some() {
                            None
                        } else {
                            Some(edge_id as EdgeT)
                        }
                    })
            })
        }
        /// Returns iterator over edge IDs of the edges with known edge types
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn iter_edge_ids_with_known_edge_types(
            &self,
        ) -> Result<impl Iterator<Item = EdgeT> + '_> {
            self.must_have_edge_types().map(|edge_types| {
                edge_types
                    .ids
                    .iter()
                    .enumerate()
                    .filter_map(|(edge_id, edge_type_id)| {
                        if edge_type_id.is_some() {
                            Some(edge_id as EdgeT)
                        } else {
                            None
                        }
                    })
            })
        }
        /// Returns iterator over edge node IDs of the edges with unknown edge types
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to load the edges as directed or undirected.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn iter_edge_node_ids_with_unknown_edge_types(
            &self,
            directed: bool,
        ) -> Result<impl Iterator<Item = (NodeT, NodeT)> + '_> {
            self.must_have_edge_types()?;
            Ok(self
                .iter_edge_node_ids_and_edge_type_id(directed)
                .filter_map(|(_, src, dst, edge_type)| {
                    if edge_type.is_none() {
                        Some((src, dst))
                    } else {
                        None
                    }
                }))
        }
        /// Returns iterator over edge node IDs of the edges with known edge types
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to load the edges as directed or undirected.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn iter_edge_node_ids_with_known_edge_types(
            &self,
            directed: bool,
        ) -> Result<impl Iterator<Item = (NodeT, NodeT)> + '_> {
            self.must_have_edge_types()?;
            Ok(self
                .iter_edge_node_ids_and_edge_type_id(directed)
                .filter_map(|(_, src, dst, edge_type)| {
                    if edge_type.is_some() {
                        Some((src, dst))
                    } else {
                        None
                    }
                }))
        }
        /// Returns iterator over node IDs of the nodes with unknown node types
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn iter_node_ids_with_unknown_node_types(
            &self,
        ) -> Result<impl Iterator<Item = NodeT> + '_> {
            self.must_have_node_types().map(|node_types| {
                node_types
                    .ids
                    .iter()
                    .enumerate()
                    .filter_map(|(node_id, node_type_id)| {
                        if node_type_id.is_some() {
                            None
                        } else {
                            Some(node_id as NodeT)
                        }
                    })
            })
        }
        /// Returns iterator over node IDs of the nodes with known node types
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn iter_node_ids_with_known_node_types(
            &self,
        ) -> Result<impl Iterator<Item = NodeT> + '_> {
            self.must_have_node_types().map(|node_types| {
                node_types
                    .ids
                    .iter()
                    .enumerate()
                    .filter_map(|(node_id, node_type_id)| {
                        if node_type_id.is_some() {
                            Some(node_id as NodeT)
                        } else {
                            None
                        }
                    })
            })
        }
        /// Returns iterator over edge node names of the edges with unknown edge types
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to load the edges as directed or undirected.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn iter_edge_node_names_with_unknown_edge_types(
            &self,
            directed: bool,
        ) -> Result<impl Iterator<Item = (String, String)> + '_> {
            self.iter_edge_node_ids_with_unknown_edge_types(directed)
                .map(|x| {
                    x.map(move |(src, dst)| unsafe {
                        (
                            self.get_unchecked_node_name_from_node_id(src),
                            self.get_unchecked_node_name_from_node_id(dst),
                        )
                    })
                })
        }
        /// Returns iterator over edge node names of the edges with known edge types
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to load the edges as directed or undirected.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn iter_edge_node_names_with_known_edge_types(
            &self,
            directed: bool,
        ) -> Result<impl Iterator<Item = (String, String)> + '_> {
            self.iter_edge_node_ids_with_known_edge_types(directed)
                .map(|x| {
                    x.map(move |(src, dst)| unsafe {
                        (
                            self.get_unchecked_node_name_from_node_id(src),
                            self.get_unchecked_node_name_from_node_id(dst),
                        )
                    })
                })
        }
        /// Returns iterator over node names of the nodes with unknown node types
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn iter_node_names_with_unknown_node_types(
            &self,
        ) -> Result<impl Iterator<Item = String> + '_> {
            self.iter_node_ids_with_unknown_node_types().map(|x| {
                x.map(move |node_id| unsafe { self.get_unchecked_node_name_from_node_id(node_id) })
            })
        }
        /// Returns iterator over node names of the nodes with known node types
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn iter_node_names_with_known_node_types(
            &self,
        ) -> Result<impl Iterator<Item = String> + '_> {
            self.iter_node_ids_with_known_node_types().map(|x| {
                x.map(move |node_id| unsafe { self.get_unchecked_node_name_from_node_id(node_id) })
            })
        }
        /// Returns parallel iterator over edge IDs of the edges with unknown edge types
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn par_iter_edge_ids_with_unknown_edge_types(
            &self,
        ) -> Result<impl ParallelIterator<Item = EdgeT> + '_> {
            self.must_have_edge_types().map(|edge_types| {
                edge_types
                    .ids
                    .par_iter()
                    .enumerate()
                    .filter_map(|(edge_id, edge_type_id)| {
                        if edge_type_id.is_some() {
                            None
                        } else {
                            Some(edge_id as EdgeT)
                        }
                    })
            })
        }
        /// Returns parallel iterator over edge IDs of the edges with known edge types
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn par_iter_edge_ids_with_known_edge_types(
            &self,
        ) -> Result<impl ParallelIterator<Item = EdgeT> + '_> {
            self.must_have_edge_types().map(|edge_types| {
                edge_types
                    .ids
                    .par_iter()
                    .enumerate()
                    .filter_map(|(edge_id, edge_type_id)| {
                        if edge_type_id.is_some() {
                            Some(edge_id as EdgeT)
                        } else {
                            None
                        }
                    })
            })
        }
        /// Returns parallel iterator over edge node IDs of the edges with unknown edge types
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to load the edges as directed or undirected.
        ///
        /// # Raises
        /// * If there arIndexedParallele no edge types in the graph.
        pub fn par_iter_edge_node_ids_with_unknown_edge_types(
            &self,
            directed: bool,
        ) -> Result<impl ParallelIterator<Item = (NodeT, NodeT)> + '_> {
            self.must_have_edge_types()?;
            Ok(self
                .par_iter_edge_node_ids_and_edge_type_id(directed)
                .filter_map(|(_, src, dst, edge_type)| {
                    if edge_type.is_none() {
                        Some((src, dst))
                    } else {
                        None
                    }
                }))
        }
        /// Returns parallel iterator over edge node IDs of the edges with known edge types
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to load the edges as directed or undirected.
        ///
        /// # Raises
        /// * If there arIndexedParallele no edge types in the graph.
        pub fn par_iter_edge_node_ids_with_known_edge_types(
            &self,
            directed: bool,
        ) -> Result<impl ParallelIterator<Item = (NodeT, NodeT)> + '_> {
            self.must_have_edge_types()?;
            Ok(self
                .par_iter_edge_node_ids_and_edge_type_id(directed)
                .filter_map(|(_, src, dst, edge_type)| {
                    if edge_type.is_some() {
                        Some((src, dst))
                    } else {
                        None
                    }
                }))
        }
        /// Returns parallel iterator over node IDs of the nodes with unknown node types
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn par_iter_node_ids_with_unknown_node_types(
            &self,
        ) -> Result<impl ParallelIterator<Item = NodeT> + '_> {
            self.must_have_node_types().map(|node_types| {
                node_types
                    .ids
                    .par_iter()
                    .enumerate()
                    .filter_map(|(node_id, node_type_id)| {
                        if node_type_id.is_some() {
                            None
                        } else {
                            Some(node_id as NodeT)
                        }
                    })
            })
        }
        /// Returns parallel iterator over node IDs of the nodes with known node types
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn par_iter_node_ids_with_known_node_types(
            &self,
        ) -> Result<impl ParallelIterator<Item = NodeT> + '_> {
            self.must_have_node_types().map(|node_types| {
                node_types
                    .ids
                    .par_iter()
                    .enumerate()
                    .filter_map(|(node_id, node_type_id)| {
                        if node_type_id.is_some() {
                            Some(node_id as NodeT)
                        } else {
                            None
                        }
                    })
            })
        }
        /// Returns parallel iterator over edge node names of the edges with unknown edge types
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to load the edges as directed or undirected.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn par_iter_edge_node_names_with_unknown_edge_types(
            &self,
            directed: bool,
        ) -> Result<impl ParallelIterator<Item = (String, String)> + '_> {
            self.par_iter_edge_node_ids_with_unknown_edge_types(directed)
                .map(|x| {
                    x.map(move |(src, dst)| unsafe {
                        (
                            self.get_unchecked_node_name_from_node_id(src),
                            self.get_unchecked_node_name_from_node_id(dst),
                        )
                    })
                })
        }
        /// Returns parallel iterator over edge node names of the edges with known edge types
        ///
        /// # Arguments
        /// * `directed`: bool - Whether to load the edges as directed or undirected.
        ///
        /// # Raises
        /// * If there are no edge types in the graph.
        pub fn par_iter_edge_node_names_with_known_edge_types(
            &self,
            directed: bool,
        ) -> Result<impl ParallelIterator<Item = (String, String)> + '_> {
            self.par_iter_edge_node_ids_with_known_edge_types(directed)
                .map(|x| {
                    x.map(move |(src, dst)| unsafe {
                        (
                            self.get_unchecked_node_name_from_node_id(src),
                            self.get_unchecked_node_name_from_node_id(dst),
                        )
                    })
                })
        }
        /// Returns parallel iterator over node names of the nodes with unknown node types
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn par_iter_node_names_with_unknown_node_types(
            &self,
        ) -> Result<impl ParallelIterator<Item = String> + '_> {
            self.par_iter_node_ids_with_unknown_node_types().map(|x| {
                x.map(move |node_id| unsafe { self.get_unchecked_node_name_from_node_id(node_id) })
            })
        }
        /// Returns parallel iterator over node names of the nodes with known node types
        ///
        /// # Raises
        /// * If there are no node types in the graph.
        pub fn par_iter_node_names_with_known_node_types(
            &self,
        ) -> Result<impl ParallelIterator<Item = String> + '_> {
            self.par_iter_node_ids_with_known_node_types().map(|x| {
                x.map(move |node_id| unsafe { self.get_unchecked_node_name_from_node_id(node_id) })
            })
        }
    }
}
mod laplacian {
    use indicatif::ProgressIterator;
    use num_traits::Zero;
    use rayon::iter::ParallelIterator;
    use super::*;
    /// # Generators of laplacian-transformed graphs.
    impl Graph {
        /// Returns unweighted laplacian transformation of the graph.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        pub fn get_laplacian_transformed_graph(&self, verbose: Option<bool>) -> Graph {
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id(true).map(
                    |(_, src, dst, edge_type)| {
                        Ok((
                            src,
                            dst,
                            edge_type,
                            Some(if src == dst {
                                unsafe {
                                    self.get_unchecked_node_degree_from_node_id(src) as WeightT
                                }
                            } else {
                                -1.0
                            }),
                        ))
                    },
                ),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                self.has_edge_types(),
                true,
                false,
                self.has_singleton_nodes(),
                self.has_singleton_nodes_with_selfloops(),
                self.has_trap_nodes(),
                verbose.unwrap_or(true),
            )
            .unwrap()
        }
        /// Returns unweighted random walk normalized laplacian transformation of the graph.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        pub fn get_random_walk_normalized_laplacian_transformed_graph(
            &self,
            verbose: Option<bool>,
        ) -> Graph {
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id(true).map(
                    |(_, src, dst, edge_type)| {
                        Ok((
                            src,
                            dst,
                            edge_type,
                            Some(if src == dst {
                                1.0
                            } else {
                                -1.0 / unsafe { self.get_unchecked_node_degree_from_node_id(src) }
                                    as WeightT
                            }),
                        ))
                    },
                ),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                true,
                self.get_name(),
                true,
                self.has_edge_types(),
                true,
                false,
                self.has_singleton_nodes(),
                self.has_singleton_nodes_with_selfloops(),
                self.has_trap_nodes(),
                verbose.unwrap_or(true),
            )
            .unwrap()
        }
        /// Returns unweighted symmetric normalized laplacian transformation of the graph.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        /// # Raises
        /// * The graph must be undirected, as we do not currently support this transformation for directed graphs.
        pub fn get_symmetric_normalized_laplacian_transformed_graph(
            &self,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            self.must_be_undirected()?;
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id(true).map(
                    |(_, src, dst, edge_type)| unsafe {
                        Ok((
                            src,
                            dst,
                            edge_type,
                            Some(if src == dst {
                                1.0
                            } else {
                                -1.0 / (self.get_unchecked_node_degree_from_node_id(src) as f64
                                    * self.get_unchecked_node_degree_from_node_id(dst) as f64)
                                    .sqrt() as WeightT
                            }),
                        ))
                    },
                ),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                self.has_edge_types(),
                true,
                false,
                self.has_singleton_nodes(),
                self.has_singleton_nodes_with_selfloops(),
                self.has_trap_nodes(),
                verbose.unwrap_or(true),
            )
        }
        /// Returns unweighted symmetric normalized transformation of the graph.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        /// # Raises
        /// * The graph must be undirected, as we do not currently support this transformation for directed graphs.
        pub fn get_symmetric_normalized_transformed_graph(
            &self,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            self.must_be_undirected()?;
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id(true)
                    .filter(|(_, src, dst, _)| src != dst)
                    .map(|(_, src, dst, edge_type)| unsafe {
                        Ok((
                            src,
                            dst,
                            edge_type,
                            Some(
                                1.0 / ((self.get_unchecked_node_degree_from_node_id(src)
                                    * self.get_unchecked_node_degree_from_node_id(dst))
                                    as WeightT)
                                    .sqrt(),
                            ),
                        ))
                    }),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                self.has_edge_types(),
                true,
                false,
                self.has_singleton_nodes() || self.has_singleton_nodes_with_selfloops(),
                false,
                self.has_trap_nodes(),
                verbose.unwrap_or(true),
            )
        }
        /// Returns weighted laplacian transformation of the graph.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        /// # Raises
        /// * If the graph is not weighted it is not possible to compute the weighted laplacian transformation.
        pub fn get_weighted_laplacian_transformed_graph(
            &self,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            self.must_have_edge_weights()?;
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)
                    .filter_map(|(_, src, dst, edge_type, edge_weight)| unsafe {
                        let weight = if src == dst {
                            self.get_unchecked_weighted_node_degree_from_node_id(src) as WeightT
                        } else {
                            -edge_weight.unwrap()
                        };
                        if weight.is_zero() || weight.is_infinite() {
                            return None;
                        }
                        Some(Ok((src, dst, edge_type, Some(weight))))
                    }),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                self.has_edge_types(),
                true,
                false,
                self.has_singleton_nodes() || self.has_singleton_nodes_with_selfloops(),
                self.has_singleton_nodes_with_selfloops(),
                self.has_trap_nodes(),
                verbose.unwrap_or(true),
            )
        }
        /// Returns unweighted symmetric normalized laplacian transformation of the graph.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        /// # Raises
        /// * The graph must be undirected, as we do not currently support this transformation for directed graphs.
        /// * If the graph is not weighted it is not possible to compute the weighted laplacian transformation.
        pub fn get_weighted_symmetric_normalized_laplacian_transformed_graph(
            &self,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            self.must_have_edge_weights()?;
            self.must_be_undirected()?;
            self.must_not_contain_weighted_singleton_nodes()?;
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id(true)
                    .filter_map(|(_, src, dst, edge_type)| unsafe {
                        let weight = if src == dst {
                            1.0
                        } else {
                            (-1.0
                                / (self.get_unchecked_weighted_node_degree_from_node_id(src)
                                    * self.get_unchecked_weighted_node_degree_from_node_id(dst))
                                .sqrt()) as WeightT
                        };
                        if weight.is_nan() || weight.is_zero() || weight.is_infinite() {
                            return None;
                        }
                        Some(Ok((src, dst, edge_type, Some(weight))))
                    }),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                self.has_edge_types(),
                true,
                false,
                true,
                true,
                true,
                verbose.unwrap_or(true),
            )
        }
        /// Returns weighted symmetric normalized transformation of the graph.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        /// # Raises
        /// * The graph must be undirected, as we do not currently support this transformation for directed graphs.
        /// * If the graph is not weighted it is not possible to compute the weighted laplacian transformation.
        pub fn get_weighted_symmetric_normalized_transformed_graph(
            &self,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            self.must_be_undirected()?;
            self.must_not_contain_weighted_singleton_nodes()?;
            let weighted_node_degrees = self.get_weighted_node_degrees()?;
            let loading_bar = get_loading_bar(
                verbose.unwrap_or(true),
                "Building weighted symmetric normalized transformed graph",
                self.get_directed_edges_number() as usize,
            );
            Graph::from_integer_sorted(
                self.iter_edge_node_ids_and_edge_type_id(true)
                    .progress_with(loading_bar)
                    .filter_map(|(_, src, dst, edge_type)| {
                        if src == dst {
                            return None;
                        }
                        let distance = (1.0
                            / (weighted_node_degrees[src as usize]
                                * weighted_node_degrees[dst as usize])
                                .sqrt()) as WeightT;
                        if distance.is_nan() || distance.is_infinite() || distance.is_zero() {
                            None
                        } else {
                            Some(Ok((src, dst, edge_type, Some(distance))))
                        }
                    }),
                (self.get_directed_edges_number() - self.get_selfloop_number()) as usize,
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                true,
                self.get_name(),
                false,
                self.has_edge_types(),
                true,
                false,
                true,
                false,
                true,
            )
        }
        /// Returns weighted random walk normalized laplacian transformation of the graph.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        /// # Raises
        /// * If the graph is not weighted it is not possible to compute the weighted laplacian transformation.
        /// * If the graph contains nodes with zero weighted degree.
        pub fn get_weighted_random_walk_normalized_laplacian_transformed_graph(
            &self,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            self.must_have_edge_weights()?;
            self.must_not_contain_weighted_singleton_nodes()?;
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id(true)
                    .filter_map(|(_, src, dst, edge_type)| unsafe {
                        let weight = if src == dst {
                            1.0
                        } else {
                            -1.0 / self.get_unchecked_weighted_node_degree_from_node_id(src)
                                as WeightT
                        };
                        if weight.is_nan() || weight.is_zero() || weight.is_infinite() {
                            return None;
                        }
                        Some(Ok((src, dst, edge_type, Some(weight))))
                    }),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                true,
                self.get_name(),
                true,
                self.has_edge_types(),
                true,
                false,
                true,
                true,
                true,
                verbose.unwrap_or(true),
            )
        }
    }
}
mod modifiers {
    use super::*;
    impl Graph {
        /// Enable extra perks that buys you time as you accept to spend more memory.
        ///
        /// # Arguments
        /// * `vector_sources`: Option<bool> - Whether to cache sources into a vector for faster walks.
        /// * `vector_destinations`: Option<bool> - Whether to cache destinations into a vector for faster walks.
        /// * `vector_cumulative_node_degrees`: Option<bool> - Whether to cache cumulative_node_degrees into a vector for faster walks.
        pub fn enable(
            &mut self,
            vector_sources: Option<bool>,
            vector_destinations: Option<bool>,
            vector_cumulative_node_degrees: Option<bool>,
        ) -> Result<()> {
            let vector_sources = vector_sources.unwrap_or(false);
            let vector_destinations = vector_destinations.unwrap_or(true);
            let vector_cumulative_node_degrees = vector_cumulative_node_degrees.unwrap_or(true);
            if vector_destinations {
                if self.destinations.is_none() {
                    self.destinations = Some(self.get_destination_node_ids(true));
                }
            } else {
                self.destinations = None;
            }
            if vector_sources {
                if self.sources.is_none() {
                    self.sources = Some(self.get_source_node_ids(true));
                }
            } else {
                self.sources = None;
            }
            if vector_cumulative_node_degrees {
                if self.cumulative_node_degrees.is_none() {
                    self.cumulative_node_degrees = Some(self.get_cumulative_node_degrees());
                }
            } else {
                self.cumulative_node_degrees = None;
            }
            Ok(())
        }
        /// Disable all extra perks, reducing memory impact but incresing time requirements.
        pub fn disable_all(&mut self) {
            self.destinations = None;
            self.sources = None;
            self.cumulative_node_degrees = None;
        }
    }
}
mod operators {
    use rayon::iter::{IntoParallelIterator, ParallelIterator};
    use super::*;
    use std::ops;
    fn build_operator_graph_name(main: &Graph, other: &Graph, operator: String) -> String {
        {
            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                &["(", " ", " ", ")"],
                &match (&main.name, &operator, &other.name) {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ));
            res
        }
    }
    /// Return graph composed of the two near-incompatible graphs.
    ///
    /// The two graphs can have different nodes, edge types and node types.
    /// These operators are slower than the generic integer operators since they
    /// require a reverse mapping step.
    ///
    /// # Arguments
    ///
    /// * `main`: &Graph - The current graph instance.
    /// * `other`: &Graph - The other graph.
    /// * `operator`: String - The operator used.
    /// * `graphs`: Vec<(&Graph, Option<&Graph>, Option<&Graph>)> - Graph list for the operation.
    /// * `might_contain_singletons`: bool - Whether we expect the graph to have singletons.
    /// * `might_contain_singletons_with_selfloops`: bool - Whether we expect the graph to have singletons with self-loops.
    /// * `might_contain_trap_nodes`: bool - Whether we expect the graph to have trap nodes.
    fn generic_string_operator(
        main: &Graph,
        other: &Graph,
        operator: String,
        graphs: Vec<(&Graph, Option<&Graph>, Option<&Graph>)>,
        might_contain_singletons: bool,
        might_contain_singletons_with_selfloops: bool,
        might_contain_trap_nodes: bool,
    ) -> Result<Graph> {
        let edges_iterator = graphs
            .iter()
            .flat_map(|(one, deny_graph, must_have_graph)| {
                one.iter_edge_node_names_and_edge_type_name_and_edge_weight(main.directed)
                    .filter(move |(_, _, src_name, _, dst_name, _, edge_type_name, _)| {
                        if let Some(dg) = deny_graph {
                            if dg.has_edge_from_node_names_and_edge_type_name(
                                src_name,
                                dst_name,
                                edge_type_name.as_deref(),
                            ) {
                                return false;
                            }
                        }
                        if let Some(mhg) = must_have_graph {
                            if !mhg.has_edge_from_node_names_and_edge_type_name(
                                src_name,
                                dst_name,
                                edge_type_name.as_deref(),
                            ) {
                                return false;
                            }
                        }
                        true
                    })
                    .map(|(_, _, src_name, _, dst_name, _, edge_type_name, weight)| {
                        Ok((src_name, dst_name, edge_type_name, weight))
                    })
            });
        let nodes_iterator =
            main.iter_node_names_and_node_type_names()
                .map(|(_, node_name, _, node_type_names)| {
                    let node_type_names =
                        match node_type_names {
                            Some(ntns) => Some(ntns),
                            None => other.get_node_id_from_node_name(&node_name).ok().and_then(
                                |node_id| other.get_node_type_names_from_node_id(node_id).unwrap(),
                            ),
                        };
                    Ok((node_name, node_type_names))
                })
                .chain(other.iter_node_names_and_node_type_names().filter_map(
                    |(_, node_name, _, node_type_names)| match main.has_node_name(&node_name) {
                        true => None,
                        false => Some(Ok((node_name, node_type_names))),
                    },
                ));
        Graph::from_string_unsorted(
            edges_iterator,
            Some(nodes_iterator),
            main.directed,
            false,
            build_operator_graph_name(main, other, operator),
            true,
            true,
            false,
            true,
            false,
            false,
            false,
            false,
            main.has_node_types(),
            main.has_edge_types(),
            main.has_edge_weights(),
            false,
            might_contain_singletons,
            might_contain_singletons_with_selfloops,
            might_contain_trap_nodes,
            false,
        )
    }
    /// Return graph composed of the two compatible graphs.
    ///
    /// The two graphs CANNOT have different nodes, edge types and node types.
    /// These operators are faster than the generic string operators since they
    /// do NOT require a reverse mapping step.
    ///
    /// # Arguments
    ///
    /// * `main`: &Graph - The current graph instance.
    /// * `other`: &Graph - The other graph.
    /// * `operator`: String - The operator used.
    /// * `graphs`: Vec<(&Graph, Option<&Graph>, Option<&Graph>)> - Graph list for the operation.
    /// * `might_contain_singletons`: bool - Whether we expect the graph to have singletons.
    /// * `might_contain_singletons_with_selfloops`: bool - Whether we expect the graph to have singletons with self-loops.
    /// * `might_contain_trap_nodes`: bool - Whether we expect the graph to have trap nodes.
    fn generic_integer_operator(
        main: &Graph,
        other: &Graph,
        operator: String,
        graphs: Vec<(&Graph, Option<&Graph>, Option<&Graph>)>,
        might_contain_singletons: bool,
        might_contain_singletons_with_selfloops: bool,
        might_contain_trap_nodes: bool,
    ) -> Graph {
        let edges_iterator =
            graphs
                .into_par_iter()
                .flat_map(|(one, deny_graph, must_have_graph)| {
                    one.par_iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)
                        .filter(move |(_, src, dst, edge_type, _)| {
                            if let Some(dg) = deny_graph {
                                if dg
                                    .has_edge_from_node_ids_and_edge_type_id(*src, *dst, *edge_type)
                                {
                                    return false;
                                }
                            }
                            if let Some(mhg) = must_have_graph {
                                if !mhg
                                    .has_edge_from_node_ids_and_edge_type_id(*src, *dst, *edge_type)
                                {
                                    return false;
                                }
                            }
                            true
                        })
                        .map(|(_, src, dst, edge_type, weight)| Ok((src, dst, edge_type, weight)))
                        .collect::<Vec<_>>()
                });
        let node_types = match (&main.node_types, &other.node_types) {
            (Some(mnts), Some(onts)) => Some(match mnts == onts {
                true => mnts.clone(),
                false => {
                    let mut main_node_types = mnts.ids.clone();
                    main_node_types
                        .iter_mut()
                        .zip(onts.ids.iter())
                        .for_each(|(mid, oid)| {
                            if mid.is_none() {
                                *mid = oid.clone();
                            }
                        });
                    NodeTypeVocabulary::from_structs(main_node_types, Some(mnts.vocabulary.clone()))
                        .unwrap()
                }
            }),
            (Some(mnts), _) => Some(mnts.clone()),
            (_, Some(onts)) => Some(onts.clone()),
            _ => None,
        };
        Graph::from_integer_unsorted(
            edges_iterator,
            main.nodes.clone(),
            node_types,
            main.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
            main.directed,
            build_operator_graph_name(main, other, operator),
            false,
            main.has_edge_types(),
            main.has_edge_weights(),
            false,
            might_contain_singletons,
            might_contain_singletons_with_selfloops,
            might_contain_trap_nodes,
            false,
        )
        .unwrap()
    }
    impl<'a, 'b> Graph {
        /// Return result containing either empty tuple or error representing what makes impossible to combine the two graphs.
        ///
        /// # Arguments
        ///
        /// * `other`: &Graph - The other graph to validate operation with.
        ///
        /// # Raises
        /// * If a graph is directed and the other is undirected.
        /// * If one of the two graphs has edge weights and the other does not.
        /// * If one of the two graphs has node types and the other does not.
        /// * If one of the two graphs has edge types and the other does not.
        pub(crate) fn validate_operator_terms(&self, other: &'b Graph) -> Result<()> {
            if self.directed != other.directed {
                return Err(String::from(
                    "The graphs must either be both directed or undirected.",
                ));
            }
            if self.has_edge_weights() != other.has_edge_weights() {
                return Err(String::from(
                    "Both graphs need to have weights or neither can.",
                ));
            }
            if self.has_node_types() != other.has_node_types() {
                return Err(String::from(
                    "Both graphs need to have node types or neither can.",
                ));
            }
            if self.has_edge_types() != other.has_edge_types() {
                return Err(String::from(
                    "Both graphs need to have edge types or neither can.",
                ));
            }
            Ok(())
        }
    }
    impl Graph {
        /// Return true if the graphs are compatible.
        ///
        /// # Arguments
        ///
        /// * `other`: &Graph - The other graph.
        ///
        /// # Raises
        /// * If a graph is directed and the other is undirected.
        /// * If one of the two graphs has edge weights and the other does not.
        /// * If one of the two graphs has node types and the other does not.
        /// * If one of the two graphs has edge types and the other does not.
        pub(crate) fn is_compatible(&self, other: &Graph) -> Result<bool> {
            self.validate_operator_terms(other)?;
            if self.nodes != other.nodes {
                return Ok(false);
            }
            if let (Some(snts), Some(onts)) = (&self.node_types, &other.node_types) {
                if snts.vocabulary != onts.vocabulary {
                    return Ok(false);
                }
            }
            if let (Some(sets), Some(oets)) = (&self.edge_types, &other.edge_types) {
                if sets.vocabulary != oets.vocabulary {
                    return Ok(false);
                }
            }
            Ok(true)
        }
        /// Return graph composed of the two near-incompatible graphs.
        ///
        /// The two graphs can have different nodes, edge types and node types.
        /// These operators are slower than the generic integer operators since they
        /// require a reverse mapping step.
        ///
        /// # Arguments
        ///
        /// * `other`: &Graph - The other graph.
        /// * `operator`: String - The operator used.
        /// * `graphs`: Vec<(&Graph, Option<&Graph>, Option<&Graph>)> - Graph list for the operation.
        /// * `might_contain_singletons`: bool - Whether we expect the graph to have singletons.
        /// * `might_contain_singletons_with_selfloops`: bool - Whether we expect the graph to have singletons with self-loops.
        /// * `might_contain_trap_nodes`: bool - Whether we expect the graph to have trap nodes.
        pub(crate) fn generic_operator(
            &self,
            other: &Graph,
            operator: String,
            graphs: Vec<(&Graph, Option<&Graph>, Option<&Graph>)>,
            might_contain_singletons: bool,
            might_contain_singletons_with_selfloops: bool,
            might_contain_trap_nodes: bool,
        ) -> Result<Graph> {
            match self.is_compatible(other)? {
                true => Ok(generic_integer_operator(
                    self,
                    other,
                    operator,
                    graphs,
                    might_contain_singletons,
                    might_contain_singletons_with_selfloops,
                    might_contain_trap_nodes,
                )),
                false => generic_string_operator(
                    self,
                    other,
                    operator,
                    graphs,
                    might_contain_singletons,
                    might_contain_singletons_with_selfloops,
                    might_contain_trap_nodes,
                ),
            }
        }
    }
    impl<'a, 'b> ops::BitOr<&'b Graph> for &'a Graph {
        type Output = Result<Graph>;
        /// Return graph composed of the two graphs.
        ///
        /// The two graphs must have the same nodes, node types and edge types.
        ///
        /// # Arguments
        ///
        /// * `other`: &Graph - Graph to be summed.
        ///
        fn bitor(self, other: &'b Graph) -> Result<Graph> {
            self.generic_operator(
                other,
                "|".to_owned(),
                <[_]>::into_vec(box [(self, None, None), (other, Some(self), None)]),
                self.has_singleton_nodes() || other.has_singleton_nodes(),
                self.has_singleton_nodes_with_selfloops()
                    || other.has_singleton_nodes_with_selfloops(),
                self.has_trap_nodes() || other.has_trap_nodes(),
            )
        }
    }
    impl<'a, 'b> ops::BitXor<&'b Graph> for &'a Graph {
        type Output = Result<Graph>;
        /// Return graph composed of the two graphs.
        ///
        /// The two graphs must have the same nodes, node types and edge types.
        ///
        /// # Arguments
        ///
        /// * `other`: &Graph - Graph to be summed.
        ///
        fn bitxor(self, other: &'b Graph) -> Result<Graph> {
            self.generic_operator(
                self,
                "^".to_owned(),
                <[_]>::into_vec(box [(self, Some(other), None), (other, Some(self), None)]),
                true,
                self.has_selfloops() || other.has_selfloops(),
                true,
            )
        }
    }
    impl<'a, 'b> ops::Sub<&'b Graph> for &'a Graph {
        type Output = Result<Graph>;
        /// Return subtraction for graphs objects.
        ///
        /// The two graphs must have the same nodes, node types and edge types.
        ///
        /// # Arguments
        ///
        /// * `other`: &Graph - Graph to be subtracted.
        ///
        fn sub(self, other: &'b Graph) -> Result<Graph> {
            self.generic_operator(
                other,
                "-".to_owned(),
                <[_]>::into_vec(box [(self, Some(other), None)]),
                true,
                self.has_selfloops(),
                true,
            )
        }
    }
    impl<'a, 'b> ops::BitAnd<&'b Graph> for &'a Graph {
        type Output = Result<Graph>;
        /// Return graph obtained from the intersection of the two graph.
        ///
        /// The two graphs must have the same nodes, node types and edge types.
        ///
        /// # Arguments
        ///
        /// * `other`: &Graph - Graph to be subtracted.
        ///
        fn bitand(self, other: &'b Graph) -> Result<Graph> {
            self.generic_operator(
                other,
                "&".to_owned(),
                <[_]>::into_vec(box [(self, None, Some(other))]),
                true,
                self.has_selfloops() && other.has_selfloops(),
                true,
            )
        }
    }
}
mod polygons {
    use super::*;
    use indicatif::ParallelProgressIterator;
    use rayon::iter::IndexedParallelIterator;
    use rayon::iter::IntoParallelIterator;
    use rayon::iter::IntoParallelRefIterator;
    use rayon::iter::IntoParallelRefMutIterator;
    use rayon::iter::ParallelIterator;
    use std::sync::atomic::{AtomicU32, Ordering};
    impl Graph {
        /// Returns number of triangles in the graph.
        ///
        /// # Arguments
        /// * `normalize`: Option<bool> - Whether to normalize the number of triangles.
        /// * `low_centrality`: Option<usize> - The threshold over which to switch to parallel matryoshka. By default 50.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # References
        /// This implementation is described in ["Faster Clustering Coefficient Using Vertex Covers"](https://ieeexplore.ieee.org/document/6693348).
        ///
        /// # Safety
        /// This method will raise a panic if called on an directed graph as those
        /// instances are not supported by this method.
        unsafe fn get_undirected_number_of_triangles(
            &self,
            normalize: Option<bool>,
            low_centrality: Option<usize>,
            verbose: Option<bool>,
        ) -> EdgeT {
            if self.is_directed() {
                {
                    ::std::rt::begin_panic("This method cannot be called on directed graphs!")
                };
            }
            let verbose = verbose.unwrap_or(true);
            let low_centrality = low_centrality.unwrap_or(50);
            let normalize = normalize.unwrap_or(true);
            let vertex_cover_set = self.approximated_vertex_cover_set();
            let pb = get_loading_bar(
                verbose,
                "Computing number of triangles",
                vertex_cover_set.len(),
            );
            let mut number_of_triangles = vertex_cover_set
                .par_iter()
                .progress_with(pb)
                .map(|&node_id| unsafe {
                    let neighbours = self
                        .iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)
                        .filter(|&neighbour_node_id| node_id != neighbour_node_id)
                        .collect::<Vec<NodeT>>();
                    if neighbours.len() < low_centrality {
                        neighbours
                            .iter()
                            .filter(|&neighbour_node_id| {
                                vertex_cover_set.contains(&neighbour_node_id)
                            })
                            .map(|&neighbour_node_id| {
                                iter_set::intersection(
                                    neighbours.iter().cloned(),
                                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(
                                        neighbour_node_id,
                                    ),
                                )
                                .filter(|&inner_neighbour_id| {
                                    inner_neighbour_id != neighbour_node_id
                                })
                                .into_iter()
                                .map(|inner_node_id| {
                                    if vertex_cover_set.contains(&inner_node_id) {
                                        1
                                    } else {
                                        3
                                    }
                                })
                                .sum::<EdgeT>()
                            })
                            .sum::<EdgeT>()
                    } else {
                        neighbours
                            .par_iter()
                            .filter(|&neighbour_node_id| {
                                vertex_cover_set.contains(&neighbour_node_id)
                            })
                            .map(|&neighbour_node_id| {
                                iter_set::intersection(
                                    neighbours.iter().cloned(),
                                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(
                                        neighbour_node_id,
                                    ),
                                )
                                .filter(|&inner_neighbour_id| {
                                    inner_neighbour_id != neighbour_node_id
                                })
                                .into_iter()
                                .map(|inner_node_id| {
                                    if vertex_cover_set.contains(&inner_node_id) {
                                        1
                                    } else {
                                        3
                                    }
                                })
                                .sum::<EdgeT>()
                            })
                            .sum::<EdgeT>()
                    }
                })
                .sum::<EdgeT>();
            if normalize {
                number_of_triangles /= 3;
            }
            number_of_triangles
        }
        /// Returns number of triangles in the graph without taking into account the weights.
        ///
        /// This is a naive implementation and is considerably less efficient
        /// than Bader's version in the case of undirected graphs.
        ///
        /// # Arguments
        /// * `low_centrality`: Option<usize> - The threshold over which to switch to parallel matryoshka. By default 50.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # Safety
        /// This method will raise a panic if called on an undirected graph becase
        /// there is a more efficient one for these cases.
        /// There is a method that automatically dispatches the more efficient method
        /// according to the instance.
        unsafe fn get_naive_number_of_triangles(
            &self,
            low_centrality: Option<usize>,
            verbose: Option<bool>,
        ) -> EdgeT {
            if !self.is_directed() {
                {
                    :: std :: rt :: begin_panic ("This method should not be called on undirected graphs! Use the efficient one!")
                };
            }
            let verbose = verbose.unwrap_or(true);
            let low_centrality = low_centrality.unwrap_or(50);
            let pb = get_loading_bar(
                verbose,
                "Computing number of triangles",
                self.get_nodes_number() as usize,
            );
            let number_of_triangles: EdgeT = self
                .par_iter_node_ids()
                .progress_with(pb)
                .map(|node_id| unsafe {
                    let neighbours = self
                        .iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)
                        .filter(|&neighbour_node_id| node_id != neighbour_node_id)
                        .collect::<Vec<NodeT>>();
                    if neighbours.len() < low_centrality {
                        neighbours
                            .iter()
                            .map(|&neighbour_node_id| {
                                iter_set::intersection(
                                    neighbours.iter().cloned(),
                                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(
                                        neighbour_node_id,
                                    ),
                                )
                                .filter(|&inner_neighbour_id| {
                                    inner_neighbour_id != neighbour_node_id
                                })
                                .count() as EdgeT
                            })
                            .sum::<EdgeT>()
                    } else {
                        neighbours
                            .par_iter()
                            .map(|&neighbour_node_id| {
                                iter_set::intersection(
                                    neighbours.iter().cloned(),
                                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(
                                        neighbour_node_id,
                                    ),
                                )
                                .filter(|&inner_neighbour_id| {
                                    inner_neighbour_id != neighbour_node_id
                                })
                                .count() as EdgeT
                            })
                            .sum::<EdgeT>()
                    }
                })
                .sum::<EdgeT>();
            number_of_triangles
        }
        /// Returns total number of triangles ignoring the weights.
        ///
        /// The method dispatches the fastest method according to the current
        /// graph instance. Specifically:
        /// - For directed graphs it will use the naive algorithm.
        /// - For undirected graphs it will use Bader's version.
        ///
        /// # Arguments
        /// * `normalize`: Option<bool> - Whether to normalize the number of triangles.
        /// * `low_centrality`: Option<usize> - The threshold over which to switch to parallel matryoshka. By default 50.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        pub fn get_number_of_triangles(
            &self,
            normalize: Option<bool>,
            low_centrality: Option<usize>,
            verbose: Option<bool>,
        ) -> EdgeT {
            if self.is_directed() {
                unsafe { self.get_naive_number_of_triangles(low_centrality, verbose) }
            } else {
                unsafe {
                    self.get_undirected_number_of_triangles(normalize, low_centrality, verbose)
                }
            }
        }
        /// Returns total number of triads in the graph without taking into account weights.
        pub fn get_triads_number(&self) -> EdgeT {
            self.par_iter_node_degrees()
                .map(|degree| (degree * degree.saturating_sub(1)) as EdgeT)
                .sum()
        }
        /// Returns total number of triads in the weighted graph.
        pub fn get_weighted_triads_number(&self) -> Result<f64> {
            Ok(self
                .par_iter_weighted_node_degrees()?
                .map(|degree| {
                    if degree > 1.0 {
                        degree * (degree - 1.0)
                    } else {
                        0.0
                    }
                })
                .sum())
        }
        /// Returns transitivity of the graph without taking into account weights.
        ///
        /// # Arguments
        /// * `low_centrality`: Option<usize> - The threshold over which to switch to parallel matryoshka. By default 50.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        pub fn get_transitivity(
            &self,
            low_centrality: Option<usize>,
            verbose: Option<bool>,
        ) -> f64 {
            self.get_number_of_triangles(Some(false), low_centrality, verbose) as f64
                / self.get_triads_number() as f64
        }
        /// Returns number of triangles for all nodes in the graph.
        ///
        /// # Arguments
        /// * `normalize`: Option<bool> - Whether to normalize the number of triangles.
        /// * `low_centrality`: Option<usize> - The threshold over which to switch to parallel matryoshka. By default 50.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # References
        /// This implementation is described in ["Faster Clustering Coefficient Using Vertex Covers"](https://ieeexplore.ieee.org/document/6693348).
        ///
        /// # Safety
        /// This method does not support directed graphs and will raise a panic.
        /// It should automatically dispatched the naive version for these cases.
        unsafe fn get_undirected_number_of_triangles_per_node(
            &self,
            normalize: Option<bool>,
            low_centrality: Option<usize>,
            verbose: Option<bool>,
        ) -> Vec<NodeT> {
            if self.is_directed() {
                {
                    ::std::rt::begin_panic("This method does not work for directed graphs!")
                };
            }
            let normalize = normalize.unwrap_or(true);
            let low_centrality = low_centrality.unwrap_or(50);
            let node_triangles_number = self
                .iter_node_ids()
                .map(|_| AtomicU32::new(0))
                .collect::<Vec<_>>();
            let verbose = verbose.unwrap_or(true);
            let vertex_cover_set = self.approximated_vertex_cover_set();
            let pb = get_loading_bar(
                verbose,
                "Computing number of triangles per node",
                vertex_cover_set.len(),
            );
            vertex_cover_set
                .par_iter()
                .progress_with(pb)
                .for_each(|&node_id| unsafe {
                    let neighbours = self
                        .iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)
                        .filter(|&neighbour_node_id| node_id != neighbour_node_id)
                        .collect::<Vec<NodeT>>();
                    if neighbours.len() < low_centrality {
                        neighbours.iter().for_each(|&neighbour_node_id| {
                            if vertex_cover_set.contains(&neighbour_node_id) {
                                iter_set::intersection(
                                    neighbours.iter().cloned(),
                                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(
                                        neighbour_node_id,
                                    ),
                                )
                                .filter(|&inner_node_id| inner_node_id != neighbour_node_id)
                                .into_iter()
                                .for_each(|inner_node_id| {
                                    node_triangles_number[node_id as usize]
                                        .fetch_add(1, Ordering::Relaxed);
                                    if !vertex_cover_set.contains(&inner_node_id) {
                                        node_triangles_number[neighbour_node_id as usize]
                                            .fetch_add(1, Ordering::Relaxed);
                                        node_triangles_number[inner_node_id as usize]
                                            .fetch_add(1, Ordering::Relaxed);
                                    }
                                });
                            }
                        });
                    } else {
                        neighbours.par_iter().for_each(|&neighbour_node_id| {
                            if vertex_cover_set.contains(&neighbour_node_id) {
                                iter_set::intersection(
                                    neighbours.iter().cloned(),
                                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(
                                        neighbour_node_id,
                                    ),
                                )
                                .filter(|&inner_node_id| inner_node_id != neighbour_node_id)
                                .into_iter()
                                .for_each(|inner_node_id| {
                                    node_triangles_number[node_id as usize]
                                        .fetch_add(1, Ordering::Relaxed);
                                    if !vertex_cover_set.contains(&inner_node_id) {
                                        node_triangles_number[neighbour_node_id as usize]
                                            .fetch_add(1, Ordering::Relaxed);
                                        node_triangles_number[inner_node_id as usize]
                                            .fetch_add(1, Ordering::Relaxed);
                                    }
                                });
                            }
                        });
                    }
                });
            let mut node_triangles_number =
                std::mem::transmute::<Vec<AtomicU32>, Vec<NodeT>>(node_triangles_number);
            if normalize {
                node_triangles_number
                    .par_iter_mut()
                    .for_each(|triangles_number| {
                        *triangles_number /= 2;
                    });
            }
            node_triangles_number
        }
        /// Returns number of triangles in the graph without taking into account the weights.
        ///
        /// This is a naive implementation and is considerably less efficient
        /// than Bader's version in the case of undirected graphs.
        ///
        /// # Arguments
        /// * `low_centrality`: Option<usize> - The threshold over which to switch to parallel matryoshka. By default 50.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # Safety
        /// This method will raise a panic if called on an directed graph becase
        /// there is a more efficient one for these cases.
        unsafe fn get_naive_number_of_triangles_per_node(
            &self,
            low_centrality: Option<usize>,
            verbose: Option<bool>,
        ) -> Vec<NodeT> {
            if !self.is_directed() {
                {
                    :: std :: rt :: begin_panic ("This method should not be called on directed graphs as there is a more efficient one!")
                };
            }
            let node_triangles_number = self
                .iter_node_ids()
                .map(|_| AtomicU32::new(0))
                .collect::<Vec<_>>();
            let verbose = verbose.unwrap_or(true);
            let low_centrality = low_centrality.unwrap_or(50);
            let pb = get_loading_bar(
                verbose,
                "Computing number of triangles per node",
                self.get_nodes_number() as usize,
            );
            self.par_iter_node_ids()
                .progress_with(pb)
                .for_each(|node_id| unsafe {
                    let neighbours = self
                        .iter_unchecked_neighbour_node_ids_from_source_node_id(node_id)
                        .filter(|&neighbour_node_id| node_id != neighbour_node_id)
                        .collect::<Vec<NodeT>>();
                    if neighbours.len() < low_centrality {
                        neighbours.iter().for_each(|&neighbour_node_id| {
                            node_triangles_number[node_id as usize].fetch_add(
                                iter_set::intersection(
                                    neighbours.iter().cloned(),
                                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(
                                        neighbour_node_id,
                                    ),
                                )
                                .filter(|&inner_neighbour_id| {
                                    inner_neighbour_id != neighbour_node_id
                                })
                                .count() as NodeT,
                                Ordering::Relaxed,
                            );
                        });
                    } else {
                        neighbours.par_iter().for_each(|&neighbour_node_id| {
                            node_triangles_number[node_id as usize].fetch_add(
                                iter_set::intersection(
                                    neighbours.iter().cloned(),
                                    self.iter_unchecked_neighbour_node_ids_from_source_node_id(
                                        neighbour_node_id,
                                    ),
                                )
                                .filter(|&inner_neighbour_id| {
                                    inner_neighbour_id != neighbour_node_id
                                })
                                .count() as NodeT,
                                Ordering::Relaxed,
                            );
                        });
                    }
                });
            std::mem::transmute::<Vec<AtomicU32>, Vec<NodeT>>(node_triangles_number)
        }
        /// Returns number of triangles in the graph without taking into account the weights.
        ///
        /// The method dispatches the fastest method according to the current
        /// graph instance. Specifically:
        /// - For directed graphs it will use the naive algorithm.
        /// - For undirected graphs it will use Bader's version.
        ///
        /// # Arguments
        /// * `normalize`: Option<bool> - Whether to normalize the number of triangles.
        /// * `low_centrality`: Option<usize> - The threshold over which to switch to parallel matryoshka. By default 50.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        pub fn get_number_of_triangles_per_node(
            &self,
            normalize: Option<bool>,
            low_centrality: Option<usize>,
            verbose: Option<bool>,
        ) -> Vec<NodeT> {
            if self.is_directed() {
                unsafe { self.get_naive_number_of_triangles_per_node(low_centrality, verbose) }
            } else {
                unsafe {
                    self.get_undirected_number_of_triangles_per_node(
                        normalize,
                        low_centrality,
                        verbose,
                    )
                }
            }
        }
        /// Returns iterator over the clustering coefficients for all nodes in the graph.
        ///
        /// # Arguments
        /// * `low_centrality`: Option<usize> - The threshold over which to switch to parallel matryoshka. By default 50.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # References
        /// This implementation is described in ["Faster Clustering Coefficient Using Vertex Covers"](https://ieeexplore.ieee.org/document/6693348).
        pub fn iter_clustering_coefficient_per_node(
            &self,
            low_centrality: Option<usize>,
            verbose: Option<bool>,
        ) -> impl IndexedParallelIterator<Item = f64> + '_ {
            self.get_number_of_triangles_per_node(Some(false), low_centrality, verbose)
                .into_par_iter()
                .zip(self.par_iter_node_degrees())
                .map(|(triangles_number, degree)| {
                    if degree < 2 {
                        0.0
                    } else {
                        triangles_number as f64 / (degree * (degree - 1)) as f64
                    }
                })
        }
        /// Returns clustering coefficients for all nodes in the graph.
        ///
        /// # Arguments
        /// * `low_centrality`: Option<usize> - The threshold over which to switch to parallel matryoshka. By default 50.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # References
        /// This implementation is described in ["Faster Clustering Coefficient Using Vertex Covers"](https://ieeexplore.ieee.org/document/6693348).
        pub fn get_clustering_coefficient_per_node(
            &self,
            low_centrality: Option<usize>,
            verbose: Option<bool>,
        ) -> Vec<f64> {
            self.iter_clustering_coefficient_per_node(low_centrality, verbose)
                .collect()
        }
        /// Returns the graph clustering coefficient.
        ///
        /// # Arguments
        /// * `low_centrality`: Option<usize> - The threshold over which to switch to parallel matryoshka. By default 50.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # References
        /// This implementation is described in ["Faster Clustering Coefficient Using Vertex Covers"](https://ieeexplore.ieee.org/document/6693348).
        pub fn get_clustering_coefficient(
            &self,
            low_centrality: Option<usize>,
            verbose: Option<bool>,
        ) -> f64 {
            self.iter_clustering_coefficient_per_node(low_centrality, verbose)
                .sum()
        }
        /// Returns the graph average clustering coefficient.
        ///
        /// # Arguments
        /// * `low_centrality`: Option<usize> - The threshold over which to switch to parallel matryoshka. By default 50.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # References
        /// This implementation is described in ["Faster Clustering Coefficient Using Vertex Covers"](https://ieeexplore.ieee.org/document/6693348).
        pub fn get_average_clustering_coefficient(
            &self,
            low_centrality: Option<usize>,
            verbose: Option<bool>,
        ) -> f64 {
            self.get_clustering_coefficient(low_centrality, verbose)
                / self.get_nodes_number() as f64
        }
    }
}
mod preprocessing {
    use super::*;
    use atomic_float::AtomicF64;
    use bitvec::prelude::*;
    use indicatif::{ParallelProgressIterator, ProgressIterator};
    use itertools::Itertools;
    use num_traits::Pow;
    use rayon::prelude::*;
    use std::collections::{HashMap, VecDeque};
    use vec_rand::xorshift::xorshift;
    /// Return training batches for Word2Vec models.
    ///
    /// The batch is composed of a tuple as the following:
    ///
    /// - (Contexts indices, central nodes indices): the tuple of nodes
    ///
    /// This does not provide any output value as the model uses NCE loss
    /// and basically the central nodes that are fed as inputs work as the
    /// outputs value.
    ///
    /// # Arguments
    ///
    /// * `sequences`: impl ParallelIterator<Item = Vec<NodeT>> + 'a - the sequence of sequences of integers to preprocess.
    /// * `window_size`: usize - Window size to consider for the sequences.
    ///
    pub fn word2vec<'a>(
        sequences: impl ParallelIterator<Item = Vec<NodeT>> + 'a,
        window_size: usize,
    ) -> impl ParallelIterator<Item = (Vec<NodeT>, NodeT)> + 'a {
        sequences . flat_map_iter (move | sequence | { let sequence_length = sequence . len () ; if sequence_length < window_size * 2 + 1 { { :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["\n            Cannot compute word2vec, got a sequence of length " , " and window size " , ".\n            for the current window_size the minimum sequence length required is "] , & match (& sequence_length , & window_size , & (window_size * 2 + 1)) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt)] , })) } ; } (window_size .. (sequence_length - window_size)) . map (move | i | { ((i - window_size .. i) . chain (i + 1 .. window_size + i + 1) . map (| j | sequence [j]) . collect () , sequence [i]) }) })
    }
    /// Return triple with CSR representation of cooccurrence matrix.
    ///
    /// The first vector has the sources, the second vector the destinations
    /// and the third one contains the min-max normalized frequencies.
    ///
    /// # Arguments
    ///
    /// * `sequences`: impl ParallelIterator<Item = Vec<NodeT>> - the sequence of sequences of integers to preprocess.
    /// * `window_size`: Option<usize> - Window size to consider for the sequences.
    /// * `verbose`: Option<bool> - Whether to show the progress bars. The default behaviour is false.
    ///     
    pub fn cooccurence_matrix(
        sequences: impl ParallelIterator<Item = Vec<NodeT>>,
        window_size: usize,
        number_of_sequences: usize,
        verbose: Option<bool>,
    ) -> Result<(usize, impl Iterator<Item = (NodeT, NodeT, f64)>)> {
        let verbose = verbose.unwrap_or(false);
        let mut cooccurence_matrix: HashMap<(NodeT, NodeT), f64> = HashMap::new();
        let mut max_frequency = 0.0;
        let pb1 = get_loading_bar(verbose, "Computing frequencies", number_of_sequences);
        let vec = sequences.collect::<Vec<Vec<NodeT>>>();
        vec.iter().progress_with(pb1).for_each(|sequence| {
            let walk_length = sequence.len();
            for (central_index, &central_word_id) in sequence.iter().enumerate() {
                let upperbound = std::cmp::min(1 + window_size, walk_length - central_index);
                for distance in 1..upperbound {
                    let context_id = sequence[central_index + distance];
                    let (smaller, bigger) = (
                        std::cmp::min(central_word_id, context_id),
                        std::cmp::max(central_word_id, context_id),
                    );
                    let freq = 1.0 / distance as f64;
                    let ptr = cooccurence_matrix
                        .entry((smaller, bigger))
                        .and_modify(|e| *e += freq)
                        .or_insert(freq);
                    if *ptr > max_frequency {
                        max_frequency = *ptr;
                    }
                }
            }
        });
        let number_of_elements = cooccurence_matrix.len();
        let pb2 = get_loading_bar(
            verbose,
            "Converting mapping into CSR matrix",
            cooccurence_matrix.len(),
        );
        Ok((
            number_of_elements,
            cooccurence_matrix.into_iter().progress_with(pb2).map(
                move |((word, context), frequency)| (word, context, frequency / max_frequency),
            ),
        ))
    }
    /// # Preprocessing for ML algorithms on graph.
    impl Graph {
        /// Return training batches for Node2Vec models.
        ///
        /// The batch is composed of a tuple as the following:
        ///
        /// - (Contexts indices, central nodes indices): the tuple of nodes
        ///
        /// This does not provide any output value as the model uses NCE loss
        /// and basically the central nodes that are fed as inputs work as the
        /// outputs value.
        ///
        /// # Arguments
        ///
        /// * `walk_parameters`: &'a WalksParameters - the weighted walks parameters.
        /// * `quantity`: NodeT - Number of nodes to consider.
        /// * `window_size`: usize - Window size to consider for the sequences.
        ///
        /// # Raises
        /// * If the graph does not contain edges.
        /// * If the graph is directed.
        /// * If the given walks parameters are not compatible with the current graph instance.
        pub fn node2vec<'a>(
            &'a self,
            walk_parameters: &'a WalksParameters,
            quantity: NodeT,
            window_size: usize,
        ) -> Result<impl ParallelIterator<Item = (Vec<NodeT>, NodeT)> + 'a> {
            Ok(word2vec(
                self.iter_random_walks(quantity, walk_parameters)?,
                window_size,
            ))
        }
        /// Return triple with CSR representation of cooccurrence matrix.
        ///
        /// The first vector has the sources, the second vector the destinations
        /// and the third one contains the min-max normalized frequencies.
        ///
        /// # Arguments
        ///
        /// * `walks_parameters`: &'a WalksParameters - the walks parameters.
        /// * `window_size`: usize - Window size to consider for the sequences.
        /// * `verbose`: Option<bool> - Whether to show the progress bars. The default behaviour is false.
        ///     
        pub fn cooccurence_matrix<'a>(
            &'a self,
            walks_parameters: &'a WalksParameters,
            window_size: usize,
            verbose: Option<bool>,
        ) -> Result<(usize, impl Iterator<Item = (NodeT, NodeT, f64)> + 'a)> {
            self.must_have_edges()?;
            let walks = self.iter_complete_walks(walks_parameters)?;
            cooccurence_matrix(
                walks,
                window_size,
                (self.get_unique_source_nodes_number() * walks_parameters.iterations) as usize,
                verbose,
            )
        }
        /// Return iterator over neighbours of random nodes, optionally including the central node IDs, and its node type.
        ///
        /// # Arguments
        /// * `ids`: u64 -  The index of the batch to generate, behaves like a random random_state.
        /// * `batch_size`: Option<NodeT> - Number of nodes to sample.
        /// * `include_central_node`: Option<bool> - Whether to include the node ID in the returned iterator.
        /// * `return_edge_weights`: Option<bool> - Whether to include the edge weights.
        /// * `max_neighbours`: Option<NodeT> - Number of maximum neighbours to consider.
        ///
        /// # Raises
        /// * If the graph does not contain node type IDs.
        /// * If the graph does not contain known node type IDs.
        /// * If the graph does not contain unknown node type IDs.
        /// * If the edge weights have been requested but the graph does not have any.
        /// * If the central node ID is to be included and the edge weights are requested as well.
        ///
        /// TODO!: Add balanced mini-batch option.
        /// TODO!: Add option to return other edge metrics than weights, like Jaccard.
        /// TODO!: Add option to generate random neighborhoods.
        /// TODO!: Add option to sample neighbours with distance k.
        /// TODO!: Add option to return stuff like the path length to random nodes.
        pub fn get_node_label_prediction_mini_batch(
            &self,
            idx: u64,
            batch_size: Option<NodeT>,
            include_central_node: Option<bool>,
            return_edge_weights: Option<bool>,
            max_neighbours: Option<NodeT>,
        ) -> Result<
            impl IndexedParallelIterator<Item = ((Vec<NodeT>, Option<Vec<WeightT>>), Vec<NodeTypeT>)>
                + '_,
        > {
            if let Some(return_edge_weights) = return_edge_weights {
                if return_edge_weights {
                    self.must_have_edge_weights()?;
                }
            }
            self.must_have_known_node_types()?;
            self.must_have_unknown_node_types()?;
            let nodes_number = self.get_nodes_number();
            let batch_size = batch_size.unwrap_or(1024).min(nodes_number);
            let return_edge_weights = return_edge_weights.unwrap_or(false);
            let include_central_node = include_central_node.unwrap_or(false);
            if return_edge_weights && include_central_node {
                return Err ("The edge weights have been requested, but also the central node ID has been requested.\nIt is not possible to return the central node ID with the requested parameters, as we do not have its edge weight.\nIf you want to include the central node ID still, consider adding self-loops to the graph by using the method `graph.add_selfloops()`." . to_string ()) ;
            }
            let idx = splitmix64(idx);
            Ok((0..batch_size).into_par_iter().map(move |i| unsafe {
                let mut sample = xorshift(idx.wrapping_mul(splitmix64(i as u64)));
                let (node_id, node_type_ids) = loop {
                    let node_id = sample as u32 % nodes_number;
                    let node_type_ids = self.get_unchecked_node_type_id_from_node_id(node_id);
                    if node_type_ids.is_some() {
                        break (node_id, node_type_ids.unwrap());
                    }
                    sample = xorshift(sample);
                };
                let (min_edge_id, max_edge_id, destinations, probabilistic_indices) = self
                    .get_unchecked_edges_and_destinations_from_source_node_id(
                        max_neighbours,
                        idx,
                        node_id,
                    );
                let mut destinations = self
                    .get_destinations_slice(min_edge_id, max_edge_id, &destinations)
                    .to_owned();
                if include_central_node {
                    destinations.push(node_id);
                }
                (
                    (
                        destinations,
                        if return_edge_weights {
                            Some(self.get_edge_weighted_transitions(
                                min_edge_id,
                                max_edge_id,
                                &probabilistic_indices,
                            ))
                        } else {
                            None
                        },
                    ),
                    node_type_ids,
                )
            }))
        }
        /// Returns n-ple with index to build numpy array, source node, source node type, destination node, destination node type, edge type and whether this edge is real or artificial.
        ///
        /// # Arguments
        /// * `idx`: u64 - The index of the batch to generate, behaves like a random random_state,
        /// * `batch_size`: Option<usize> - The maximal size of the batch to generate,
        /// * `negative_samples_rate`: Option<f64> - The component of netagetive samples to use.
        /// * `return_node_types`: Option<bool> - Whether to return the source and destination nodes node types.
        /// * `return_edge_types`: Option<bool> - Whether to return the edge types. The negative edges edge type will be samples at random.
        /// * `return_edge_metrics`: Option<bool> - Whether to return the edge metrics.
        /// * `avoid_false_negatives`: Option<bool> - Whether to remove the false negatives when generated. It should be left to false, as it has very limited impact on the training, but enabling this will slow things down.
        /// * `maximal_sampling_attempts`: Option<usize> - Number of attempts to execute to sample the negative edges.
        /// * `shuffle`: Option<bool> - Whether to shuffle the samples within the batch.
        /// * `graph_to_avoid`: &'a Option<&Graph> - The graph whose edges are to be avoided during the generation of false negatives,
        ///
        /// # Raises
        /// * If the given amount of negative samples is not a positive finite real value.
        /// * If node types are requested but the graph does not contain any.
        /// * If node types are requested but the graph contains unknown node types.
        /// * If edge types are requested but the graph does not contain any.
        /// * If edge types are requested but the graph contains unknown edge types.
        ///
        /// TODO! Add the possibility for returning only known edges
        /// TODO! When returning only known edges, add the possibility for balanced
        /// edge types.
        pub fn get_edge_prediction_mini_batch<'a>(
            &'a self,
            idx: u64,
            batch_size: Option<usize>,
            negative_samples_rate: Option<f64>,
            return_node_types: Option<bool>,
            return_edge_types: Option<bool>,
            return_edge_metrics: Option<bool>,
            avoid_false_negatives: Option<bool>,
            maximal_sampling_attempts: Option<usize>,
            shuffle: Option<bool>,
            graph_to_avoid: Option<&'a Graph>,
        ) -> Result<
            impl IndexedParallelIterator<
                    Item = (
                        NodeT,
                        Option<Vec<NodeTypeT>>,
                        NodeT,
                        Option<Vec<NodeTypeT>>,
                        Option<Vec<f64>>,
                        Option<EdgeTypeT>,
                        bool,
                    ),
                > + 'a,
        > {
            let batch_size = batch_size.unwrap_or(1024);
            let negative_samples_rate = negative_samples_rate.unwrap_or(0.5);
            let avoid_false_negatives = avoid_false_negatives.unwrap_or(false);
            let maximal_sampling_attempts = maximal_sampling_attempts.unwrap_or(10_000);
            let shuffle = shuffle.unwrap_or(true);
            let return_node_types = return_node_types.unwrap_or(false);
            let (maximum_node_types_number, multi_label) = if return_node_types {
                self.must_not_contain_unknown_node_types()?;
                (
                    self.get_maximum_multilabel_count()? as usize,
                    self.has_multilabel_node_types()?,
                )
            } else {
                (0, false)
            };
            let return_edge_types = return_edge_types.unwrap_or(false);
            let return_edge_metrics = return_edge_metrics.unwrap_or(false);
            let edge_types_number = if return_edge_types {
                self.must_not_contain_unknown_edge_types()?;
                self.get_edge_types_number()?
            } else {
                0
            };
            if negative_samples_rate < 0.0
                || negative_samples_rate > 1.0
                || !negative_samples_rate.is_finite()
            {
                return Err(
                    "Negative sample must be a posive real value between 0 and 1.".to_string(),
                );
            }
            let negative_samples_threshold =
                (negative_samples_rate * u64::MAX as f64).ceil() as u64;
            let expected_negative_samples_number =
                (batch_size as f64 * negative_samples_rate).ceil() as usize;
            let expected_positive_samples_number = batch_size - expected_negative_samples_number;
            let edges_number = self.get_directed_edges_number();
            let nodes_number = self.get_nodes_number();
            let does_not_require_resampling = !(avoid_false_negatives || graph_to_avoid.is_some());
            let get_node_type_ids = move |node_id: NodeT| -> Option<Vec<NodeTypeT>> {
                if return_node_types {
                    let node_type_ids =
                        unsafe { self.get_unchecked_node_type_id_from_node_id(node_id) };
                    if multi_label {
                        let mut padded_node_type_ids =
                            ::alloc::vec::from_elem(0, maximum_node_types_number);
                        node_type_ids.unwrap().into_iter().enumerate().for_each(
                            |(i, node_type)| {
                                padded_node_type_ids[i] = node_type + 1;
                            },
                        );
                        Some(padded_node_type_ids)
                    } else {
                        node_type_ids
                    }
                } else {
                    None
                }
            };
            let get_edge_metrics = move |src: NodeT, dst: NodeT| -> Option<Vec<f64>> {
                if return_edge_metrics {
                    Some(unsafe {
                        self.get_unchecked_all_edge_metrics_from_node_ids(src, dst, true)
                    })
                } else {
                    None
                }
            };
            let idx = splitmix64(idx);
            Ok ((0 .. batch_size) . into_par_iter () . map (move | i | unsafe { let mut sampled = xorshift (idx . wrapping_mul (splitmix64 (i as u64))) ; if shuffle && sampled > negative_samples_threshold || ! shuffle && i < expected_positive_samples_number { let edge_id = sampled % edges_number ; let (src , dst) = self . get_unchecked_node_ids_from_edge_id (edge_id) ; let edge_type = if return_edge_types { self . get_unchecked_edge_type_id_from_edge_id (edge_id) } else { None } ; return (src , get_node_type_ids (src) , dst , get_node_type_ids (dst) , get_edge_metrics (src , dst) , edge_type , true) ; } if does_not_require_resampling { let src = (sampled & 0xffffffff) as u32 % nodes_number ; let dst = (sampled >> 32) as u32 % nodes_number ; let edge_type = if return_edge_types { Some (sampled as EdgeTypeT % edge_types_number) } else { None } ; return (src , get_node_type_ids (src) , dst , get_node_type_ids (dst) , get_edge_metrics (src , dst) , edge_type , false) ; } for _ in 0 .. maximal_sampling_attempts { let src = (sampled & 0xffffffff) as u32 % nodes_number ; let dst = (sampled >> 32) as u32 % nodes_number ; if avoid_false_negatives && self . has_edge_from_node_ids (src , dst) || graph_to_avoid . as_ref () . map_or (false , | g | g . has_edge_from_node_ids (src , dst)) { sampled = xorshift (sampled) ; continue ; } let edge_type = if return_edge_types { Some (sampled as EdgeTypeT % edge_types_number) } else { None } ; return (src , get_node_type_ids (src) , dst , get_node_type_ids (dst) , get_edge_metrics (src , dst) , edge_type , false) ; } { :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["Executed more than " , " attempts to sample a negative edge.\nIf your graph is so small that you see this error, you may want to consider using one of the edge embedding transformer from the Embiggen library."] , & match (& maximal_sampling_attempts ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) } ; }))
        }
        /// Returns triple with the degrees of source nodes, destination nodes and labels for training model for link prediction.
        /// This method is just for setting the lowerbound on the simplest possible model.
        ///
        /// # Arguments
        ///
        /// * `idx`: u64 - The index of the batch to generate, behaves like a random random_state,
        /// * `batch_size`: usize - The maximal size of the batch to generate,
        /// * `normalize`: bool - Divide the degrees by the max, this way the values are in [0, 1],
        /// * `negative_samples`: f64 - The component of netagetive samples to use,
        /// * `avoid_false_negatives`: bool - Whether to remove the false negatives when generated. It should be left to false, as it has very limited impact on the training, but enabling this will slow things down.
        /// * `maximal_sampling_attempts`: usize - Number of attempts to execute to sample the negative edges.
        /// * `shuffle`: Option<bool> - Whether to shuffle the samples within the batch.
        /// * `graph_to_avoid`: &'a Option<&Graph> - The graph whose edges are to be avoided during the generation of false negatives,
        ///
        /// # Raises
        /// * If the given amount of negative samples is not a positive finite real value.
        pub fn link_prediction_degrees<'a>(
            &'a self,
            idx: u64,
            batch_size: Option<usize>,
            normalize: Option<bool>,
            negative_samples: Option<f64>,
            avoid_false_negatives: Option<bool>,
            maximal_sampling_attempts: Option<usize>,
            shuffle: Option<bool>,
            graph_to_avoid: Option<&'a Graph>,
        ) -> Result<impl ParallelIterator<Item = (f64, f64, bool)> + 'a> {
            let iter = self.get_edge_prediction_mini_batch(
                idx,
                batch_size,
                negative_samples,
                Some(false),
                Some(false),
                Some(false),
                avoid_false_negatives,
                maximal_sampling_attempts,
                shuffle,
                graph_to_avoid,
            )?;
            let normalize = normalize.unwrap_or(true);
            let max_degree = match normalize {
                true => self.get_maximum_node_degree()? as f64,
                false => 1.0,
            };
            Ok(iter.map(move |(src, _, dst, _, _, _, label)| unsafe {
                (
                    self.get_unchecked_node_degree_from_node_id(src) as f64 / max_degree,
                    self.get_unchecked_node_degree_from_node_id(dst) as f64 / max_degree,
                    label,
                )
            }))
        }
        /// Returns all available edge prediction metrics for given edges.
        ///
        /// The metrics returned are, in order:
        /// - Adamic Adar index
        /// - Jaccard Coefficient
        /// - Resource Allocation index
        /// - Preferential attachment score
        ///
        /// # Arguments
        /// `source_node_ids`: Vec<NodeT> - List of source node IDs.
        /// `destination_node_ids`: Vec<NodeT> - List of destination node IDs.
        /// `normalize`: Option<bool> - Whether to normalize the edge prediction metrics.
        /// `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        /// # Implementative details
        /// We do not check whether node IDs exist in the graph or not
        /// in this method because it would take too much time.
        ///
        /// # Safety
        /// If one of the given nodes does not exists in the graph, i.e. that is
        /// higher than the number of nodes in the graph, the method will panic
        /// and crash. Additionally, we also do not check if the two provided
        /// lists have the same length.
        ///
        pub unsafe fn par_iter_unchecked_edge_prediction_metrics(
            &self,
            source_node_ids: Vec<NodeT>,
            destination_node_ids: Vec<NodeT>,
            normalize: Option<bool>,
            verbose: Option<bool>,
        ) -> impl IndexedParallelIterator<Item = Vec<f64>> + '_ {
            let normalize = normalize.unwrap_or(true);
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(verbose, "Computing edge metrics", source_node_ids.len());
            source_node_ids
                .into_par_iter()
                .zip(destination_node_ids.into_par_iter())
                .progress_with(pb)
                .map(move |(source_node_id, destination_node_id)| {
                    self.get_unchecked_all_edge_metrics_from_node_ids(
                        source_node_id,
                        destination_node_id,
                        normalize,
                    )
                })
        }
        /// Returns all available edge prediction metrics for all edges.
        ///
        /// The metrics returned are, in order:
        /// - Adamic Adar index
        /// - Jaccard Coefficient
        /// - Resource Allocation index
        /// - Preferential attachment score
        ///
        /// # Arguments
        /// `normalize`: Option<bool> - Whether to normalize the edge prediction metrics.
        /// `verbose`: Option<bool> - Whether to show a loading bar.
        ///
        pub fn par_iter_edge_prediction_metrics(
            &self,
            normalize: Option<bool>,
            verbose: Option<bool>,
        ) -> impl IndexedParallelIterator<Item = Vec<f64>> + '_ {
            let normalize = normalize.unwrap_or(true);
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Computing edge metrics",
                self.get_directed_edges_number() as usize,
            );
            self.par_iter_directed_edge_ids().progress_with(pb).map(
                move |(_, source_node_id, destination_node_id)| unsafe {
                    self.get_unchecked_all_edge_metrics_from_node_ids(
                        source_node_id,
                        destination_node_id,
                        normalize,
                    )
                },
            )
        }
        /// Returns okapi node features propagation within given maximal distance.
        ///
        /// # Arguments
        /// * `features`: Vec<Option<Vec<f64>>> - The features to propagate. Use None to represent eventual unknown features.
        /// * `iterations`: Option<usize> - The number of iterations to execute. By default one.
        /// * `maximal_distance`: Option<usize> - The distance to consider for the cooccurrences. The default value is 3.
        /// * `k1`: Option<f64> - The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.
        /// * `b`: Option<f64> - The b parameter from okapi. Tipicaly 0.75.
        /// * `include_central_node`: Option<bool> - Whether to include the central node. By default true.
        /// * `verbose`: Option<bool> - Whether to show loading bar.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        ///
        /// # References
        /// The algorithm implemented is a generalization of the OKAPI BM25 TFIDF
        /// algorithm generalized for graphs.
        pub fn get_okapi_bm25_node_feature_propagation(
            &self,
            mut features: Vec<Vec<f64>>,
            iterations: Option<usize>,
            maximal_distance: Option<usize>,
            k1: Option<f64>,
            b: Option<f64>,
            include_central_node: Option<bool>,
            verbose: Option<bool>,
        ) -> Result<Vec<Vec<f64>>> {
            self.must_have_nodes()?;
            validate_features(&features, self.get_nodes_number() as usize)?;
            let maximal_distance = maximal_distance.unwrap_or(3);
            let k1 = k1.unwrap_or(1.5);
            if k1 <= 0.0 {
                return Err("The value of k1 must be a strictly positive real number.".to_string());
            }
            let b = b.unwrap_or(0.75);
            if k1 <= 0.0 {
                return Err("The value of b must be a strictly positive real number.".to_string());
            }
            let iterations = iterations.unwrap_or(1);
            if iterations == 0 {
                return Err(
                    "The number of iterations must be a strictly positive integer.".to_string(),
                );
            }
            let include_central_node = include_central_node.unwrap_or(true);
            let features_number = features[0].len() as usize;
            let nodes_number = self.get_nodes_number() as usize;
            let iterations_progress_bar = get_loading_bar(
                verbose.unwrap_or(true) && iterations > 1,
                "[Iterating features] propagation",
                iterations,
            );
            for _ in (0..iterations).progress_with(iterations_progress_bar) {
                let inverse_document_frequencies = (0..features_number)
                    .map(|feature_number| {
                        let feature_sum = self
                            .iter_node_ids()
                            .map(|node_id| {
                                (features[node_id as usize][feature_number] > 0.0) as NodeT
                            })
                            .sum::<NodeT>();
                        ((nodes_number as f64 - feature_sum as f64 + 0.5)
                            / (feature_sum as f64 + 0.5)
                            + 1.0)
                            .ln()
                    })
                    .collect::<Vec<f64>>();
                let total_document_size = AtomicF64::new(0.0);
                let pb = get_loading_bar(
                    verbose.unwrap_or(true),
                    "Computing new co-occurrences",
                    nodes_number,
                );
                features = self
                    .par_iter_node_ids()
                    .progress_with(pb)
                    .map(|node_id| {
                        let mut neighbours_stack = VecDeque::with_capacity(nodes_number);
                        neighbours_stack.push_front((node_id, 0));
                        let mut visited =
                            ::bitvec::vec::BitVec::<Lsb0, u8>::repeat(0 != 0, nodes_number);
                        let mut document_features_sum = 0.0;
                        unsafe { *visited.get_unchecked_mut(node_id as usize) = true };
                        let mut cooccurrences = if include_central_node {
                            features[node_id as usize].clone()
                        } else {
                            ::alloc::vec::from_elem(0.0, features_number)
                        };
                        while let Some((current_node_id, distance)) = neighbours_stack.pop_back() {
                            let new_distance = distance + 1;
                            unsafe {
                                self.iter_unchecked_neighbour_node_ids_from_source_node_id(
                                    current_node_id,
                                )
                            }
                            .for_each(|neighbour_node_id| {
                                if visited[neighbour_node_id as usize] {
                                    return;
                                }
                                unsafe {
                                    *visited.get_unchecked_mut(neighbour_node_id as usize) = true
                                };
                                features[neighbour_node_id as usize]
                                    .iter()
                                    .cloned()
                                    .enumerate()
                                    .for_each(|(i, feature)| {
                                        let normalized_feature =
                                            feature / (new_distance as f64).pow(2);
                                        document_features_sum += normalized_feature;
                                        cooccurrences[i] += normalized_feature;
                                    });
                                if new_distance <= maximal_distance {
                                    neighbours_stack.push_front((neighbour_node_id, new_distance));
                                }
                            });
                        }
                        total_document_size
                            .fetch_add(document_features_sum, std::sync::atomic::Ordering::Relaxed);
                        cooccurrences
                    })
                    .collect::<Vec<Vec<f64>>>();
                let average_document_size = total_document_size
                    .load(std::sync::atomic::Ordering::Relaxed)
                    / nodes_number as f64;
                let pb = get_loading_bar(
                    verbose.unwrap_or(true),
                    "Propagating features",
                    nodes_number,
                );
                features
                    .par_iter_mut()
                    .progress_with(pb)
                    .for_each(|node_cooccurrences| {
                        let document_features_sum = node_cooccurrences.iter().sum::<f64>();
                        if document_features_sum > 0.0 {
                            node_cooccurrences.iter_mut().enumerate().for_each(
                                |(node_type, cooccurrence)| {
                                    *cooccurrence = inverse_document_frequencies[node_type]
                                        * ((*cooccurrence * (k1 + 1.0))
                                            / (*cooccurrence
                                                + k1 * (1.0 - b
                                                    + b * document_features_sum
                                                        / average_document_size)));
                                },
                            );
                        }
                    });
                let min_max = (0..features_number)
                    .map(|feature_number| {
                        self.iter_node_ids()
                            .map(|node_id| features[node_id as usize][feature_number])
                            .minmax()
                            .into_option()
                            .unwrap()
                    })
                    .collect::<Vec<_>>();
                features.par_iter_mut().for_each(|node_features| {
                    node_features.iter_mut().zip(min_max.iter()).for_each(
                        |(feature, &(min_feature, max_feature))| {
                            *feature = (*feature - min_feature)
                                / (max_feature - min_feature + f64::EPSILON);
                        },
                    );
                });
            }
            Ok(features)
        }
        /// Returns okapi node label propagation within given maximal distance.
        ///
        /// # Arguments
        /// * `iterations`: Option<usize> - The number of iterations to execute. By default one.
        /// * `maximal_distance`: Option<usize> - The distance to consider for the cooccurrences. The default value is 3.
        /// * `k1`: Option<f64> - The k1 parameter from okapi. Tipicaly between 1.2 and 2.0. It can be seen as a smoothing.
        /// * `b`: Option<f64> - The b parameter from okapi. Tipicaly 0.75.
        /// * `verbose`: Option<bool> - Whether to show loading bar.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        ///
        /// # References
        /// The algorithm implemented is a generalization of the OKAPI BM25 TFIDF
        /// algorithm generalized for graphs.
        pub fn get_okapi_bm25_node_label_propagation(
            &self,
            iterations: Option<usize>,
            maximal_distance: Option<usize>,
            k1: Option<f64>,
            b: Option<f64>,
            verbose: Option<bool>,
        ) -> Result<Vec<Vec<f64>>> {
            self.get_okapi_bm25_node_feature_propagation(
                self.get_one_hot_encoded_node_types()?
                    .into_iter()
                    .map(|dummies| {
                        dummies
                            .into_iter()
                            .map(|dummie| if dummie { 1.0 } else { 0.0 })
                            .collect()
                    })
                    .collect(),
                iterations,
                maximal_distance,
                k1,
                b,
                Some(false),
                verbose,
            )
        }
    }
}
mod remap {
    use super::*;
    use indicatif::{ParallelProgressIterator, ProgressIterator};
    use itertools::Itertools;
    use rayon::iter::ParallelIterator;
    impl Graph {
        /// Return whether nodes are remappable to those of the given graph.
        ///
        /// # Arguments
        /// * `other`: &Graph - graph towards remap the nodes to.
        ///
        /// # Example
        /// A graph is always remappable to itself:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(graph.are_nodes_remappable(&graph));
        /// ```
        /// Two different graphs, like Cora and STRING, are not remappable:
        /// ```rust
        /// # let cora = graph::test_utilities::load_cora();
        /// # let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(!cora.are_nodes_remappable(&ppi));
        /// ```
        ///
        pub fn are_nodes_remappable(&self, other: &Graph) -> bool {
            if self.get_nodes_number() != other.get_nodes_number() {
                return false;
            }
            self.par_iter_node_names_and_node_type_names()
                .all(|(_, node_name, _, node_type)| {
                    other.has_node_name_and_node_type_name(&node_name, node_type)
                })
        }
        /// Returns graph remapped using given node IDs ordering.
        ///
        /// # Arguments
        /// * `node_ids`: Vec<NodeT> - The node Ids to remap the graph to.
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        /// # Safety
        /// This method will cause a panic if the node IDs are either:
        /// * Not unique
        /// * Not available for each of the node IDs of the graph.
        pub unsafe fn remap_unchecked_from_node_ids(
            &self,
            node_ids: Vec<NodeT>,
            verbose: Option<bool>,
        ) -> Graph {
            let verbose = verbose.unwrap_or(true);
            let pb_edges = get_loading_bar(
                verbose,
                "Building sorted edges with node IDs in increasing outbound node degree",
                self.get_directed_edges_number() as usize,
            );
            let pb_nodes = get_loading_bar(
                verbose,
                "Building node IDs {} with increasing outbound node degree",
                self.get_nodes_number() as usize,
            );
            Graph::from_string_unsorted(
                self.iter_edge_node_names_and_edge_type_name_and_edge_weight(true)
                    .progress_with(pb_edges)
                    .map(|(_, _, src_name, _, dst_name, _, edge_type_name, weight)| {
                        Ok((src_name, dst_name, edge_type_name, weight))
                    }),
                Some(
                    node_ids
                        .iter()
                        .progress_with(pb_nodes)
                        .map(|node_id| unsafe {
                            Ok((
                                self.get_unchecked_node_name_from_node_id(*node_id),
                                self.get_unchecked_node_type_names_from_node_id(*node_id),
                            ))
                        }),
                ),
                self.is_directed(),
                true,
                self.get_name(),
                false,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                self.has_node_types(),
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                self.has_singleton_nodes(),
                self.has_singleton_nodes_with_selfloops(),
                self.has_trap_nodes(),
                verbose,
            )
            .unwrap()
        }
        /// Returns graph remapped using given node IDs ordering.
        ///
        /// # Arguments
        /// * `node_ids`: Vec<NodeT> - The node Ids to remap the graph to.
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        /// # Raises
        /// * If the given node IDs are not unique.
        /// * If the given node IDs are not available for all the values in the graph.
        pub fn remap_from_node_ids(
            &self,
            node_ids: Vec<NodeT>,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            if node_ids.len() != self.get_nodes_number() as usize {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "The provided node IDs list has length ",
                            ", while the number of nodes in the current graph is ",
                            ".",
                        ],
                        &match (&node_ids.len(), &self.get_nodes_number()) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                });
            }
            if !self.has_nodes() {
                return Ok(self.clone());
            }
            let (min, max) = node_ids.iter().cloned().minmax().into_option().unwrap();
            if min != 0 {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "The minimum node ID provided in the given mapping is ",
                            ", while 0 was expected.",
                        ],
                        &match (&min,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                });
            }
            if max != self.get_nodes_number() - 1 {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "The maximum node ID provided in the given mapping is ",
                            ", while ",
                            " was expected.",
                        ],
                        &match (&max, &(self.get_nodes_number() - 1)) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                });
            }
            let without_duplicates_len = node_ids.iter().unique().count();
            if without_duplicates_len != node_ids.len() {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["There are ", " duplicated values in the provided node IDs."],
                        &match (&(node_ids.len() - without_duplicates_len),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                });
            }
            Ok(unsafe { self.remap_unchecked_from_node_ids(node_ids, verbose) })
        }
        /// Returns graph remapped using given node names ordering.
        ///
        /// # Arguments
        /// * `node_names`: Vec<&str> - The node names to remap the graph to.
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        /// # Raises
        /// * If the given node names are not unique.
        /// * If the given node names are not available for all the values in the graph.
        pub fn remap_from_node_names(
            &self,
            node_names: Vec<&str>,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            self.remap_from_node_ids(
                node_names
                    .into_iter()
                    .map(|node_name| self.get_node_id_from_node_name(node_name))
                    .collect::<Result<Vec<NodeT>>>()?,
                verbose,
            )
        }
        /// Return graph remapped towards nodes of the given graph.
        ///
        /// # Arguments
        ///
        /// * `other`: &Graph - The graph to remap towards.
        /// * `verbose`: Option<bool> - Whether to show a loding bar.
        ///
        /// # Example
        /// A graph is always remappable to itself:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert_eq!(graph, graph.remap_from_graph(&graph, None).unwrap());
        /// ```
        ///
        pub fn remap_from_graph(&self, other: &Graph, verbose: Option<bool>) -> Result<Graph> {
            let verbose = verbose.unwrap_or(false);
            let pb = get_loading_bar(
                verbose,
                {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Building remapped "],
                        &match (&self.name,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                .as_ref(),
                self.get_directed_edges_number() as usize,
            );
            if !self.are_nodes_remappable(other) {
                return Err("The two graphs nodes sets are not remappable one-another.".to_owned());
            }
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_names_and_edge_type_name_and_edge_weight(true)
                    .progress_with(pb)
                    .map(
                        |(_, _, src_name, _, dst_name, _, edge_type, weight)| unsafe {
                            Ok((
                                other.get_unchecked_node_id_from_node_name(&src_name),
                                other.get_unchecked_node_id_from_node_name(&dst_name),
                                edge_type.and_then(|et| {
                                    self.get_unchecked_edge_type_id_from_edge_type_name(et.as_str())
                                }),
                                weight,
                            ))
                        },
                    ),
                other.nodes.clone(),
                other.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.name.clone(),
                false,
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                self.has_singleton_nodes(),
                self.has_singleton_nodes_with_selfloops(),
                self.has_trap_nodes(),
                verbose,
            )
        }
    }
}
mod remove {
    use super::*;
    use counter::Counter;
    use indicatif::ProgressIterator;
    use roaring::RoaringBitmap;
    use std::collections::HashSet;
    /// # remove.
    impl Graph {
        /// remove all the components that are not connected to interesting
        /// nodes and edges.
        ///
        /// # Arguments
        /// * `node_names`: Option<Vec<String>> - The name of the nodes of which components to keep.
        /// * `node_types`: Option<Vec<Option<String>>> - The types of the nodes of which components to keep.
        /// * `edge_types`: Option<Vec<Option<String>>> - The types of the edges of which components to keep.
        /// * `minimum_component_size`: Option<NodeT> - Optional, Minimum size of the components to keep.
        /// * `top_k_components`: Option<NodeT> - Optional, number of components to keep sorted by number of nodes.
        /// * `verbose`: Option<bool> - Whether to show the loading bar.
        pub fn remove_components(
            &self,
            node_names: Option<Vec<String>>,
            node_types: Option<Vec<Option<String>>>,
            edge_types: Option<Vec<Option<String>>>,
            minimum_component_size: Option<NodeT>,
            top_k_components: Option<NodeT>,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            let verbose = verbose.unwrap_or(false);
            let mut keep_components = RoaringBitmap::new();
            let components_vector = self.get_node_connected_component_ids(Some(verbose));
            if let Some(node_ids) = self.get_filter_bitmap(node_names, node_types)? {
                keep_components.extend(
                    node_ids
                        .iter()
                        .map(|node_id| components_vector[node_id as usize]),
                );
            }
            if let Some(ets) = edge_types {
                let edge_types_ids: HashSet<Option<EdgeTypeT>> = self
                    .get_edge_type_ids_from_edge_type_names(ets)?
                    .into_iter()
                    .collect();
                let pb = get_loading_bar(
                    verbose,
                    &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Computing which components are to keep for the graph "],
                            &match (&&self.name,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    },
                    self.get_directed_edges_number() as usize,
                );
                self.iter_edge_node_ids_and_edge_type_id(self.directed)
                    .progress_with(pb)
                    .for_each(|(_, src, dst, edge_type)| {
                        if edge_types_ids.contains(&edge_type) {
                            keep_components.insert(components_vector[src as usize]);
                            keep_components.insert(components_vector[dst as usize]);
                        }
                    });
            }
            let counter = Counter::init(components_vector.clone());
            let component_counts: Vec<(NodeT, NodeT)> = counter.most_common_ordered();
            if let Some(tkc) = top_k_components {
                for (i, (component_id, _)) in component_counts.iter().enumerate() {
                    if i < tkc as usize {
                        keep_components.insert(*component_id);
                    }
                }
            }
            if let Some(mcs) = &minimum_component_size {
                component_counts
                    .iter()
                    .for_each(|(component, component_size)| {
                        if *component_size < *mcs {
                            keep_components.remove(*component);
                        }
                    });
            }
            let pb = get_loading_bar(
                verbose,
                &{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Building edge list with only required components "],
                        &match (&&self.name,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                },
                self.get_directed_edges_number() as usize,
            );
            let pb_nodes = get_loading_bar(
                verbose,
                &{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Building node list with only required components "],
                        &match (&&self.name,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                },
                self.get_nodes_number() as usize,
            );
            let min_component_size = keep_components
                .iter()
                .map(|component_id| *counter.get(&component_id).unwrap())
                .min();
            Graph::from_string_unsorted(
                self.iter_edge_node_names_and_edge_type_name_and_edge_weight(true)
                    .progress_with(pb)
                    .filter_map(
                        |(_, src, src_name, _, dst_name, _, edge_type_name, weight)| {
                            match keep_components.contains(components_vector[src as usize]) {
                                true => Some(Ok((src_name, dst_name, edge_type_name, weight))),
                                false => None,
                            }
                        },
                    ),
                Some(
                    self.iter_node_names_and_node_type_names()
                        .progress_with(pb_nodes)
                        .filter_map(
                            |(node_id, node_name, _, node_type_names)| match keep_components
                                .contains(components_vector[node_id as usize])
                            {
                                true => Some(Ok((node_name, node_type_names))),
                                false => None,
                            },
                        ),
                ),
                self.directed,
                true,
                self.get_name(),
                false,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                self.has_node_types(),
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                min_component_size.as_ref().map_or(true, |mcs| *mcs <= 1),
                self.has_singleton_nodes_with_selfloops()
                    && min_component_size.as_ref().map_or(true, |mcs| *mcs <= 1),
                self.has_trap_nodes(),
                verbose,
            )
        }
    }
}
mod selfloops {
    use super::*;
    use rayon::iter::ParallelIterator;
    /// # Selfloops.
    impl Graph {
        /// Returns new graph with added in missing self-loops with given edge type and weight.
        ///
        /// # Arguments
        /// `edge_type_name`: Option<&str> - The edge type to use for the selfloops.
        /// `weight`: Option<WeightT> - The weight to use for the new selfloops edges.
        /// `verbose`: Option<bool> - Whether to show loading bars while building the graph.
        ///
        /// # Raises
        /// * If the edge type for the new singletons is provided but the graph does not have edge types.
        /// * If the edge weight for the new singletons is provided but the graph does not have edge weights.
        /// * If the edge weight for the new singletons is NOT provided but the graph does have edge weights.
        pub fn add_selfloops(
            &self,
            edge_type_name: Option<&str>,
            weight: Option<WeightT>,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            let verbose = verbose.unwrap_or(true);
            let edge_type_id = if edge_type_name.is_some() {
                self.get_edge_type_id_from_edge_type_name(edge_type_name)?
            } else {
                None
            };
            if weight.is_some() ^ self.has_edge_weights() {
                return Err ("The weight for the self-loops must be specified only and exclusively if the graph has edge weights." . to_string ()) ;
            }
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)
                    .map(|(_, src, dst, edge_type_id, weight)| Ok((src, dst, edge_type_id, weight)))
                    .chain(
                        self.par_iter_node_ids()
                            .filter(|&node_id| !self.has_selfloop_from_node_id(node_id))
                            .map(|node_id| Ok((node_id, node_id, edge_type_id, weight))),
                    ),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                false,
                self.has_singleton_nodes_with_selfloops() || self.has_singleton_nodes(),
                self.has_trap_nodes(),
                verbose,
            )
        }
    }
}
mod setters {
    use super::*;
    use itertools::Itertools;
    use rayon::iter::IntoParallelRefMutIterator;
    use rayon::iter::ParallelIterator;
    use std::sync::atomic::{AtomicU32, AtomicU64, Ordering};
    impl Graph {
        /// Set the name of the graph.
        ///
        /// # Arguments
        ///
        /// * `name`: String - Name of the graph.
        pub fn set_name(&mut self, name: String) {
            self.name = name;
        }
        /// Replace all edge types (if present) and set all the edge to edge_type.
        ///
        /// This happens INPLACE, that is edits the current graph instance.
        ///
        /// # Arguments
        /// * `edge_type`: S - The edge type to assing to all the edges.
        ///
        /// # Raises
        /// * If the graph does not have edges.
        /// * If the graph is a multigraph.
        pub fn set_inplace_all_edge_types<S: Into<String>>(
            &mut self,
            edge_type: S,
        ) -> Result<&Graph> {
            self.must_have_edges()?;
            self . must_not_be_multigraph () . map_err (| _ | { "The method set_all_edge_types does not support multigraphs because setting the edge types of all edges to a single one in this typeof graphs will cause a multigraph to collapse to an homogeneous graph, leading to multiple undefined behaviours, such as loosing the parallel edges that would collapse to one: which one should we keep?\nYou can drop the parallell edges by calling the not INPLACE version of this method.\nConsider that when using the remove method, you will still collapse the multigraph to an homogeneous graph, and it will keep the FIRST edge of any group of multigraph edges between two given nodes." . to_string () }) ? ;
            let mut vocabulary = Vocabulary::default();
            vocabulary.insert(edge_type.into())?;
            vocabulary.build_reverse_mapping()?;
            let edge_types = EdgeTypeVocabulary::from_structs(
                ::alloc::vec::from_elem(Some(0), self.get_directed_edges_number() as usize),
                vocabulary,
            );
            self.edge_types = Some(edge_types);
            Ok(self)
        }
        /// Replace all edge types (if present) and set all the edge to edge_type.
        ///
        /// This DOES NOT happen inplace, but created a new instance of the graph.
        ///
        /// # Arguments
        /// * `edge_type`: S - The edge type to assing to all the edges.
        /// * `verbose`: Option<bool> - Whether to show a loading bar in the case of a multigraph.
        pub fn set_all_edge_types<S: Into<String>>(
            &self,
            edge_type: S,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            let mut graph = self.drop_parallel_edges(verbose);
            graph.set_inplace_all_edge_types(edge_type)?;
            Ok(graph)
        }
        /// Replace all node types (if present) and set all the node to node_type.
        ///
        /// # Arguments
        /// * `node_type`: S - The node type to assing to all the nodes.
        pub fn set_inplace_all_node_types<S: Into<String>>(
            &mut self,
            node_type: S,
        ) -> Result<&Graph> {
            self.must_have_nodes()?;
            let mut vocabulary = Vocabulary::default();
            vocabulary.insert(node_type.into())?;
            vocabulary.build_reverse_mapping()?;
            let node_types = NodeTypeVocabulary::from_structs(
                ::alloc::vec::from_elem(
                    Some(<[_]>::into_vec(box [0])),
                    self.get_nodes_number() as usize,
                ),
                Some(vocabulary),
            );
            self.node_types = node_types;
            Ok(self)
        }
        /// Replace all node types (if present) and set all the node to node_type.
        ///
        /// This DOES NOT happen inplace, but created a new instance of the graph.
        ///
        /// # Arguments
        /// * `node_type`: S - The node type to assing to all the nodes.
        pub fn set_all_node_types<S: Into<String>>(&self, node_type: S) -> Result<Graph> {
            let mut graph = self.clone();
            graph.set_inplace_all_node_types(node_type)?;
            Ok(graph)
        }
        /// Remove given node type ID from all nodes.
        ///
        /// If any given node remains with no node type, that node is labeled
        /// with node type None. Note that the modification happens inplace.
        ///
        /// # Arguments
        /// * `node_type_id_to_remove`: NodeTypeT - The node type ID to remove.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        /// * If the given node type ID does not exists in the graph.
        ///
        pub fn remove_inplace_node_type_ids(
            &mut self,
            node_type_ids_to_remove: Vec<NodeTypeT>,
        ) -> Result<&Graph> {
            self.must_have_node_types()?;
            if node_type_ids_to_remove.is_empty() {
                return Ok(self);
            }
            self.validate_node_type_id(node_type_ids_to_remove.iter().max().cloned())?;
            if node_type_ids_to_remove.len() != node_type_ids_to_remove.iter().unique().count() {
                return Err(
                    "In the given vector of node type ids to remove there are duplicated values."
                        .to_string(),
                );
            }
            if let Some(node_types) = self.node_types.as_mut() {
                let new_node_type_ids =
                    unsafe { node_types.unchecked_remove_values(node_type_ids_to_remove.clone()) };
                let new_unknown_nodes = AtomicU32::new(0);
                node_types.ids.par_iter_mut().for_each(|node_type_ids| {
                    if let Some(ntis) = node_type_ids.as_mut() {
                        for node_type_id_to_remove in &node_type_ids_to_remove {
                            if let Some(pos) =
                                ntis.iter().position(|x| *x == *node_type_id_to_remove)
                            {
                                ntis.remove(pos);
                            }
                        }
                        if ntis.is_empty() {
                            *node_type_ids = None;
                            new_unknown_nodes.fetch_add(1, Ordering::SeqCst);
                            return;
                        }
                        ntis.iter_mut().for_each(|node_type_id| {
                            if let Some(idx) = new_node_type_ids[*node_type_id as usize] {
                                *node_type_id = idx as NodeTypeT;
                            } else {
                                {
                                    {
                                        ::core::panicking::panic_fmt(
                                            ::core::fmt::Arguments::new_v1(
                                                &["internal error: entered unreachable code: "],
                                                &match (&"This should not happen",) {
                                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::core::fmt::Display::fmt,
                                                    )],
                                                },
                                            ),
                                        )
                                    }
                                };
                            }
                        });
                    }
                });
                node_types.unknown_count += new_unknown_nodes.load(Ordering::SeqCst);
            }
            Ok(self)
        }
        /// Remove singleton node types from all nodes.
        ///
        /// If any given node remains with no node type, that node is labeled
        /// with node type None. Note that the modification happens inplace.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        ///
        pub fn remove_inplace_singleton_node_types(&mut self) -> Result<&mut Graph> {
            self.remove_inplace_node_type_ids(self.get_singleton_node_type_ids()?)?;
            Ok(self)
        }
        /// Remove given edge type ID from all edges.
        ///
        /// # Arguments
        /// * `edge_type_id`: EdgeTypeT - The edge type ID to remove.
        ///
        /// # Raises
        /// * If the graph is a multigraph.
        /// * If the graph does not have edge types.
        /// * If the given edge type ID does not exists in the graph.
        ///
        pub fn remove_inplace_edge_type_ids(
            &mut self,
            edge_type_ids_to_remove: Vec<EdgeTypeT>,
        ) -> Result<&mut Graph> {
            self.must_have_edge_types()?;
            self . must_not_be_multigraph () . map_err (| _ | { "The method remove_edge_type_id does not support multigraphs because setting the edge types of all edges to a single one in this typeof graphs will cause a multigraph to collapse to an homogeneous graph, leading to multiple undefined behaviours, such as loosing the parallel edges that would collapse to one: which one should we keep?\nYou can drop the parallell edges by calling the not INPLACE version of this method.\nConsider that when using the remove method, you will still collapse the multigraph to an homogeneous graph, and it will keep the FIRST edge of any group of multigraph edges between two given nodes." . to_string () }) ? ;
            if edge_type_ids_to_remove.is_empty() {
                return Ok(self);
            }
            self.validate_edge_type_id(edge_type_ids_to_remove.iter().max().cloned())?;
            if edge_type_ids_to_remove.len() != edge_type_ids_to_remove.iter().unique().count() {
                return Err(
                    "In the given vector of edge type ids to remove there are duplicated values."
                        .to_string(),
                );
            }
            if let Some(edge_types) = self.edge_types.as_mut() {
                let new_edge_type_ids =
                    unsafe { edge_types.unchecked_remove_values(edge_type_ids_to_remove) };
                let new_unknown_edges = AtomicU64::new(0);
                edge_types
                    .ids
                    .par_iter_mut()
                    .for_each(|maybe_edge_type_id| {
                        *maybe_edge_type_id = maybe_edge_type_id.and_then(|x| {
                            new_edge_type_ids[x as usize].map_or_else(
                                || {
                                    new_unknown_edges.fetch_add(1, Ordering::SeqCst);
                                    None
                                },
                                |x| Some(x as EdgeTypeT),
                            )
                        });
                    });
                edge_types.unknown_count += new_unknown_edges.load(Ordering::SeqCst);
            }
            Ok(self)
        }
        /// Remove singleton edge types from all edges.
        ///
        /// If any given edge remains with no edge type, that edge is labeled
        /// with edge type None. Note that the modification happens inplace.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        ///
        pub fn remove_inplace_singleton_edge_types(&mut self) -> Result<&mut Graph> {
            self.remove_inplace_edge_type_ids(self.get_singleton_edge_type_ids()?)?;
            Ok(self)
        }
        /// Remove given node type name from all nodes.
        ///
        /// If any given node remains with no node type, that node is labeled
        /// with node type None. Note that the modification happens inplace.
        ///
        /// # Arguments
        /// * `node_type_name`: &str - The node type ID to remove.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        /// * If the given node type name does not exists in the graph.
        ///
        pub fn remove_inplace_node_type_name(&mut self, node_type_name: &str) -> Result<&Graph> {
            let node_type_id = self.get_node_type_id_from_node_type_name(node_type_name)?;
            self.remove_inplace_node_type_ids(<[_]>::into_vec(box [node_type_id]))?;
            Ok(self)
        }
        /// Remove given node type ID from all nodes.
        ///
        /// If any given node remains with no node type, that node is labeled
        /// with node type None. Note that the modification DOES NOT happen inplace.
        ///
        /// # Arguments
        /// * `node_type_id`: NodeTypeT - The node type ID to remove.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        /// * If the given node type ID does not exists in the graph.
        ///
        pub fn remove_node_type_id(&self, node_type_id: NodeTypeT) -> Result<Graph> {
            let mut graph = self.clone();
            graph.remove_inplace_node_type_ids(<[_]>::into_vec(box [node_type_id]))?;
            Ok(graph)
        }
        /// Remove singleton node types from all nodes.
        ///
        /// If any given node remains with no node type, that node is labeled
        /// with node type None. Note that the modification DOES NOT happen inplace.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        ///
        pub fn remove_singleton_node_types(&self) -> Result<Graph> {
            let mut graph = self.clone();
            graph.remove_inplace_singleton_node_types()?;
            Ok(graph)
        }
        /// Remove given node type name from all nodes.
        ///
        /// If any given node remains with no node type, that node is labeled
        /// with node type None. Note that the modification DOES NOT happen inplace.
        ///
        /// # Arguments
        /// * `node_type_name`: &str - The node type ID to remove.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        /// * If the given node type name does not exists in the graph.
        ///
        pub fn remove_node_type_name(&self, node_type_name: &str) -> Result<Graph> {
            let mut graph = self.clone();
            graph.remove_inplace_node_type_name(node_type_name)?;
            Ok(graph)
        }
        /// Remove given edge type name from all edges.
        ///
        /// If any given edge remains with no edge type, that edge is labeled
        /// with edge type None. Note that the modification happens inplace.
        ///
        /// # Arguments
        /// * `edge_type_name`: &str - The edge type ID to remove.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        /// * If the given edge type name does not exists in the graph.
        ///
        pub fn remove_inplace_edge_type_name(
            &mut self,
            edge_type_name: &str,
        ) -> Result<&mut Graph> {
            let edge_type_id = self
                .get_edge_type_id_from_edge_type_name(Some(edge_type_name))?
                .unwrap();
            self.remove_inplace_edge_type_ids(<[_]>::into_vec(box [edge_type_id]))
        }
        /// Remove given edge type ID from all edges.
        ///
        /// If any given edge remains with no edge type, that edge is labeled
        /// with edge type None. Note that the modification DOES NOT happen inplace.
        ///
        /// # Arguments
        /// * `edge_type_id`: EdgeTypeT - The edge type ID to remove.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        /// * If the given edge type ID does not exists in the graph.
        ///
        pub fn remove_edge_type_id(&self, edge_type_id: EdgeTypeT) -> Result<Graph> {
            let mut graph = self.clone();
            graph.remove_inplace_edge_type_ids(<[_]>::into_vec(box [edge_type_id]))?;
            Ok(graph)
        }
        /// Remove singleton edge types from all edges.
        ///
        /// If any given edge remains with no edge type, that edge is labeled
        /// with edge type None. Note that the modification DOES NOT happen inplace.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        ///
        pub fn remove_singleton_edge_types(&self) -> Result<Graph> {
            let mut graph = self.clone();
            graph.remove_inplace_singleton_edge_types()?;
            Ok(graph)
        }
        /// Remove given edge type name from all edges.
        ///
        /// If any given edge remains with no edge type, that edge is labeled
        /// with edge type None. Note that the modification DOES NOT happen inplace.
        ///
        /// # Arguments
        /// * `edge_type_name`: &str - The edge type ID to remove.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        /// * If the given edge type name does not exists in the graph.
        ///
        pub fn remove_edge_type_name(&self, edge_type_name: &str) -> Result<Graph> {
            let mut graph = self.clone();
            graph.remove_inplace_edge_type_name(edge_type_name)?;
            Ok(graph)
        }
        /// Remove node types from the graph.
        ///
        /// Note that the modification happens inplace.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        ///
        pub fn remove_inplace_node_types(&mut self) -> Result<&Graph> {
            self.must_have_node_types()?;
            self.node_types = None;
            Ok(self)
        }
        /// Remove node types from the graph.
        ///
        /// Note that the modification does not happen inplace.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        ///
        pub fn remove_node_types(&self) -> Result<Graph> {
            let mut graph = self.clone();
            graph.remove_inplace_node_types()?;
            Ok(graph)
        }
        /// Remove edge types from the graph.
        ///
        /// Note that the modification happens inplace.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        /// * If the graph is a multigraph.
        ///
        pub fn remove_inplace_edge_types(&mut self) -> Result<&Graph> {
            self.must_have_edge_types()?;
            self.must_not_be_multigraph()?;
            self.edge_types = None;
            Ok(self)
        }
        /// Remove edge types from the graph.
        ///
        /// Note that the modification does not happen inplace.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar in the case of a multigraph.
        ///
        /// # Raises
        /// * If the graph does not have edge types.
        ///
        pub fn remove_edge_types(&self, verbose: Option<bool>) -> Result<Graph> {
            let mut graph = self.drop_parallel_edges(verbose);
            graph.remove_inplace_edge_types()?;
            Ok(graph)
        }
        /// Remove edge weights from the graph.
        ///
        /// Note that the modification happens inplace.
        ///
        /// # Raises
        /// * If the graph does not have edge weights.
        ///
        pub fn remove_inplace_edge_weights(&mut self) -> Result<&Graph> {
            self.must_have_edge_weights()?;
            self.weights = None;
            Ok(self)
        }
        /// Remove edge weights from the graph.
        ///
        /// Note that the modification does not happen inplace.
        ///
        /// # Raises
        /// * If the graph does not have edge weights.
        ///
        pub fn remove_edge_weights(&self) -> Result<Graph> {
            let mut graph = self.clone();
            graph.remove_inplace_edge_weights()?;
            Ok(graph)
        }
    }
}
mod tarjan {
    use super::types::*;
    use super::Graph;
    use std::cmp::min;
    use std::collections::HashSet;
    /// # Tarjan algorithm
    impl Graph {
        /// Returns list of nodes of the various strongly connected components.
        ///
        /// This is an implementation of Tarjan algorithm.
        ///
        pub fn strongly_connected_components(&self) -> Vec<HashSet<NodeT>> {
            let mut indexed_mask: Vec<bool> =
                ::alloc::vec::from_elem(false, self.get_nodes_number() as usize);
            let mut stacked_mask: Vec<bool> =
                ::alloc::vec::from_elem(false, self.get_nodes_number() as usize);
            let mut low_indices: Vec<NodeT> =
                ::alloc::vec::from_elem(0, self.get_nodes_number() as usize);
            let mut indices: Vec<NodeT> =
                ::alloc::vec::from_elem(0, self.get_nodes_number() as usize);
            let mut components_stack: Vec<NodeT> = Vec::new();
            let mut components: Vec<HashSet<NodeT>> = Vec::new();
            let mut common_index = 0;
            let mut recurse: bool;
            for node in self.iter_node_ids() {
                if !indexed_mask[node as usize] {
                    let mut to_visit: Vec<(NodeT, usize)> = <[_]>::into_vec(box [(node, 0)]);
                    while !to_visit.is_empty() {
                        let (src, i) = to_visit.pop().unwrap();
                        if !indexed_mask[src as usize] {
                            low_indices[src as usize] = common_index;
                            indices[src as usize] = common_index;
                            indexed_mask[src as usize] = true;
                            stacked_mask[src as usize] = true;
                            common_index += 1;
                            components_stack.push(src);
                        }
                        recurse = false;
                        let (_min, _max) =
                            unsafe { self.get_unchecked_minmax_edge_ids_from_source_node_id(src) };
                        for (j, dst) in ((_min + i as EdgeT).._max)
                            .map(|edge_id| unsafe {
                                self.get_unchecked_destination_node_id_from_edge_id(edge_id)
                            })
                            .enumerate()
                        {
                            if !indexed_mask[dst as usize] {
                                to_visit.push((src, i + j + 1));
                                to_visit.push((dst, 0));
                                recurse = true;
                                break;
                            } else if stacked_mask[dst as usize] {
                                low_indices[src as usize] =
                                    min(low_indices[src as usize], indices[dst as usize]);
                            }
                        }
                        if recurse {
                            continue;
                        }
                        if low_indices[src as usize] == indices[src as usize] {
                            let mut new_component: HashSet<NodeT> = HashSet::new();
                            loop {
                                let dst = components_stack.pop().unwrap();
                                stacked_mask[dst as usize] = false;
                                new_component.insert(dst);
                                if dst == src {
                                    break;
                                }
                            }
                            components.push(new_component);
                        }
                        if !to_visit.is_empty() {
                            let (root, _) = to_visit.last().unwrap();
                            low_indices[*root as usize] =
                                min(low_indices[*root as usize], low_indices[src as usize]);
                        }
                    }
                }
            }
            components
        }
    }
}
mod url_utilities {
    use super::*;
    /// Returns whether the given node name is valid according to given seeds.
    ///
    /// # Arguments
    /// * `node_name`: &str - The name of the nodes.
    /// * `base_name`: Option<&str> - The expected base of the node name, how the expected KG nodes may start.
    /// * `base_length`: Option<usize> - The expected length of the node name when it includes the base name.
    /// * `separator`: Option<&str> - The expected separator that must be included when the node name starts with the base name.
    /// * `id_acronym`: Option<&str> - The expected ID the node name must start with AFTER the separator.
    /// * `id_length`: Option<usize> - The expected length of the node name after the separator.
    /// * `numeric_part_length`: Option<usize> - The expected length of the numeric part at the end of the node name.
    fn is_valid_node_name_from_seeds(
        node_name: &str,
        base_name: Option<&str>,
        base_length: Option<usize>,
        separator: Option<&str>,
        id_acronym: Option<&str>,
        id_length: Option<usize>,
        numeric_part_length: Option<usize>,
    ) -> Result<()> {
        if base_name.is_none() && id_acronym.is_none() {
            {
                :: std :: rt :: begin_panic ("There is some error: both base name and ID acronym are None.At least one of the two must be not None.")
            };
        }
        let mut validated = false;
        let mut node_name = node_name.to_string();
        if let Some(base_name) = base_name {
            if node_name.starts_with(base_name) {
                if base_length
                    .as_ref()
                    .map_or(false, |len| node_name.len() != *len)
                {
                    return Err({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[
                                "The given node name ",
                                " does not respect the given base length ",
                                ".",
                            ],
                            &match (&node_name, &base_length) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                                ],
                            },
                        ));
                        res
                    });
                }
                node_name = node_name[base_name.len()..node_name.len()].to_string();
                if let Some(separator) = separator {
                    if node_name.matches(separator).count() == 1 {
                        node_name = node_name
                            .split(separator)
                            .collect::<Vec<_>>()
                            .last()
                            .unwrap()
                            .to_string();
                    } else {
                        return Err({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "We expect for the given separator ",
                                    " to appear exactly once in the given object \'",
                                    "\'.",
                                ],
                                &match (&separator, &node_name) {
                                    (arg0, arg1) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                    ],
                                },
                            ));
                            res
                        });
                    }
                }
                if let Some(numeric_part_length) = numeric_part_length {
                    if node_name[(node_name.len() - numeric_part_length)..node_name.len()]
                        .chars()
                        .any(|character| !character.is_ascii_digit())
                    {
                        return Err({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "The last ",
                                    " characters of the node name ",
                                    " are expected to be digits.",
                                ],
                                &match (&numeric_part_length, &node_name) {
                                    (arg0, arg1) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                    ],
                                },
                            ));
                            res
                        });
                    }
                }
                validated = true;
            }
        }
        if let Some(id_acronym) = id_acronym {
            if !node_name.starts_with(id_acronym) {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "The given node name ",
                            " does not start with the expected ID acronym ",
                            ".",
                        ],
                        &match (&node_name, &id_acronym) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                });
            }
            if id_length
                .as_ref()
                .map_or(false, |len| node_name.len() != *len)
            {
                return Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "The given node name ",
                            " starts with the given acronym ",
                            " but does not have the expected length ",
                            ".",
                        ],
                        &match (&node_name, &id_acronym, &id_length) {
                            (arg0, arg1, arg2) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Debug::fmt),
                            ],
                        },
                    ));
                    res
                });
            }
            if let Some(numeric_part_length) = numeric_part_length {
                if node_name[(node_name.len() - numeric_part_length)..node_name.len()]
                    .chars()
                    .any(|character| !character.is_ascii_digit())
                {
                    return Err({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[
                                "The last ",
                                " characters of the node name ",
                                " are expected to be digits.",
                            ],
                            &match (&numeric_part_length, &node_name) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ],
                            },
                        ));
                        res
                    });
                }
            }
            validated = true;
        }
        if validated {
            Ok(())
        } else {
            Err({
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &["The given node name ", " was not validated successfully."],
                    &match (&node_name,) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ));
                res
            })
        }
    }
    /// Returns formatted url.
    ///
    /// # Arguments
    /// * `url_pattern`: &str - The URL pattern.
    /// * `node_name`: &str - The node name.
    /// * `separator`: Option<&str> - The expected separator.
    fn format_url_from_node_name(
        url_pattern: &str,
        node_name: &str,
        separator: Option<&str>,
    ) -> String {
        url_pattern.replace(
            "{node_name}",
            separator.map_or(node_name, |sep| {
                if node_name.contains(sep) {
                    node_name.split(sep).collect::<Vec<_>>().last().unwrap()
                } else {
                    node_name
                }
            }),
        )
    }
    /// Returns whether the given node name respects the flybase nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let flybase_node_name = "FlyBase:FBgn0000003";
    /// let not_flybase_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_flybase_node_name(flybase_node_name));
    /// assert!(!is_valid_flybase_node_name(not_flybase_node_name));
    /// ```
    pub fn is_valid_flybase_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("FlyBase"),
            Some(19),
            Some(":"),
            Some("FB"),
            Some(11),
            Some(7),
        )
        .is_ok()
    }
    /// Returns URL from given flybase node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a flybase node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_flybase_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://flybase.org/reports/{node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the sequence ontology nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let sequence_ontology_node_name = "SO:0001217";
    /// let not_sequence_ontology_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_sequence_ontology_node_name(sequence_ontology_node_name));
    /// assert!(!is_valid_sequence_ontology_node_name(not_sequence_ontology_node_name));
    /// ```
    pub fn is_valid_sequence_ontology_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("SO"),
            Some(10),
            Some(":"),
            None,
            None,
            Some(7),
        )
        .is_ok()
    }
    /// Returns URL from given sequence ontology node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a sequence ontology node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_sequence_ontology_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "http://www.sequenceontology.org/browser/current_svn/term/{node_name}",
            node_name,
            None,
        )
    }
    /// Returns whether the given node name respects the mouse genome informatics nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let mouse_genome_informatics_node_name1 = "MGI:2159965";
    /// let mouse_genome_informatics_node_name2 = "MGI:MGI:2159965";
    /// let not_mouse_genome_informatics_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_mouse_genome_informatics_node_name(mouse_genome_informatics_node_name1));
    /// assert!(!is_valid_mouse_genome_informatics_node_name(mouse_genome_informatics_node_name2));
    /// assert!(!is_valid_mouse_genome_informatics_node_name(not_mouse_genome_informatics_node_name));
    /// ```
    pub fn is_valid_mouse_genome_informatics_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(node_name, Some("MGI"), None, Some(":"), None, None, None)
            .is_ok()
    }
    /// Returns URL from given mouse genome informatics node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a mouse genome informatics node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_mouse_genome_informatics_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "http://www.informatics.jax.org/reference/strain/{node_name}",
            node_name,
            None,
        )
    }
    /// Returns whether the given node name respects the Pubmed NCBI nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let pubmed_ncbi_node_name = "PMID:1001879";
    /// let not_pubmed_ncbi_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_pubmed_ncbi_node_name(pubmed_ncbi_node_name));
    /// assert!(!is_valid_pubmed_ncbi_node_name(not_pubmed_ncbi_node_name));
    /// ```
    pub fn is_valid_pubmed_ncbi_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(node_name, Some("PMID"), None, Some(":"), None, None, None)
            .is_ok()
    }
    /// Returns URL from given Pubmed NCBI node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a Pubmed NCBI node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_pubmed_ncbi_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://pubmed.ncbi.nlm.nih.gov/{node_name}/",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the NCBI Genes nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let ncbi_gene_node_name1 = "NCBIGene:100000024";
    /// let ncbi_gene_node_name2 = "NCBIGene:562690";
    /// let not_ncbi_gene_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_ncbi_gene_node_name(ncbi_gene_node_name1));
    /// assert!(is_valid_ncbi_gene_node_name(ncbi_gene_node_name2));
    /// assert!(!is_valid_ncbi_gene_node_name(not_ncbi_gene_node_name));
    /// ```
    pub fn is_valid_ncbi_gene_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("NCBIGene"),
            None,
            Some(":"),
            None,
            None,
            None,
        )
        .is_ok()
    }
    /// Returns URL from given NCBI Genes node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a NCBI Genes node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_ncbi_gene_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://www.ncbi.nlm.nih.gov/gene/{node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the NCBI clinvars nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let ncbi_clinvar_node_name1 = "ClinVarVariant:10003";
    /// let ncbi_clinvar_node_name2 = "ClinVarVariant:100059";
    /// let not_ncbi_clinvar_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_ncbi_clinvar_node_name(ncbi_clinvar_node_name1));
    /// assert!(is_valid_ncbi_clinvar_node_name(ncbi_clinvar_node_name2));
    /// assert!(!is_valid_ncbi_clinvar_node_name(not_ncbi_clinvar_node_name));
    /// ```
    pub fn is_valid_ncbi_clinvar_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("ClinVarVariant"),
            None,
            Some(":"),
            None,
            None,
            None,
        )
        .is_ok()
    }
    /// Returns URL from given NCBI clinvars node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a NCBI clinvars node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_ncbi_clinvar_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://www.ncbi.nlm.nih.gov/clinvar/variation/{node_name}/",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the WormBase nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let wormbase_node_name1 = "WormBase:WBGene00195045";
    /// let wormbase_node_name2 = "WBGene00195045";
    /// let not_wormbase_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_wormbase_node_name(wormbase_node_name1));
    /// assert!(is_valid_wormbase_node_name(wormbase_node_name2));
    /// assert!(!is_valid_wormbase_node_name(not_wormbase_node_name));
    /// ```
    pub fn is_valid_wormbase_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("WormBase"),
            Some(23),
            Some(":"),
            Some("WBGene"),
            Some(14),
            Some(8),
        )
        .is_ok()
    }
    /// Returns URL from given WormBase node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a WormBase node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_wormbase_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://wormbase.org/search/all/{node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the ensembl nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let ensembl_node_name1 = "ENSEMBL:ENSACAG00000000017";
    /// let ensembl_node_name2 = "ENSACAG00000000017";
    /// let not_ensembl_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_ensembl_node_name(ensembl_node_name1));
    /// assert!(is_valid_ensembl_node_name(ensembl_node_name2));
    /// assert!(!is_valid_ensembl_node_name(not_ensembl_node_name));
    /// ```
    pub fn is_valid_ensembl_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("ENSEMBL"),
            Some(26),
            Some(":"),
            Some("ENS"),
            Some(18),
            Some(11),
        )
        .is_ok()
    }
    /// Returns URL from given ensembl node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a ensembl node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_ensembl_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://www.ensembl.org/Gene/Summary?g={node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the zfin nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let zfin_node_name1 = "ZFIN:ZDB-GENE-130530-778";
    /// let zfin_node_name2 = "ZDB-GENE-101108-4";
    /// let not_zfin_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_zfin_node_name(zfin_node_name1));
    /// assert!(is_valid_zfin_node_name(zfin_node_name2));
    /// assert!(!is_valid_zfin_node_name(not_zfin_node_name));
    /// ```
    pub fn is_valid_zfin_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("ZFIN"),
            None,
            Some(":"),
            Some("ZDB"),
            None,
            None,
        )
        .is_ok()
    }
    /// Returns URL from given zfin node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a zfin node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_zfin_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name("http://zfin.org/{node_name}", node_name, Some(":"))
    }
    /// Returns whether the given node name respects the doi nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let doi_node_name1 = "DOI:10.1002/1873-3468.12198";
    /// let doi_node_name2 = "DOI:000337984";
    /// let not_doi_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_doi_node_name(doi_node_name1));
    /// assert!(is_valid_doi_node_name(doi_node_name2));
    /// assert!(!is_valid_doi_node_name(not_doi_node_name));
    /// ```
    pub fn is_valid_doi_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(node_name, Some("DOI"), None, Some(":"), None, None, None)
            .is_ok()
    }
    /// Returns URL from given doi node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a doi node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_doi_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name("http://doi.org/{node_name}", node_name, Some(":"))
    }
    /// Returns whether the given node name respects the chebi nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let chebi_node_name1 = "CHEBI:145556";
    /// let chebi_node_name2 = "CHEBI:85302";
    /// let not_chebi_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_chebi_node_name(chebi_node_name1));
    /// assert!(is_valid_chebi_node_name(chebi_node_name2));
    /// assert!(!is_valid_chebi_node_name(not_chebi_node_name));
    /// ```
    pub fn is_valid_chebi_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(node_name, Some("CHEBI"), None, Some(":"), None, None, None)
            .is_ok()
    }
    /// Returns URL from given chebi node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a chebi node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_chebi_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://www.ebi.ac.uk/chebi/searchId.do?chebiId={node_name}",
            node_name,
            None,
        )
    }
    /// Returns whether the given node name respects the biogrid nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let biogrid_node_name = "BIOGRID:106534";
    /// let not_biogrid_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_biogrid_node_name(biogrid_node_name));
    /// assert!(!is_valid_biogrid_node_name(not_biogrid_node_name));
    /// ```
    pub fn is_valid_biogrid_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("BIOGRID"),
            None,
            Some(":"),
            None,
            None,
            None,
        )
        .is_ok()
    }
    /// Returns URL from given biogrid node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a biogrid node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_biogrid_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name("https://thebiogrid.org/{node_name}", node_name, Some(":"))
    }
    /// Returns whether the given node name respects the omim nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let omim_node_name = "OMIM:611636";
    /// let not_omim_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_omim_node_name(omim_node_name));
    /// assert!(!is_valid_omim_node_name(not_omim_node_name));
    /// ```
    pub fn is_valid_omim_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("OMIM"),
            Some(11),
            Some(":"),
            None,
            None,
            Some(6),
        )
        .is_ok()
    }
    /// Returns URL from given omim node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a omim node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_omim_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://www.omim.org/entry/{node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the rat_genome_database nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let rat_genome_database_node_name = "RGD:10059728";
    /// let not_rat_genome_database_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_rat_genome_database_node_name(rat_genome_database_node_name));
    /// assert!(!is_valid_rat_genome_database_node_name(not_rat_genome_database_node_name));
    /// ```
    pub fn is_valid_rat_genome_database_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("RGD"),
            Some(12),
            Some(":"),
            None,
            None,
            Some(8),
        )
        .is_ok()
    }
    /// Returns URL from given Rat Genome DataBase node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a Rat Genome DataBase node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_rat_genome_database_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://rgd.mcw.edu/rgdweb/report/gene/main.html?id={node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the Mutant Mouse Resource & Research Center nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let mmrrc_node_name = "MMRRC:000123";
    /// let not_mmrrc_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_mmrrc_node_name(mmrrc_node_name));
    /// assert!(!is_valid_mmrrc_node_name(not_mmrrc_node_name));
    /// ```
    pub fn is_valid_mmrrc_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("MMRRC"),
            Some(12),
            Some(":"),
            None,
            None,
            Some(6),
        )
        .is_ok()
    }
    /// Returns URL from given Mutant Mouse Resource & Research Center node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a Mutant Mouse Resource & Research Center node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_mmrrc_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://www.mmrrc.org/catalog/sds.php?mmrrc_id={node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the Gene Ontology nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let go_node_name1 = "GO:0043281PHENOTYPE";
    /// let go_node_name2 = "GO:0043281";
    /// let not_go_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_gene_ontology_node_name(go_node_name1));
    /// assert!(is_valid_gene_ontology_node_name(go_node_name2));
    /// assert!(!is_valid_gene_ontology_node_name(not_go_node_name));
    /// ```
    pub fn is_valid_gene_ontology_node_name(node_name: &str) -> bool {
        let mut node_name = node_name.to_string();
        if node_name.ends_with("PHENOTYPE") {
            node_name = node_name[0..(node_name.len() - 9)].to_string();
        }
        is_valid_node_name_from_seeds(
            node_name.as_ref(),
            Some("GO"),
            Some(10),
            Some(":"),
            None,
            None,
            Some(7),
        )
        .is_ok()
    }
    /// Returns URL from given Gene Ontology node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a Gene Ontology node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_gene_ontology_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "http://amigo.geneontology.org/amigo/term/{node_name}",
            node_name,
            None,
        )
    }
    /// Returns whether the given node name respects the UNIPROT nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let uniprotkb_node_name1 = "UniProtKB:Q63ZW2";
    /// let uniprotkb_node_name2 = "UniProtKB:A0A2R9YJI3";
    /// let not_uniprotkb_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_uniprotkb_node_name(uniprotkb_node_name1));
    /// assert!(is_valid_uniprotkb_node_name(uniprotkb_node_name2));
    /// assert!(!is_valid_uniprotkb_node_name(not_uniprotkb_node_name));
    /// ```
    pub fn is_valid_uniprotkb_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("UniProtKB"),
            None,
            Some(":"),
            None,
            None,
            None,
        )
        .is_ok()
    }
    /// Returns URL from given UniProtKB node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a UniProtKB node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_uniprotkb_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://www.uniprot.org/uniprot/{node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the Coriell nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let coriell_node_name = "Coriell:AG01439";
    /// let not_coriell_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_coriell_node_name(coriell_node_name));
    /// assert!(!is_valid_coriell_node_name(not_coriell_node_name));
    /// ```
    pub fn is_valid_coriell_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("Coriell"),
            Some(15),
            Some(":"),
            None,
            None,
            None,
        )
        .is_ok()
    }
    /// Returns URL from given Coriell node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a Coriell node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_coriell_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://coriell.org/0/Sections/Search/Sample_Detail.aspx?Ref={node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the drugcentral nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let drugcentral_node_name = "DrugCentral:217";
    /// let not_drugcentral_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_drugcentral_node_name(drugcentral_node_name));
    /// assert!(!is_valid_drugcentral_node_name(not_drugcentral_node_name));
    /// ```
    pub fn is_valid_drugcentral_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("DrugCentral"),
            None,
            Some(":"),
            None,
            None,
            None,
        )
        .is_ok()
    }
    /// Returns URL from given DrugCentral node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a DrugCentral node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_drugcentral_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://drugcentral.org/drugcard/{node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the NCBI MESH nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let ncbi_mesh_node_name = "MESH:217";
    /// let not_ncbi_mesh_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_ncbi_mesh_node_name(ncbi_mesh_node_name));
    /// assert!(!is_valid_ncbi_mesh_node_name(not_ncbi_mesh_node_name));
    /// ```
    pub fn is_valid_ncbi_mesh_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(node_name, Some("MESH"), None, Some(":"), None, None, None)
            .is_ok()
    }
    /// Returns URL from given NCBI MESH node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a NCBI MESH node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_ncbi_mesh_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://ncbi.nlm.nih.gov/mesh/?term={node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the NCBI taxonomy nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let ncbi_taxonomy_node_name = "NCBITaxon:264379";
    /// let not_ncbi_taxonomy_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_ncbi_taxonomy_node_name(ncbi_taxonomy_node_name));
    /// assert!(!is_valid_ncbi_taxonomy_node_name(not_ncbi_taxonomy_node_name));
    /// ```
    pub fn is_valid_ncbi_taxonomy_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("NCBITaxon"),
            Some(16),
            Some(":"),
            None,
            None,
            Some(6),
        )
        .is_ok()
    }
    /// Returns URL from given NCBI taxonomy node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a NCBI taxonomy node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_ncbi_taxonomy_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://www.ncbi.nlm.nih.gov/taxonomy/?term={node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the JAX nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let jax_node_name = "JAX:000046";
    /// let not_jax_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_jax_node_name(jax_node_name));
    /// assert!(!is_valid_jax_node_name(not_jax_node_name));
    /// ```
    pub fn is_valid_jax_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("JAX"),
            Some(10),
            Some(":"),
            None,
            None,
            Some(6),
        )
        .is_ok()
    }
    /// Returns URL from given JAX node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a JAX node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_jax_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://www.jax.org/strain/{node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the wikidata nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let wikidata_node_name = "WD:Q30";
    /// let not_wikidata_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_wikidata_node_name(wikidata_node_name));
    /// assert!(!is_valid_wikidata_node_name(not_wikidata_node_name));
    /// ```
    pub fn is_valid_wikidata_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(node_name, Some("WD"), None, Some(":"), None, None, None)
            .is_ok()
    }
    /// Returns URL from given WikiData node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a WikiData node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_wikidata_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://www.wikidata.org/wiki/{node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the Therapeutic Target Database nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let therapeutic_target_database_node_name1 = "ttd.drug:D0O1KD";
    /// let therapeutic_target_database_node_name2 = "ttd.drug:D06FHW";
    /// let therapeutic_target_database_node_name3 = "ttd.drug:D09RZX";
    /// let therapeutic_target_database_node_name4 = "ttd.drug:D0G2MM";
    /// let not_therapeutic_target_database_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_therapeutic_target_database_node_name(therapeutic_target_database_node_name1));
    /// assert!(is_valid_therapeutic_target_database_node_name(therapeutic_target_database_node_name2));
    /// assert!(is_valid_therapeutic_target_database_node_name(therapeutic_target_database_node_name3));
    /// assert!(is_valid_therapeutic_target_database_node_name(therapeutic_target_database_node_name4));
    /// assert!(!is_valid_therapeutic_target_database_node_name(not_therapeutic_target_database_node_name));
    /// ```
    pub fn is_valid_therapeutic_target_database_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("ttd.drug"),
            Some(15),
            Some(":"),
            None,
            None,
            None,
        )
        .is_ok()
    }
    /// Returns URL from given Therapeutic Target Database node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a therapeutic_target_database node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_therapeutic_target_database_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "http://db.idrblab.net/ttd/search/ttd/target?search_api_fulltext={node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns whether the given node name respects the Reactome nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let reactome_node_name1 = "REACT:R-HSA-8851222";
    /// let reactome_node_name2 = "REACT:R-HSA-77267";
    /// let not_reactome_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_reactome_node_name(reactome_node_name1));
    /// assert!(is_valid_reactome_node_name(reactome_node_name2));
    /// assert!(!is_valid_reactome_node_name(not_reactome_node_name));
    /// ```
    pub fn is_valid_reactome_node_name(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(node_name, Some("REACT"), None, Some(":"), None, None, None)
            .is_ok()
    }
    /// Returns URL from given Reactome node name.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a Reactome node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_reactome_url_from_node_name(node_name: &str) -> String {
        format_url_from_node_name(
            "https://reactome.org/content/detail/{node_name}",
            node_name,
            Some(":"),
        )
    }
    /// Returns url describing the given node name if a pattern is known.
    ///
    /// # Implementative details
    /// Currently we have support for building the URLs for:
    /// * [Sequence Ontology](http://www.sequenceontology.org/)
    /// * [FlyBase](http://flybase.org/)
    /// * [Mouse Genome Informations](http://www.informatics.jax.org/)
    /// * [Pubmed NCBI](https://www.ncbi.nlm.nih.gov/)
    /// * [NCBI Gene](https://www.ncbi.nlm.nih.gov/gene/)
    /// * [NCBI ClinVar](https://www.ncbi.nlm.nih.gov/clinvar/)
    /// * [WormBase](https://wormbase.org)
    /// * [Ensembl](https://www.ensembl.org/index.html)
    /// * [ZFIN](http://zfin.org/)
    /// * [DOI](https://www.doi.org/)
    /// * [CHEBI](https://www.ebi.ac.uk/chebi/init.do)
    /// * [BioGrid](https://thebiogrid.org/)
    /// * [OMIM](https://www.omim.org/)
    /// * [Rat Genome DataBase](https://rgd.mcw.edu/rgdweb/homepage/)
    /// * [MMRRC](https://www.mmrrc.org/)
    /// * [GO](http://amigo.geneontology.org/amigo/landing)
    /// * [UniProtKB](https://www.uniprot.org/)
    /// * [Coriell](https://coriell.org/)
    /// * [DrugCentral](https://drugcentral.org/)
    /// * [NCBI MESH](https://www.ncbi.nlm.nih.gov/mesh/)
    /// * [NCBI Taxonomy](https://www.ncbi.nlm.nih.gov/taxonomy)
    /// * [JAX](https://www.jax.org/strain)
    /// * [WikiData](https://www.wikidata.org/wiki/Wikidata:Main_Page)
    /// * [Therapeutic Target Database](http://db.idrblab.net/ttd/)
    /// * [Reactome](https://reactome.org/)
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to query for.
    ///
    /// # Raises
    /// * If there is no known url source for the given node name.
    pub fn get_node_source_url_from_node_name(node_name: &str) -> Result<String> {
        if is_valid_flybase_node_name(node_name) {
            return Ok(unsafe { format_flybase_url_from_node_name(node_name) });
        }
        if is_valid_sequence_ontology_node_name(node_name) {
            return Ok(unsafe { format_sequence_ontology_url_from_node_name(node_name) });
        }
        if is_valid_mmrrc_node_name(node_name) {
            return Ok(unsafe { format_mmrrc_url_from_node_name(node_name) });
        }
        if is_valid_wormbase_node_name(node_name) {
            return Ok(unsafe { format_wormbase_url_from_node_name(node_name) });
        }
        if is_valid_mouse_genome_informatics_node_name(node_name) {
            return Ok(unsafe { format_mouse_genome_informatics_url_from_node_name(node_name) });
        }
        if is_valid_pubmed_ncbi_node_name(node_name) {
            return Ok(unsafe { format_pubmed_ncbi_url_from_node_name(node_name) });
        }
        if is_valid_ncbi_gene_node_name(node_name) {
            return Ok(unsafe { format_ncbi_gene_url_from_node_name(node_name) });
        }
        if is_valid_ncbi_clinvar_node_name(node_name) {
            return Ok(unsafe { format_ncbi_clinvar_url_from_node_name(node_name) });
        }
        if is_valid_ensembl_node_name(node_name) {
            return Ok(unsafe { format_ensembl_url_from_node_name(node_name) });
        }
        if is_valid_zfin_node_name(node_name) {
            return Ok(unsafe { format_zfin_url_from_node_name(node_name) });
        }
        if is_valid_doi_node_name(node_name) {
            return Ok(unsafe { format_doi_url_from_node_name(node_name) });
        }
        if is_valid_chebi_node_name(node_name) {
            return Ok(unsafe { format_chebi_url_from_node_name(node_name) });
        }
        if is_valid_biogrid_node_name(node_name) {
            return Ok(unsafe { format_biogrid_url_from_node_name(node_name) });
        }
        if is_valid_omim_node_name(node_name) {
            return Ok(unsafe { format_omim_url_from_node_name(node_name) });
        }
        if is_valid_rat_genome_database_node_name(node_name) {
            return Ok(unsafe { format_rat_genome_database_url_from_node_name(node_name) });
        }
        if is_valid_gene_ontology_node_name(node_name) {
            return Ok(unsafe { format_gene_ontology_url_from_node_name(node_name) });
        }
        if is_valid_uniprotkb_node_name(node_name) {
            return Ok(unsafe { format_uniprotkb_url_from_node_name(node_name) });
        }
        if is_valid_coriell_node_name(node_name) {
            return Ok(unsafe { format_coriell_url_from_node_name(node_name) });
        }
        if is_valid_drugcentral_node_name(node_name) {
            return Ok(unsafe { format_drugcentral_url_from_node_name(node_name) });
        }
        if is_valid_ncbi_mesh_node_name(node_name) {
            return Ok(unsafe { format_ncbi_mesh_url_from_node_name(node_name) });
        }
        if is_valid_ncbi_taxonomy_node_name(node_name) {
            return Ok(unsafe { format_ncbi_taxonomy_url_from_node_name(node_name) });
        }
        if is_valid_jax_node_name(node_name) {
            return Ok(unsafe { format_jax_url_from_node_name(node_name) });
        }
        if is_valid_therapeutic_target_database_node_name(node_name) {
            return Ok(unsafe { format_therapeutic_target_database_url_from_node_name(node_name) });
        }
        if is_valid_wikidata_node_name(node_name) {
            return Ok(unsafe { format_wikidata_url_from_node_name(node_name) });
        }
        if is_valid_reactome_node_name(node_name) {
            return Ok(unsafe { format_reactome_url_from_node_name(node_name) });
        }
        Err({
            let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["There is no known url with a pattern for the provided node name " , ".\nIf you believe there should be one, please do open a pull request to add it to the library!"] , & match (& node_name ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , })) ;
            res
        })
    }
    /// Returns name of the graph repository from the given node name.
    ///
    /// # Implementative details
    /// Currently we have support for building the URLs for:
    /// * [Sequence Ontology](http://www.sequenceontology.org/)
    /// * [FlyBase](http://flybase.org/)
    /// * [Mouse Genome Informations](http://www.informatics.jax.org/)
    /// * [Pubmed NCBI](https://www.ncbi.nlm.nih.gov/)
    /// * [NCBI Gene](https://www.ncbi.nlm.nih.gov/gene/)
    /// * [NCBI ClinVar](https://www.ncbi.nlm.nih.gov/clinvar/)
    /// * [WormBase](https://wormbase.org)
    /// * [Ensembl](https://www.ensembl.org/index.html)
    /// * [ZFIN](http://zfin.org/)
    /// * [DOI](https://www.doi.org/)
    /// * [CHEBI](https://www.ebi.ac.uk/chebi/init.do)
    /// * [BioGrid](https://thebiogrid.org/)
    /// * [OMIM](https://www.omim.org/)
    /// * [Rat Genome DataBase](https://rgd.mcw.edu/rgdweb/homepage/)
    /// * [MMRRC](https://www.mmrrc.org/)
    /// * [GO](http://amigo.geneontology.org/amigo/landing)
    /// * [UniProtKB](https://www.uniprot.org/)
    /// * [Coriell](https://coriell.org/)
    /// * [DrugCentral](https://drugcentral.org/)
    /// * [NCBI MESH](https://www.ncbi.nlm.nih.gov/mesh/)
    /// * [NCBI Taxonomy](https://www.ncbi.nlm.nih.gov/taxonomy)
    /// * [JAX](https://www.jax.org/strain)
    /// * [WikiData](https://www.wikidata.org/wiki/Wikidata:Main_Page)
    /// * [Therapeutic Target Database](http://db.idrblab.net/ttd/)
    /// * [Reactome](https://reactome.org/)
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to query for.
    ///
    /// # Raises
    /// * If there is no known url source for the given node name.
    pub fn get_node_repository_from_node_name(node_name: &str) -> Result<&str> {
        if is_valid_flybase_node_name(node_name) {
            return Ok("FlyBase");
        }
        if is_valid_sequence_ontology_node_name(node_name) {
            return Ok("Sequence Ontology");
        }
        if is_valid_mmrrc_node_name(node_name) {
            return Ok("MMRRC");
        }
        if is_valid_wormbase_node_name(node_name) {
            return Ok("WormBase");
        }
        if is_valid_mouse_genome_informatics_node_name(node_name) {
            return Ok("Mouse Genome Informatics");
        }
        if is_valid_pubmed_ncbi_node_name(node_name) {
            return Ok("Pubmed NCBI");
        }
        if is_valid_ncbi_gene_node_name(node_name) {
            return Ok("NCBI Gene");
        }
        if is_valid_ncbi_clinvar_node_name(node_name) {
            return Ok("NCBI ClinVar");
        }
        if is_valid_ensembl_node_name(node_name) {
            return Ok("ENSEMBL");
        }
        if is_valid_zfin_node_name(node_name) {
            return Ok("ZFIN");
        }
        if is_valid_doi_node_name(node_name) {
            return Ok("DOI");
        }
        if is_valid_chebi_node_name(node_name) {
            return Ok("CHEBI");
        }
        if is_valid_biogrid_node_name(node_name) {
            return Ok("BIOGRID");
        }
        if is_valid_omim_node_name(node_name) {
            return Ok("OMIN");
        }
        if is_valid_rat_genome_database_node_name(node_name) {
            return Ok("Rat Genome Database");
        }
        if is_valid_gene_ontology_node_name(node_name) {
            return Ok("Gene Ontology");
        }
        if is_valid_uniprotkb_node_name(node_name) {
            return Ok("UniProtKB");
        }
        if is_valid_coriell_node_name(node_name) {
            return Ok("Coriell");
        }
        if is_valid_drugcentral_node_name(node_name) {
            return Ok("DrugCentral");
        }
        if is_valid_ncbi_mesh_node_name(node_name) {
            return Ok("NCBI Mesh");
        }
        if is_valid_ncbi_taxonomy_node_name(node_name) {
            return Ok("NCBI Taxonomy");
        }
        if is_valid_jax_node_name(node_name) {
            return Ok("JAX");
        }
        if is_valid_wikidata_node_name(node_name) {
            return Ok("WikiData");
        }
        if is_valid_therapeutic_target_database_node_name(node_name) {
            return Ok("Therapeutic Target Database");
        }
        if is_valid_reactome_node_name(node_name) {
            return Ok("Reactome");
        }
        Err({
            let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["There is no known url with a pattern for the provided node name " , ".\nIf you believe there should be one, please do open a pull request to add it to the library!"] , & match (& node_name ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , })) ;
            res
        })
    }
    /// Returns whether the given node name respects the BioLink nodes pattern.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to check pattern with.
    ///
    /// # Example
    /// To validate a node you can use:
    /// ```rust
    /// # use graph::*;
    /// let biolink_node_name1 = "biolink:BehavioralOutcome";
    /// let biolink_node_name2 = "biolink:Book";
    /// let not_biolink_node_name = "PizzaQuattroStagioni";
    /// assert!(is_valid_biolink_from_object(biolink_node_name1));
    /// assert!(is_valid_biolink_from_object(biolink_node_name2));
    /// assert!(!is_valid_biolink_from_object(not_biolink_node_name));
    /// ```
    pub fn is_valid_biolink_from_object(node_name: &str) -> bool {
        is_valid_node_name_from_seeds(
            node_name,
            Some("biolink"),
            None,
            Some(":"),
            None,
            None,
            None,
        )
        .is_ok()
    }
    /// Returns URL from given JAX node name.
    ///
    /// # Arguments
    /// * `object_name`: &str - Object name to build pattern for.
    ///
    /// # Safety
    /// This method assumes that the provided node name is a JAX node name and
    /// may cause a panic if the aforementioned assumption is not true.
    unsafe fn format_biolink_from_object(object_name: &str) -> String {
        format_url_from_node_name(
            "https://biolink.github.io/biolink-model/docs/{node_name}.html",
            object_name,
            Some(":"),
        )
    }
    /// Returns url describing the given node type if a pattern is known.
    ///
    /// # Implementative details
    /// Currently we have support for building the URLs for:
    /// * [BioLink](https://biolink.github.io/biolink-model/)
    ///
    /// # Arguments
    /// * `node_type_name`: &str - Node name to query for.
    ///
    /// # Raises
    /// * If there is no known url source for the given node type.
    pub fn get_node_type_source_url_from_node_type_name(node_type_name: &str) -> Result<String> {
        if is_valid_biolink_from_object(node_type_name) {
            return Ok(unsafe { format_biolink_from_object(node_type_name) });
        }
        Err({
            let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["There is no known url with a pattern for the provided node type " , ".\nIf you believe there should be one, please do open a pull request to add it to the library!"] , & match (& node_type_name ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , })) ;
            res
        })
    }
    /// Returns url describing the given edge type if a pattern is known.
    ///
    /// # Implementative details
    /// Currently we have support for building the URLs for:
    /// * [BioLink](https://biolink.github.io/biolink-model/)
    ///
    /// # Arguments
    /// * `edge_type_name`: &str - edge name to query for.
    ///
    /// # Raises
    /// * If there is no known url source for the given edge type.
    pub fn get_edge_type_source_url_from_edge_type_name(edge_type_name: &str) -> Result<String> {
        if is_valid_biolink_from_object(edge_type_name) {
            return Ok(unsafe { format_biolink_from_object(edge_type_name) });
        }
        Err({
            let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["There is no known url with a pattern for the provided edge type " , ".\nIf you believe there should be one, please do open a pull request to add it to the library!"] , & match (& edge_type_name ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , })) ;
            res
        })
    }
    /// Returns built url for given element
    fn get_url_formatted(url: &str, content: &str, repository: &str) -> String {
        {
            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1_formatted(
                &[
                    "<a href=\'",
                    "\' target=\'_blank\' title=\'Go to ",
                    " to get more informations about ",
                    "\'>",
                    "</a>",
                ],
                &match (&url, &content, &repository) {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
                &[
                    ::core::fmt::rt::v1::Argument {
                        position: 0usize,
                        format: ::core::fmt::rt::v1::FormatSpec {
                            fill: ' ',
                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                            flags: 0u32,
                            precision: ::core::fmt::rt::v1::Count::Implied,
                            width: ::core::fmt::rt::v1::Count::Implied,
                        },
                    },
                    ::core::fmt::rt::v1::Argument {
                        position: 2usize,
                        format: ::core::fmt::rt::v1::FormatSpec {
                            fill: ' ',
                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                            flags: 0u32,
                            precision: ::core::fmt::rt::v1::Count::Implied,
                            width: ::core::fmt::rt::v1::Count::Implied,
                        },
                    },
                    ::core::fmt::rt::v1::Argument {
                        position: 1usize,
                        format: ::core::fmt::rt::v1::FormatSpec {
                            fill: ' ',
                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                            flags: 0u32,
                            precision: ::core::fmt::rt::v1::Count::Implied,
                            width: ::core::fmt::rt::v1::Count::Implied,
                        },
                    },
                    ::core::fmt::rt::v1::Argument {
                        position: 1usize,
                        format: ::core::fmt::rt::v1::FormatSpec {
                            fill: ' ',
                            align: ::core::fmt::rt::v1::Alignment::Unknown,
                            flags: 0u32,
                            precision: ::core::fmt::rt::v1::Count::Implied,
                            width: ::core::fmt::rt::v1::Count::Implied,
                        },
                    },
                ],
            ));
            res
        }
    }
    /// Returns html-formatted source of given node name if known.
    ///
    /// # Implementative details
    /// If an URL is detected from the provided node name then a standard
    /// html URL formatting is returned, otherwise the node name is returned.
    /// Refer to the `get_node_source_url_from_node_name` method documentation
    /// to see which node databases are supported currently.
    ///
    /// # Arguments
    /// * `node_name`: &str - Node name to query for.
    pub fn get_node_source_html_url_from_node_name(node_name: &str) -> String {
        match get_node_source_url_from_node_name(node_name) {
            Ok(url) => get_url_formatted(
                url.as_str(),
                node_name,
                get_node_repository_from_node_name(node_name).unwrap(),
            ),
            Err(_) => node_name.to_string(),
        }
    }
    /// Returns html-formatted source of given node type name if known.
    ///
    /// # Implementative details
    /// If an URL is detected from the provided node type name then a standard
    /// html URL formatting is returned, otherwise the node type name is returned.
    /// Refer to the `get_node_source_url_from_node_type_name` method documentation
    /// to see which node databases are supported currently.
    ///
    /// # Arguments
    /// * `node_type_name`: &str - Node name to query for.
    pub fn get_node_type_source_html_url_from_node_type_name(node_type_name: &str) -> String {
        match get_node_type_source_url_from_node_type_name(node_type_name) {
            Ok(url) => get_url_formatted(url.as_str(), node_type_name, "BioLink"),
            Err(_) => node_type_name.to_string(),
        }
    }
    /// Returns html-formatted source of given edge type name if known.
    ///
    /// # Implementative details
    /// If an URL is detected from the provided edge type name then a standard
    /// html URL formatting is returned, otherwise the edge type name is returned.
    /// Refer to the `get_edge_source_url_from_edge_type_name` method documentation
    /// to see which edge databases are supported currently.
    ///
    /// # Arguments
    /// * `edge_type_name`: &str - edge name to query for.
    pub fn get_edge_type_source_html_url_from_edge_type_name(edge_type_name: &str) -> String {
        match get_edge_type_source_url_from_edge_type_name(edge_type_name) {
            Ok(url) => get_url_formatted(url.as_str(), edge_type_name, "BioLink"),
            Err(_) => edge_type_name.to_string(),
        }
    }
}
mod tfidf {
    use counter::Counter;
    use indicatif::{ParallelProgressIterator, ProgressIterator};
    use rayon::iter::{IntoParallelIterator, IntoParallelRefIterator, ParallelIterator};
    use std::collections::hash_map::Entry::{Occupied, Vacant};
    use std::collections::HashMap;
    use super::*;
    /// Return vector of hashmaps containing the non-zero frequencies.
    ///
    /// # Arguments
    /// * `documents`: &[Vec<&str>] - The documents to parse
    /// * `k1`: Option<f64> - The default parameter for k1, tipically between 1.2 and 2.0.
    /// * `b`: Option<f64> - The default parameter for b, tipically equal to 0.75.
    /// * `vocabulary_size`: Option<usize> - The expected vocabulary size.
    /// * `verbose`: Option<bool> - Whether to show a loading bar.
    ///
    pub fn okapi_bm25_tfidf(
        documents: &[Vec<&str>],
        k1: Option<f64>,
        b: Option<f64>,
        vocabulary_size: Option<usize>,
        verbose: Option<bool>,
    ) -> Result<Vec<HashMap<String, f64>>> {
        if documents.is_empty() {
            return Err("The given documents set is empty!".to_string());
        }
        let verbose = verbose.unwrap_or(true);
        let k1 = k1.unwrap_or(1.5);
        let b = b.unwrap_or(0.75);
        let number_of_documents = documents.len();
        let vocabulary_size = vocabulary_size.unwrap_or(100);
        let mut total_documents_length = 0;
        let mut vocabulary: HashMap<&str, usize> = HashMap::with_capacity(vocabulary_size);
        let mut word_counts: Vec<usize> = Vec::new();
        let pb = get_loading_bar(verbose, "Building vocabulary", number_of_documents);
        for document in documents.iter().progress_with(pb) {
            total_documents_length += document.len();
            for word in document.iter() {
                let current_vocabulary_length = vocabulary.len();
                match vocabulary.entry(word) {
                    Vacant(entry) => {
                        entry.insert(current_vocabulary_length);
                        word_counts.push(1);
                    }
                    Occupied(entry) => {
                        word_counts[*entry.get()] += 1;
                    }
                }
            }
        }
        let average_document_len = total_documents_length as f64 / number_of_documents as f64;
        let inverse_document_frequencies = word_counts
            .into_par_iter()
            .map(|counts| {
                ((number_of_documents as f64 - counts as f64 + 0.5) / (counts as f64 + 0.5)).ln_1p()
            })
            .collect::<Vec<f64>>();
        let pb = get_loading_bar(verbose, "Building TFIDF", number_of_documents);
        Ok(documents
            .par_iter()
            .progress_with(pb)
            .map(|document| {
                let document_len = document.len() as f64;
                let counts: Counter<&str, usize> = document.iter().cloned().collect();
                counts
                    .into_iter()
                    .map(|(word_name, word_count)| {
                        let word_id = *vocabulary.get(word_name).unwrap();
                        let word_frequency = *word_count as f64 / document_len;
                        (
                            word_name.to_string(),
                            inverse_document_frequencies[word_id] * (word_frequency * (k1 + 1.0))
                                / (word_frequency
                                    + k1 * (1.0 - b + b * document_len / average_document_len)),
                        )
                    })
                    .collect::<HashMap<String, f64>>()
            })
            .collect::<Vec<HashMap<String, f64>>>())
    }
}
mod thickeners {
    use super::*;
    use indicatif::ParallelProgressIterator;
    use num_traits::Pow;
    use rayon::prelude::*;
    use std::convert::TryFrom;
    pub enum Distance {
        L2,
        Cosine,
    }
    impl TryFrom<&str> for Distance {
        type Error = String;
        fn try_from(value: &str) -> std::result::Result<Self, Self::Error> {
            match value {
                "L2" => Ok(Distance::L2),
                "COSINE" => Ok(Distance::Cosine),
                _ => Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Unknown distance metric "],
                        &match (&value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }),
            }
        }
    }
    /// # Methods to thicken the graph.
    impl Graph {
        /// Returns graph with edges added extracted from given node_features.
        ///
        /// This operation might distrupt the graph topology.
        /// Proceed with caution!
        ///
        /// # Arguments
        /// * `features`: Vec<Vec<f64>> - node_features to use to identify the new neighbours.
        /// * `neighbours_number`: Option<NodeT> - Number of neighbours to add.
        /// * `max_degree`: Option<NodeT> - The maximum degree a node can have its neighbours augmented. By default 0, that is, only singletons are augmented.
        /// * `distance_name`: Option<&str> - Name of distance to use. Can either be L2 or COSINE. By default COSINE.
        /// * `verbose`: Option<bool> - Whether to show loading bars.
        ///
        /// # Raises
        /// * If the graph does not have nodes.
        /// * If the given node_features are not provided exactly for each node.
        /// * If the node_features do not have a consistent shape.
        /// * If the provided number of neighbours is zero.
        pub fn generate_new_edges_from_node_features(
            &self,
            features: Vec<Vec<f64>>,
            neighbours_number: Option<NodeT>,
            max_degree: Option<NodeT>,
            distance_name: Option<&str>,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            self.must_have_nodes()?;
            validate_features(&features, self.get_nodes_number() as usize)?;
            let max_degree = max_degree.unwrap_or(0);
            let neighbours_number =
                neighbours_number.unwrap_or(self.get_node_degrees_mean()?.ceil() as NodeT);
            if neighbours_number == 0 {
                return Err("The number of neighbours to add per node cannot be zero!".to_string());
            }
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Computing additional edges to thicken graph",
                self.get_nodes_number() as usize,
            );
            let distance_metric = match Distance::try_from(distance_name.unwrap_or("COSINE"))? {
                Distance::L2 => {
                    |current_node_features: &Vec<f64>, node_features: &Vec<f64>| -> f64 {
                        current_node_features
                            .iter()
                            .zip(node_features.iter())
                            .map(|(&left, &right)| (left - right).pow(2))
                            .sum()
                    }
                }
                Distance::Cosine => {
                    |current_node_features: &Vec<f64>, node_features: &Vec<f64>| -> f64 {
                        let numerator = current_node_features
                            .iter()
                            .zip(node_features.iter())
                            .map(|(&left, &right)| left * right)
                            .sum::<f64>();
                        let denominator_left = current_node_features
                            .iter()
                            .map(|&left| left.pow(2))
                            .sum::<f64>()
                            .sqrt();
                        let denominator_right = node_features
                            .iter()
                            .map(|&right| right.pow(2))
                            .sum::<f64>()
                            .sqrt();
                        1.0 - numerator / (denominator_left * denominator_right + f64::EPSILON)
                    }
                }
            };
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)
                    .map(|(_, src_node_id, dst_node_id, edge_type, weight)| {
                        Ok((src_node_id, dst_node_id, edge_type, weight))
                    })
                    .chain(
                        self.par_iter_node_ids()
                            .zip(self.par_iter_node_degrees())
                            .progress_with(pb)
                            .map(|(source_node_id, node_degree)| {
                                if node_degree <= max_degree {
                                    let mut closest_nodes =
                                        Vec::with_capacity(neighbours_number as usize);
                                    let current_node_features = &features[source_node_id as usize];
                                    let mut closest_nodes_distances = ::alloc::vec::from_elem(
                                        f64::INFINITY,
                                        neighbours_number as usize,
                                    );
                                    features
                                        .iter()
                                        .zip(self.iter_node_ids())
                                        .filter(|(_, destination_node_id)| {
                                            source_node_id != *destination_node_id
                                        })
                                        .for_each(|(node_features, destination_node_id)| {
                                            let distance = distance_metric(
                                                current_node_features,
                                                node_features,
                                            );
                                            let (i, max_distance) = unsafe {
                                                closest_nodes_distances.argmax().unwrap_unchecked()
                                            };
                                            if max_distance > distance {
                                                if max_distance == f64::INFINITY {
                                                    closest_nodes.push(destination_node_id);
                                                } else {
                                                    closest_nodes[i] = destination_node_id;
                                                }
                                                closest_nodes_distances[i] = distance;
                                            }
                                        });
                                    closest_nodes
                                } else {
                                    Vec::new()
                                }
                            })
                            .enumerate()
                            .map(|(source_node_id, new_neighbours)| {
                                new_neighbours
                                    .into_iter()
                                    .map(move |destination_node_id| {
                                        if !self.is_directed() {
                                            <[_]>::into_vec(box [
                                                Ok((
                                                    source_node_id as NodeT,
                                                    destination_node_id,
                                                    None,
                                                    None,
                                                )),
                                                Ok((
                                                    destination_node_id,
                                                    source_node_id as NodeT,
                                                    None,
                                                    None,
                                                )),
                                            ])
                                        } else {
                                            <[_]>::into_vec(box [Ok((
                                                source_node_id as NodeT,
                                                destination_node_id,
                                                None,
                                                None,
                                            ))])
                                        }
                                    })
                                    .flatten()
                                    .collect::<Vec<_>>()
                            })
                            .flatten(),
                    ),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                self.has_singleton_nodes(),
                self.has_singleton_nodes_with_selfloops(),
                self.has_trap_nodes(),
                verbose,
            )
        }
    }
}
mod to_conversions {
    use indicatif::ParallelProgressIterator;
    use rayon::iter::ParallelIterator;
    use super::*;
    /// # Conversion of the graph.
    impl Graph {
        /// Convert inplace the graph to directed.
        ///
        /// # Implementative details
        /// The conversion to a directed graph is trivial as only requires to
        /// switch the flag for directed to true.
        pub fn to_directed_inplace(&mut self) -> &mut Graph {
            self.directed = true;
            self
        }
        /// Return a new instance of the current graph as directed.
        pub fn to_directed(&self) -> Graph {
            let mut new_graph = self.clone();
            new_graph.to_directed_inplace();
            new_graph
        }
        /// Return the directed graph from the upper triangular adjacency matrix.
        ///
        /// # Implementative details
        /// Filtering a graph to the upper triangular matrix means that the
        /// resulting graph will exclusively have edges so that `dst > src`.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        pub fn to_upper_triangular(&self, verbose: Option<bool>) -> Graph {
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Building upper triangular matrix",
                self.get_directed_edges_number() as usize,
            );
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)
                    .progress_with(pb)
                    .filter_map(|(_, src, dst, edge_type, weight)| {
                        if dst > src {
                            Some(Ok((src, dst, edge_type, weight)))
                        } else {
                            None
                        }
                    }),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                true,
                self.get_name(),
                true,
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                true,
                true,
                true,
                verbose,
            )
            .unwrap()
        }
        /// Return the directed graph from the lower triangular adjacency matrix.
        ///
        /// # Implementative details
        /// Filtering a graph to the lower triangular matrix means that the
        /// resulting graph will exclusively have edges so that `src > dst`.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        pub fn to_lower_triangular(&self, verbose: Option<bool>) -> Graph {
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Building lower triangular matrix",
                self.get_directed_edges_number() as usize,
            );
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)
                    .progress_with(pb)
                    .filter_map(|(_, src, dst, edge_type, weight)| {
                        if src > dst {
                            Some(Ok((src, dst, edge_type, weight)))
                        } else {
                            None
                        }
                    }),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                true,
                self.get_name(),
                true,
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                true,
                true,
                true,
                verbose,
            )
            .unwrap()
        }
        /// Return the graph from the main diagonal adjacency matrix.
        ///
        /// # Implementative details
        /// The resulting graph will only contain the selfloops present in the
        /// original graph.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        pub fn to_main_diagonal(&self, verbose: Option<bool>) -> Graph {
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Building the main diagonal matrix",
                self.get_directed_edges_number() as usize,
            );
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)
                    .progress_with(pb)
                    .filter_map(|(_, src, dst, edge_type, weight)| {
                        if src == dst {
                            Some(Ok((src, dst, edge_type, weight)))
                        } else {
                            None
                        }
                    }),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                true,
                true,
                true,
                verbose,
            )
            .unwrap()
        }
        /// Return the graph from the anti-diagonal adjacency matrix.
        ///
        /// # Implementative details
        /// The resulting graph will include only the edges present on the
        /// anti-diagonal of the graph.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        pub fn to_anti_diagonal(&self, verbose: Option<bool>) -> Graph {
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Building the anti-diagonal matrix",
                self.get_directed_edges_number() as usize,
            );
            let nodes_number = self.get_nodes_number();
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)
                    .progress_with(pb)
                    .filter_map(|(_, src, dst, edge_type, weight)| {
                        if src == nodes_number - dst {
                            Some(Ok((src, dst, edge_type, weight)))
                        } else {
                            None
                        }
                    }),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                true,
                true,
                true,
                verbose,
            )
            .unwrap()
        }
        /// Return the graph from the bidiagonal adjacency matrix.
        ///
        /// # Implementative details
        /// The resulting graph will include only the edges present on either
        /// the diagonal or anti-diagonal matrix.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        pub fn to_bidiagonal(&self, verbose: Option<bool>) -> Graph {
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Building the bidiagonal matrix",
                self.get_directed_edges_number() as usize,
            );
            let nodes_number = self.get_nodes_number();
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)
                    .progress_with(pb)
                    .filter_map(|(_, src, dst, edge_type, weight)| {
                        if src == dst || src == nodes_number - dst {
                            Some(Ok((src, dst, edge_type, weight)))
                        } else {
                            None
                        }
                    }),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                true,
                true,
                true,
                verbose,
            )
            .unwrap()
        }
        /// Return the graph from the arrowhead adjacency matrix.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        pub fn to_arrowhead(&self, verbose: Option<bool>) -> Graph {
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Building the arrowhead matrix",
                self.get_directed_edges_number() as usize,
            );
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)
                    .progress_with(pb)
                    .filter_map(|(_, src, dst, edge_type, weight)| {
                        if src == 1 || dst == 1 || src == dst {
                            Some(Ok((src, dst, edge_type, weight)))
                        } else {
                            None
                        }
                    }),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                true,
                true,
                true,
                verbose,
            )
            .unwrap()
        }
        /// Return the graph from the transposed adjacency matrix.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        pub fn to_transposed(&self, verbose: Option<bool>) -> Graph {
            if !self.is_directed() {
                return self.clone();
            }
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Building the transposed matrix",
                self.get_directed_edges_number() as usize,
            );
            Graph::from_integer_unsorted(
                self.par_iter_edge_node_ids_and_edge_type_id_and_edge_weight(true)
                    .progress_with(pb)
                    .map(|(_, src, dst, edge_type, weight)| Ok((dst, src, edge_type, weight))),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                true,
                self.get_name(),
                true,
                self.has_edge_types(),
                self.has_edge_weights(),
                false,
                self.has_singleton_nodes(),
                self.has_singleton_nodes_with_selfloops(),
                true,
                verbose,
            )
            .unwrap()
        }
        /// Return the complementary graph.
        ///
        /// # Implementative details
        /// Note that the resulting graph may require a significant amount
        /// of memory.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        pub fn to_complementary(&self, verbose: Option<bool>) -> Graph {
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Building the complementary graph",
                self.get_nodes_number() as usize,
            );
            Graph::from_integer_unsorted(
                self.par_iter_node_ids()
                    .progress_with(pb)
                    .map(|src| {
                        self.iter_node_ids()
                            .filter_map(|dst| {
                                if self.has_edge_from_node_ids(src, dst) {
                                    None
                                } else {
                                    Some(Ok((src, dst, None, None)))
                                }
                            })
                            .collect::<Vec<_>>()
                    })
                    .flatten(),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                false,
                false,
                false,
                true,
                true,
                true,
                verbose,
            )
            .unwrap()
        }
    }
}
mod transitivity {
    use super::*;
    use indicatif::ParallelProgressIterator;
    use rayon::iter::ParallelIterator;
    /// # Transitivity.
    impl Graph {
        /// Returns graph to the i-th transitivity closure iteration.
        ///
        /// # Implementative details
        /// If the given iterations is None, it will return the complete
        /// number of transitivity.
        ///
        /// If the number of iterations given is 0, the method will return
        /// the same graph.
        ///
        /// # Arguments
        /// * `iterations`: Option<NodeT> - The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        pub fn get_transitive_closure(
            &self,
            iterations: Option<NodeT>,
            verbose: Option<bool>,
        ) -> Graph {
            if let Some(i) = iterations {
                if i == 0 {
                    return self.clone();
                }
            }
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Computing transitive closure",
                self.get_nodes_number() as usize,
            );
            Graph::from_integer_unsorted(
                self.par_iter_node_ids()
                    .progress_with(pb)
                    .filter_map(|src_node_id| unsafe {
                        if self.is_unchecked_singleton_from_node_id(src_node_id) {
                            None
                        } else {
                            Some(
                                self.get_unchecked_breath_first_search_from_node_ids(
                                    src_node_id,
                                    None,
                                    None,
                                    iterations,
                                )
                                .into_distances()
                                .into_iter()
                                .enumerate()
                                .filter(|&(_, distance)| distance != NOT_PRESENT)
                                .map(move |(dst_node_id, _)| {
                                    Ok((src_node_id, dst_node_id as NodeT, None, None))
                                })
                                .collect::<Vec<_>>(),
                            )
                        }
                    })
                    .flatten(),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                false,
                false,
                false,
                self.has_singleton_nodes(),
                self.has_singleton_nodes_with_selfloops(),
                self.has_trap_nodes() || self.has_selfloops(),
                verbose,
            )
            .unwrap()
        }
        /// Returns graph with unweighted shortest paths computed up to the given depth.
        ///
        /// The returned graph will have no selfloops.
        ///
        /// # Implementative details
        /// If the given iterations is None, it will return the complete
        /// sparse matrix of shortest paths.
        ///
        /// If the number of iterations given is 0, the method will return
        /// the same graph.
        ///
        /// # Arguments
        /// * `iterations`: Option<NodeT> - The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        pub fn get_all_shortest_paths(
            &self,
            iterations: Option<NodeT>,
            verbose: Option<bool>,
        ) -> Graph {
            if let Some(i) = iterations {
                if i == 0 {
                    return self.clone();
                }
            }
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Computing all unweighted shortest paths",
                self.get_nodes_number() as usize,
            );
            Graph::from_integer_unsorted(
                self.par_iter_node_ids()
                    .progress_with(pb)
                    .filter_map(|src_node_id| unsafe {
                        if self.is_unchecked_connected_from_node_id(src_node_id) {
                            Some(
                                self.get_unchecked_breath_first_search_from_node_ids(
                                    src_node_id,
                                    None,
                                    None,
                                    iterations,
                                )
                                .into_distances()
                                .into_iter()
                                .enumerate()
                                .filter(move |&(dst_node_id, distance)| {
                                    distance != NOT_PRESENT && src_node_id != dst_node_id as NodeT
                                })
                                .map(move |(dst_node_id, distance)| {
                                    Ok((
                                        src_node_id,
                                        dst_node_id as NodeT,
                                        None,
                                        Some(distance as WeightT),
                                    ))
                                })
                                .collect::<Vec<_>>(),
                            )
                        } else {
                            None
                        }
                    })
                    .flatten(),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                self.is_directed(),
                self.get_name(),
                true,
                false,
                true,
                false,
                self.has_singleton_nodes() || self.has_singleton_nodes_with_selfloops(),
                self.has_singleton_nodes_with_selfloops(),
                self.has_trap_nodes() || self.has_selfloops(),
                verbose,
            )
            .unwrap()
        }
        /// Returns graph with weighted shortest paths computed up to the given depth.
        ///
        /// The returned graph will have no selfloops.
        ///
        /// # Implementative details
        /// If the given iterations is None, it will return the complete
        /// sparse matrix of shortest paths.
        ///
        /// If the number of iterations given is 0, the method will return
        /// the same graph.
        ///
        /// # Arguments
        /// * `iterations`: Option<NodeT> - The number of iterations of the transitive closure to execute. If None, the complete transitive closure is computed.
        /// * `use_edge_weights_as_probabilities`: Option<bool> - Whether to treat the edge weights as probabilities.
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        /// # Raises
        /// * If the graph does not have weights.
        /// * If the graph contains negative weights.
        /// * If the user has asked for the weights to be treated as probabilities but the weights are not between 0 and 1.
        ///
        pub fn get_weighted_all_shortest_paths(
            &self,
            iterations: Option<NodeT>,
            use_edge_weights_as_probabilities: Option<bool>,
            verbose: Option<bool>,
        ) -> Result<Graph> {
            if let Some(i) = iterations {
                if i == 0 {
                    return Ok(self.clone());
                }
            }
            if let Some(uewap) = use_edge_weights_as_probabilities {
                if uewap {
                    self.must_have_edge_weights_representing_probabilities()?;
                }
            }
            self.must_have_positive_edge_weights()?;
            let verbose = verbose.unwrap_or(true);
            let pb = get_loading_bar(
                verbose,
                "Computing all unweighted shortest paths",
                self.get_nodes_number() as usize,
            );
            Graph::from_integer_unsorted(
                self.par_iter_node_ids()
                    .progress_with(pb)
                    .filter_map(|src_node_id| unsafe {
                        if self.is_unchecked_connected_from_node_id(src_node_id) {
                            Some(
                                self.get_unchecked_dijkstra_from_node_ids(
                                    src_node_id,
                                    None,
                                    None,
                                    Some(false),
                                    iterations,
                                    use_edge_weights_as_probabilities,
                                )
                                .distances
                                .into_iter()
                                .enumerate()
                                .map(|(dst_node_id, distance)| (dst_node_id, distance as WeightT))
                                .filter(move |(dst_node_id, distance)| {
                                    distance.is_finite()
                                        && src_node_id != *dst_node_id as NodeT
                                        && *distance > 0.0
                                })
                                .map(move |(dst_node_id, distance)| {
                                    Ok((src_node_id, dst_node_id as NodeT, None, Some(distance)))
                                })
                                .collect::<Vec<_>>(),
                            )
                        } else {
                            None
                        }
                    })
                    .flatten(),
                self.nodes.clone(),
                self.node_types.clone(),
                self.edge_types.as_ref().map(|ets| ets.vocabulary.clone()),
                iterations.is_some() || self.is_directed(),
                self.get_name(),
                true,
                false,
                true,
                false,
                self.has_singleton_nodes() || self.has_singleton_nodes_with_selfloops(),
                self.has_singleton_nodes_with_selfloops(),
                self.has_trap_nodes() || self.has_selfloops(),
                verbose,
            )
        }
    }
}
mod trees {
    use super::*;
    use indicatif::ProgressIterator;
    use rayon::iter::IntoParallelIterator;
    use rayon::iter::IntoParallelRefMutIterator;
    use rayon::iter::ParallelIterator;
    use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
    use std::sync::{Arc, Mutex};
    use std::{collections::HashSet, sync::atomic::AtomicU32};
    use vec_rand::xorshift::xorshift as rand_u64;
    /// # Implementation of algorithms relative to trees.
    ///
    /// # Definitions
    /// - **Self-loops**: Edges with source equal to the destination.
    /// - **Singleton**: A node with no incident edges, (self-loops are not considered).
    /// - **Spanning Tree**: A set of edges that allows to build a path between every
    ///     node in the graph. For a graph with n nodes the spanning tree will have n - 1 edges.
    /// - **Spanning Arborescence**: is the generalizzation of the spanning tree for graphs
    ///     with multiple components. Being a tree it trivially contains no self-loops.
    ///     For a grpah with n nodes and c components the spanning arborescence will have
    ///     n - c edges.
    /// - **Component**: Set of nodes in which any two vertices in it are connected to
    ///     each other by paths. A singleton is a component and so is a singleton with a
    ///     self-loop.
    impl Graph {
        /// Returns iterator over shuffled edge IDs and node IDs.
        ///
        /// # Arguments
        /// * `random_state`: u64 - The random state to reproduce the given edge sampling.
        fn iter_edges_from_random_state(
            &self,
            random_state: u64,
        ) -> impl Iterator<Item = (EdgeT, NodeT, NodeT)> + '_ {
            let edges_number = self.get_directed_edges_number();
            let updated_random_state = rand_u64(rand_u64(splitmix64(random_state)));
            (updated_random_state..edges_number + updated_random_state).filter_map(move |i| {
                let edge_id = i % edges_number;
                let (src, dst) = unsafe { self.get_unchecked_node_ids_from_edge_id(edge_id) };
                match src == dst || !self.directed && src > dst {
                    true => None,
                    false => Some((edge_id, src, dst)),
                }
            })
        }
        /// Returns iterator over shuffled edge IDs and node IDs with preference to given edge types.
        ///
        /// # Arguments
        /// * `random_state`: Option<u64> - The random state to reproduce the given edge sampling.
        /// * `undesired_edge_types`: Option<HashSet<Option<EdgeTypeT>>> - The edge types whose edges are to leave as last.
        /// * `verbose`: Option<bool> - Whether to show a loading bar.
        fn iter_on_edges_with_preference_from_random_state(
            &self,
            random_state: Option<u64>,
            undesired_edge_types: Option<HashSet<Option<EdgeTypeT>>>,
            verbose: Option<bool>,
        ) -> impl Iterator<Item = (NodeT, NodeT)> + '_ {
            let random_state = random_state.unwrap_or(0xbadf00d);
            let verbose = verbose.unwrap_or(false);
            let pb = get_loading_bar(
                verbose,
                {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Building random spanning tree for "],
                        &match (&self.name,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                .as_ref(),
                self.get_directed_edges_number() as usize,
            );
            let result: Box<dyn Iterator<Item = (NodeT, NodeT)>> =
                if let (Some(uet), _) = (undesired_edge_types, &self.edge_types) {
                    let uet_copy = uet.clone();
                    Box::new(
                        self.iter_edges_from_random_state(random_state)
                            .filter_map(move |(edge_id, src, dst)| {
                                if uet.contains(&unsafe {
                                    self.get_unchecked_edge_type_id_from_edge_id(edge_id)
                                }) {
                                    return None;
                                }
                                Some((src, dst))
                            })
                            .chain(self.iter_edges_from_random_state(random_state).filter_map(
                                move |(edge_id, src, dst)| {
                                    if !uet_copy.contains(&unsafe {
                                        self.get_unchecked_edge_type_id_from_edge_id(edge_id)
                                    }) {
                                        return None;
                                    }
                                    Some((src, dst))
                                },
                            )),
                    )
                } else {
                    Box::new(
                        self.iter_edges_from_random_state(random_state)
                            .map(|(_, src, dst)| (src, dst)),
                    )
                };
            result.progress_with(pb)
        }
        /// Returns set of edges composing a spanning tree and connected components.
        ///
        /// If the graph is composed of a single node with one or more self-loops,
        /// we consider such a graph as a graph with an empty spanning tree, with
        /// a single component of size one.
        ///
        /// # Arguments
        ///
        /// `edges`: impl Iterator<Item = (NodeT, NodeT)> + 'a - Iterator for the edges to explore. If sorted, computed a minimum spanning tree.
        ///
        /// # Returns
        /// Tuple with:
        ///     - Set of the edges
        ///     - Vector of the nodes components
        ///     - Total components number
        ///     - Minimum component size
        ///     - Maximum component size
        pub(crate) fn kruskal<'a>(
            &self,
            edges: impl Iterator<Item = (NodeT, NodeT)> + 'a,
        ) -> (HashSet<(NodeT, NodeT)>, Vec<NodeT>, NodeT, NodeT, NodeT) {
            if !self.has_nodes() {
                return (HashSet::new(), Vec::new(), 0, 0, 0);
            }
            if !self.has_edges() {
                return (
                    HashSet::new(),
                    self.get_node_ids(),
                    self.get_nodes_number(),
                    1,
                    1,
                );
            }
            let nodes_number = self.get_nodes_number() as usize;
            let mut tree = HashSet::with_capacity(self.get_nodes_number() as usize);
            let mut components = ::alloc::vec::from_elem(NOT_PRESENT, nodes_number);
            let mut component_sizes: Vec<NodeT> = Vec::new();
            let mut components_remapping: Vec<NodeT> = Vec::new();
            let mut max_component_size: NodeT = 0;
            let mut min_component_size = NodeT::MAX;
            if self.has_disconnected_nodes() {
                min_component_size = 1;
                max_component_size = 1;
                self.iter_singleton_node_ids()
                    .chain(self.iter_singleton_nodes_with_selfloops_node_ids())
                    .enumerate()
                    .for_each(|(component_number, node_id)| {
                        components[node_id as usize] = component_number as NodeT;
                    });
                component_sizes =
                    ::alloc::vec::from_elem(1, self.get_disconnected_nodes_number() as usize);
                components_remapping =
                    (0..self.get_disconnected_nodes_number()).collect::<Vec<NodeT>>();
            }
            edges.for_each(|(src, dst)| {
                if src == dst {
                    return;
                }
                let src_component = components[src as usize];
                let dst_component = components[dst as usize];
                match (src_component == NOT_PRESENT, dst_component == NOT_PRESENT) {
                    (true, true) => {
                        let new_component_id = components_remapping.len() as NodeT;
                        components[src as usize] = new_component_id;
                        components[dst as usize] = new_component_id;
                        components_remapping.push(new_component_id);
                        component_sizes.push(2);
                        max_component_size = max_component_size.max(2);
                    }
                    (false, false) => {
                        if src_component == dst_component {
                            return;
                        }
                        let src_component = components_remapping[src_component as usize];
                        let dst_component = components_remapping[dst_component as usize];
                        if src_component == dst_component {
                            return;
                        }
                        let min_component_id = src_component.min(dst_component);
                        let max_component_id = src_component.max(dst_component);
                        component_sizes[min_component_id as usize] +=
                            component_sizes[max_component_id as usize];
                        max_component_size =
                            max_component_size.max(component_sizes[min_component_id as usize]);
                        components_remapping
                            .iter_mut()
                            .zip(component_sizes.iter_mut())
                            .for_each(|(component_id, component_size)| {
                                if *component_id == max_component_id {
                                    *component_id = min_component_id;
                                    *component_size = 0;
                                }
                            });
                    }
                    _ => {
                        let (component_id, not_inserted_node) = match src_component == NOT_PRESENT {
                            true => (components_remapping[dst_component as usize], src),
                            false => (components_remapping[src_component as usize], dst),
                        };
                        component_sizes[component_id as usize] += 1;
                        max_component_size =
                            max_component_size.max(component_sizes[component_id as usize]);
                        components[not_inserted_node as usize] = component_id as NodeT;
                    }
                };
                tree.insert((src, dst));
            });
            let mut components_number = 0;
            for i in 0..components_remapping.len() {
                if components_remapping[i] >= components_number {
                    components_remapping[i] = components_number;
                    components_number += 1;
                } else {
                    components_remapping[i] =
                        components_remapping[components_remapping[i] as usize];
                }
            }
            components.par_iter_mut().for_each(|remapped| {
                *remapped = components_remapping[*remapped as usize];
            });
            if min_component_size > 1 {
                min_component_size = match components_number {
                    1 => max_component_size,
                    2 => self.get_nodes_number() - max_component_size,
                    _ => component_sizes
                        .into_par_iter()
                        .filter(|val| *val > 0)
                        .min()
                        .unwrap(),
                };
            }
            (
                tree,
                components,
                components_number as NodeT,
                min_component_size,
                max_component_size,
            )
        }
        /// Returns set of edges composing a spanning tree and connected components.
        ///
        /// The spanning tree is NOT minimal.
        /// The given random_state is NOT the root of the tree.
        ///
        /// This method, additionally, allows for undesired edge types to be
        /// used to build the spanning tree only in extremis when it is utterly
        /// necessary in order to complete the spanning arborescence.
        ///
        /// The quintuple returned contains:
        /// - Set of the edges used in order to build the spanning arborescence.
        /// - Vector of the connected component of each node.
        /// - Number of connected components.
        /// - Minimum component size.
        /// - Maximum component size.
        ///
        /// # Arguments
        ///
        /// * `random_state`: Option<EdgeT> - The random_state to use for the holdout,
        /// * `undesired_edge_types`: &Option<HashSet<Option<EdgeTypeT>>> - Which edge types id to try to avoid.
        /// * `verbose`: Option<bool> - Whether to show a loading bar or not.
        ///
        /// # Example
        /// To compute a random spanning arborescence using Kruskal you can use the following:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let (
        ///     spanning_arborescence_set,
        ///     connected_components_number,
        ///     number_of_connected_components,
        ///     minimum_component_size,
        ///     maximum_component_size
        /// ) = graph.random_spanning_arborescence_kruskal(
        ///     Some(42),
        ///     None,
        ///     Some(false)
        /// );
        /// assert_eq!(connected_components_number.len(), graph.get_nodes_number() as usize);
        /// assert!(minimum_component_size <= maximum_component_size);
        /// assert!(maximum_component_size <= graph.get_nodes_number());
        /// ```
        pub fn random_spanning_arborescence_kruskal(
            &self,
            random_state: Option<EdgeT>,
            undesired_edge_types: Option<HashSet<Option<EdgeTypeT>>>,
            verbose: Option<bool>,
        ) -> (HashSet<(NodeT, NodeT)>, Vec<NodeT>, NodeT, NodeT, NodeT) {
            self.kruskal(self.iter_on_edges_with_preference_from_random_state(
                random_state,
                undesired_edge_types,
                verbose,
            ))
        }
        /// Returns consistent spanning arborescence using Kruskal.
        ///
        /// The spanning tree is NOT minimal.
        ///
        /// The quintuple returned contains:
        /// - Set of the edges used in order to build the spanning arborescence.
        /// - Vector of the connected component of each node.
        /// - Number of connected components.
        /// - Minimum component size.
        /// - Maximum component size.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar or not.
        ///
        /// # Example
        /// To compute a spanning arborescence using Kruskal you can use the following:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let (
        ///     spanning_arborescence_set,
        ///     connected_components_number,
        ///     number_of_connected_components,
        ///     minimum_component_size,
        ///     maximum_component_size
        /// ) = graph.spanning_arborescence_kruskal(None);
        /// assert_eq!(connected_components_number.len(), graph.get_nodes_number() as usize);
        /// assert!(minimum_component_size <= maximum_component_size);
        /// assert!(maximum_component_size <= graph.get_nodes_number());
        /// ```
        pub fn spanning_arborescence_kruskal(
            &self,
            verbose: Option<bool>,
        ) -> (HashSet<(NodeT, NodeT)>, Vec<NodeT>, NodeT, NodeT, NodeT) {
            let verbose = verbose.unwrap_or(false);
            let pb = get_loading_bar(
                verbose,
                &{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Computing spanning arborescence with Kruskal for "],
                        &match (&self.get_name(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                },
                self.get_unique_edges_number() as usize,
            );
            self.kruskal(
                self.iter_unique_edge_node_ids(self.directed)
                    .progress_with(pb),
            )
        }
        /// Returns set of edges composing a spanning arborescence.
        ///
        /// This is the implementaiton of [A Fast, Parallel Spanning Tree Algorithm for Symmetric Multiprocessors (SMPs)](https://smartech.gatech.edu/bitstream/handle/1853/14355/GT-CSE-06-01.pdf)
        /// by David A. Bader and Guojing Cong.
        ///
        /// The returned tuple contains:
        /// - The number edges required in order to build the spanning arborescence.
        /// - Iterator over the edges used in order to build the spanning arborescence.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar or not.
        ///
        /// # Raises
        /// * If the system configuration does not allow for the creation of the thread pool.
        pub fn spanning_arborescence(
            &self,
            verbose: Option<bool>,
        ) -> Result<(usize, impl Iterator<Item = (NodeT, NodeT)> + '_)> {
            self.must_be_undirected()?;
            let verbose = verbose.unwrap_or(false);
            let nodes_number = self.get_nodes_number() as usize;
            let mut parents = ::alloc::vec::from_elem(NOT_PRESENT, nodes_number);
            let (cpu_number, pool) = get_thread_pool()?;
            let shared_stacks: Arc<Vec<Mutex<Vec<NodeT>>>> = Arc::from(
                (0..std::cmp::max(cpu_number - 1, 1))
                    .map(|_| Mutex::from(Vec::new()))
                    .collect::<Vec<Mutex<Vec<NodeT>>>>(),
            );
            let active_nodes_number = AtomicUsize::new(0);
            let completed = AtomicBool::new(false);
            let total_inserted_edges = AtomicUsize::new(0);
            let thread_safe_parents = ThreadDataRaceAware {
                value: std::cell::UnsafeCell::new(&mut parents),
            };
            pool . scope (| s | { s . spawn (| _ | { let pb = get_loading_bar (verbose , { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Computing spanning tree of graph "] , & match (& self . get_name () ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } . as_ref () , nodes_number) ; let parents = thread_safe_parents . value . get () ; (0 .. nodes_number) . progress_with (pb) . for_each (| src | unsafe { if (* parents) [src] != NOT_PRESENT { return ; } if self . is_unchecked_singleton_from_node_id (src as NodeT) { (* parents) [src] = src as NodeT ; return ; } loop { if (* parents) [src] != NOT_PRESENT { break ; } if active_nodes_number . load (Ordering :: SeqCst) == 0 { if (* parents) [src] != NOT_PRESENT { break ; } (* parents) [src] = src as NodeT ; shared_stacks [0] . lock () . expect ("The lock is poisoned from the panic of another thread") . push (src as NodeT) ; active_nodes_number . fetch_add (1 , Ordering :: SeqCst) ; break ; } } }) ; completed . store (true , Ordering :: SeqCst) ; }) ; (0 .. shared_stacks . len ()) . for_each (| _ | { s . spawn (| _ | 'outer : loop { let thread_id = rayon :: current_thread_index () . expect ("current_thread_id not called from a rayon thread. This should not be possible because this is in a Rayon Thread Pool.") ; let src = 'inner : loop { { for mut stack in (thread_id .. (shared_stacks . len () + thread_id)) . map (| id | shared_stacks [id % shared_stacks . len ()] . lock () . expect ("The lock is poisoned from the panic of another thread")) { if let Some (src) = stack . pop () { break 'inner src ; } } if completed . load (Ordering :: SeqCst) { break 'outer ; } } } ; let parents = thread_safe_parents . value . get () ; unsafe { self . iter_unchecked_neighbour_node_ids_from_source_node_id (src) } . for_each (| dst | unsafe { if (* parents) [dst as usize] == NOT_PRESENT { (* parents) [dst as usize] = src ; total_inserted_edges . fetch_add (1 , Ordering :: SeqCst) ; active_nodes_number . fetch_add (1 , Ordering :: SeqCst) ; shared_stacks [rand_u64 (dst as u64) as usize % shared_stacks . len ()] . lock () . expect ("The lock is poisoned from the panic of another thread") . push (dst) ; } }) ; active_nodes_number . fetch_sub (1 , Ordering :: SeqCst) ; }) ; }) ; }) ;
            Ok((
                total_inserted_edges.load(Ordering::SeqCst),
                parents.into_iter().enumerate().filter_map(|(src, dst)| {
                    if src as NodeT == dst {
                        return None;
                    }
                    Some((src as NodeT, dst))
                }),
            ))
        }
        /// Compute the connected components building in parallel a spanning tree using [bader's algorithm](https://www.sciencedirect.com/science/article/abs/pii/S0743731505000882).
        ///
        /// **This works only for undirected graphs.**
        ///
        /// This method is **not thread save and not deterministic** but by design of the algorithm this
        /// shouldn't matter but if we will encounter non-detemristic bugs here is where we want to look.
        ///
        /// The returned quadruple contains:
        /// - Vector of the connected component for each node.
        /// - Number of connected components.
        /// - Minimum connected component size.
        /// - Maximum connected component size.
        ///
        /// # Arguments
        ///
        /// * `verbose`: Option<bool> - Whether to show a loading bar or not.
        ///
        /// # Example
        /// ```rust
        ///  # #![feature(impl_trait_in_bindings)]
        ///  # use graph::Graph;
        ///  // Graph is a weightless graph with the edges
        ///  // [(0, 1), (1, 4), (2, 3)]
        ///  # let edge: Vec<Result<(String, String, Option<String>, Option<f32>), String>> = vec![
        ///  #        Ok(("0".to_string(), "1".to_string(), None, None)),
        ///  #        Ok(("1".to_string(), "4".to_string(), None, None)),
        ///  #        Ok(("2".to_string(), "3".to_string(), None, None)),
        ///  #     ];
        ///  #
        ///  # let nodes = None.map(|x: Vec<Result<(String, Option<Vec<String>>), String>>| x.into_iter());
        ///  #
        ///  # let graph = Graph::from_string_unsorted(
        ///  #     edge.into_iter(),
        ///  #     nodes,      // nodes
        ///  #     false,     // directed
        ///  #     false,      // directe edge list
        ///  #     "test graph",// name
        ///  #     false,     // ignore_duplicated_nodes
        ///  #     true,     // node_list_is_correct
        ///  #     false,     // ignore_duplicated_nodes
        ///  #     true,     // node_list_is_correct
        ///  #     false,     // numeric_edge_types_ids
        ///  #     false,     // numeric_node_ids
        ///  #     false,     // numeric_edge_node_ids
        ///  #     false,     // numeric_node_types_ids
        ///  #     false,     // has_node_types
        ///  #     false,     // has_edge_types
        ///  #     false,     // has_edge_weights
        ///  #     false,    // maybe_contains_invalid_weights
        ///  #     true,    // maybe_has_singleton
        ///  #     true,    // maybe_has_singleton_with_selfloops
        ///  #     true,    // maybe_has_node_traps
        ///  #     false,     // verbose
        ///  # ).unwrap();
        /// let (components, number_of_components, smallest, biggest) =
        ///     graph.connected_components(None).unwrap();
        ///
        /// //   nodes names:       0  1  4  2  3
        /// assert_eq!(components, [0, 0, 0, 1, 1].to_vec());
        ///
        /// assert_eq!(number_of_components, 2);
        /// assert_eq!(smallest, 2); // the size of the smallest component
        /// assert_eq!(biggest, 3);  // the size of the biggest component
        /// ```
        ///
        /// # Raises
        /// * If the given graph is directed.
        /// * If the system configuration does not allow for the creation of the thread pool.
        pub fn connected_components(
            &self,
            verbose: Option<bool>,
        ) -> Result<(Vec<NodeT>, NodeT, NodeT, NodeT)> {
            self.must_be_undirected()?;
            if !self.has_nodes() {
                return Ok((Vec::new(), 0, 0, 0));
            }
            if self.get_edges_number() == 0 {
                return Ok((
                    self.iter_node_ids().collect(),
                    self.get_nodes_number(),
                    1,
                    1,
                ));
            }
            let verbose = verbose.unwrap_or(false);
            let components = self
                .iter_node_ids()
                .map(|_| AtomicU32::new(NOT_PRESENT))
                .collect::<Vec<_>>();
            let mut min_component_size: NodeT = NodeT::MAX;
            let mut max_component_size: NodeT = 0;
            let mut components_number: NodeT = 0;
            let (cpu_number, pool) = get_thread_pool()?;
            let shared_stacks: Arc<Vec<Mutex<Vec<NodeT>>>> = Arc::from(
                (0..std::cmp::max(cpu_number - 1, 1))
                    .map(|_| Mutex::from(Vec::new()))
                    .collect::<Vec<Mutex<Vec<NodeT>>>>(),
            );
            let active_nodes_number = AtomicUsize::new(0);
            let current_component_size = AtomicU32::new(0);
            let completed = AtomicBool::new(false);
            let thread_safe_min_component_size = ThreadDataRaceAware {
                value: std::cell::UnsafeCell::new(&mut min_component_size),
            };
            let thread_safe_max_component_size = ThreadDataRaceAware {
                value: std::cell::UnsafeCell::new(&mut max_component_size),
            };
            let thread_safe_components_number = ThreadDataRaceAware {
                value: std::cell::UnsafeCell::new(&mut components_number),
            };
            pool . scope (| s | { s . spawn (| _ | { let pb = get_loading_bar (verbose , { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["Computing connected components of graph "] , & match (& self . get_name () ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } . as_ref () , self . get_nodes_number () as usize) ; let min_component_size = thread_safe_min_component_size . value . get () ; let max_component_size = thread_safe_max_component_size . value . get () ; let components_number = thread_safe_components_number . value . get () ; self . iter_node_ids () . progress_with (pb) . for_each (| src | { if components [src as usize] . load (Ordering :: Relaxed) != NOT_PRESENT { return ; } if self . has_disconnected_nodes () && (unsafe { self . is_unchecked_singleton_from_node_id (src) } || self . is_singleton_with_selfloops_from_node_id (src)) { unsafe { components [src as usize] . store (* * components_number , Ordering :: Relaxed) ; * * components_number += 1 ; * * min_component_size = 1 ; * * max_component_size = (* * max_component_size) . max (1) ; } return ; } loop { if components [src as usize] . load (Ordering :: Relaxed) != NOT_PRESENT { break ; } if active_nodes_number . load (Ordering :: Relaxed) == 0 { if components [src as usize] . load (Ordering :: Relaxed) != NOT_PRESENT { break ; } let ccs = current_component_size . swap (1 , Ordering :: Relaxed) as NodeT ; unsafe { * * max_component_size = (* * max_component_size) . max (ccs) ; if ccs > 1 { * * min_component_size = (* * min_component_size) . min (ccs) ; } components [src as usize] . store (* * components_number , Ordering :: Relaxed) ; * * components_number += 1 ; } active_nodes_number . fetch_add (1 , Ordering :: Relaxed) ; shared_stacks [0] . lock () . expect ("The lock is poisoned from the panic of another thread") . push (src) ; break ; } } }) ; completed . store (true , Ordering :: Relaxed) ; }) ; (0 .. shared_stacks . len ()) . for_each (| _ | { s . spawn (| _ | 'outer : loop { let thread_id = rayon :: current_thread_index () . expect ("current_thread_id not called from a rayon thread. This should not be possible because this is in a Rayon Thread Pool.") ; let src = 'inner : loop { { for mut stack in (thread_id .. (shared_stacks . len () + thread_id)) . map (| id | shared_stacks [id % shared_stacks . len ()] . lock () . expect ("The lock is poisoned from the panic of another thread")) { if let Some (src) = stack . pop () { break 'inner src ; } } if completed . load (Ordering :: Relaxed) { break 'outer ; } } } ; let src_component = components [src as usize] . load (Ordering :: Relaxed) ; unsafe { self . iter_unchecked_neighbour_node_ids_from_source_node_id (src) } . for_each (| dst | { if components [dst as usize] . swap (src_component , Ordering :: SeqCst) == NOT_PRESENT { active_nodes_number . fetch_add (1 , Ordering :: SeqCst) ; current_component_size . fetch_add (1 , Ordering :: SeqCst) ; shared_stacks [rand_u64 (dst as u64) as usize % shared_stacks . len ()] . lock () . expect ("The lock is poisoned from the panic of another thread") . push (dst) ; } }) ; active_nodes_number . fetch_sub (1 , Ordering :: SeqCst) ; }) ; }) ; }) ;
            let ccs = current_component_size.load(Ordering::SeqCst);
            max_component_size = max_component_size.max(ccs);
            if ccs > 1 {
                min_component_size = min_component_size.min(ccs);
            }
            Ok((
                unsafe { std::mem::transmute::<Vec<AtomicU32>, Vec<NodeT>>(components) },
                components_number,
                min_component_size,
                max_component_size,
            ))
        }
    }
}
mod types {
    use std::fmt::Display;
    use std::hash::Hash;
    use std::ops::{Add, Sub, AddAssign};
    /// Type used to index the Nodes.
    pub type NodeT = u32;
    /// Type used to index the Node Types.
    pub type NodeTypeT = u16;
    /// Type used to index the Edges.
    pub type EdgeT = u64;
    /// Type used to index the Edge Types.
    pub type EdgeTypeT = u16;
    /// Type used for the weights of the edges.
    pub type WeightT = f32;
    /// Type used for the parameters of the walk such as the return weight (p),
    /// and the explore weight (q).
    pub type ParamsT = WeightT;
    /// Type used to save contexts used for Skipgram and CBOW.
    pub type Contexts = Vec<Vec<NodeT>>;
    /// Type used to save a group of words indices.
    pub type Words = Vec<NodeT>;
    /// Type used to save the frequencies of words
    pub type Frequencies = Vec<f64>;
    /// Triple of edge data
    pub type Triple = (NodeT, NodeT, Option<EdgeTypeT>);
    /// Quadruple of edge data
    pub type Quadruple = (NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>);
    /// Quadrule of string edge data
    pub type StringQuadruple = (String, String, Option<String>, Option<WeightT>);
    /// Symbol reserved to unmapped nodes for algoritms such as connected components.
    pub const NOT_PRESENT: NodeT = NodeT::MAX;
    pub type Result<T> = std::result::Result<T, String>;
    /// Trait used for the Vocabulary class.
    /// It represent an unsigned integer that can be converted to and from usize.
    /// This allows us to save memory using indicies of smaller size than u64
    /// and it has no effects on performance because it's optimized away during
    /// compilaton.
    pub trait ToFromUsize:
        Clone + Display + Ord + Copy + AddAssign + Add + Sub<Output = Self> + Hash
    {
        /// create the type from a usize
        fn from_usize(v: usize) -> Self;
        /// create an usize from the type
        fn to_usize(v: Self) -> usize;
    }
    impl ToFromUsize for u8 {
        #[inline(always)]
        fn from_usize(v: usize) -> u8 {
            v as u8
        }
        #[inline(always)]
        fn to_usize(v: u8) -> usize {
            v as usize
        }
    }
    impl ToFromUsize for u16 {
        #[inline(always)]
        fn from_usize(v: usize) -> u16 {
            v as u16
        }
        #[inline(always)]
        fn to_usize(v: u16) -> usize {
            v as usize
        }
    }
    impl ToFromUsize for u32 {
        #[inline(always)]
        fn from_usize(v: usize) -> u32 {
            v as u32
        }
        #[inline(always)]
        fn to_usize(v: u32) -> usize {
            v as usize
        }
    }
    impl ToFromUsize for u64 {
        #[inline(always)]
        fn from_usize(v: usize) -> u64 {
            v as u64
        }
        #[inline(always)]
        fn to_usize(v: u64) -> usize {
            v as usize
        }
    }
    impl ToFromUsize for usize {
        #[inline(always)]
        fn from_usize(v: usize) -> usize {
            v as usize
        }
        #[inline(always)]
        fn to_usize(v: usize) -> usize {
            v as usize
        }
    }
    use std::cell::UnsafeCell;
    pub(crate) struct ThreadDataRaceAware<T> {
        pub(crate) value: UnsafeCell<T>,
    }
    unsafe impl<T> Sync for ThreadDataRaceAware<T> {}
}
mod sort {
    use super::*;
    use permutation::permutation;
    /// # Sorting algorithms.
    impl Graph {
        /// Returns graph with node IDs sorted by increasing outbound node degree.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        pub fn sort_by_increasing_outbound_node_degree(&self, verbose: Option<bool>) -> Graph {
            if self.has_nodes_sorted_by_increasing_outbound_node_degree() {
                return self.clone();
            }
            let sorted_node_ids_permutation = permutation::sort(self.get_node_degrees());
            let new_sorted_node_ids = sorted_node_ids_permutation
                .apply_slice(self.iter_node_ids().collect::<Vec<NodeT>>());
            unsafe { self.remap_unchecked_from_node_ids(new_sorted_node_ids, verbose) }
        }
        /// Returns graph with node IDs sorted by decreasing outbound node degree.
        ///
        /// # Arguments
        /// * `verbose`: Option<bool> - Whether to show a loading bar while building the graph.
        ///
        pub fn sort_by_decreasing_outbound_node_degree(&self, verbose: Option<bool>) -> Graph {
            if self.has_nodes_sorted_by_decreasing_outbound_node_degree() {
                return self.clone();
            }
            let sorted_node_ids_permutation =
                permutation::sort_by(self.get_node_degrees(), |a, b| b.cmp(a));
            let new_sorted_node_ids = sorted_node_ids_permutation
                .apply_slice(self.iter_node_ids().collect::<Vec<NodeT>>());
            unsafe { self.remap_unchecked_from_node_ids(new_sorted_node_ids, verbose) }
        }
    }
}
mod vertex_cover {
    use super::*;
    use rayon::iter::ParallelIterator;
    use std::collections::HashSet;
    impl Graph {
        /// Returns 2-approximated verted cover bitvec using greedy algorithm.
        ///
        /// # Implementative details
        /// We DO NOT provide a loading bar for this method because the loading bar
        /// iterative step is slower than the actual iteration.
        ///
        /// # References
        /// This implementation is described in ["A local-ratio theorem for approximating the weighted vertex cover problem"](http://www.cs.technion.ac.il/~reuven/PDF/vc_lr.pdf).
        ///
        pub fn par_iter_approximated_vertex_cover(
            &self,
        ) -> impl ParallelIterator<Item = NodeT> + '_ {
            let nodes_number = self.get_nodes_number() as usize;
            let thread_shared_vertex_cover = ThreadDataRaceAware {
                value: std::cell::UnsafeCell::new(::alloc::vec::from_elem(false, nodes_number)),
            };
            self.par_iter_node_ids()
                .filter_map(move |src_node_id| unsafe {
                    if self.is_unchecked_singleton_from_node_id(src_node_id) {
                        return None;
                    }
                    let vertex_cover = thread_shared_vertex_cover.value.get();
                    if self
                        .iter_unchecked_neighbour_node_ids_from_source_node_id(src_node_id)
                        .any(|dst_node_id| !(*vertex_cover)[dst_node_id as usize])
                    {
                        *(*vertex_cover).get_unchecked_mut(src_node_id as usize) = true;
                        Some(src_node_id)
                    } else {
                        None
                    }
                })
        }
        /// Returns 2-approximated verted cover set using greedy algorithm.
        ///
        /// # Implementative details
        /// We DO NOT provide a loading bar for this method because the loading bar
        /// iterative step is slower than the actual iteration.
        ///
        /// # References
        /// This implementation is described in ["A local-ratio theorem for approximating the weighted vertex cover problem"](http://www.cs.technion.ac.il/~reuven/PDF/vc_lr.pdf).
        pub fn approximated_vertex_cover_set(&self) -> HashSet<NodeT> {
            self.par_iter_approximated_vertex_cover().collect()
        }
    }
}
mod walks {
    use super::*;
    use log::info;
    use rayon::prelude::*;
    use vec_rand::sample_f32 as sample;
    use vec_rand::sample_uniform;
    use vec_rand::splitmix64;
    #[inline(always)]
    fn update_return_weight_transition(
        transition: &mut Vec<WeightT>,
        destinations: &[NodeT],
        src: NodeT,
        dst: NodeT,
        return_weight: ParamsT,
        has_selfloop: bool,
    ) {
        if let Ok(mut i) = destinations.binary_search(&src) {
            let mut j = i;
            while j > 0 && destinations[j] == src {
                transition[j] *= return_weight;
                j -= 1;
            }
            i += 1;
            while i < destinations.len() && destinations[i] == src {
                transition[i] *= return_weight;
                i += 1;
            }
        }
        if src != dst && has_selfloop {
            if let Ok(mut i) = destinations.binary_search(&dst) {
                let mut j = i;
                while j > 0 && destinations[j] == dst {
                    transition[j] *= return_weight;
                    j -= 1;
                }
                i += 1;
                while i < destinations.len() && destinations[i] == dst {
                    transition[i] *= return_weight;
                    i += 1;
                }
            }
        }
    }
    #[inline(always)]
    fn rust_update_explore_weight_transition(
        transition: &mut Vec<WeightT>,
        destinations: &[NodeT],
        previous_destinations: &[NodeT],
        explore_weight: ParamsT,
        src: NodeT,
        dst: NodeT,
    ) {
        let mut i = 0;
        let mut j = 0;
        let mut v1: NodeT;
        let mut v2: NodeT;
        while i < destinations.len() && j < previous_destinations.len() {
            v1 = destinations[i];
            v2 = previous_destinations[j];
            if v1 <= v2 {
                let is_less = v1 < v2;
                if is_less && v1 != src && v1 != dst {
                    transition[i] *= explore_weight;
                }
                j += !is_less as usize;
                i += 1;
            } else {
                j += 1;
            }
        }
        for k in i..destinations.len() {
            v1 = destinations[k];
            transition[k] *=
                1.0 + (v1 != src && v1 != dst) as u64 as WeightT * (explore_weight - 1.0);
        }
    }
    #[inline(always)]
    fn rust_update_return_explore_weight_transition(
        transition: &mut Vec<WeightT>,
        destinations: &[NodeT],
        previous_destinations: &[NodeT],
        return_weight: ParamsT,
        explore_weight: ParamsT,
        src: NodeT,
        dst: NodeT,
    ) {
        let mut i = 0;
        let mut j = 0;
        let mut v1: NodeT;
        let mut v2: NodeT;
        while i < destinations.len() && j < previous_destinations.len() {
            v1 = destinations[i];
            v2 = previous_destinations[j];
            if v1 == src || v1 == dst {
                transition[i] *= return_weight;
                i += 1;
                continue;
            }
            if v1 <= v2 {
                let is_less = v1 < v2;
                if is_less {
                    transition[i] *= explore_weight;
                }
                j += !is_less as usize;
                i += 1;
            } else {
                j += 1;
            }
        }
        for k in i..destinations.len() {
            v1 = destinations[k];
            if v1 == src || v1 == dst {
                transition[k] *= return_weight;
            } else {
                transition[k] *= explore_weight;
            }
        }
    }
    extern "C" {
        fn c_update_explore_weight_transition(
            transition: *const f32,
            destinations: *const u32,
            destinations_len: u32,
            previous_destinations: *const u32,
            previous_destinations_len: u32,
            explore_weight: f32,
            src: u32,
            dst: u32,
        );
        fn c_update_return_explore_weight_transition(
            transition: *const f32,
            destinations: *const u32,
            destinations_len: u32,
            previous_destinations: *const u32,
            previous_destinations_len: u32,
            explore_weight: f32,
            return_weight: f32,
            src: u32,
            dst: u32,
        );
    }
    fn update_explore_weight_transition(
        transition: &mut Vec<WeightT>,
        destinations: &[NodeT],
        previous_destinations: &[NodeT],
        explore_weight: ParamsT,
        src: NodeT,
        dst: NodeT,
    ) {
        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
        {
            if false || ::std_detect::detect::__is_feature_detected::avx2() {
                unsafe {
                    c_update_explore_weight_transition(
                        transition.as_ptr(),
                        destinations.as_ptr(),
                        destinations.len() as u32,
                        previous_destinations.as_ptr(),
                        previous_destinations.len() as u32,
                        explore_weight,
                        src,
                        dst,
                    );
                }
                return;
            }
        }
        rust_update_explore_weight_transition(
            transition,
            destinations,
            previous_destinations,
            explore_weight,
            src,
            dst,
        );
    }
    fn update_return_explore_weight_transition(
        transition: &mut Vec<WeightT>,
        destinations: &[NodeT],
        previous_destinations: &[NodeT],
        return_weight: ParamsT,
        explore_weight: ParamsT,
        src: NodeT,
        dst: NodeT,
    ) {
        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
        {
            if false || ::std_detect::detect::__is_feature_detected::avx2() {
                unsafe {
                    c_update_return_explore_weight_transition(
                        transition.as_ptr(),
                        destinations.as_ptr(),
                        destinations.len() as u32,
                        previous_destinations.as_ptr(),
                        previous_destinations.len() as u32,
                        explore_weight,
                        return_weight,
                        src,
                        dst,
                    );
                }
                return;
            }
        }
        rust_update_return_explore_weight_transition(
            transition,
            destinations,
            previous_destinations,
            return_weight,
            explore_weight,
            src,
            dst,
        );
    }
    impl Graph {
        /// Return the base weighted transitions.
        ///
        /// # Arguments
        /// * `min_edge_id`: EdgeT - The minimum edge id.
        /// * `max_edge_id`: EdgeT - The maximum edge id.
        /// * `probabilistic_indices`: &Option<Vec<u64>> - Optional list of the indices used to subsample.
        ///
        /// # Safety
        /// Calling this method with either edge ID ranges that do not exist in this
        /// graph or calling this method on a graph without edge weights will cause
        /// this method to panic.
        pub(crate) unsafe fn get_edge_weighted_transitions(
            &self,
            min_edge_id: EdgeT,
            max_edge_id: EdgeT,
            probabilistic_indices: &Option<Vec<u64>>,
        ) -> Vec<WeightT> {
            match &probabilistic_indices {
                Some(indices) => match &self.weights {
                    Some(ws) => indices
                        .iter()
                        .map(|edge_id| ws[*edge_id as usize])
                        .collect(),
                    None => ::alloc::vec::from_elem(1.0, indices.len()),
                },
                None => match &self.weights {
                    Some(ws) => ws[(min_edge_id as usize)..(max_edge_id as usize)].to_vec(),
                    None => ::alloc::vec::from_elem(1.0, (max_edge_id - min_edge_id) as usize),
                },
            }
        }
        /// Updates the the transitions probability score for the change of the node type.
        ///
        /// Specifically, we multiply the transition score by the given `change_node_type_weight`
        /// when the node type changes.
        ///
        /// # Arguments
        ///
        /// * `node`: NodeT - Source node.
        /// * `transition`: &mut Vec<WeightT> - Vector of transitions to update.
        /// * `destinations`: impl Iterator<Item = NodeT> - Iterator of the destinations.
        /// * `change_node_type_weight`: ParamsT - The weight to multiply the transition by if there is a change of node type.
        ///
        /// # Safety
        /// If a non-existing node ID is provided, this method may cause an out of bound.
        unsafe fn update_node_transition(
            &self,
            node: NodeT,
            transition: &mut Vec<WeightT>,
            destinations: impl Iterator<Item = NodeT>,
            change_node_type_weight: ParamsT,
        ) {
            if not_one(change_node_type_weight) {
                if let Some(nt) = &self.node_types {
                    transition
                        .iter_mut()
                        .zip(destinations)
                        .for_each(|(transition_value, dst)| {
                            if nt.ids[node as usize] != nt.ids[dst as usize] {
                                *transition_value *= change_node_type_weight
                            }
                        });
                }
            }
        }
        /// Return the node transition weights and the related node and edges.
        ///
        /// # Arguments
        ///
        /// * `node`: NodeT, the previous node from which to compute the transitions, if this is bigger that the number of nodes it will panic.
        /// * `walk_weights`: WalkWeights, the weights for the weighted random walks.
        ///
        /// # Safety
        /// If a non-existing node ID is provided, this method may cause an out of bound.
        unsafe fn get_node_transition(
            &self,
            node: NodeT,
            walk_weights: &WalkWeights,
            min_edge_id: EdgeT,
            max_edge_id: EdgeT,
            destinations: &[NodeT],
            probabilistic_indices: &Option<Vec<u64>>,
        ) -> Vec<WeightT> {
            let mut transition =
                self.get_edge_weighted_transitions(min_edge_id, max_edge_id, probabilistic_indices);
            self.update_node_transition(
                node,
                &mut transition,
                destinations.iter().cloned(),
                walk_weights.change_node_type_weight,
            );
            transition
        }
        /// Return the edge transition weights and the related node and edges.
        ///
        /// # Arguments
        ///
        /// * `edge`: EdgeT - the previous edge from which to compute the transitions.
        /// * `weights`: WalkWeights - Weights to use for the weighted walk.
        ///
        /// # Safety
        /// If a non-existing node ID is provided, this method may cause an out of bound.
        unsafe fn get_edge_transition(
            &self,
            src: NodeT,
            dst: NodeT,
            edge_id: EdgeT,
            walk_weights: &WalkWeights,
            min_edge_id: EdgeT,
            max_edge_id: EdgeT,
            destinations: &[NodeT],
            previous_destinations: &[NodeT],
            probabilistic_indices: &Option<Vec<u64>>,
            has_selfloop: bool,
        ) -> (Vec<WeightT>, EdgeT) {
            let mut transition =
                self.get_edge_weighted_transitions(min_edge_id, max_edge_id, probabilistic_indices);
            self.update_node_transition(
                dst,
                &mut transition,
                destinations.iter().cloned(),
                walk_weights.change_node_type_weight,
            );
            if not_one(walk_weights.change_edge_type_weight) {
                if let Some(ets) = &self.edge_types {
                    let this_type: Option<EdgeTypeT> = ets.ids[edge_id as usize];
                    transition
                        .iter_mut()
                        .zip(min_edge_id..max_edge_id)
                        .for_each(|(transition_value, edge_id)| {
                            if this_type == ets.ids[edge_id as usize] {
                                *transition_value /= walk_weights.change_edge_type_weight
                            }
                        });
                }
            }
            match (
                not_one(walk_weights.return_weight),
                not_one(walk_weights.explore_weight),
            ) {
                (false, false) => {}
                (false, true) => {
                    update_explore_weight_transition(
                        &mut transition,
                        destinations,
                        previous_destinations,
                        walk_weights.explore_weight,
                        src,
                        dst,
                    );
                }
                (true, false) => {
                    update_return_weight_transition(
                        &mut transition,
                        destinations,
                        src,
                        dst,
                        walk_weights.return_weight,
                        has_selfloop,
                    );
                }
                (true, true) => {
                    update_return_explore_weight_transition(
                        &mut transition,
                        destinations,
                        previous_destinations,
                        walk_weights.return_weight,
                        walk_weights.explore_weight,
                        src,
                        dst,
                    );
                }
            }
            (transition, min_edge_id)
        }
        /// Return new sampled node with the transition edge used.
        ///
        /// # Arguments
        ///
        /// * `node`: NodeT, the previous node from which to compute the transitions.
        /// * `random_state`: u64, the random_state to use for extracting the node.
        ///
        /// # Safety
        /// If a non-existing node ID is provided, this method may cause an out of bound.
        unsafe fn extract_uniform_node(&self, node: NodeT, random_state: u64) -> NodeT {
            let (min_edge, max_edge) = self.get_unchecked_minmax_edge_ids_from_source_node_id(node);
            let sampled_offset = sample_uniform((max_edge - min_edge) as u64, random_state);
            self.get_unchecked_destination_node_id_from_edge_id(min_edge + sampled_offset as EdgeT)
        }
        /// Return new sampled node with the transition edge used.
        ///
        /// # Arguments
        ///
        /// * `node`: NodeT, the previous node from which to compute the transitions.
        /// * `random_state`: usize, the random_state to use for extracting the node.
        /// * `walk_weights`: WalkWeights, the weights for the weighted random walks.
        ///
        /// # Safety
        /// If a non-existing node ID is provided, this method may cause an out of bound.
        unsafe fn extract_node(
            &self,
            node: NodeT,
            random_state: u64,
            walk_weights: &WalkWeights,
            min_edge_id: EdgeT,
            max_edge_id: EdgeT,
            destinations: &[NodeT],
            probabilistic_indices: &Option<Vec<u64>>,
        ) -> (NodeT, EdgeT) {
            let mut weights = self.get_node_transition(
                node,
                walk_weights,
                min_edge_id,
                max_edge_id,
                destinations,
                probabilistic_indices,
            );
            let sampled_offset = sample(&mut weights, random_state);
            let edge_id = match probabilistic_indices {
                Some(inds) => inds[sampled_offset],
                None => min_edge_id + sampled_offset as EdgeT,
            };
            (
                self.get_unchecked_destination_node_id_from_edge_id(edge_id),
                edge_id,
            )
        }
        /// Return new random edge with given weights.
        ///
        /// # Arguments
        ///
        /// * `src`: NodeT - Current source node id.
        /// * `dst`: NodeT - Current destination node id.
        /// * `edge`: EdgeT - Current edge id.
        /// * `random_state`: NodeT - The random state to use to sample the next edge id.
        /// * `walk_weights`: &WalkWeights - Struct with the weights to use to update the transitions.
        /// * `min_edge_id`: EdgeT - Minimum edge id to sample for given destination node id.
        /// * `max_edge_id`: EdgeT - Maximum edge id to sample for given destination node id.
        /// * `destinations`: &[NodeT] - Current destinations slice.
        /// * `previous_destinations`: &[NodeT] - Previous destination slice.
        /// * `probabilistic_indices`: &Option<Vec<u64>> - Probabilistic indices, used when max neighbours is provided.
        ///
        /// # Safety
        /// If a non-existing node ID is provided, this method may cause an out of bound.
        unsafe fn extract_edge(
            &self,
            src: NodeT,
            dst: NodeT,
            edge: EdgeT,
            random_state: u64,
            walk_weights: &WalkWeights,
            min_edge_id: EdgeT,
            max_edge_id: EdgeT,
            destinations: &[NodeT],
            previous_destinations: &[NodeT],
            probabilistic_indices: &Option<Vec<u64>>,
        ) -> (NodeT, EdgeT) {
            let (mut weights, min_edge_id) = self.get_edge_transition(
                src,
                dst,
                edge,
                walk_weights,
                min_edge_id,
                max_edge_id,
                destinations,
                previous_destinations,
                probabilistic_indices,
                self.has_selfloops(),
            );
            let sampled_offset = sample(&mut weights, random_state as u64);
            let edge_id = match probabilistic_indices {
                Some(inds) => inds[sampled_offset],
                None => min_edge_id + sampled_offset as EdgeT,
            };
            (
                self.get_unchecked_destination_node_id_from_edge_id(edge_id),
                edge_id,
            )
        }
        /// Return vector of walks run on each non-trap node of the graph.
        ///
        /// # Arguments
        ///
        /// * `quantity`: NodeT - Number of random walk to compute.
        /// * `parameters`: &'a WalksParameters - the weighted walks parameters.
        ///
        /// # Raises
        /// * If the graph does not contain edges.
        /// * If the graph is directed.
        /// * If the given walks parameters are not compatible with the current graph instance.
        pub fn iter_random_walks<'a>(
            &'a self,
            quantity: NodeT,
            parameters: &'a WalksParameters,
        ) -> Result<impl IndexedParallelIterator<Item = Vec<NodeT>> + 'a> {
            self.must_have_edges()?;
            let factor = 0xDEAD;
            let random_state = splitmix64(parameters.random_state.wrapping_mul(factor) as u64);
            self.iter_walk(
                quantity,
                move |index| {
                    let local_index = index % quantity;
                    let random_source_id =
                        splitmix64(random_state + local_index.wrapping_mul(factor) as u64) as NodeT;
                    (
                        splitmix64(random_state + index.wrapping_mul(factor) as u64),
                        unsafe {
                            self.get_unchecked_unique_source_node_id(
                                random_source_id % self.get_unique_source_nodes_number(),
                            )
                        },
                    )
                },
                parameters,
            )
        }
        /// Return vector of walks run on a random subset of the not trap nodes.
        ///
        /// # Arguments
        ///
        /// * `parameters`: &'a WalksParameters - the weighted walks parameters.
        ///
        /// # Raises
        /// * If the graph does not contain edges.
        /// * If the graph is directed.
        /// * If the given walks parameters are not compatible with the current graph instance.
        pub fn iter_complete_walks<'a>(
            &'a self,
            parameters: &'a WalksParameters,
        ) -> Result<impl IndexedParallelIterator<Item = Vec<NodeT>> + 'a> {
            self.must_have_edges()?;
            let factor = 0xDEAD;
            let random_state = splitmix64(parameters.random_state.wrapping_mul(factor) as u64);
            self.iter_walk(
                self.get_unique_source_nodes_number(),
                move |index| {
                    (
                        splitmix64(random_state + index.wrapping_mul(factor) as u64),
                        unsafe {
                            self.get_unchecked_unique_source_node_id(
                                index as NodeT % self.get_unique_source_nodes_number(),
                            )
                        },
                    )
                },
                parameters,
            )
        }
        /// Returns vector of walks.
        ///
        /// # Arguments
        ///
        /// * `parameters`: WalksParameters - the weighted walks parameters.
        ///
        /// # Raises
        /// * If the graph is directed.
        /// * If the given walks parameters are not compatible with the current graph instance.
        /// * If the graph contains negative edge weights.
        fn iter_walk<'a>(
            &'a self,
            quantity: NodeT,
            to_node: impl Fn(NodeT) -> (u64, NodeT) + Sync + Send + 'a,
            parameters: &'a WalksParameters,
        ) -> Result<impl IndexedParallelIterator<Item = Vec<NodeT>> + 'a> {
            self.must_be_undirected()?;
            if self.has_edge_weights() {
                self.must_have_positive_edge_weights()?;
            }
            parameters.validate(&self)?;
            let total_iterations = quantity * parameters.iterations;
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &["Starting random walk."],
                            &match () {
                                () => [],
                            },
                        ),
                        lvl,
                        &("graph::walks", "graph::walks", "src/walks.rs", 717u32),
                    );
                }
            };
            let use_uniform = !self.has_edge_weights() && parameters.is_first_order_walk();
            let walks = (0..total_iterations)
                .into_par_iter()
                .map(move |index| unsafe {
                    let (random_state, node) = to_node(index);
                    let mut walk = match use_uniform {
                        true => self.uniform_walk(
                            node,
                            random_state,
                            parameters.single_walk_parameters.walk_length,
                        ),
                        false => self.get_unchecked_single_walk(
                            node,
                            random_state,
                            &parameters.single_walk_parameters,
                        ),
                    };
                    if let Some(dense_node_mapping) = &parameters.dense_node_mapping {
                        walk.iter_mut()
                            .for_each(|node| *node = *dense_node_mapping.get(node).unwrap());
                    }
                    walk
                });
            Ok(walks)
        }
        /// Returns single walk from given node.
        ///
        /// This method assumes that there are no traps in the graph.
        ///
        /// # Arguments
        /// * `node`: NodeT - Node from where to start the random walks.
        /// * `random_state`: usize, the random_state to use for extracting the nodes and edges.
        /// * `parameters`: SingleWalkParameters - Parameters for the single walk.
        ///
        /// # Safety
        /// If the given node ID does not exists, the method will cause an out of bound.
        unsafe fn get_unchecked_single_walk(
            &self,
            node: NodeT,
            random_state: u64,
            parameters: &SingleWalkParameters,
        ) -> Vec<NodeT> {
            let (min_edge_id, max_edge_id, destinations, indices) = self
                .get_unchecked_edges_and_destinations_from_source_node_id(
                    parameters.max_neighbours,
                    random_state,
                    node,
                );
            let (dst, edge) = self.extract_node(
                node,
                random_state,
                &parameters.weights,
                min_edge_id,
                max_edge_id,
                self.get_destinations_slice(min_edge_id, max_edge_id, &destinations),
                &indices,
            );
            let mut result = Vec::with_capacity(parameters.walk_length as usize);
            result.push(node);
            result.push(dst);
            let mut previous_min_edge_id = min_edge_id;
            let mut previous_max_edge_id = max_edge_id;
            let mut previous_destinations = destinations;
            let mut previous_src = node;
            let mut previous_dst = dst;
            let mut previous_edge = edge;
            for i in 2..parameters.walk_length {
                let (min_edge_id, max_edge_id, destinations, indices) = self
                    .get_unchecked_edges_and_destinations_from_source_node_id(
                        parameters.max_neighbours,
                        random_state + i,
                        previous_dst,
                    );
                let (dst, edge) = self.extract_edge(
                    previous_src,
                    previous_dst,
                    previous_edge,
                    random_state + i,
                    &parameters.weights,
                    min_edge_id,
                    max_edge_id,
                    self.get_destinations_slice(min_edge_id, max_edge_id, &destinations),
                    self.get_destinations_slice(
                        previous_min_edge_id,
                        previous_max_edge_id,
                        &previous_destinations,
                    ),
                    &indices,
                );
                previous_min_edge_id = min_edge_id;
                previous_max_edge_id = max_edge_id;
                previous_destinations = destinations;
                previous_src = previous_dst;
                previous_dst = dst;
                previous_edge = edge;
                result.push(dst);
            }
            result
        }
        /// Returns single walk from given node.
        ///
        /// This method assumes that there are no traps in the graph.
        ///
        /// # Arguments
        /// * `node`: NodeT - Node from where to start the random walks.
        /// * `random_state`: usize - the random_state to use for extracting the nodes and edges.
        /// * `walk_length`: u64 - Length of the random walk.
        ///
        /// # Safety
        /// If a non-existing node ID is provided, this method may cause an out of bound.
        unsafe fn uniform_walk(
            &self,
            node: NodeT,
            random_state: u64,
            walk_length: u64,
        ) -> Vec<NodeT> {
            (0..1)
                .map(move |_| node)
                .chain((1..walk_length).scan(node, move |node, iteration| {
                    *node = self.extract_uniform_node(*node, random_state + iteration);
                    Some(*node)
                }))
                .collect()
        }
    }
}
pub mod walks_parameters {
    use super::*;
    use std::collections::HashMap;
    /// Struct to wrap walk weights.
    pub struct WalkWeights {
        pub return_weight: ParamsT,
        pub(crate) explore_weight: ParamsT,
        pub(crate) change_node_type_weight: ParamsT,
        pub(crate) change_edge_type_weight: ParamsT,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for WalkWeights {
        #[inline]
        fn clone(&self) -> WalkWeights {
            match *self {
                WalkWeights {
                    return_weight: ref __self_0_0,
                    explore_weight: ref __self_0_1,
                    change_node_type_weight: ref __self_0_2,
                    change_edge_type_weight: ref __self_0_3,
                } => WalkWeights {
                    return_weight: ::core::clone::Clone::clone(&(*__self_0_0)),
                    explore_weight: ::core::clone::Clone::clone(&(*__self_0_1)),
                    change_node_type_weight: ::core::clone::Clone::clone(&(*__self_0_2)),
                    change_edge_type_weight: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for WalkWeights {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                WalkWeights {
                    return_weight: ref __self_0_0,
                    explore_weight: ref __self_0_1,
                    change_node_type_weight: ref __self_0_2,
                    change_edge_type_weight: ref __self_0_3,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "WalkWeights");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "return_weight",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "explore_weight",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "change_node_type_weight",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "change_edge_type_weight",
                        &&(*__self_0_3),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for WalkWeights {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for WalkWeights {
        #[inline]
        fn eq(&self, other: &WalkWeights) -> bool {
            match *other {
                WalkWeights {
                    return_weight: ref __self_1_0,
                    explore_weight: ref __self_1_1,
                    change_node_type_weight: ref __self_1_2,
                    change_edge_type_weight: ref __self_1_3,
                } => match *self {
                    WalkWeights {
                        return_weight: ref __self_0_0,
                        explore_weight: ref __self_0_1,
                        change_node_type_weight: ref __self_0_2,
                        change_edge_type_weight: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &WalkWeights) -> bool {
            match *other {
                WalkWeights {
                    return_weight: ref __self_1_0,
                    explore_weight: ref __self_1_1,
                    change_node_type_weight: ref __self_1_2,
                    change_edge_type_weight: ref __self_1_3,
                } => match *self {
                    WalkWeights {
                        return_weight: ref __self_0_0,
                        explore_weight: ref __self_0_1,
                        change_node_type_weight: ref __self_0_2,
                        change_edge_type_weight: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    /// Struct to wrap parameters relative to a single walk.
    pub struct SingleWalkParameters {
        pub(crate) walk_length: u64,
        pub(crate) weights: WalkWeights,
        pub(crate) max_neighbours: Option<NodeT>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for SingleWalkParameters {
        #[inline]
        fn clone(&self) -> SingleWalkParameters {
            match *self {
                SingleWalkParameters {
                    walk_length: ref __self_0_0,
                    weights: ref __self_0_1,
                    max_neighbours: ref __self_0_2,
                } => SingleWalkParameters {
                    walk_length: ::core::clone::Clone::clone(&(*__self_0_0)),
                    weights: ::core::clone::Clone::clone(&(*__self_0_1)),
                    max_neighbours: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for SingleWalkParameters {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                SingleWalkParameters {
                    walk_length: ref __self_0_0,
                    weights: ref __self_0_1,
                    max_neighbours: ref __self_0_2,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "SingleWalkParameters");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "walk_length",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "weights",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "max_neighbours",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for SingleWalkParameters {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for SingleWalkParameters {
        #[inline]
        fn eq(&self, other: &SingleWalkParameters) -> bool {
            match *other {
                SingleWalkParameters {
                    walk_length: ref __self_1_0,
                    weights: ref __self_1_1,
                    max_neighbours: ref __self_1_2,
                } => match *self {
                    SingleWalkParameters {
                        walk_length: ref __self_0_0,
                        weights: ref __self_0_1,
                        max_neighbours: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &SingleWalkParameters) -> bool {
            match *other {
                SingleWalkParameters {
                    walk_length: ref __self_1_0,
                    weights: ref __self_1_1,
                    max_neighbours: ref __self_1_2,
                } => match *self {
                    SingleWalkParameters {
                        walk_length: ref __self_0_0,
                        weights: ref __self_0_1,
                        max_neighbours: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    /// Struct to wrap parameters relative to a set of walks.
    pub struct WalksParameters {
        pub(crate) single_walk_parameters: SingleWalkParameters,
        pub(crate) iterations: NodeT,
        pub(crate) random_state: NodeT,
        pub(crate) dense_node_mapping: Option<HashMap<NodeT, NodeT>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for WalksParameters {
        #[inline]
        fn clone(&self) -> WalksParameters {
            match *self {
                WalksParameters {
                    single_walk_parameters: ref __self_0_0,
                    iterations: ref __self_0_1,
                    random_state: ref __self_0_2,
                    dense_node_mapping: ref __self_0_3,
                } => WalksParameters {
                    single_walk_parameters: ::core::clone::Clone::clone(&(*__self_0_0)),
                    iterations: ::core::clone::Clone::clone(&(*__self_0_1)),
                    random_state: ::core::clone::Clone::clone(&(*__self_0_2)),
                    dense_node_mapping: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for WalksParameters {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                WalksParameters {
                    single_walk_parameters: ref __self_0_0,
                    iterations: ref __self_0_1,
                    random_state: ref __self_0_2,
                    dense_node_mapping: ref __self_0_3,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "WalksParameters");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "single_walk_parameters",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "iterations",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "random_state",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "dense_node_mapping",
                        &&(*__self_0_3),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for WalksParameters {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for WalksParameters {
        #[inline]
        fn eq(&self, other: &WalksParameters) -> bool {
            match *other {
                WalksParameters {
                    single_walk_parameters: ref __self_1_0,
                    iterations: ref __self_1_1,
                    random_state: ref __self_1_2,
                    dense_node_mapping: ref __self_1_3,
                } => match *self {
                    WalksParameters {
                        single_walk_parameters: ref __self_0_0,
                        iterations: ref __self_0_1,
                        random_state: ref __self_0_2,
                        dense_node_mapping: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &WalksParameters) -> bool {
            match *other {
                WalksParameters {
                    single_walk_parameters: ref __self_1_0,
                    iterations: ref __self_1_1,
                    random_state: ref __self_1_2,
                    dense_node_mapping: ref __self_1_3,
                } => match *self {
                    WalksParameters {
                        single_walk_parameters: ref __self_0_0,
                        iterations: ref __self_0_1,
                        random_state: ref __self_0_2,
                        dense_node_mapping: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl Default for WalkWeights {
        /// Create new WalkWeights object.
        ///
        /// The default WalkWeights object is parametrized to execute a first-order walk.
        fn default() -> WalkWeights {
            WalkWeights {
                return_weight: 1.0,
                explore_weight: 1.0,
                change_node_type_weight: 1.0,
                change_edge_type_weight: 1.0,
            }
        }
    }
    impl WalkWeights {
        /// Validate given weight and format the exception if necessary, eventually.
        ///
        /// # Arguments
        ///
        /// * `weight_name`: &str - name of the weight, used for building the exception.
        /// * `weight`: Option<WeightT> - Value of the weight.
        ///
        /// TODO: is this a duplicate?
        fn validate_weight(weight_name: &str, weight: WeightT) -> Result<WeightT> {
            if weight <= 0.0 || !weight.is_finite() {
                Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "Given \'",
                            "\' (",
                            ") is not a strictly positive real number.",
                        ],
                        &match (&weight_name, &weight) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                })
            } else {
                Ok(weight)
            }
        }
        /// Return boolean value representing if walk is of first order.
        ///
        /// # Example
        /// The default parametrization defines a first order walk:
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalkWeights;
        /// let weights = WalkWeights::default();
        /// assert!(weights.is_first_order_walk());
        /// ```
        pub fn is_first_order_walk(&self) -> bool {
            let weights = <[_]>::into_vec(box [
                self.change_node_type_weight,
                self.change_edge_type_weight,
                self.return_weight,
                self.explore_weight,
            ]);
            weights.iter().all(|weight| !not_one(*weight))
        }
    }
    impl SingleWalkParameters {
        /// Create new WalksParameters object.
        ///
        /// By default the object is parametrized for a simple first-order walk.
        ///
        /// # Arguments
        ///
        /// * `walk_length`: usize - Maximal walk_length of the walk.
        ///
        /// # Example
        /// You can create a single walk parameters struct as follows:
        ///
        /// ```rust
        /// # use graph::walks_parameters::SingleWalkParameters;
        /// assert!(SingleWalkParameters::new(45).is_ok());
        /// ```
        ///
        /// as long as you don't try to make a zero walk length you'll be fine:
        ///
        /// ```rust
        /// # use graph::walks_parameters::SingleWalkParameters;
        /// assert!(SingleWalkParameters::new(0).is_err());
        /// ```
        pub fn new(walk_length: u64) -> Result<SingleWalkParameters> {
            if walk_length == 0 {
                return Err(String::from("The provided lenght for the walk is zero!"));
            }
            Ok(SingleWalkParameters {
                walk_length,
                weights: WalkWeights::default(),
                max_neighbours: None,
            })
        }
        /// Return boolean value representing if walk is of first order.
        ///
        /// # Example
        /// The default parametrization defines a first order walk:
        ///
        /// ```rust
        /// # use graph::walks_parameters::SingleWalkParameters;
        /// let weights = SingleWalkParameters::new(32).unwrap();
        /// assert!(weights.is_first_order_walk());
        /// ```
        pub fn is_first_order_walk(&self) -> bool {
            self.weights.is_first_order_walk()
        }
    }
    /// Setters for the Walk's parameters
    impl WalksParameters {
        /// Create new WalksParameters object.
        ///
        /// By default the object is parametrized for a simple first-order walk.
        ///
        /// # Arguments
        ///
        /// * `walk_length`: NodeT - Maximal walk_length of the walk.
        ///
        pub fn new(walk_length: u64) -> Result<WalksParameters> {
            Ok(WalksParameters {
                single_walk_parameters: SingleWalkParameters::new(walk_length)?,
                iterations: 1,
                random_state: splitmix64(42) as NodeT,
                dense_node_mapping: None,
            })
        }
        /// Set the iterations.
        ///
        /// # Arguments
        ///
        /// * `iterations`: Option<NodeT> - Whether to show the loading bar or not.
        ///
        /// # Example
        /// You can change the `iterations` parameter as follows:
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// assert!(WalksParameters::new(32).unwrap().set_iterations(Some(0)).is_err());
        /// assert!(WalksParameters::new(32).unwrap().set_iterations(Some(2)).is_ok());
        /// ```
        ///
        /// You can also call the method with an option None, in order to avoid a match
        /// wrapper above. This will end up don't doing anything, just a passthrough.
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// assert!(WalksParameters::new(32).unwrap().set_iterations(None).is_ok());
        /// ```
        pub fn set_iterations(mut self, iterations: Option<NodeT>) -> Result<WalksParameters> {
            if let Some(it) = iterations {
                if it == 0 {
                    return Err(String::from(
                        "Iterations parameter must be a strictly positive integer.",
                    ));
                }
                self.iterations = it;
            }
            Ok(self)
        }
        /// Return the iterations.
        ///
        /// # Example
        /// To retrieve the number of iterations you can do the following:
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// let mut walk_parameters = WalksParameters::new(32).unwrap();
        /// assert_eq!(walk_parameters.get_iterations(), 1);
        /// let iterations_number = 56;
        /// walk_parameters = walk_parameters.set_iterations(Some(iterations_number)).unwrap();
        /// assert_eq!(walk_parameters.get_iterations(), iterations_number);
        /// ```
        pub fn get_iterations(&self) -> NodeT {
            self.iterations
        }
        /// Set the maximum neighbours number to consider, making the walk probabilistic.
        ///
        /// # Arguments
        ///
        /// * `max_neighbours`: Option<NodeT> - Number of neighbours to consider for each extraction.
        ///
        /// # Example
        /// You can change the `max_neighbours` parameter as follows:
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// assert!(WalksParameters::new(32).unwrap().set_max_neighbours(Some(0)).is_err());
        /// assert!(WalksParameters::new(32).unwrap().set_max_neighbours(Some(2)).is_ok());
        /// ```
        ///
        /// You can also call the method with an option None, in order to avoid a match
        /// wrapper above. This will end up don't doing anything, just a passthrough.
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// assert!(WalksParameters::new(32).unwrap().set_max_neighbours(None).is_ok());
        /// ```
        pub fn set_max_neighbours(
            mut self,
            max_neighbours: Option<NodeT>,
        ) -> Result<WalksParameters> {
            if let Some(mn) = max_neighbours {
                if mn == 0 {
                    return Err(String::from(
                        "max_neighbours parameter must be a strictly positive integer.",
                    ));
                }
                self.single_walk_parameters.max_neighbours = Some(mn);
            }
            Ok(self)
        }
        /// Set the random_state.
        ///
        /// # Arguments
        ///
        /// * `random_state`: Option<usize> - random_state for reproducible random walks.
        ///
        pub fn set_random_state(mut self, random_state: Option<usize>) -> WalksParameters {
            if let Some(s) = random_state {
                self.random_state = splitmix64(s as u64) as NodeT;
            }
            self
        }
        /// Set the dense_node_mapping.
        ///
        /// The nodes mapping primary porpose is to map a sparse set of nodes into
        /// a smaller dense set of nodes.
        ///
        /// # Arguments
        ///
        /// * `dense_node_mapping`: Option<HashMap<NodeT, NodeT>> - mapping for the mapping the nodes of the walks.
        ///
        pub fn set_dense_node_mapping(
            mut self,
            dense_node_mapping: Option<HashMap<NodeT, NodeT>>,
        ) -> WalksParameters {
            self.dense_node_mapping = dense_node_mapping;
            self
        }
        /// Set the return weight.
        ///
        /// # Arguments
        ///
        /// * `return_weight`: Option<WeightT> - weight for the exploitation factor.
        ///
        /// # Example
        /// You can change the `return_weight` parameter as follows:
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// assert!(WalksParameters::new(32).unwrap().set_return_weight(Some(-1.0)).is_err());
        /// assert!(WalksParameters::new(32).unwrap().set_return_weight(Some(2.0)).is_ok());
        /// assert!(WalksParameters::new(32).unwrap().set_return_weight(Some(1.0)).is_ok());
        /// assert!(WalksParameters::new(32).unwrap().set_return_weight(Some(1.0)).unwrap().is_first_order_walk());
        /// ```
        ///
        /// You can also call the method with an option None, in order to avoid a match
        /// wrapper above. This will end up don't doing anything, just a passthrough.
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// assert!(WalksParameters::new(32).unwrap().set_return_weight(None).unwrap().is_first_order_walk());
        /// ```
        pub fn set_return_weight(
            mut self,
            return_weight: Option<WeightT>,
        ) -> Result<WalksParameters> {
            if let Some(rw) = return_weight {
                self.single_walk_parameters.weights.return_weight =
                    WalkWeights::validate_weight("return_weight", rw)?;
            }
            Ok(self)
        }
        /// Set the explore weight.
        ///
        /// # Arguments
        ///
        /// * `explore_weight`: Option<WeightT> - weight for the exploration factor.
        ///
        /// # Example
        /// You can change the `explore_weight` parameter as follows:
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// assert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(-1.0)).is_err());
        /// assert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(2.0)).is_ok());
        /// assert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(1.0)).is_ok());
        /// assert!(WalksParameters::new(32).unwrap().set_explore_weight(Some(1.0)).unwrap().is_first_order_walk());
        /// ```
        ///
        /// You can also call the method with an option None, in order to avoid a match
        /// wrapper above. This will end up don't doing anything, just a passthrough.
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// assert!(WalksParameters::new(32).unwrap().set_explore_weight(None).unwrap().is_first_order_walk());
        /// ```
        pub fn set_explore_weight(
            mut self,
            explore_weight: Option<WeightT>,
        ) -> Result<WalksParameters> {
            if let Some(ew) = explore_weight {
                self.single_walk_parameters.weights.explore_weight =
                    WalkWeights::validate_weight("explore_weight", ew)?;
            }
            Ok(self)
        }
        /// Set the change_node_type weight.
        ///
        /// # Arguments
        ///
        /// * `change_node_type_weight`: Option<WeightT> - weight for the exploration of different node types.
        ///
        /// # Example
        /// You can change the `change_node_type_weight` parameter as follows:
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(-1.0)).is_err());
        /// assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(2.0)).is_ok());
        /// assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(1.0)).is_ok());
        /// assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(Some(1.0)).unwrap().is_first_order_walk());
        /// ```
        ///
        /// You can also call the method with an option None, in order to avoid a match
        /// wrapper above. This will end up don't doing anything, just a passthrough.
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// assert!(WalksParameters::new(32).unwrap().set_change_node_type_weight(None).unwrap().is_first_order_walk());
        /// ```
        pub fn set_change_node_type_weight(
            mut self,
            change_node_type_weight: Option<WeightT>,
        ) -> Result<WalksParameters> {
            if let Some(cntw) = change_node_type_weight {
                self.single_walk_parameters.weights.change_node_type_weight =
                    WalkWeights::validate_weight("change_node_type_weight", cntw)?;
            }
            Ok(self)
        }
        /// Set the change_edge_type weight.
        ///
        /// # Arguments
        ///
        /// * `change_edge_type_weight`: Option<WeightT> - weight for the exploration of different node types.
        ///
        /// # Example
        /// You can change the `change_edge_type_weight` parameter as follows:
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(-1.0)).is_err());
        /// assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(2.0)).is_ok());
        /// assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(1.0)).is_ok());
        /// assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(Some(1.0)).unwrap().is_first_order_walk());
        /// ```
        /// You can also call the method with an option None, in order to avoid a match
        /// wrapper above. This will end up don't doing anything, just a passthrough.
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// assert!(WalksParameters::new(32).unwrap().set_change_edge_type_weight(None).unwrap().is_first_order_walk());
        /// ```
        pub fn set_change_edge_type_weight(
            mut self,
            change_edge_type_weight: Option<WeightT>,
        ) -> Result<WalksParameters> {
            if let Some(cetw) = change_edge_type_weight {
                self.single_walk_parameters.weights.change_edge_type_weight =
                    WalkWeights::validate_weight("change_edge_type_weight", cetw)?;
            }
            Ok(self)
        }
        /// Validate for graph.
        ///
        /// Check if walks parameters are compatible with given graph.
        ///
        /// # Arguments
        ///
        /// * `graph`: Graph - Graph object for which parameters are to be validated.
        ///
        /// # Example
        /// A graph is always remappable to itself:
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// # let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// # let mut parameters = WalksParameters::new(32).unwrap();
        /// assert!(parameters.set_dense_node_mapping(Some(ppi.get_dense_nodes_mapping())).validate(&ppi).is_ok());
        /// ```
        /// Two different graphs, like Cora and STRING, are not remappable:
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// # let cora = graph::test_utilities::load_cora();
        /// # let ppi = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// # let mut parameters = WalksParameters::new(32).unwrap();
        /// assert!(parameters.set_dense_node_mapping(Some(ppi.get_dense_nodes_mapping())).validate(&cora).is_err());
        /// ```
        ///
        pub fn validate(&self, graph: &Graph) -> Result<()> {
            if let Some(dense_node_mapping) = &self.dense_node_mapping {
                if !graph
                    .iter_unique_source_node_ids()
                    .all(|node| dense_node_mapping.contains_key(&(node as NodeT)))
                {
                    return Err (String :: from ("Given nodes mapping does not contain one or more NOT trap nodes that may be extracted from walk.")) ;
                }
            }
            Ok(())
        }
        /// Return boolean value representing if walk is of first order.
        ///
        /// # Example
        /// The default parametrization defines a first order walk:
        ///
        /// ```rust
        /// # use graph::walks_parameters::WalksParameters;
        /// assert!(WalksParameters::new(32).unwrap().is_first_order_walk());
        /// ```
        pub fn is_first_order_walk(&self) -> bool {
            self.single_walk_parameters.is_first_order_walk()
        }
    }
}
mod report {
    use super::types::*;
    use super::*;
    use itertools::Itertools;
    use rayon::prelude::*;
    use std::collections::HashMap;
    /// # Human readable report of the properties of the graph
    impl Graph {
        /// Returns report relative to the graph metrics
        ///
        /// The report includes the following metrics by default:
        /// * Name of the graph
        /// * Whether the graph is directed or undirected
        /// * Number of singleton nodes
        /// * Number of nodes
        ///     - If the graph has nodes, we also compute:
        ///         * Minimum unweighted node degree
        ///         * Maximum unweighted node degree
        ///         * Unweighted node degree mean
        /// * Number of edges
        /// * Number of self-loops
        /// * Number of singleton with self-loops
        /// * Whether the graph is a multigraph
        /// * Number of parallel edges
        /// * Number of directed edges
        ///     - If the graph has edges, we also compute:
        ///         * Rate of self-loops
        /// * Whether the graph has weighted edges
        ///     - If the graph has weights, we also compute:
        ///         * Minimum weighted node degree
        ///         * Maximum weighted node degree
        ///         * Weighted node degree mean
        ///         * The total edge weights
        /// * Whether the graph has node types
        ///     - If the graph has node types, we also compute:
        ///         * Whether the graph has singleton node types
        ///         * The number of node types
        ///         * The number of nodes with unknown node types
        ///         * The number of nodes with known node types
        /// * Whether the graph has edge types
        ///     - If the graph has edge types, we also compute:
        ///         * Whether the graph has singleton edge types
        ///         * The number of edge types
        ///         * The number of edges with unknown edge types
        ///         * The number of edges with known edge types
        ///
        /// On request, since it takes more time to compute it, the method also provides:
        ///
        /// # Examples
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// graph.report();
        /// ```
        pub fn report(&self) -> HashMap<&str, String> {
            let mut report: HashMap<&str, String> = HashMap::new();
            report.insert("name", self.name.clone());
            report.insert("directed", self.is_directed().to_string());
            report.insert("nodes_number", self.get_nodes_number().to_string());
            report.insert(
                "singleton_nodes_number",
                self.get_singleton_nodes_number().to_string(),
            );
            if self.has_nodes() {
                report.insert("density", self.get_density().unwrap().to_string());
                report.insert(
                    "minimum_node_degree",
                    self.get_minimum_node_degree().unwrap().to_string(),
                );
                report.insert(
                    "maximum_node_degree",
                    self.get_maximum_node_degree().unwrap().to_string(),
                );
                report.insert(
                    "unweighted_node_degrees_mean",
                    self.get_node_degrees_mean().unwrap().to_string(),
                );
            }
            report.insert(
                "directed_edges_number",
                self.get_directed_edges_number().to_string(),
            );
            report.insert("selfloops_number", self.get_selfloop_number().to_string());
            report.insert(
                "singleton_nodes_with_selfloops_number",
                self.get_singleton_nodes_with_selfloops_number().to_string(),
            );
            report.insert("multigraph", self.is_multigraph().to_string());
            report.insert(
                "parallel_edges_number",
                self.get_parallel_edges_number().to_string(),
            );
            if self.has_edges() {
                report.insert(
                    "selfloops_rate",
                    self.get_selfloop_nodes_rate().unwrap().to_string(),
                );
            }
            report.insert("has_edge_weights", self.has_edge_weights().to_string());
            if self.has_edge_weights() {
                report.insert(
                    "minimum_weighted_node_degree",
                    self.get_weighted_mininum_node_degree().unwrap().to_string(),
                );
                report.insert(
                    "maximum_weighted_node_degree",
                    self.get_weighted_maximum_node_degree().unwrap().to_string(),
                );
                report.insert(
                    "unweighted_node_degrees_mean",
                    self.get_weighted_node_degrees_mean().unwrap().to_string(),
                );
                report.insert(
                    "total_edge_weights",
                    self.get_total_edge_weights().unwrap().to_string(),
                );
            }
            report.insert("has_node_types", self.has_node_types().to_string());
            if self.has_node_types() {
                report.insert(
                    "has_singleton_node_types",
                    self.has_singleton_node_types().unwrap().to_string(),
                );
                report.insert(
                    "node_types_number",
                    self.get_node_types_number().unwrap().to_string(),
                );
                report.insert(
                    "unknown_node_types_number",
                    self.get_unknown_node_types_number().unwrap().to_string(),
                );
                report.insert(
                    "known_node_types_number",
                    self.get_known_node_types_number().unwrap().to_string(),
                );
            }
            report.insert("has_edge_types", self.has_edge_types().to_string());
            if self.has_edge_types() {
                report.insert(
                    "has_singleton_edge_types",
                    self.has_singleton_edge_types().unwrap().to_string(),
                );
                report.insert(
                    "edge_types_number",
                    self.get_edge_types_number().unwrap().to_string(),
                );
                report.insert(
                    "unknown_edge_types_number",
                    self.get_unknown_edge_types_number().unwrap().to_string(),
                );
                report.insert(
                    "known_edge_types_number",
                    self.get_known_edge_types_number().unwrap().to_string(),
                );
            }
            report
        }
        fn shared_components_number(&self, nodes_components: &[NodeT], other: &Graph) -> NodeT {
            other
                .iter_node_names_and_node_type_names()
                .filter_map(|(_, node_name, _, _)| {
                    match self.get_node_id_from_node_name(&node_name) {
                        Ok(node_id) => Some(nodes_components[node_id as usize]),
                        Err(_) => None,
                    }
                })
                .unique()
                .count() as NodeT
        }
        /// Return number of distinct components that are merged by the other graph in current graph.bitvec
        ///
        /// # Arguments
        /// * `nodes_components`: &[NodeT] - Slice with the node components.
        /// * `other`: &Graph - Graph from where to extract the edge list.
        fn merged_components_number(&self, nodes_components: &[NodeT], other: &Graph) -> NodeT {
            other
                .iter_edges(false)
                .filter_map(|(_, _, src_name, _, dst_name)| {
                    match (
                        self.get_node_id_from_node_name(&src_name),
                        self.get_node_id_from_node_name(&dst_name),
                    ) {
                        (Ok(src_id), Ok(dst_id)) => {
                            let src_component_number = nodes_components[src_id as usize];
                            let dst_component_number = nodes_components[dst_id as usize];
                            match src_component_number == dst_component_number {
                                true => None,
                                false => Some(<[_]>::into_vec(box [
                                    src_component_number,
                                    dst_component_number,
                                ])),
                            }
                        }
                        _ => None,
                    }
                })
                .flatten()
                .unique()
                .count() as NodeT
        }
        /// Return rendered textual report about the graph overlaps.
        ///
        /// # Arguments
        ///
        /// * `other`: &Graph - graph to create overlap report with.
        /// * `verbose`: Option<bool> - Whether to shor the loading bars.
        pub fn overlap_textual_report(
            &self,
            other: &Graph,
            verbose: Option<bool>,
        ) -> Result<String> {
            self.validate_operator_terms(other)?;
            let overlapping_nodes_number = self
                .iter_node_names_and_node_type_names()
                .filter(|(_, node_name, _, node_type)| {
                    other.has_node_name_and_node_type_name(node_name, node_type.clone())
                })
                .count();
            let overlapping_edges_number = self
                .par_iter_edge_node_names_and_edge_type_name(self.directed)
                .filter(|(_, _, src_name, _, dst_name, _, edge_type_name)| {
                    other.has_edge_from_node_names_and_edge_type_name(
                        src_name,
                        dst_name,
                        edge_type_name.as_deref(),
                    )
                })
                .count();
            let first_nodes_components = self.get_node_connected_component_ids(verbose);
            let second_nodes_components = other.get_node_connected_component_ids(verbose);
            let first_components_number = first_nodes_components.iter().unique().count() as NodeT;
            let second_components_number = second_nodes_components.iter().unique().count() as NodeT;
            let first_shared_components_number =
                self.shared_components_number(&first_nodes_components, other);
            let second_shared_components_number =
                other.shared_components_number(&second_nodes_components, self);
            let first_merged_components_number =
                self.merged_components_number(&first_nodes_components, other);
            let second_merged_components_number =
                other.merged_components_number(&second_nodes_components, self);
            let first_edges = match self.directed {
                true => self.get_directed_edges_number(),
                false => self.get_undirected_edges_number(),
            };
            let second_edges = match other.directed {
                true => other.get_directed_edges_number(),
                false => other.get_undirected_edges_number(),
            };
            Ok({
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1_formatted(
                    &[
                        "The graph ",
                        " and the graph ",
                        " share ",
                        " nodes and ",
                        " edges. By percent, ",
                        " shares ",
                        "% (",
                        " out of ",
                        ") of its nodes and ",
                        "% (",
                        " out of ",
                        ") of its edges with ",
                        ". ",
                        " shares ",
                        "% (",
                        " out of ",
                        ") of its nodes and ",
                        "% (",
                        " out of ",
                        ") of its edges with ",
                        ". Nodes from ",
                        " appear in ",
                        " components of ",
                        "",
                        ". Similarly, nodes from ",
                        " appear in ",
                        " components of ",
                        "",
                        ". ",
                    ],
                    &match (
                        &self.get_name(),
                        &other.get_name(),
                        &overlapping_nodes_number,
                        &overlapping_edges_number,
                        &self.get_nodes_number(),
                        &other.get_nodes_number(),
                        &first_edges,
                        &second_edges,
                        &match second_shared_components_number == second_components_number {
                            true => "all the".to_owned(),
                            false => {
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &["", " of the "],
                                    &match (
                                        &second_shared_components_number,
                                        &second_components_number,
                                    ) {
                                        (arg0, arg1) => [
                                            ::core::fmt::ArgumentV1::new(
                                                arg0,
                                                ::core::fmt::Display::fmt,
                                            ),
                                            ::core::fmt::ArgumentV1::new(
                                                arg1,
                                                ::core::fmt::Display::fmt,
                                            ),
                                        ],
                                    },
                                ));
                                res
                            }
                        },
                        &match first_shared_components_number == first_components_number {
                            true => "all the".to_owned(),
                            false => {
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &["", " of the "],
                                    &match (
                                        &first_shared_components_number,
                                        &first_components_number,
                                    ) {
                                        (arg0, arg1) => [
                                            ::core::fmt::ArgumentV1::new(
                                                arg0,
                                                ::core::fmt::Display::fmt,
                                            ),
                                            ::core::fmt::ArgumentV1::new(
                                                arg1,
                                                ::core::fmt::Display::fmt,
                                            ),
                                        ],
                                    },
                                ));
                                res
                            }
                        },
                        &match second_components_number > 1 {
                            false => "".to_owned(),
                            true => {
                                let res =
                                    ::alloc::fmt::format(::core::fmt::Arguments::new_v1_formatted(
                                        &[": of these, ", " connected by edges of "],
                                        &match (
                                            &self.name,
                                            &match second_merged_components_number {
                                                d if d == 0 => "none are".to_owned(),
                                                d if d == 1 => "one is".to_owned(),
                                                d if d == second_components_number => {
                                                    "all components are".to_owned()
                                                }
                                                _ => {
                                                    let res = ::alloc::fmt::format(
                                                        ::core::fmt::Arguments::new_v1(
                                                            &["", " components are"],
                                                            &match (
                                                                &second_merged_components_number,
                                                            ) {
                                                                (arg0,) => {
                                                                    [::core::fmt::ArgumentV1::new(
                                                                        arg0,
                                                                        ::core::fmt::Display::fmt,
                                                                    )]
                                                                }
                                                            },
                                                        ),
                                                    );
                                                    res
                                                }
                                            },
                                        ) {
                                            (arg0, arg1) => [
                                                ::core::fmt::ArgumentV1::new(
                                                    arg0,
                                                    ::core::fmt::Display::fmt,
                                                ),
                                                ::core::fmt::ArgumentV1::new(
                                                    arg1,
                                                    ::core::fmt::Display::fmt,
                                                ),
                                            ],
                                        },
                                        &[
                                            ::core::fmt::rt::v1::Argument {
                                                position: 1usize,
                                                format: ::core::fmt::rt::v1::FormatSpec {
                                                    fill: ' ',
                                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                    flags: 0u32,
                                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                                    width: ::core::fmt::rt::v1::Count::Implied,
                                                },
                                            },
                                            ::core::fmt::rt::v1::Argument {
                                                position: 0usize,
                                                format: ::core::fmt::rt::v1::FormatSpec {
                                                    fill: ' ',
                                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                    flags: 0u32,
                                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                                    width: ::core::fmt::rt::v1::Count::Implied,
                                                },
                                            },
                                        ],
                                    ));
                                res
                            }
                        },
                        &match first_components_number > 1 {
                            false => "".to_owned(),
                            true => {
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1_formatted(
                                        &[": of these, ", " connected by edges of "],
                                        &match (
                                            &other.name,
                                            &match first_merged_components_number {
                                                d if d == 0 => "none are".to_owned(),
                                                d if d == 1 => "one is".to_owned(),
                                                d if d == first_components_number => {
                                                    "all components are".to_owned()
                                                }
                                                _ => {
                                                    let res = ::alloc::fmt::format(
                                                        ::core::fmt::Arguments::new_v1(
                                                            &["", " components are"],
                                                            &match (&first_merged_components_number,)
                                                            {
                                                                (arg0,) => {
                                                                    [::core::fmt::ArgumentV1::new(
                                                                        arg0,
                                                                        ::core::fmt::Display::fmt,
                                                                    )]
                                                                }
                                                            },
                                                        ),
                                                    );
                                                    res
                                                }
                                            },
                                        ) {
                                            (arg0, arg1) => [
                                                ::core::fmt::ArgumentV1::new(
                                                    arg0,
                                                    ::core::fmt::Display::fmt,
                                                ),
                                                ::core::fmt::ArgumentV1::new(
                                                    arg1,
                                                    ::core::fmt::Display::fmt,
                                                ),
                                            ],
                                        },
                                        &[
                                            ::core::fmt::rt::v1::Argument {
                                                position: 1usize,
                                                format: ::core::fmt::rt::v1::FormatSpec {
                                                    fill: ' ',
                                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                    flags: 0u32,
                                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                                    width: ::core::fmt::rt::v1::Count::Implied,
                                                },
                                            },
                                            ::core::fmt::rt::v1::Argument {
                                                position: 0usize,
                                                format: ::core::fmt::rt::v1::FormatSpec {
                                                    fill: ' ',
                                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                    flags: 0u32,
                                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                                    width: ::core::fmt::rt::v1::Count::Implied,
                                                },
                                            },
                                        ],
                                    ),
                                );
                                res
                            }
                        },
                        &(100.0
                            * (overlapping_nodes_number as f64 / self.get_nodes_number() as f64)),
                        &(100.0
                            * (overlapping_nodes_number as f64 / other.get_nodes_number() as f64)),
                        &(100.0 * (overlapping_edges_number as f64 / first_edges as f64)),
                        &(100.0 * (overlapping_edges_number as f64 / second_edges as f64)),
                    ) {
                        (
                            arg0,
                            arg1,
                            arg2,
                            arg3,
                            arg4,
                            arg5,
                            arg6,
                            arg7,
                            arg8,
                            arg9,
                            arg10,
                            arg11,
                            arg12,
                            arg13,
                            arg14,
                            arg15,
                        ) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg4, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg5, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg6, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg7, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg8, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg9, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg10, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg11, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg12, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg13, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg14, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg15, ::core::fmt::Display::fmt),
                        ],
                    },
                    &[
                        ::core::fmt::rt::v1::Argument {
                            position: 0usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 1usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 2usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 3usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 0usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 12usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Is(2usize),
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 2usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 4usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 14usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Is(2usize),
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 3usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 6usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 1usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 1usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 13usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Is(2usize),
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 2usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 5usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 15usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Is(2usize),
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 3usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 7usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 0usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 0usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 8usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 1usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 10usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 1usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 9usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 0usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 11usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                    ],
                ));
                res
            })
        }
        /// Returns given list in a uman readable format.
        ///
        /// # Safety
        /// If the list is empty the method will raise a panic.
        unsafe fn get_unchecked_formatted_list(&self, list: &[String]) -> String {
            if list.is_empty() {
                {
                    ::std::rt::begin_panic("Cannot format a list with no elements.")
                };
            }
            if list.len() == 1 {
                return list.first().unwrap().clone();
            }
            let all_minus_last: String = list[0..list.len() - 1].join(", ");
            {
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &["", " and "],
                    &match (&all_minus_last, &list.last().unwrap()) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ],
                    },
                ));
                res
            }
        }
        /// Return human-readable html report of the given node.
        ///
        /// The report, by default, is rendered using html.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - Whether to show a loading bar in graph operations.
        ///
        pub fn get_node_report_from_node_id(&self, node_id: NodeT) -> Result<String> {
            self.validate_node_id(node_id)?;
            let mut partial_reports: Vec<String> = Vec::new();
            let node_name = unsafe { self.get_unchecked_node_name_from_node_id(node_id) };
            partial_reports.push(
                if unsafe { self.is_unchecked_singleton_from_node_id(node_id) } {
                    match self.get_singleton_nodes_number() {
                        1 => {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "The given node ",
                                    " is the only singleton node of the graph.",
                                ],
                                &match (&node_name,) {
                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                        arg0,
                                        ::core::fmt::Display::fmt,
                                    )],
                                },
                            ));
                            res
                        }
                        singleton_nodes_number => {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["The given node ", " is one of ", " singleton nodes."],
                                &match (&node_name, &singleton_nodes_number) {
                                    (arg0, arg1) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                    ],
                                },
                            ));
                            res
                        }
                    }
                } else if self.is_singleton_with_selfloops_from_node_id(node_id) {
                    match self.get_singleton_nodes_with_selfloops_number() {
                        1 => {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "The given node ",
                                    " is the only singleton node with selfloops in the graph.",
                                ],
                                &match (&node_name,) {
                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                        arg0,
                                        ::core::fmt::Display::fmt,
                                    )],
                                },
                            ));
                            res
                        }
                        singleton_nodes_with_selfloops_number => {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "The given node ",
                                    " is one of ",
                                    " singleton nodes with selfloops.",
                                ],
                                &match (&node_name, &singleton_nodes_with_selfloops_number) {
                                    (arg0, arg1) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                    ],
                                },
                            ));
                            res
                        }
                    }
                } else if unsafe { self.is_unchecked_trap_node_from_node_id(node_id) } {
                    match self.get_trap_nodes_number() {
                        1 => {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["The given node ", " is the only trap node in the graph."],
                                &match (&node_name,) {
                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                        arg0,
                                        ::core::fmt::Display::fmt,
                                    )],
                                },
                            ));
                            res
                        }
                        trap_nodes_number => {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "The given node ",
                                    " is one of ",
                                    " trap nodes in the graph.",
                                ],
                                &match (&node_name, &trap_nodes_number) {
                                    (arg0, arg1) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                    ],
                                },
                            ));
                            res
                        }
                    }
                } else {
                    {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["The given node ", " has degree "],
                            &match (&node_name, &unsafe {
                                self.get_unchecked_node_degree_from_node_id(node_id)
                            }) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ],
                            },
                        ));
                        res
                    }
                },
            );
            Ok(partial_reports.join(""))
        }
        /// Return human-readable html report of the given node.
        ///
        /// The report, by default, is rendered using html.
        ///
        /// # Arguments
        /// * `node_name`: &str - Whether to show a loading bar in graph operations.
        ///
        pub fn get_node_report_from_node_name(&self, node_name: &str) -> Result<String> {
            self.get_node_id_from_node_name(node_name)
                .and_then(|node_id| self.get_node_report_from_node_id(node_id))
        }
        /// Returns html formatting for the given node name URLs.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - Node ID to query for.
        ///
        /// # Safety
        /// This method will cause an out of bound if the given node ID does not exist.
        unsafe fn get_unchecked_succinct_node_description(&self, node_id: NodeT) -> String {
            let node_name = self.get_unchecked_node_name_from_node_id(node_id);
            let node_name = get_node_source_html_url_from_node_name(node_name.as_ref());
            let node_type = if self.has_node_types() {
                match self.get_unchecked_node_type_names_from_node_id(node_id) {
                    Some(node_type_names) => {
                        match node_type_names.len() {
                            1 => Some({
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &["node type "],
                                    &match (&get_node_type_source_html_url_from_node_type_name(
                                        node_type_names.first().unwrap().as_ref(),
                                    ),)
                                    {
                                        (arg0,) => [::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        )],
                                    },
                                ));
                                res
                            }),
                            _ => {
                                Some({
                                    let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["node types "] , & match (& self . get_unchecked_formatted_list (node_type_names . iter () . map (| node_type_name | { get_node_type_source_html_url_from_node_type_name (node_type_name) }) . collect :: < Vec < _ > > () . as_ref ()) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ;
                                    res
                                })
                            }
                        }
                    }
                    None => Some("unknown node type".to_string()),
                }
            } else {
                None
            };
            let mut node_degree = match self.get_node_degree_from_node_id(node_id) {
                Ok(degree) => {
                    if degree == 0 {
                        None
                    } else {
                        Some({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["degree "],
                                &match (&degree,) {
                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                        arg0,
                                        ::core::fmt::Display::fmt,
                                    )],
                                },
                            ));
                            res
                        })
                    }
                }
                Err(_) => None,
            };
            if self.has_edge_weights() {
                node_degree = node_degree.map(|degree_string| {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1_formatted(
                        &["", "", " weighted degree "],
                        &match (
                            &degree_string,
                            &if node_type.is_some() { "," } else { " and" },
                            &self.get_unchecked_node_degree_from_node_id(node_id),
                        ) {
                            (arg0, arg1, arg2) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ],
                        },
                        &[
                            ::core::fmt::rt::v1::Argument {
                                position: 0usize,
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: 1usize,
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: 2usize,
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Is(2usize),
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                        ],
                    ));
                    res
                });
            }
            let description = if node_degree.is_some() || node_type.is_some() {
                let node_degree_is_some = node_degree.is_some();
                {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[" (", "", "", ")"],
                        &match (
                            &node_degree.unwrap_or_else(|| "".to_string()),
                            &if node_degree_is_some && node_type.is_some() {
                                " and "
                            } else {
                                ""
                            },
                            &node_type.unwrap_or_else(|| "".to_string()),
                        ) {
                            (arg0, arg1, arg2) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                }
            } else {
                "".to_string()
            };
            {
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &["", ""],
                    &match (&node_name, &description) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ],
                    },
                ));
                res
            }
        }
        /// Returns html formatting for the given node name URLs.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - Node ID to query for.
        ///
        /// # Safety
        /// This method will cause an out of bound if the given edge ID does not exist.
        unsafe fn get_unchecked_succinct_edge_description(&self, edge_id: EdgeT) -> String {
            {
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &["edge between ", " and ", ""],
                    &match (
                        &self.get_unchecked_succinct_node_description(
                            self.get_unchecked_source_node_id_from_edge_id(edge_id),
                        ),
                        &self.get_unchecked_succinct_node_description(
                            self.get_unchecked_destination_node_id_from_edge_id(edge_id),
                        ),
                        &if self.has_edge_types() {
                            match self.get_edge_type_name_from_edge_id(edge_id).unwrap() {
                                Some(edge_type_name) => {
                                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                        &[" with edge type "],
                                        &match (&get_edge_type_source_html_url_from_edge_type_name(
                                            edge_type_name.as_ref(),
                                        ),)
                                        {
                                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                                arg0,
                                                ::core::fmt::Display::fmt,
                                            )],
                                        },
                                    ));
                                    res
                                }
                                None => " with unknown edge type".to_string(),
                            }
                        } else {
                            "".to_string()
                        },
                    ) {
                        (arg0, arg1, arg2) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ],
                    },
                ));
                res
            }
        }
        /// Returns summary of the high level characteristics of a graph.
        ///
        /// # Implementative details
        /// The method currently supports multiple use cases, including:
        /// * Graphs without nodes
        /// * Graphs without edges
        /// * Normal graphs
        fn get_textual_report_summary(&self) -> String {
            let mut report = Vec::new();
            let name = if self.has_default_graph_name() {
                None
            } else {
                report.push({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["<h2>", "</h2>"],
                        &match (&self.get_name(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                });
                Some({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[" "],
                        &match (&self.get_name(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })
            };
            if !self.has_nodes() {
                report . push ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The graph" , " is <b>empty</b>, that is, it has neither nodes nor edges.\nIf this is unexpected, it may have happened because of a mis-parametrization of a filter method uphill.\n"] , & match (& name . unwrap_or_else (| | "" . to_string ()) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res }) ;
                return report.join("");
            }
            let nodes_number = unsafe {
                match self.get_nodes_number() {
                    1 => {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["a single node called "],
                            &match (&self.get_unchecked_succinct_node_description(0),) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    }
                    nodes_number => {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["", "", " nodes"],
                            &match (
                                &nodes_number,
                                &match self.get_node_types_number() {
                                    Ok(n) => {
                                        if n == 1 {
                                            " homogeneous"
                                        } else {
                                            " heterogenous"
                                        }
                                    }
                                    Err(_) => "",
                                },
                            ) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ],
                            },
                        ));
                        res
                    }
                }
            };
            if !self.has_edges() {
                report . push ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The graph" , " contains " , " and no edges.\nIf this is unexpected, it may have happened because of a mis-parametrization of a filter method uphill.\n"] , & match (& name . unwrap_or_else (| | "" . to_string ()) , & nodes_number) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , })) ; res }) ;
                return report.join("");
            }
            let edges_number = unsafe {
                match self.get_edges_number() {
                    1 => {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["a single "],
                            &match (&self.get_unchecked_succinct_edge_description(0),) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    }
                    edges_number => {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["", "", " edges"],
                            &match (
                                &edges_number,
                                &match self.get_edge_types_number() {
                                    Ok(n) => {
                                        if n == 1 {
                                            " homogeneous"
                                        } else {
                                            " heterogenous"
                                        }
                                    }
                                    Err(_) => "",
                                },
                            ) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ],
                            },
                        ));
                        res
                    }
                }
            };
            report.push({
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &["The ", "", " graph", " has ", " and ", ".\n"],
                    &match (
                        &if self.is_directed() {
                            "directed"
                        } else {
                            "undirected"
                        },
                        &if self.is_multigraph() {
                            " multigraph"
                        } else {
                            ""
                        },
                        &name.unwrap_or_else(|| "".to_string()),
                        &nodes_number,
                        &edges_number,
                    ) {
                        (arg0, arg1, arg2, arg3, arg4) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg4, ::core::fmt::Display::fmt),
                        ],
                    },
                ));
                res
            });
            report.join("")
        }
        /// Returns report on the unweighted node degree centrality.
        ///
        /// # Safety
        /// This method may cause a panic when called on a graph with no edges.
        unsafe fn get_node_degree_centrality_report(&self) -> String {
            {
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1_formatted(
                    &[
                        "<h3>Degree centrality</h3>The minimum node degree is ",
                        ", the maximum node degree is ",
                        ", the mode degree is ",
                        ", the mean degree is ",
                        " and the node degree median is ",
                        ".\nThe nodes with highest degree centrality are: ",
                        ".\n",
                    ],
                    &match (
                        &self.get_minimum_node_degree().unwrap(),
                        &self.get_maximum_node_degree().unwrap(),
                        &self.get_node_degrees_mode().unwrap(),
                        &self.get_node_degrees_mean().unwrap(),
                        &self.get_node_degrees_median().unwrap(),
                        &self.get_unchecked_formatted_list(
                            self.get_top_k_central_node_ids(5)
                                .unwrap()
                                .into_iter()
                                .filter(|node_id| {
                                    self.get_unchecked_node_degree_from_node_id(*node_id) > 0
                                })
                                .map(|node_id| {
                                    self.get_unchecked_succinct_node_description(node_id)
                                })
                                .collect::<Vec<_>>()
                                .as_ref(),
                        ),
                    ) {
                        (arg0, arg1, arg2, arg3, arg4, arg5) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg4, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg5, ::core::fmt::Display::fmt),
                        ],
                    },
                    &[
                        ::core::fmt::rt::v1::Argument {
                            position: 0usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 1usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 2usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 3usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Is(2usize),
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 4usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 5usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                    ],
                ));
                res
            }
        }
        /// Returns report on the singleton nodes of the graph.
        ///
        /// # Safety
        /// This method may cause a panic when called on graphs without
        /// singleton nodes.
        unsafe fn get_singleton_nodes_report(&self) -> String {
            {
                let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["<h4>Singleton nodes</h4>Singleton nodes are nodes with no edge to other nodes nor selfloops.\nThe graph contains " , ".\n"] , & match (& match self . get_singleton_nodes_number () { 1 => { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["a singleton node, which is "] , & match (& self . get_unchecked_succinct_node_description (self . iter_singleton_node_ids () . next () . unwrap ()) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } singleton_nodes_number => { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["" , " singleton nodes, which are " , ""] , & match (& singleton_nodes_number , & self . get_unchecked_formatted_list (self . iter_singleton_node_ids () . take (5) . map (| node_id | { self . get_unchecked_succinct_node_description (node_id) }) . collect :: < Vec < _ > > () . as_ref ()) , & if singleton_nodes_number > 5 { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& [", plus other " , " singleton nodes"] , & match (& (singleton_nodes_number - 5) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } } else { "." . to_string () }) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt)] , })) ; res } } } ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ;
                res
            }
        }
        /// Returns report on the singleton nodes with selfloops of the graph.
        ///
        /// # Safety
        /// This method may cause a panic when called on graphs without
        /// singleton nodes with selfloops.
        unsafe fn get_singleton_nodes_with_selfloops_report(&self) -> String {
            {
                let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["<h4>Singleton nodes with selfloops</h4>Singleton nodes with selfloops are nodes with no edge to other nodes and have exclusively selfloops.\nThe graph contains " , ".\n"] , & match (& match self . get_singleton_nodes_with_selfloops_number () { 1 => { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["a singleton node with selfloop, which is "] , & match (& self . get_unchecked_succinct_node_description (self . iter_singleton_nodes_with_selfloops_node_ids () . next () . unwrap ()) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } singleton_nodes_with_selfloops_number => { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["" , " singleton nodes with selfloops, which are " , ""] , & match (& singleton_nodes_with_selfloops_number , & self . get_unchecked_formatted_list (self . iter_singleton_nodes_with_selfloops_node_ids () . take (5) . map (| node_id | { self . get_unchecked_succinct_node_description (node_id) }) . collect :: < Vec < _ > > () . as_ref ()) , & if singleton_nodes_with_selfloops_number > 5 { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& [", plus other " , " singleton nodes with selfloops"] , & match (& (singleton_nodes_with_selfloops_number - 5) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } } else { "" . to_string () }) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt)] , })) ; res } } } ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ;
                res
            }
        }
        /// Returns report on the disconnected nodes.
        ///
        /// # Safety
        /// This method may cause a panic when called on graphs without
        /// disconnected nodes.
        unsafe fn get_disconnected_nodes_report(&self) -> String {
            let mut paragraphs = Vec::new();
            paragraphs . push ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["<h3>Disconnected nodes</h3>Disconnected nodes are nodes that are not connected to any other node.\nThe graph contains " , " disconnected nodes.\n"] , & match (& self . get_disconnected_nodes_number () ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res }) ;
            if self.has_singleton_nodes() {
                paragraphs.push(self.get_singleton_nodes_report());
            }
            if self.has_singleton_nodes_with_selfloops() {
                paragraphs.push(self.get_singleton_nodes_with_selfloops_report());
            }
            paragraphs.join("")
        }
        /// Returns report on the graph edge weights
        ///
        /// # Safety
        /// This method may cause a panic when called on graphs that do not contain
        /// edge weights.
        ///
        /// TODO! Add formatting for cases with constant weights.
        /// TODO! Add formatting for cases with negative edge weights.
        unsafe fn get_edge_weights_report(&self) -> String {
            {
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1_formatted(
                    &[
                        "<h3>Weights</h3>\n<p>The minimum edge weight is ",
                        ", the maximum edge weight is ",
                        " and the total edge weight is ",
                        ".</p>\n<h4>Weighted degree centrality</h4><p>The minimum node degree is ",
                        ", the maximum node degree is ",
                        ", the mean degree is ",
                        " and the node degree median is ",
                        ".</p>\n<p>The nodes with highest degree centrality are: ",
                        ".</p>\n",
                    ],
                    &match (
                        &self.get_mininum_edge_weight().unwrap(),
                        &self.get_maximum_edge_weight().unwrap(),
                        &self.get_total_edge_weights().unwrap(),
                        &self.get_weighted_mininum_node_degree().unwrap(),
                        &self.get_weighted_maximum_node_degree().unwrap(),
                        &self.get_weighted_node_degrees_mean().unwrap(),
                        &self.get_weighted_node_degrees_median().unwrap(),
                        &self.get_unchecked_formatted_list(
                            self.get_weighted_top_k_central_node_ids(5)
                                .unwrap()
                                .into_iter()
                                .map(|node_id| {
                                    self.get_unchecked_succinct_node_description(node_id)
                                })
                                .collect::<Vec<_>>()
                                .as_ref(),
                        ),
                    ) {
                        (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg4, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg5, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg6, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg7, ::core::fmt::Display::fmt),
                        ],
                    },
                    &[
                        ::core::fmt::rt::v1::Argument {
                            position: 0usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 1usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 2usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 3usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Is(2usize),
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 4usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Is(2usize),
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 5usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Is(2usize),
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 6usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Is(2usize),
                            },
                        },
                        ::core::fmt::rt::v1::Argument {
                            position: 7usize,
                            format: ::core::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::core::fmt::rt::v1::Count::Implied,
                                width: ::core::fmt::rt::v1::Count::Implied,
                            },
                        },
                    ],
                ));
                res
            }
        }
        /// Returns report on the singleton node types of the graph.
        ///
        /// # Safety
        /// This method may cause a panic when called on graphs without
        /// singleton node types.
        unsafe fn get_singleton_nodes_types_report(&self) -> String {
            {
                let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["<h4>Singleton node types</h4>Singleton node types are node types that are assigned exclusively to a single node, making the node type relatively meaningless, as it adds no more information then the name of node itself.\nThe graph contains " , ".\n"] , & match (& match self . get_singleton_node_types_number () . unwrap () { 1 => { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["a singleton node type, which is "] , & match (& get_node_type_source_html_url_from_node_type_name (self . iter_singleton_node_type_names () . unwrap () . next () . unwrap () . as_ref ()) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } singleton_nodes_types_number => { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["" , " singleton node types, which are " , ""] , & match (& singleton_nodes_types_number , & self . get_unchecked_formatted_list (self . iter_singleton_node_type_names () . unwrap () . take (5) . map (| node_type_name | { get_node_type_source_html_url_from_node_type_name (node_type_name . as_ref ()) }) . collect :: < Vec < _ > > () . as_ref ()) , & if singleton_nodes_types_number > 5 { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& [", plus other " , " singleton node types"] , & match (& (singleton_nodes_types_number - 5) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } } else { "" . to_string () }) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt)] , })) ; res } } } ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ;
                res
            }
        }
        /// Returns report on the unknown types of the graph.
        ///
        /// # Safety
        /// This method may cause a panic when called on graphs without
        /// unknown types.
        unsafe fn get_unknown_node_types_report(&self) -> String {
            {
                let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1_formatted (& ["<h4>Unknown node types</h4>Nodes with unknown node types are nodes with a node type that was not provided during the creation of the graph, which may be desired as the output of a node-label holdout.\nThe graph contains " , ", making up " , " of the nodes.\n"] , & match (& (self . get_unknown_node_types_rate () . unwrap () * 100.0) , & match self . get_unknown_node_types_number () . unwrap () { 1 => { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["a node with unknown node type, which is "] , & match (& self . get_unchecked_succinct_node_description (self . iter_node_ids_with_unknown_node_types () . unwrap () . next () . unwrap ()) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } unknown_node_types_number => { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["" , " nodes with unknown node type, which are " , ""] , & match (& unknown_node_types_number , & self . get_unchecked_formatted_list (self . iter_node_ids_with_unknown_node_types () . unwrap () . take (5) . map (| node_id | { self . get_unchecked_succinct_node_description (node_id) }) . collect :: < Vec < _ > > () . as_ref ()) , & if unknown_node_types_number > 5 { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& [", plus other " , " nodes with unknown node types"] , & match (& (unknown_node_types_number - 5) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } } else { "" . to_string () }) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt)] , })) ; res } } }) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , } , & [:: core :: fmt :: rt :: v1 :: Argument { position : 1usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Implied , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , } , :: core :: fmt :: rt :: v1 :: Argument { position : 0usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Is (2usize) , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , }])) ;
                res
            }
        }
        /// Returns report on the graph node types.
        ///
        /// # Safety
        /// This method may raise a panic when called on graph instances
        /// without node types.
        ///
        /// TODO! Add paragram handling the corner case where all node types are unknown.
        unsafe fn get_node_types_report(&self) -> String {
            let mut paragraphs = Vec::new();
            paragraphs . push ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["<h3>Node types</h3>The graph has " , ".\n"] , & match (& match self . get_node_types_number () . unwrap () { 1 => { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["a single node type, which is " , ". Note that this means that all nodes have the same node type, that is, all nodes are homogeneous."] , & match (& get_node_type_source_html_url_from_node_type_name (self . get_node_type_name_from_node_type_id (0) . unwrap () . as_ref ()) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } node_types_number => { let mut node_type_counts = self . get_node_type_names_counts_hashmap () . unwrap () . into_iter () . collect :: < Vec < _ > > () ; node_type_counts . sort_by (| (_ , a) , (_ , b) | b . cmp (a)) ; let node_type_descriptions = self . get_unchecked_formatted_list (node_type_counts . into_iter () . take (5) . map (| (node_type_name , count) | { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1_formatted (& ["" , " (" , " nodes, " , "%)"] , & match (& get_node_type_source_html_url_from_node_type_name (node_type_name . as_ref ()) , & count , & ((count as f64 / self . get_nodes_number () as f64) * 100.0)) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt)] , } , & [:: core :: fmt :: rt :: v1 :: Argument { position : 0usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Implied , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , } , :: core :: fmt :: rt :: v1 :: Argument { position : 1usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Implied , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , } , :: core :: fmt :: rt :: v1 :: Argument { position : 2usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Is (2usize) , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , }])) ; res } }) . collect :: < Vec < _ > > () . as_ref ()) ; { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["" , " node types, " , " "] , & match (& node_types_number , & if node_types_number > 5 { "of which the 5 most common are" } else { "which are" } , & node_type_descriptions) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt)] , })) ; res } } } ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res }) ;
            if self.has_singleton_node_types().unwrap() {
                paragraphs.push(self.get_singleton_nodes_types_report());
            }
            if self.has_unknown_node_types().unwrap() {
                paragraphs.push(self.get_unknown_node_types_report());
            }
            paragraphs.join("")
        }
        /// Returns report on the singleton edge types of the graph.
        ///
        /// # Safety
        /// This method may cause a panic when called on graphs without
        /// singleton edge types.
        unsafe fn get_singleton_edges_types_report(&self) -> String {
            {
                let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["<h4>Singleton edge types</h4>Singleton edge types are edge types that are assigned exclusively to a single edge, making the edge type relatively meaningless, as it adds no more information then the name of edge itself.\nThe graph contains "] , & match (& match self . get_singleton_edge_types_number () . unwrap () { 1 => { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["a edge with singleton edge type, which is " , "."] , & match (& get_edge_type_source_html_url_from_edge_type_name (self . iter_singleton_edge_type_names () . unwrap () . next () . unwrap () . as_ref ()) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } singleton_edges_types_number => { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["" , " edges with singleton edge types, which are " , "" , ".\n"] , & match (& singleton_edges_types_number , & self . get_unchecked_formatted_list (self . iter_singleton_edge_type_names () . unwrap () . take (5) . map (| edge_type_name | { get_edge_type_source_html_url_from_edge_type_name (edge_type_name . as_ref ()) }) . collect :: < Vec < _ > > () . as_ref ()) , & if singleton_edges_types_number > 5 { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& [", plus other " , " edges with singleton edge types"] , & match (& (singleton_edges_types_number - 5) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } } else { "" . to_string () }) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt)] , })) ; res } } } ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ;
                res
            }
        }
        /// Returns report on the unknown edge types of the graph.
        ///
        /// # Safety
        /// This method may cause a panic when called on graphs without
        /// unknown types.
        unsafe fn get_unknown_edge_types_report(&self) -> String {
            {
                let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1_formatted (& ["<h4>Unknown edge types</h4>Edges with unknown edge types are edges with a edge type that was not provided during the creation of the graph, which may be desired as the output of a edge-label holdout.\nThe graph contains " , ", making up " , " of the edges.\n"] , & match (& (self . get_unknown_edge_types_rate () . unwrap () * 100.0) , & match self . get_unknown_edge_types_number () . unwrap () { 1 => { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["a edge with unknown edge type, which is " , "."] , & match (& self . get_unchecked_succinct_edge_description (self . iter_edge_ids_with_unknown_edge_types () . unwrap () . next () . unwrap ()) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } unknown_types_number => { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["" , " edges with unknown edge type, which are " , "" , ".\n"] , & match (& unknown_types_number , & self . get_unchecked_formatted_list (self . iter_edge_ids_with_unknown_edge_types () . unwrap () . take (5) . map (| edge_id | { self . get_unchecked_succinct_edge_description (edge_id) }) . collect :: < Vec < _ > > () . as_ref ()) , & if unknown_types_number > 5 { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& [", plus other " , " edges with unknown edge types"] , & match (& (unknown_types_number - 5) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } } else { "" . to_string () }) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt)] , })) ; res } } }) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , } , & [:: core :: fmt :: rt :: v1 :: Argument { position : 1usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Implied , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , } , :: core :: fmt :: rt :: v1 :: Argument { position : 0usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Is (2usize) , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , }])) ;
                res
            }
        }
        /// Returns report on the graph edge types.
        ///
        /// # Safety
        /// This method may raise a panic when called on graph instances
        /// without edge types.
        ///
        /// TODO! Add paragram handling the corner case where all edge types are unknown.
        unsafe fn get_edge_types_report(&self) -> String {
            let mut paragraphs = Vec::new();
            paragraphs . push ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["<h3>Edge types</h3>The graph has " , ".\n"] , & match (& match self . get_edge_types_number () . unwrap () { 1 => { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["a single edge type, which is " , ". Note that this means that all edges have the same edge type, that is, all edges are homogeneous."] , & match (& get_edge_type_source_html_url_from_edge_type_name (self . get_edge_type_name_from_edge_type_id (0) . unwrap () . as_ref ()) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res } edge_types_number => { let mut edge_type_counts = self . get_edge_type_names_counts_hashmap () . unwrap () . into_iter () . collect :: < Vec < _ > > () ; edge_type_counts . sort_by (| (_ , a) , (_ , b) | b . cmp (a)) ; let edge_type_descriptions = self . get_unchecked_formatted_list (edge_type_counts . into_iter () . take (5) . map (| (edge_type_name , count) | { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1_formatted (& ["" , " (" , " edges, " , "%)"] , & match (& get_edge_type_source_html_url_from_edge_type_name (edge_type_name . as_ref ()) , & count , & ((count as f64 / self . get_directed_edges_number () as f64) * 100.0)) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt)] , } , & [:: core :: fmt :: rt :: v1 :: Argument { position : 0usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Implied , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , } , :: core :: fmt :: rt :: v1 :: Argument { position : 1usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Implied , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , } , :: core :: fmt :: rt :: v1 :: Argument { position : 2usize , format : :: core :: fmt :: rt :: v1 :: FormatSpec { fill : ' ' , align : :: core :: fmt :: rt :: v1 :: Alignment :: Unknown , flags : 0u32 , precision : :: core :: fmt :: rt :: v1 :: Count :: Is (2usize) , width : :: core :: fmt :: rt :: v1 :: Count :: Implied , } , }])) ; res } }) . collect :: < Vec < _ > > () . as_ref ()) ; { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["" , " edge types, " , " "] , & match (& edge_types_number , & if edge_types_number > 5 { "of which the 5 most common are" } else { "which are" } , & edge_type_descriptions) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt)] , })) ; res } } } ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) ; res }) ;
            if self.has_singleton_edge_types().unwrap() {
                paragraphs.push(self.get_singleton_edges_types_report());
            }
            if self.has_unknown_edge_types().unwrap() {
                paragraphs.push(self.get_unknown_edge_types_report());
            }
            paragraphs.join("")
        }
        /// Return html short textual report of the graph.
        ///
        /// TODO! Add reports on triangles
        /// TODO! Add reports on connected components
        /// TODO! Add reports on various node metrics
        /// TODO! Add reports on various edge metrics
        /// NOTE! Most of the above TODOs will require first to implement the
        /// support for the fast computation of the inbound edges in a directed
        /// graphs.
        pub fn textual_report(&self) -> String {
            let mut paragraphs = Vec::new();
            paragraphs.push(self.get_textual_report_summary());
            if self.has_edges() {
                paragraphs.push(unsafe { self.get_node_degree_centrality_report() });
            }
            if self.has_disconnected_nodes() {
                paragraphs.push(unsafe { self.get_disconnected_nodes_report() });
            }
            if self.has_edge_weights() {
                paragraphs.push(unsafe { self.get_edge_weights_report() });
            }
            if self.has_node_types() && self.has_known_node_types().unwrap() {
                paragraphs.push(unsafe { self.get_node_types_report() });
            }
            if self.has_edge_types() && self.has_known_edge_types().unwrap() {
                paragraphs.push(unsafe { self.get_edge_types_report() });
            }
            paragraphs.join("").replace("\n", "<br>")
        }
    }
}
pub use self::report::*;
mod queries {
    use super::*;
    use permutation::permutation;
    /// # Queries
    /// The naming convention we follow is:
    /// * `/get_(.+?)_from_(.+)/`
    /// * `/get_(.+?)_from_(.+)_unchecked/`
    impl Graph {
        /// Returns option with the weight of the given edge id.
        ///
        /// This method will raise a panic if the given edge ID is higher than
        /// the number of edges in the graph. Additionally, it will simply
        /// return None if there are no graph weights.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge whose edge weight is to be returned.
        ///
        /// # Safety
        /// If the given edge ID does not exists in the graph this method will panic.
        pub unsafe fn get_unchecked_edge_weight_from_edge_id(
            &self,
            edge_id: EdgeT,
        ) -> Option<WeightT> {
            self.weights.as_ref().map(|ws| ws[edge_id as usize])
        }
        /// Returns option with the weight of the given node ids.
        ///
        /// This method will raise a panic if the given node IDs are higher than
        /// the number of nodes in the graph.
        ///
        /// # Arguments
        /// * `src`: NodeT - The source node ID.
        /// * `dst`: NodeT - The destination node ID.
        ///
        /// # Safety
        /// If either of the two given node IDs does not exists in the graph.
        pub unsafe fn get_unchecked_edge_weight_from_node_ids(
            &self,
            src: NodeT,
            dst: NodeT,
        ) -> WeightT {
            self.get_unchecked_edge_weight_from_edge_id(
                self.get_unchecked_edge_id_from_node_ids(src, dst),
            )
            .unwrap_unchecked()
        }
        /// Returns node id from given node name raising a panic if used unproperly.
        ///
        /// # Arguments
        /// * `node_name`: &str - The node name whose node ID is to be returned.
        ///
        /// # Safety
        /// If the given node name does not exists in the considered graph the method will panic.
        pub unsafe fn get_unchecked_node_id_from_node_name(&self, node_name: &str) -> NodeT {
            *self.nodes.get(node_name).unwrap()
        }
        /// Return edge type ID corresponding to the given edge type name.
        ///
        /// # Arguments
        /// * `edge_type_name`: &str - The edge type name whose edge type ID is to be returned.
        ///
        /// # Safety
        /// If the given edge type name does not exists in the considered graph the method will panic.
        pub unsafe fn get_unchecked_edge_type_id_from_edge_type_name(
            &self,
            edge_type_name: &str,
        ) -> Option<EdgeTypeT> {
            self.edge_types
                .as_ref()
                .and_then(|ets| ets.get(edge_type_name).copied())
        }
        /// Return edge type ID corresponding to the given edge type name
        /// raising panic if edge type ID does not exists in current graph.
        ///
        /// # Arguments
        /// * `edge_type_id`: Option<EdgeTypeT> - The edge type naIDme whose edge type name is to be returned.
        ///
        /// # Safety
        /// If the given edge type ID does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_edge_type_name_from_edge_type_id(
            &self,
            edge_type_id: Option<EdgeTypeT>,
        ) -> Option<String> {
            match (&self.edge_types, edge_type_id) {
                (Some(ets), Some(et)) => Some(ets.unchecked_translate(et)),
                _ => None,
            }
        }
        /// Return number of edges of the given edge type without checks.
        ///
        /// # Arguments
        /// * `edge_type`: Option<EdgeTypeT> - The edge type to retrieve count of.
        ///
        /// # Safety
        /// If the given edge type ID does not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_edge_count_from_edge_type_id(
            &self,
            edge_type: Option<EdgeTypeT>,
        ) -> EdgeT {
            match (&self.edge_types, edge_type) {
                (Some(ets), None) => ets.get_unknown_count(),
                (Some(ets), Some(et)) => ets.counts[et as usize],
                _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                    &["internal error: entered unreachable code: "],
                    &match (&"The current graph instance does not have edge types!",) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                )),
            }
        }
        /// Return number of nodes of the given node type without checks.
        ///
        /// # Arguments
        /// * node_type: Option<NodeTypeT> - The node type to retrieve count of.
        pub(crate) fn get_unchecked_node_count_from_node_type_id(
            &self,
            node_type: Option<NodeTypeT>,
        ) -> NodeT {
            match (&self.node_types, node_type) {
                (Some(nts), None) => nts.get_unknown_count(),
                (Some(nts), Some(nt)) => nts.counts[nt as usize],
                _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                    &["internal error: entered unreachable code: "],
                    &match (&"The current graph instance does not have node types!",) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                )),
            }
        }
        /// Return edge ID without any checks for given tuple of nodes and edge type.
        ///
        /// # Arguments
        /// * `src`: NodeT - Source node of the edge.
        /// * `dst`: NodeT - Destination node of the edge.
        /// * `edge_type`: Option<EdgeTypeT> - Edge Type of the edge.
        ///
        /// # Safety
        /// If the given node IDs or edge type does not exists in the graph this method will panic.
        pub unsafe fn get_unchecked_edge_id_from_node_ids_and_edge_type_id(
            &self,
            src: NodeT,
            dst: NodeT,
            edge_type: Option<EdgeTypeT>,
        ) -> EdgeT {
            self.edge_types.as_ref().map_or_else(
                || self.get_unchecked_edge_id_from_node_ids(src, dst),
                |ets| {
                    self.iter_unchecked_edge_ids_from_node_ids(src, dst)
                        .find(|edge_id| ets.ids[*edge_id as usize] == edge_type)
                        .unwrap()
                },
            )
        }
        /// Return range of outbound edges IDs for all the edges bewteen the given
        /// source and destination nodes.
        /// This operation is meaningfull only in a multigraph.
        ///
        /// # Arguments
        ///
        /// * `src`: NodeT - Source node.
        /// * `dst`: NodeT - Destination node.
        ///
        /// # Safety
        /// If the given node type IDs do not exist in the graph this method will panic.
        pub unsafe fn get_unchecked_minmax_edge_ids_from_node_ids(
            &self,
            src: NodeT,
            dst: NodeT,
        ) -> (EdgeT, EdgeT) {
            (
                self.get_unchecked_edge_id_from_node_ids(src, dst),
                self.get_unchecked_edge_id_from_node_ids(src, dst + 1),
            )
        }
        /// Return the number of edges between the given source and destination nodes.
        ///
        /// This might be thought as the degree of an edge in a multigraph.
        /// On non-multigraph this trivially return 1 on existing edges and 0 on
        /// the non-existing ones.
        ///
        /// # Arguments
        ///
        /// * `src`: NodeT - Source node.
        /// * `dst`: NodeT - Destination node.
        ///
        pub(crate) fn get_unchecked_edge_degree_from_node_ids(
            &self,
            src: NodeT,
            dst: NodeT,
        ) -> EdgeT {
            let (min_edge_id, max_edge_id) =
                unsafe { self.get_unchecked_minmax_edge_ids_from_node_ids(src, dst) };
            max_edge_id - min_edge_id
        }
        #[inline(always)]
        /// Returns node IDs corresponding to given edge ID.
        ///
        /// The method will panic if the given edge ID does not exists in the
        /// current graph instance.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose source and destination node IDs are to e retrieved.
        ///
        /// # Example
        /// To retrieve the source and destination node IDs of a given edge ID you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let edge_id = 0;
        /// let (src, dst) = unsafe { graph.get_unchecked_node_ids_from_edge_id(edge_id) };
        /// println!("The edge with ID {} has source node ID {} and destination node ID {}.", edge_id, src, dst);
        /// ```
        ///
        /// # Safety
        /// If the given edge ID does not exist in the current graph the method will raise a panic.
        pub unsafe fn get_unchecked_node_ids_from_edge_id(&self, edge_id: EdgeT) -> (NodeT, NodeT) {
            if let (Some(sources), Some(destinations)) = (&self.sources, &self.destinations) {
                return (sources[edge_id as usize], destinations[edge_id as usize]);
            }
            self.decode_edge(self.edges.unchecked_select(edge_id))
        }
        /// Returns node names corresponding to given edge ID.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose source and destination node IDs are to e retrieved.
        ///
        /// # Safety
        /// If the given edge ID does not exist in the current graph the method will raise a panic.
        pub unsafe fn get_unchecked_node_names_from_edge_id(
            &self,
            edge_id: EdgeT,
        ) -> (String, String) {
            let (src, dst) = self.get_unchecked_node_ids_from_edge_id(edge_id);
            (
                self.get_unchecked_node_name_from_node_id(src),
                self.get_unchecked_node_name_from_node_id(dst),
            )
        }
        /// Returns the source of given edge id without making any boundary check.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose source is to be retrieved.
        ///
        /// # Safety
        /// If the given edge ID does not exist in the current graph the method will cause an out of bounds.
        pub unsafe fn get_unchecked_source_node_id_from_edge_id(&self, edge_id: EdgeT) -> NodeT {
            self.sources.as_ref().map_or_else(
                || self.get_unchecked_node_ids_from_edge_id(edge_id).0,
                |srscs| srscs[edge_id as usize],
            )
        }
        /// Returns the destination of given edge id without making any boundary check.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose destination is to be retrieved.
        ///
        /// # Safety
        /// If the given edge ID does not exist in the current graph the method will cause an out of bounds.
        pub unsafe fn get_unchecked_destination_node_id_from_edge_id(
            &self,
            edge_id: EdgeT,
        ) -> NodeT {
            self.destinations.as_ref().map_or_else(
                || self.get_unchecked_node_ids_from_edge_id(edge_id).1,
                |dsts| dsts[edge_id as usize],
            )
        }
        /// Returns source node ID corresponding to given edge ID.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose source node ID is to be retrieved.
        ///
        /// # Raises
        /// * If the given edge ID does not exist in the current graph.
        pub fn get_source_node_id_from_edge_id(&self, edge_id: EdgeT) -> Result<NodeT> {
            self.validate_edge_id(edge_id)
                .map(|edge_id| unsafe { self.get_unchecked_source_node_id_from_edge_id(edge_id) })
        }
        /// Returns destination node ID corresponding to given edge ID.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose destination node ID is to be retrieved.
        ///
        /// # Raises
        /// * If the given edge ID does not exist in the current graph.
        pub fn get_destination_node_id_from_edge_id(&self, edge_id: EdgeT) -> Result<NodeT> {
            self.validate_edge_id(edge_id).map(|edge_id| unsafe {
                self.get_unchecked_destination_node_id_from_edge_id(edge_id)
            })
        }
        /// Returns source node name corresponding to given edge ID.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose source node name is to be retrieved.
        ///
        /// # Safety
        /// If the given edge ID does not exist in the current graph the method will raise a panic.
        pub unsafe fn get_unchecked_source_node_name_from_edge_id(&self, edge_id: EdgeT) -> String {
            self.get_unchecked_node_name_from_node_id(
                self.get_unchecked_source_node_id_from_edge_id(edge_id),
            )
        }
        /// Returns destination node name corresponding to given edge ID.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose destination node name is to be retrieved.
        ///
        /// # Safety
        /// If the given edge ID does not exist in the current graph the method will raise a panic.
        pub unsafe fn get_unchecked_destination_node_name_from_edge_id(
            &self,
            edge_id: EdgeT,
        ) -> String {
            self.get_unchecked_node_name_from_node_id(
                self.get_unchecked_destination_node_id_from_edge_id(edge_id),
            )
        }
        /// Returns source node name corresponding to given edge ID.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose source node name is to be retrieved.
        ///
        /// # Raises
        /// If the given edge ID does not exist in the current graph.
        pub fn get_source_node_name_from_edge_id(&self, edge_id: EdgeT) -> Result<String> {
            self.validate_edge_id(edge_id)
                .map(|edge_id| unsafe { self.get_unchecked_source_node_name_from_edge_id(edge_id) })
        }
        /// Returns destination node name corresponding to given edge ID.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose destination node name is to be retrieved.
        ///
        /// # Raises
        /// If the given edge ID does not exist in the current graph.
        pub fn get_destination_node_name_from_edge_id(&self, edge_id: EdgeT) -> Result<String> {
            self.validate_edge_id(edge_id).map(|edge_id| unsafe {
                self.get_unchecked_destination_node_name_from_edge_id(edge_id)
            })
        }
        /// Returns node names corresponding to given edge ID.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose source and destination node IDs are to e retrieved.
        ///
        pub fn get_node_names_from_edge_id(&self, edge_id: EdgeT) -> Result<(String, String)> {
            self.validate_edge_id(edge_id)
                .map(|edge_id| unsafe { self.get_unchecked_node_names_from_edge_id(edge_id) })
        }
        /// Returns node names corresponding to given edge ID.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose source and destination node IDs are to e retrieved.
        ///
        /// # Example
        /// To retrieve the source and destination node IDs of a given edge ID you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(graph.get_node_ids_from_edge_id(0).is_ok());
        /// assert!(graph.get_node_ids_from_edge_id(10000000000).is_err());
        /// ```
        pub fn get_node_ids_from_edge_id(&self, edge_id: EdgeT) -> Result<(NodeT, NodeT)> {
            self.validate_edge_id(edge_id)
                .map(|edge_id| unsafe { self.get_unchecked_node_ids_from_edge_id(edge_id) })
        }
        #[inline(always)]
        /// Returns edge ID corresponding to given source and destination node IDs.
        ///
        /// The method will panic if the given source and destination node IDs do
        /// not correspond to an edge in this graph instance.
        ///
        /// # Arguments
        /// * `src`: NodeT - The source node ID.
        /// * `dst`: NodeT - The destination node ID.
        ///
        /// # Example
        /// To retrieve the edge ID curresponding to the given source and destination node IDs you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// let src = 0;
        /// let dst = 1;
        /// let edge_id = unsafe { graph.get_unchecked_edge_id_from_node_ids(src, dst) };
        /// println!("The source node ID {} and destination node ID {} corrrespond to the edge with ID {}.", src, dst, edge_id);
        /// ```
        ///
        /// # Safety
        /// If any of the given node IDs do not exist in the graph the method will panic.
        pub unsafe fn get_unchecked_edge_id_from_node_ids(&self, src: NodeT, dst: NodeT) -> EdgeT {
            self.edges.unchecked_rank(self.encode_edge(src, dst)) as EdgeT
        }
        #[inline(always)]
        /// Returns edge ID corresponding to given source and destination node IDs.
        ///
        /// # Arguments
        /// * `src`: NodeT - The source node ID.
        /// * `dst`: NodeT - The destination node ID.
        ///
        /// # Example
        /// To retrieve the edge ID curresponding to the given source and destination node IDs you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// assert!(graph.get_edge_id_from_node_ids(0, 1).is_ok());
        /// assert!(graph.get_edge_id_from_node_ids(0, 100000000).is_err());
        /// ```
        pub fn get_edge_id_from_node_ids(&self, src: NodeT, dst: NodeT) -> Result<EdgeT> {
            match self
                .edges
                .rank(self.encode_edge(src, dst))
                .map(|value| value as EdgeT)
            {
                Some(edge_id) => Ok(edge_id),
                None => Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[
                            "The edge composed by the source node ",
                            " and destination node ",
                            " does not exist in this graph.",
                        ],
                        &match (&src, &dst) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ));
                    res
                }),
            }
        }
        #[inline(always)]
        /// Returns edge ID corresponding to given source and destination node IDs.
        ///
        /// # Arguments
        /// * `source_id`: NodeT - The source node ID.
        ///
        /// # Example
        /// To retrieve the edge ID curresponding to the given source and destination node IDs you can use the following:
        ///
        /// ```rust
        /// # let graph_without_singletons = graph::test_utilities::load_ppi(false, true, true, false, false, false);
        /// for node_id in graph_without_singletons.iter_node_ids(){
        ///     assert_eq!(
        ///         unsafe { graph_without_singletons.get_unchecked_unique_source_node_id(node_id)},
        ///         node_id,
        ///         "The expected node ID does not match the obtained node ID."
        ///     );
        /// }
        /// ```
        ///
        /// # Safety
        /// If the given source node ID does not exist in the current graph the method will panic.
        pub unsafe fn get_unchecked_unique_source_node_id(&self, source_id: NodeT) -> NodeT {
            self.unique_sources
                .as_ref()
                .map_or(source_id, |x| x.unchecked_select(source_id as u64) as NodeT)
        }
        /// Return the src, dst, edge type of a given edge ID.
        ///
        /// This method will raise a panic when an improper configuration is used.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose source, destination and edge type are to be retrieved.
        ///
        /// # Example
        /// In order to retrieve a given edge ID informations, you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let edge_id = 0;
        /// let (src, dst, edge_type) = unsafe { graph.get_unchecked_node_ids_and_edge_type_id_from_edge_id(edge_id) };
        /// println!("The edge with ID {} has source node ID {}, destination node ID {} and edge type ID {:?}", edge_id, src, dst, edge_type);
        /// ```
        ///
        /// # Safety
        /// If the given edge ID does not exist in the current graph the method will raise a panic.
        pub unsafe fn get_unchecked_node_ids_and_edge_type_id_from_edge_id(
            &self,
            edge_id: EdgeT,
        ) -> (NodeT, NodeT, Option<EdgeTypeT>) {
            let (src, dst) = self.get_unchecked_node_ids_from_edge_id(edge_id);
            (
                src,
                dst,
                self.get_unchecked_edge_type_id_from_edge_id(edge_id),
            )
        }
        /// Return the src, dst, edge type of a given edge ID.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose source, destination and edge type are to be retrieved.
        ///
        /// # Example
        /// In order to retrieve a given edge ID informations, you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(graph.get_node_ids_and_edge_type_id_from_edge_id(0).is_ok());
        /// assert!(graph.get_node_ids_and_edge_type_id_from_edge_id(10000000000).is_err());
        /// ```
        pub fn get_node_ids_and_edge_type_id_from_edge_id(
            &self,
            edge_id: EdgeT,
        ) -> Result<(NodeT, NodeT, Option<EdgeTypeT>)> {
            self.validate_edge_id(edge_id).map(|edge_id| unsafe {
                self.get_unchecked_node_ids_and_edge_type_id_from_edge_id(edge_id)
            })
        }
        /// Return the src, dst, edge type and weight of a given edge ID.
        ///
        /// This method will raise a panic when an improper configuration is used.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose source, destination, edge type and weight are to be retrieved.
        ///
        /// # Example
        /// In order to retrieve a given edge ID informations, you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let edge_id = 0;
        /// let (src, dst, edge_type, weight) = unsafe { graph.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(edge_id) };
        /// println!("The edge with ID {} has source node ID {}, destination node ID {}, edge type ID {:?} and weight {:?}.", edge_id, src, dst, edge_type, weight);
        /// ```
        ///
        /// # Safety
        /// If the given edge ID does not exist in the current graph the method will raise a panic.
        pub unsafe fn get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(
            &self,
            edge_id: EdgeT,
        ) -> (NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>) {
            let (src, dst, edge_type) =
                self.get_unchecked_node_ids_and_edge_type_id_from_edge_id(edge_id);
            (
                src,
                dst,
                edge_type,
                self.get_unchecked_edge_weight_from_edge_id(edge_id),
            )
        }
        /// Return the src, dst, edge type and weight of a given edge ID.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose source, destination, edge type and weight are to be retrieved.
        ///
        /// # Example
        /// In order to retrieve a given edge ID informations, you can use the following:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(0).is_ok());
        /// assert!(graph.get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(10000000000).is_err());
        /// ```
        pub fn get_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(
            &self,
            edge_id: EdgeT,
        ) -> Result<(NodeT, NodeT, Option<EdgeTypeT>, Option<WeightT>)> {
            self.validate_edge_id(edge_id).map(|edge_id| unsafe {
                self.get_unchecked_node_ids_and_edge_type_id_and_edge_weight_from_edge_id(edge_id)
            })
        }
        /// Return vector with unweighted top k central node Ids.
        ///
        /// If the k passed is bigger than the number of nodes this method will return
        /// all the nodes in the graph.
        ///
        /// # Arguments
        /// * `k`: NodeT - Number of central nodes to extract.
        ///
        /// # Raises
        /// * If the given value k is zero.
        /// * If the graph has no nodes.
        pub fn get_top_k_central_node_ids(&self, k: NodeT) -> Result<Vec<NodeT>> {
            if k == 0 {
                return Err(
                    "K must be strictly a positive integer value greater than zero.".to_string(),
                );
            }
            if !self.has_nodes() {
                return Err("The node degrees are not well defined in an empty graph.".to_string());
            }
            let k = k.min(self.get_nodes_number());
            let mut most_central_node_degrees = ::alloc::vec::from_elem(0, k as usize);
            let mut most_central_node_ids = ::alloc::vec::from_elem(0, k as usize);
            self.iter_node_ids().for_each(|node_id| unsafe {
                let degree = self.get_unchecked_node_degree_from_node_id(node_id);
                let (argmin, min_degree) = most_central_node_degrees
                    .iter_mut()
                    .enumerate()
                    .min_by(|(_, node_degree_one), (_, node_degree_two)| {
                        (**node_degree_one).cmp(*node_degree_two)
                    })
                    .unwrap();
                if *min_degree <= degree {
                    *min_degree = degree;
                    most_central_node_ids[argmin] = node_id;
                }
            });
            let degree_permutation =
                permutation::sort_by(most_central_node_degrees, |a, b| b.cmp(a));
            most_central_node_ids = degree_permutation.apply_slice(most_central_node_ids);
            Ok(most_central_node_ids)
        }
        /// Return vector with weighted top k central node Ids.
        ///
        /// If the k passed is bigger than the number of nodes this method will return
        /// all the nodes in the graph.
        ///
        /// # Arguments
        /// * `k`: NodeT - Number of central nodes to extract.
        ///
        /// # Raises
        /// * If the current graph instance does not contain edge weights.
        /// * If the given value k is zero.
        ///
        /// TODO! Sort the returned values!
        pub fn get_weighted_top_k_central_node_ids(&self, k: NodeT) -> Result<Vec<NodeT>> {
            self.must_have_edge_weights()?;
            if k == 0 {
                return Err(
                    "K must be strictly a positive integer value greater than zero.".to_string(),
                );
            }
            if !self.has_nodes() {
                return Err(
                    "The weighted node degrees are not well defined in an empty graph.".to_string(),
                );
            }
            let k = k.min(self.get_nodes_number());
            let mut most_central_node_degrees = ::alloc::vec::from_elem(0.0, k as usize);
            let mut most_central_node_ids = ::alloc::vec::from_elem(0, k as usize);
            self.iter_node_ids().for_each(|node_id| unsafe {
                let degree = self.get_unchecked_weighted_node_degree_from_node_id(node_id);
                let (argmin, min_degree) = most_central_node_degrees
                    .iter_mut()
                    .enumerate()
                    .min_by(|(_, node_degree_one), (_, node_degree_two)| {
                        (**node_degree_one).partial_cmp(*node_degree_two).unwrap()
                    })
                    .unwrap();
                if *min_degree <= degree {
                    *min_degree = degree;
                    most_central_node_ids[argmin] = node_id;
                }
            });
            Ok(most_central_node_ids)
        }
        /// Returns the number of outbound neighbours of given node.
        ///
        /// # Arguments
        ///
        /// * `node_id`: NodeT - Integer ID of the node.
        ///
        /// # Safety
        /// If the given node ID does not exist in the current graph the method will raise a panic.
        pub unsafe fn get_unchecked_node_degree_from_node_id(&self, node_id: NodeT) -> NodeT {
            let (min_edge_id, max_edge_id) =
                self.get_unchecked_minmax_edge_ids_from_source_node_id(node_id);
            (max_edge_id - min_edge_id) as NodeT
        }
        /// Returns the weighted sum of outbound neighbours of given node.
        ///
        /// The method will panic if the given node id is higher than the number of
        /// nodes in the graph.
        ///
        /// # Arguments
        ///
        /// * `node_id`: NodeT - Integer ID of the node.
        ///
        /// # Safety
        /// If the given node ID does not exist in the current graph the method will raise a panic.
        pub unsafe fn get_unchecked_weighted_node_degree_from_node_id(
            &self,
            node_id: NodeT,
        ) -> f64 {
            self.iter_unchecked_edge_weights_from_source_node_id(node_id)
                .map(|w| w as f64)
                .sum::<f64>()
        }
        /// Returns the number of outbound neighbours of given node ID.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - Integer ID of the node.
        ///
        pub fn get_node_degree_from_node_id(&self, node_id: NodeT) -> Result<NodeT> {
            self.validate_node_id(node_id)
                .map(|node_id| unsafe { self.get_unchecked_node_degree_from_node_id(node_id) })
        }
        /// Returns the weighted sum of outbound neighbours of given node ID.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - Integer ID of the node.
        ///
        pub fn get_weighted_node_degree_from_node_id(&self, node_id: NodeT) -> Result<f64> {
            self.must_have_edge_weights()?;
            self.validate_node_id(node_id).map(|node_id| unsafe {
                self.get_unchecked_weighted_node_degree_from_node_id(node_id)
            })
        }
        /// Returns the number of outbound neighbours of given node name.
        ///
        /// # Arguments
        /// * `node_name`: &str - Integer ID of the node.
        ///
        /// # Raises
        /// * If the given node name does not exist in the graph.
        pub fn get_node_degree_from_node_name(&self, node_name: &str) -> Result<NodeT> {
            Ok(unsafe {
                self.get_unchecked_node_degree_from_node_id(
                    self.get_node_id_from_node_name(node_name)?,
                )
            })
        }
        /// Return vector with top k central node names.
        ///
        /// # Arguments
        ///
        /// * `k`: NodeT - Number of central nodes to extract.
        pub fn get_top_k_central_node_names(&self, k: NodeT) -> Result<Vec<String>> {
            self.get_top_k_central_node_ids(k).map(|x| {
                x.into_iter()
                    .map(|node_id| unsafe { self.get_unchecked_node_name_from_node_id(node_id) })
                    .collect()
            })
        }
        /// Returns option with vector of node types of given node.
        ///
        /// This method will panic if the given node ID is greater than
        /// the number of nodes in the graph.
        /// Furthermore, if the graph does NOT have node types, it will NOT
        /// return neither an error or a panic.
        ///
        /// # Arguments
        ///
        /// * `node_id`: NodeT - node whose node type is to be returned.
        ///
        /// # Example
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The node type id of node {} is {:?}", 0, unsafe{ graph.get_unchecked_node_type_id_from_node_id(0) });
        /// ```
        ///
        /// # Safety
        /// Even though the method will return an option when the node types are
        /// not available for the current graph, the behaviour is undefined.
        pub unsafe fn get_unchecked_node_type_id_from_node_id(
            &self,
            node_id: NodeT,
        ) -> Option<Vec<NodeTypeT>> {
            self.node_types
                .as_ref()
                .and_then(|nts| nts.ids[node_id as usize].clone())
        }
        /// Returns node type of given node.
        ///
        /// # Arguments
        ///
        /// * `node_id`: NodeT - node whose node type is to be returned.
        ///
        /// # Example
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// println!("The node type id of node {} is {:?}", 0, graph.get_node_type_id_from_node_id(0));
        /// ```
        ///
        pub fn get_node_type_id_from_node_id(
            &self,
            node_id: NodeT,
        ) -> Result<Option<Vec<NodeTypeT>>> {
            self.must_have_node_types()?;
            self.validate_node_id(node_id)
                .map(|node_id| unsafe { self.get_unchecked_node_type_id_from_node_id(node_id) })
        }
        /// Returns edge type of given edge.
        ///
        /// This method will panic if the given edge ID is greater than
        /// the number of edges in the graph.
        /// Furthermore, if the graph does NOT have edge types, it will NOT
        /// return neither an error or a panic.
        ///
        /// # Arguments
        ///
        /// * `edge_id`: EdgeT - edge whose edge type is to be returned.
        ///
        /// # Example
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert_eq!(unsafe{ graph.get_unchecked_edge_type_id_from_edge_id(0) }, Some(0));
        /// ```
        ///
        /// # Safety
        /// If the given edge ID does not exist in the current graph the method will raise a panic.
        pub unsafe fn get_unchecked_edge_type_id_from_edge_id(
            &self,
            edge_id: EdgeT,
        ) -> Option<EdgeTypeT> {
            self.edge_types
                .as_ref()
                .and_then(|ets| ets.ids[edge_id as usize])
        }
        /// Returns edge type of given edge.
        ///
        /// # Arguments
        ///
        /// * `edge_id`: EdgeT - edge whose edge type is to be returned.
        ///
        /// # Example
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// # let graph_without_edge_types = graph::test_utilities::load_ppi(true, false, true, true, false, false);
        /// assert_eq!(graph.get_edge_type_id_from_edge_id(0).unwrap(), Some(0));
        /// assert!(graph_without_edge_types.get_edge_type_id_from_edge_id(0).is_err());
        /// ```
        pub fn get_edge_type_id_from_edge_id(&self, edge_id: EdgeT) -> Result<Option<EdgeTypeT>> {
            self.must_have_edge_types()?;
            self.validate_edge_id(edge_id)
                .map(|edge_id| unsafe { self.get_unchecked_edge_type_id_from_edge_id(edge_id) })
        }
        /// Returns result of option with the node type of the given node id.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - The node ID whose node types are to be returned.
        ///
        /// # Safety
        /// This method will return an iterator of None values when the graph
        /// does not contain node types.
        pub unsafe fn get_unchecked_node_type_names_from_node_id(
            &self,
            node_id: NodeT,
        ) -> Option<Vec<String>> {
            self.get_unchecked_node_type_id_from_node_id(node_id)
                .map(|node_type_ids| {
                    self.get_unchecked_node_type_names_from_node_type_ids(node_type_ids)
                })
        }
        /// Returns result of option with the node type of the given node id.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - The node ID whose node types are to be returned.
        ///
        /// # Raises
        /// * If the node types are not available for the current graph instance.
        pub fn get_node_type_names_from_node_id(
            &self,
            node_id: NodeT,
        ) -> Result<Option<Vec<String>>> {
            self.must_have_node_types()?;
            Ok(self
                .get_node_type_id_from_node_id(node_id)?
                .map(|node_type_ids| unsafe {
                    self.get_unchecked_node_type_names_from_node_type_ids(node_type_ids)
                }))
        }
        /// Returns result of option with the node type of the given node name.
        ///
        /// # Arguments
        /// * `node_name`: &str - The node name whose node types are to be returned.
        pub fn get_node_type_names_from_node_name(
            &self,
            node_name: &str,
        ) -> Result<Option<Vec<String>>> {
            self.get_node_type_names_from_node_id(self.get_node_id_from_node_name(node_name)?)
        }
        /// Returns option with the edge type of the given edge id.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose edge type is to be returned.
        pub fn get_edge_type_name_from_edge_id(&self, edge_id: EdgeT) -> Result<Option<String>> {
            self.get_edge_type_id_from_edge_id(edge_id)?
                .map_or(Ok(None), |x| {
                    Ok(Some(self.get_edge_type_name_from_edge_type_id(x)?))
                })
        }
        /// Return edge type name of given edge type.
        ///
        /// # Arguments
        /// * `edge_type_id`: EdgeTypeT - Id of the edge type.
        pub fn get_edge_type_name_from_edge_type_id(
            &self,
            edge_type_id: EdgeTypeT,
        ) -> Result<String> {
            self.must_have_edge_types()?;
            self.edge_types
                .as_ref()
                .map(|ets| ets.translate(edge_type_id))
                .unwrap()
        }
        /// Returns weight of the given edge id.
        ///
        /// # Arguments
        /// * `edge_id`: EdgeT - The edge ID whose weight is to be returned.
        ///
        /// # Example
        /// To get the weight of a given `edge_id` you can run:
        /// ```rust
        /// # let weighted_graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// # let unweighted_graph = graph::test_utilities::load_ppi(true, true, false, true, false, false);
        /// let edge_id = 0;
        /// let unexistent_edge_id = 123456789;
        /// assert!(weighted_graph.get_edge_weight_from_edge_id(edge_id).is_ok());
        /// assert!(weighted_graph.get_edge_weight_from_edge_id(unexistent_edge_id).is_err());
        /// assert!(unweighted_graph.get_edge_weight_from_edge_id(edge_id).is_err());
        /// ```
        pub fn get_edge_weight_from_edge_id(&self, edge_id: EdgeT) -> Result<WeightT> {
            self.must_have_edge_weights()?;
            self.weights
                .as_ref()
                .map(|weights| {
                    weights.get(edge_id as usize).map_or(
                        Err({
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &[
                                    "The given edge_id ",
                                    " is higher than the number of available directed edges ",
                                    ".",
                                ],
                                &match (&edge_id, &self.get_directed_edges_number()) {
                                    (arg0, arg1) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                    ],
                                },
                            ));
                            res
                        }),
                        |value| Ok(*value),
                    )
                })
                .unwrap()
        }
        /// Returns weight of the given node ids.
        ///
        /// # Arguments
        /// * `src`: NodeT - The node ID of the source node.
        /// * `dst`: NodeT - The node ID of the destination node.
        ///
        /// # Example
        /// To get the weight of a given `src` and `dst` you can run:
        /// ```rust
        /// # let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// let src = 0;
        /// let dst = 1;
        /// assert!(weighted_graph.get_edge_weight_from_node_ids(src, dst).is_ok());
        /// ```
        pub fn get_edge_weight_from_node_ids(&self, src: NodeT, dst: NodeT) -> Result<WeightT> {
            self.get_edge_weight_from_edge_id(self.get_edge_id_from_node_ids(src, dst)?)
        }
        /// Returns weight of the given node ids and edge type.
        ///
        /// # Arguments
        /// * `src`: NodeT - The node ID of the source node.
        /// * `dst`: NodeT - The node ID of the destination node.
        /// * `edge_type`: Option<EdgeTypeT> - The edge type ID of the edge.
        ///
        /// # Example
        /// To get the weight of a given `src` and `dst` and `edge_type` you can run:
        /// ```rust
        /// # let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// let src = 0;
        /// let dst = 1;
        /// let edge_type = Some(0);
        /// assert!(weighted_graph.get_edge_weight_from_node_ids_and_edge_type_id(src, dst, edge_type).is_ok());
        /// ```
        pub fn get_edge_weight_from_node_ids_and_edge_type_id(
            &self,
            src: NodeT,
            dst: NodeT,
            edge_type: Option<EdgeTypeT>,
        ) -> Result<WeightT> {
            self.get_edge_weight_from_edge_id(
                self.get_edge_id_from_node_ids_and_edge_type_id(src, dst, edge_type)?,
            )
        }
        /// Returns weight of the given node names and edge type.
        ///
        /// # Arguments
        /// * `src`: &str - The node name of the source node.
        /// * `dst`: &str - The node name of the destination node.
        /// * `edge_type`: Option<&str> - The edge type name of the edge.
        ///
        /// # Example
        /// To get the weight of a given `src` and `dst` and `edge_type` you can run:
        /// ```rust
        /// # let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// let src = "ENSP00000000233";
        /// let dst = "ENSP00000432568";
        /// let edge_type = Some("red");
        /// assert!(weighted_graph.get_edge_weight_from_node_names_and_edge_type_name(src, dst, edge_type).is_ok());
        /// ```
        pub fn get_edge_weight_from_node_names_and_edge_type_name(
            &self,
            src: &str,
            dst: &str,
            edge_type: Option<&str>,
        ) -> Result<WeightT> {
            self.get_edge_weight_from_edge_id(
                self.get_edge_id_from_node_names_and_edge_type_name(src, dst, edge_type)?,
            )
        }
        /// Returns weight of the given node names.
        ///
        /// # Arguments
        /// * `src_name`: &str - The node name of the source node.
        /// * `dst_name`: &str - The node name of the destination node.
        ///
        /// # Example
        /// To get the weight of a given `src_name` and `dst_name` you can run:
        /// ```rust
        /// # let weighted_graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// let src_name = "ENSP00000000233";
        /// let dst_name = "ENSP00000432568";
        /// assert!(weighted_graph.get_edge_weight_from_node_names(src_name, dst_name).is_ok());
        /// ```
        pub fn get_edge_weight_from_node_names(
            &self,
            src_name: &str,
            dst_name: &str,
        ) -> Result<WeightT> {
            self.get_edge_weight_from_edge_id(self.get_edge_id_from_node_names(src_name, dst_name)?)
        }
        /// Returns result with the node name.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - The node ID whose name is to be returned.
        ///
        /// # Example
        /// To get the name of a node you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert_eq!(unsafe { graph.get_unchecked_node_name_from_node_id(0) }, "ENSG00000004059".to_string());
        /// ```
        ///
        /// # Safety
        /// If the given node ID does not exist in the current graph the method will raise a panic.
        pub unsafe fn get_unchecked_node_name_from_node_id(&self, node_id: NodeT) -> String {
            self.nodes.unchecked_translate(node_id)
        }
        /// Returns result with the node name.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - The node ID whose name is to be returned.
        ///
        /// # Example
        /// To get the name of a node you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// assert!(graph.get_node_name_from_node_id(0).is_ok());
        /// ```
        pub fn get_node_name_from_node_id(&self, node_id: NodeT) -> Result<String> {
            self.validate_node_id(node_id)
                .map(|node_id| unsafe { self.get_unchecked_node_name_from_node_id(node_id) })
        }
        /// Returns result with the node ID.
        ///
        /// # Arguments
        /// * `node_name`: &str - The node name whose node ID is to be returned.
        ///
        /// # Raises
        /// * When the given node name does not exists in the current graph.
        pub fn get_node_id_from_node_name(&self, node_name: &str) -> Result<NodeT> {
            match self.nodes.get(node_name) {
                Some(node_id) => Ok(*node_id),
                None => Err({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["Given node name ", " is not available in current graph."],
                        &match (&node_name,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }),
            }
        }
        /// Returns result with the node IDs.
        ///
        /// # Arguments
        /// * `node_names`: Vec<&str> - The node names whose node IDs is to be returned.
        ///
        /// # Raises
        /// * When any of the given node name does not exists in the current graph.
        pub fn get_node_ids_from_node_names(&self, node_names: Vec<&str>) -> Result<Vec<NodeT>> {
            node_names
                .into_iter()
                .map(|node_name| self.get_node_id_from_node_name(node_name))
                .collect::<Result<Vec<NodeT>>>()
        }
        /// Returns result with the edge node IDs.
        ///
        /// # Arguments
        /// * `edge_node_names`: Vec<(&str, &str)> - The node names whose node IDs is to be returned.
        ///
        /// # Raises
        /// * When any of the given node name does not exists in the current graph.
        pub fn get_edge_node_ids_from_edge_node_names(
            &self,
            edge_node_names: Vec<(&str, &str)>,
        ) -> Result<Vec<(NodeT, NodeT)>> {
            edge_node_names
                .into_iter()
                .map(|(src_name, dst_name)| {
                    Ok((
                        self.get_node_id_from_node_name(src_name)?,
                        self.get_node_id_from_node_name(dst_name)?,
                    ))
                })
                .collect::<Result<Vec<(NodeT, NodeT)>>>()
        }
        /// Returns result with the edge node names.
        ///
        /// # Arguments
        /// * `edge_node_ids`: Vec<(NodeT, NodeT)> - The node names whose node names is to be returned.
        ///
        /// # Raises
        /// * When any of the given node IDs does not exists in the current graph.
        pub fn get_edge_node_names_from_edge_node_ids(
            &self,
            edge_node_ids: Vec<(NodeT, NodeT)>,
        ) -> Result<Vec<(String, String)>> {
            edge_node_ids
                .into_iter()
                .map(|(src_name, dst_name)| {
                    Ok((
                        self.get_node_name_from_node_id(src_name)?,
                        self.get_node_name_from_node_id(dst_name)?,
                    ))
                })
                .collect::<Result<Vec<(String, String)>>>()
        }
        /// Return node type ID for the given node name if available.
        ///
        /// # Arguments
        ///
        /// * `node_name`: &str - Name of the node.
        ///
        /// # Example
        /// To get the node type ID for a given node name you can run:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let node_name = "ENSP00000000233";
        /// println!("The node type ID of node {} is {:?}.", node_name, graph.get_node_type_id_from_node_name(node_name).unwrap());
        /// ```
        pub fn get_node_type_id_from_node_name(
            &self,
            node_name: &str,
        ) -> Result<Option<Vec<NodeTypeT>>> {
            self.get_node_type_id_from_node_id(self.get_node_id_from_node_name(node_name)?)
        }
        /// Return node type name for the given node name if available.
        ///
        /// # Arguments
        ///
        /// * `node_name`: &str - Name of the node.
        ///
        /// # Example
        /// To get the node type name for a given node name you can run:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let node_name = "ENSP00000000233";
        /// println!("The node type of node {} is {:?}", node_name, graph.get_node_type_name_from_node_name(node_name).unwrap());
        /// ```
        pub fn get_node_type_name_from_node_name(
            &self,
            node_name: &str,
        ) -> Result<Option<Vec<String>>> {
            self.get_node_type_names_from_node_id(self.get_node_id_from_node_name(node_name)?)
        }
        /// Return number of edges with given edge type ID.
        ///
        /// If None is given as an edge type ID, the unknown edge type IDs
        /// will be returned.
        ///
        /// # Arguments
        /// * `edge_type_id`: Option<EdgeTypeT> - The edge type ID to count the edges of.
        ///
        pub fn get_edge_count_from_edge_type_id(
            &self,
            edge_type_id: Option<EdgeTypeT>,
        ) -> Result<EdgeT> {
            self.validate_edge_type_id(edge_type_id)
                .map(|edge_type_id| unsafe {
                    self.get_unchecked_edge_count_from_edge_type_id(edge_type_id)
                })
        }
        /// Return edge type ID curresponding to given edge type name.
        ///
        /// If None is given as an edge type ID, None is returned.
        ///
        /// # Arguments
        /// * `edge_type_name`: Option<&str> - The edge type name whose ID is to be returned.
        ///
        /// TODO: refactor this method using new validation methods.
        pub fn get_edge_type_id_from_edge_type_name(
            &self,
            edge_type_name: Option<&str>,
        ) -> Result<Option<EdgeTypeT>> {
            match (&self.edge_types, edge_type_name) {
                (None, _) => Err("Current graph does not have edge types.".to_owned()),
                (Some(_), None) => Ok(None),
                (Some(ets), Some(etn)) => match ets.get(etn) {
                    Some(edge_type_id) => Ok(Some(*edge_type_id)),
                    None => Err({
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[
                                "Given edge type name ",
                                " is not available in current graph.",
                            ],
                            &match (&etn,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    }),
                },
            }
        }
        /// Return number of edges with given edge type name.
        ///
        /// If None is given as an edge type name, the unknown edge types
        /// will be returned.
        ///
        /// # Arguments
        /// * `edge_type_name`: Option<&str> - The edge type name to count the edges of.
        ///
        pub fn get_edge_count_from_edge_type_name(
            &self,
            edge_type_name: Option<&str>,
        ) -> Result<EdgeT> {
            self.get_edge_count_from_edge_type_id(
                self.get_edge_type_id_from_edge_type_name(edge_type_name)?,
            )
        }
        /// Return node type ID curresponding to given node type name.
        ///
        /// If None is given as an node type ID, None is returned.
        ///
        /// # Arguments
        /// * `node_type_name`: &str - The node type name whose ID is to be returned.
        ///
        pub fn get_node_type_id_from_node_type_name(
            &self,
            node_type_name: &str,
        ) -> Result<NodeTypeT> {
            self.must_have_node_types()?;
            self . node_types . as_ref () . map (| nts | { nts . get (node_type_name) . map_or_else (| | { Err ({ let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The given node type name " , " does not exists in the current graph instance.\nThe supported node types are " , "."] , & match (& node_type_name , & self . get_unique_node_type_names ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , })) ; res }) } , | node_type_id | Ok (* node_type_id)) }) . unwrap ()
        }
        /// Return number of nodes with given node type ID.
        ///
        /// If None is given as an node type ID, the unknown node types
        /// will be returned.
        ///
        /// # Arguments
        /// * `node_type_id`: Option<NodeTypeT> - The node type ID to count the nodes of.
        ///
        pub fn get_node_count_from_node_type_id(
            &self,
            node_type_id: Option<NodeTypeT>,
        ) -> Result<NodeT> {
            self.validate_node_type_id(node_type_id)
                .map(|node_type_id| self.get_unchecked_node_count_from_node_type_id(node_type_id))
        }
        /// Return number of nodes with given node type name.
        ///
        /// If None is given as an node type name, the unknown node types
        /// will be returned.
        ///
        /// # Arguments
        /// * `node_type_name`: Option<&str> - The node type name to count the nodes of.
        ///
        pub fn get_node_count_from_node_type_name(
            &self,
            node_type_name: Option<&str>,
        ) -> Result<NodeT> {
            self.get_node_count_from_node_type_id(
                node_type_name.map_or(Ok::<_, String>(None), |ntn| {
                    Ok(Some(self.get_node_type_id_from_node_type_name(ntn)?))
                })?,
            )
        }
        /// Return vector of destinations for the given source node ID.
        ///
        /// # Arguments
        ///
        /// * `node_id`: NodeT - Node ID whose neighbours are to be retrieved.
        ///
        /// # Example
        /// To retrieve the neighbours of a given node `src` you can use:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// # let node_id = 0;
        /// println!("The neighbours of the node {} are {:?}.", node_id, graph.get_neighbour_node_ids_from_node_id(node_id).unwrap());
        /// let unavailable_node = 2349765432;
        /// assert!(graph.get_neighbour_node_ids_from_node_id(unavailable_node).is_err());
        /// ```
        pub fn get_neighbour_node_ids_from_node_id(&self, node_id: NodeT) -> Result<Vec<NodeT>> {
            self.validate_node_id(node_id).map(|node_id| {
                unsafe { self.iter_unchecked_neighbour_node_ids_from_source_node_id(node_id) }
                    .collect()
            })
        }
        /// Return vector of destinations for the given source node name.
        ///
        /// # Arguments
        ///
        /// * `node_name`: &str - Node ID whose neighbours are to be retrieved.
        ///
        /// # Example
        /// To retrieve the neighbours of a given node `src` you can use:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let node_name = "ENSP00000000233";
        /// println!("The neighbours of the node {} are {:?}.", node_name, graph.get_neighbour_node_ids_from_node_name(node_name).unwrap());
        /// ```
        pub fn get_neighbour_node_ids_from_node_name(&self, node_name: &str) -> Result<Vec<NodeT>> {
            self.get_neighbour_node_ids_from_node_id(self.get_node_id_from_node_name(node_name)?)
        }
        /// Return vector of destination names for the given source node name.
        ///
        /// # Arguments
        ///
        /// * `node_name`: &str - Node name whose neighbours are to be retrieved.
        ///
        /// # Example
        /// To retrieve the neighbours of a given node `src` you can use:
        ///
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let node_name = "ENSP00000000233";
        /// println!("The neighbours of the node {} are {:?}.", node_name, graph.get_neighbour_node_names_from_node_name(node_name).unwrap());
        /// ```
        pub fn get_neighbour_node_names_from_node_name(
            &self,
            node_name: &str,
        ) -> Result<Vec<String>> {
            Ok(unsafe {
                self.iter_unchecked_neighbour_node_names_from_source_node_id(
                    self.get_node_id_from_node_name(node_name)?,
                )
            }
            .collect())
        }
        /// Return range of outbound edges IDs for all the edges bewteen the given
        /// source and destination nodes.
        /// This operation is meaningfull only in a multigraph.
        ///
        /// # Arguments
        ///
        /// * `src`: NodeT - Source node.
        /// * `dst`: NodeT - Destination node.
        ///
        pub fn get_minmax_edge_ids_from_node_ids(
            &self,
            src: NodeT,
            dst: NodeT,
        ) -> Result<(EdgeT, EdgeT)> {
            Ok((self.get_edge_id_from_node_ids(src, dst)?, unsafe {
                self.get_unchecked_edge_id_from_node_ids(src, dst + 1)
            }))
        }
        /// Return edge ID for given tuple of nodes and edge type.
        ///
        /// This method will return an error if the graph does not contain the
        /// requested edge with edge type.
        ///
        /// # Arguments
        /// * `src`: NodeT - Source node of the edge.
        /// * `dst`: NodeT - Destination node of the edge.
        /// * `edge_type`: Option<EdgeTypeT> - Edge Type of the edge.
        ///
        pub fn get_edge_id_from_node_ids_and_edge_type_id(
            &self,
            src: NodeT,
            dst: NodeT,
            edge_type: Option<EdgeTypeT>,
        ) -> Result<EdgeT> {
            self . edge_types . as_ref () . map_or_else (| | self . get_edge_id_from_node_ids (src , dst) . ok () , | ets | { self . iter_edge_ids_from_node_ids (src , dst) . ok () . and_then (| mut edge_ids | { edge_ids . find (| edge_id | ets . ids [* edge_id as usize] == edge_type) }) }) . ok_or_else (| | { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The current graph instance does not contain the required edge composed of source node ID " , ", destination node ID " , " and edge ID " , "."] , & match (& src , & dst , & edge_type) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , })) ; res } })
        }
        /// Return edge ID for given tuple of node names.
        ///
        /// This method will return an error if the graph does not contain the
        /// requested edge with edge type.
        ///
        /// # Arguments
        /// * `src_name`: &str - Source node name of the edge.
        /// * `dst_name`: &str - Destination node name of the edge.
        ///
        pub fn get_edge_id_from_node_names(&self, src_name: &str, dst_name: &str) -> Result<EdgeT> {
            match (self . nodes . get (src_name) , self . nodes . get (dst_name)) { (Some (src) , Some (dst)) => self . get_edge_id_from_node_ids (* src , * dst) . ok () , _ => None , } . ok_or_else (| | { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The current graph instance does not contain the required edge composed of source node name " , " and destination node name " , "."] , & match (& src_name , & dst_name) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , })) ; res } })
        }
        /// Return edge ID for given tuple of node names and edge type name.
        ///
        /// This method will return an error if the graph does not contain the
        /// requested edge with edge type.
        ///
        /// # Arguments
        /// * `src_name`: &str - Source node name of the edge.
        /// * `dst_name`: &str - Destination node name of the edge.
        /// * `edge_type_name`: Option<&str> - Edge type name.
        ///
        pub fn get_edge_id_from_node_names_and_edge_type_name(
            &self,
            src_name: &str,
            dst_name: &str,
            edge_type_name: Option<&str>,
        ) -> Result<EdgeT> {
            match (self . nodes . get (src_name) , self . nodes . get (dst_name)) { (Some (src) , Some (dst)) => self . get_edge_id_from_node_ids_and_edge_type_id (* src , * dst , self . get_edge_type_id_from_edge_type_name (edge_type_name) ?) . ok () , _ => None , } . ok_or_else (| | { { let res = :: alloc :: fmt :: format (:: core :: fmt :: Arguments :: new_v1 (& ["The current graph instance does not contain the required edge composed of source node name " , ", destination node name " , " and edge name " , "."] , & match (& src_name , & dst_name , & edge_type_name) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , })) ; res } })
        }
        /// Return translated edge types from string to internal edge ID.
        ///
        /// # Arguments
        /// * `edge_type_names`: Vec<Option<String>> - Vector of edge types to be converted.
        pub fn get_edge_type_ids_from_edge_type_names(
            &self,
            edge_type_names: Vec<Option<String>>,
        ) -> Result<Vec<Option<EdgeTypeT>>> {
            edge_type_names
                .iter()
                .map(|edge_type_name| match edge_type_name {
                    None => Ok(None),
                    Some(edge_type_name) => {
                        self.get_edge_type_id_from_edge_type_name(Some(edge_type_name))
                    }
                })
                .collect::<Result<Vec<Option<EdgeTypeT>>>>()
        }
        /// Return translated node types from string to internal node ID.
        ///
        /// # Arguments
        ///
        /// * `node_type_names`: Vec<Option<String>> - Vector of node types to be converted.
        pub fn get_node_type_ids_from_node_type_names(
            &self,
            node_type_names: Vec<Option<String>>,
        ) -> Result<Vec<Option<NodeTypeT>>> {
            self.must_have_node_types()?;
            node_type_names
                .iter()
                .map(|node_type_name| match node_type_name {
                    None => Ok(None),
                    Some(node_type_name) => self
                        .get_node_type_id_from_node_type_name(node_type_name)
                        .map(Some),
                })
                .collect::<Result<Vec<Option<NodeTypeT>>, String>>()
        }
        /// Return translated node types from string to internal node ID.
        ///
        /// # Arguments
        ///
        /// * `node_type_names`: Vec<Option<Vec<&str>>> - Vector of node types to be converted.
        ///
        /// # Raises
        /// * If the graph does not have node types.
        /// * If any of the given node type names do not exists in the graph.
        pub fn get_multiple_node_type_ids_from_node_type_names(
            &self,
            node_type_names: Vec<Option<Vec<&str>>>,
        ) -> Result<Vec<Option<Vec<NodeTypeT>>>> {
            self.must_have_node_types()?;
            node_type_names
                .iter()
                .map(|maybe_node_type_names| {
                    maybe_node_type_names.as_ref().map_or(
                        Ok::<_, String>(None),
                        |node_type_names| {
                            Ok(Some(
                                node_type_names
                                    .iter()
                                    .map(|node_type_name| {
                                        self.get_node_type_id_from_node_type_name(node_type_name)
                                    })
                                    .collect::<Result<Vec<NodeTypeT>>>()?,
                            ))
                        },
                    )
                })
                .collect::<Result<Vec<Option<Vec<NodeTypeT>>>>>()
        }
        /// Return range of outbound edges IDs which have as source the given Node.
        ///
        /// The method will panic if the given source node ID is higher than
        /// the number of nodes in the graph.
        ///
        /// # Arguments
        ///
        /// * `src`: NodeT - Node for which we need to compute the cumulative_node_degrees range.
        ///
        /// # Safety
        /// If the given node ID does not exist in the current graph the method will raise a panic.
        pub unsafe fn get_unchecked_minmax_edge_ids_from_source_node_id(
            &self,
            src: NodeT,
        ) -> (EdgeT, EdgeT) {
            match &self.cumulative_node_degrees {
                Some(cumulative_node_degrees) => {
                    let min_edge_id = if src == 0 {
                        0
                    } else {
                        cumulative_node_degrees[src as usize - 1]
                    };
                    (min_edge_id, cumulative_node_degrees[src as usize])
                }
                None => {
                    let min_edge_id: EdgeT = self.get_unchecked_edge_id_from_node_ids(src, 0);
                    (
                        min_edge_id,
                        self.get_unchecked_edge_id_from_node_ids(src + 1, 0),
                    )
                }
            }
        }
        /// Return range of outbound edges IDs which have as source the given Node.
        ///
        /// # Arguments
        ///
        /// * `src`: NodeT - Node for which we need to compute the cumulative_node_degrees range.
        ///
        pub fn get_minmax_edge_ids_from_source_node_id(
            &self,
            src: NodeT,
        ) -> Result<(EdgeT, EdgeT)> {
            self.validate_node_id(src)
                .map(|src| unsafe { self.get_unchecked_minmax_edge_ids_from_source_node_id(src) })
        }
        /// Return node type name of given node type.
        ///
        /// There is no need for a unchecked version since we will have to map
        /// on the note_types anyway.
        ///
        /// # Arguments
        /// * `node_type_id`: NodeTypeT - Id of the node type.
        pub fn get_node_type_name_from_node_type_id(
            &self,
            node_type_id: NodeTypeT,
        ) -> Result<String> {
            self.must_have_node_types()?;
            self.node_types
                .as_ref()
                .map(|nts| nts.translate(node_type_id))
                .unwrap()
        }
        /// Return node type name of given node type.
        ///
        /// # Arguments
        /// * `node_type_ids`: Vec<NodeTypeT> - Id of the node type.
        ///
        /// # Safety
        /// The method will panic if the graph does not contain node types.
        pub unsafe fn get_unchecked_node_type_names_from_node_type_ids(
            &self,
            node_type_ids: Vec<NodeTypeT>,
        ) -> Vec<String> {
            self.node_types
                .as_ref()
                .map(|nts| nts.unchecked_translate_vector(node_type_ids))
                .unwrap_unchecked()
        }
    }
}
mod queries_boolean {
    use super::*;
    /// # Boolean Queries
    /// The naming convention for unchecked methods follows:
    /// * `/is_(.+?)_from_(.+)/`
    /// * `/has_(.+?)_from_(.+)/`
    /// * `/is_(.+?)_from_(.+)_unchecked/`
    /// * `/has_(.+?)_from_(.+)_unchecked/`
    impl Graph {
        /// Returns boolean representing if given node is a singleton.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - The node to be checked for.
        ///
        /// # Safety
        /// If the given node ID does not exists in the graph this method will panic.
        pub unsafe fn is_unchecked_singleton_from_node_id(&self, node_id: NodeT) -> bool {
            self.connected_nodes
                .as_ref()
                .map_or(false, |nsns| !nsns[node_id as usize])
        }
        /// Returns boolean representing if given node is a singleton or a singleton with selfloop.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - The node to be checked for.
        ///
        /// # Safety
        /// If the given node ID does not exists in the graph this method will panic.
        pub unsafe fn is_unchecked_disconnected_from_node_id(&self, node_id: NodeT) -> bool {
            self.is_unchecked_singleton_from_node_id(node_id)
                || self.is_singleton_with_selfloops_from_node_id(node_id)
        }
        /// Returns boolean representing if given node is not a singleton nor a singleton with selfloop.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - The node to be checked for.
        ///
        /// # Safety
        /// If the given node ID does not exists in the graph this method will panic.
        pub unsafe fn is_unchecked_connected_from_node_id(&self, node_id: NodeT) -> bool {
            !self.is_unchecked_disconnected_from_node_id(node_id)
        }
        /// Returns boolean representing if given node is a singleton.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - The node to be checked for.
        pub fn is_singleton_from_node_id(&self, node_id: NodeT) -> Result<bool> {
            self.validate_node_id(node_id)
                .map(|node_id| unsafe { self.is_unchecked_singleton_from_node_id(node_id) })
        }
        /// Returns boolean representing if given node is a singleton with self-loops.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - The node to be checked for.
        pub fn is_singleton_with_selfloops_from_node_id(&self, node_id: NodeT) -> bool {
            self.singleton_nodes_with_selfloops
                .as_ref()
                .map_or(false, |snsls| snsls.contains(node_id))
        }
        /// Returns boolean representing if given node is a singleton.
        ///
        /// Nota that this method will raise a panic if caled with unproper
        /// parametrization.
        ///
        /// # Arguments
        /// * `node_name`: &str - The node name to be checked for.
        ///
        /// # Safety
        /// If the given node name does not exist in the graph this method will panic.
        pub unsafe fn is_unchecked_singleton_from_node_name(&self, node_name: &str) -> bool {
            self.is_unchecked_singleton_from_node_id(
                self.get_unchecked_node_id_from_node_name(node_name),
            )
        }
        /// Returns boolean representing if given node is a singleton.
        ///
        /// # Arguments
        /// * `node_name`: &str - The node name to be checked for.
        pub fn is_singleton_from_node_name(&self, node_name: &str) -> Result<bool> {
            Ok(unsafe {
                self.is_unchecked_singleton_from_node_id(
                    self.get_node_id_from_node_name(node_name)?,
                )
            })
        }
        /// Returns whether the graph has the given node name.
        ///
        /// # Arguments
        ///
        /// * `node_name`: &str - Name of the node.
        ///
        /// # Example
        /// To check if a node appears in the graph you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let node_name = "ENSP00000000233";
        /// let unexistent_node_name = "I_do_not_exist!";
        /// assert!(graph.has_node_name(node_name));
        /// assert!(!graph.has_node_name(unexistent_node_name));
        /// ```
        pub fn has_node_name(&self, node_name: &str) -> bool {
            self.get_node_id_from_node_name(node_name).is_ok()
        }
        /// Returns whether the graph has the given node type id.
        ///
        /// # Arguments
        ///
        /// * `node_type_id`: NodeTypeT - id of the node.
        ///
        /// # Example
        /// To check if a node appears in the graph you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let node_type_id = 0;
        /// let unexistent_node_type_id = 34567;
        /// assert!(graph.has_node_type_id(node_type_id));
        /// assert!(!graph.has_node_type_id(unexistent_node_type_id));
        /// ```
        pub fn has_node_type_id(&self, node_type_id: NodeTypeT) -> bool {
            self.validate_node_type_id(Some(node_type_id)).is_ok()
        }
        /// Returns whether the graph has the given node type name.
        ///
        /// # Arguments
        ///
        /// * `node_type_name`: &str - Name of the node.
        ///
        /// # Example
        /// To check if a node appears in the graph you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let node_type_name = "biolink:Gene";
        /// let unexistent_node_type_name = "I_do_not_exist!";
        /// assert!(graph.has_node_type_name(node_type_name));
        /// assert!(!graph.has_node_type_name(unexistent_node_type_name));
        /// ```
        pub fn has_node_type_name(&self, node_type_name: &str) -> bool {
            self.get_node_type_id_from_node_type_name(node_type_name)
                .is_ok()
        }
        /// Returns whether the graph has the given edge type id.
        ///
        /// # Arguments
        ///
        /// * `edge_type_id`: EdgeTypeT - id of the edge.
        ///
        /// # Example
        /// To check if a edge appears in the graph you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let edge_type_id = 0;
        /// let unexistent_edge_type_id = 567;
        /// assert!(graph.has_edge_type_id(edge_type_id));
        /// assert!(!graph.has_edge_type_id(unexistent_edge_type_id));
        /// ```
        pub fn has_edge_type_id(&self, edge_type_id: EdgeTypeT) -> bool {
            self.validate_edge_type_id(Some(edge_type_id)).is_ok()
        }
        /// Returns whether the graph has the given edge type name.
        ///
        /// # Arguments
        ///
        /// * `edge_type_name`: &str - Name of the edge.
        ///
        /// # Example
        /// To check if a edge appears in the graph you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(true, true, true, true, false, false);
        /// let edge_type_name = "red";
        /// let unexistent_edge_type_name = "I_do_not_exist!";
        /// assert!(graph.has_edge_type_name(edge_type_name));
        /// assert!(!graph.has_edge_type_name(unexistent_edge_type_name));
        /// ```
        pub fn has_edge_type_name(&self, edge_type_name: &str) -> bool {
            self.get_edge_type_id_from_edge_type_name(Some(edge_type_name))
                .is_ok()
        }
        /// Returns whether edge passing between given node ids exists.
        ///
        /// # Arguments
        ///
        /// * `src`: NodeT - Source node id.
        /// * `dst`: NodeT - Destination node id.
        ///
        /// # Example
        /// To check if an edge appears in the graph you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// assert!(graph.has_edge_from_node_ids(0, 1));
        /// assert!(!graph.has_edge_from_node_ids(0, 4565));
        /// ```
        pub fn has_edge_from_node_ids(&self, src: NodeT, dst: NodeT) -> bool {
            self.get_edge_id_from_node_ids(src, dst).is_ok()
        }
        /// Returns whether the given node ID has a selfloop.
        ///
        /// # Arguments
        /// * `node_id`: NodeT - Source node id.
        ///
        /// # Example
        /// To check if a selfloop appears in the graph you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// assert!(graph.has_selfloop_from_node_id(0));
        /// assert!(!graph.has_selfloop_from_node_id(4565));
        /// ```
        pub fn has_selfloop_from_node_id(&self, node_id: NodeT) -> bool {
            self.has_edge_from_node_ids(node_id, node_id)
        }
        /// Returns whether edge with the given type passing between given nodes exists.
        ///
        /// # Arguments
        ///
        /// * `src`: NodeT - The source node of the edge.
        /// * `dst`: NodeT - The destination node of the edge.
        /// * `edge_type`: Option<EdgeTypeT> - The (optional) edge type.
        ///
        /// # Example
        /// To check if an edge with given type appears in the graph you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// assert!(graph.has_edge_from_node_ids_and_edge_type_id(0, 1, Some(0)));
        /// assert!(!graph.has_edge_from_node_ids_and_edge_type_id(0, 1, Some(1)));
        /// ```
        pub fn has_edge_from_node_ids_and_edge_type_id(
            &self,
            src: NodeT,
            dst: NodeT,
            edge_type: Option<EdgeTypeT>,
        ) -> bool {
            self.get_edge_id_from_node_ids_and_edge_type_id(src, dst, edge_type)
                .is_ok()
        }
        /// Returns boolean representing if given node is a trap.
        ///
        /// If the provided node_id is higher than the number of nodes in the graph,
        /// the method will panic.
        ///
        /// # Arguments
        ///
        /// * `node_id`: NodeT - Integer ID of the node, if this is bigger that the number of nodes it will panic.
        ///
        /// # Safety
        /// If the given node ID does not exists in the graph this method will panic.
        pub unsafe fn is_unchecked_trap_node_from_node_id(&self, node_id: NodeT) -> bool {
            self.get_unchecked_node_degree_from_node_id(node_id) == 0
                && self
                    .connected_nodes
                    .as_ref()
                    .map_or(true, |nsns| nsns[node_id as usize])
        }
        /// Returns boolean representing if given node is a trap.
        ///
        /// # Arguments
        ///
        /// * `node_id`: NodeT - Integer ID of the node, if this is bigger that the number of nodes it will panic.
        ///
        pub fn is_trap_node_from_node_id(&self, node_id: NodeT) -> Result<bool> {
            self.validate_node_id(node_id)
                .map(|node_id| unsafe { self.is_unchecked_trap_node_from_node_id(node_id) })
        }
        /// Returns whether the given node name and node type name exist in current graph.
        ///
        /// # Arguments
        ///
        /// * `node_name`: &str - The node name.
        /// * `node_type_name`: Option<Vec<String>> - The node types name.
        ///
        pub fn has_node_name_and_node_type_name(
            &self,
            node_name: &str,
            node_type_name: Option<Vec<String>>,
        ) -> bool {
            match self.get_node_id_from_node_name(node_name) {
                Err(_) => false,
                Ok(node_id) => {
                    let our_node_types = self.get_node_type_names_from_node_id(node_id);
                    match (our_node_types, node_type_name) {
                        (Err(_), None) => true,
                        (Ok(None), None) => true,
                        (Ok(Some(mut our_nts)), Some(mut other_nts)) => {
                            our_nts.sort();
                            other_nts.sort();
                            our_nts == other_nts
                        }
                        _ => false,
                    }
                }
            }
        }
        /// Returns whether if edge passing between given nodes exists.
        ///
        /// # Arguments
        ///
        /// * `src_name`: &str - The source node name of the edge.
        /// * `dst_name`: &str - The destination node name of the edge.
        ///
        /// # Example
        /// To check if an edge in the graph you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// assert!(graph.has_edge_from_node_names("ENSP00000000233", "ENSP00000432568"));
        /// assert!(!graph.has_edge_from_node_names("ENSP00000000233", "NonExistent"));
        /// ```
        pub fn has_edge_from_node_names(&self, src_name: &str, dst_name: &str) -> bool {
            self.get_edge_id_from_node_names(src_name, dst_name).is_ok()
        }
        /// Returns whether if edge with type passing between given nodes exists.
        ///
        /// # Arguments
        ///
        /// * `src_name`: &str - The source node name of the edge.
        /// * `dst_name`: &str - The destination node name of the edge.
        /// * `edge_type_name`: Option<&str> - The (optional) edge type name.
        ///
        /// # Example
        /// To check if an edge with type in the graph you can use:
        /// ```rust
        /// # let graph = graph::test_utilities::load_ppi(false, true, true, true, false, false);
        /// let edge_type = Some("red");
        /// let unexistent_edge_type = Some("NonExistent");
        /// assert!(graph.has_edge_from_node_names_and_edge_type_name("ENSP00000000233", "ENSP00000432568", edge_type));
        /// assert!(!graph.has_edge_from_node_names_and_edge_type_name("ENSP00000000233", "ENSP00000432568", unexistent_edge_type));
        /// assert!(!graph.has_edge_from_node_names_and_edge_type_name("ENSP00000000233", "NonExistent", edge_type));
        /// assert!(!graph.has_edge_from_node_names_and_edge_type_name("ENSP00000000233", "NonExistent", unexistent_edge_type));
        /// ```
        pub fn has_edge_from_node_names_and_edge_type_name(
            &self,
            src_name: &str,
            dst_name: &str,
            edge_type_name: Option<&str>,
        ) -> bool {
            self.get_edge_id_from_node_names_and_edge_type_name(src_name, dst_name, edge_type_name)
                .is_ok()
        }
    }
}
mod queries_walk {
    use super::*;
    use vec_rand::sorted_unique_sub_sampling;
    /// # Walk Queries
    /// These are the queries that are used mainly in the random walk.
    impl Graph {
        /// Returns quadruple with minimum and maximum edge ids, destination nodes and its indices if subsampling was required.
        ///
        /// If max neighbours was provided the subsampling is done by using the
        /// sorted unique sub-sampling (SUSS) algorithm.
        ///
        /// # Arguments
        /// * `max_neighbours`: Option<NodeT> - Optional maximum number of neighbours to consider.
        /// * `random_state`: u64 - The random state to use for the sampling if the maximum neighbours are asked.
        /// * `source_node_id`: NodeT - The source node ID to extract edge IDs and destination node IDs.
        pub(crate) unsafe fn get_unchecked_edges_and_destinations_from_source_node_id(
            &self,
            max_neighbours: Option<NodeT>,
            random_state: u64,
            source_node_id: NodeT,
        ) -> (EdgeT, EdgeT, Option<Vec<NodeT>>, Option<Vec<u64>>) {
            let (min_edge_id, max_edge_id) =
                self.get_unchecked_minmax_edge_ids_from_source_node_id(source_node_id);
            if let Some(indices) = max_neighbours.and_then(|mn| {
                sorted_unique_sub_sampling(min_edge_id, max_edge_id, mn as u64, random_state).ok()
            }) {
                let destinations: Vec<NodeT> = indices
                    .iter()
                    .map(|edge_id| self.get_unchecked_destination_node_id_from_edge_id(*edge_id))
                    .collect();
                return (min_edge_id, max_edge_id, Some(destinations), Some(indices));
            }
            if self.destinations.is_some() {
                return (min_edge_id, max_edge_id, None, None);
            }
            let destinations = Some(
                self.iter_unchecked_neighbour_node_ids_from_source_node_id(source_node_id)
                    .collect(),
            );
            (min_edge_id, max_edge_id, destinations, None)
        }
        /// Returns slice of destinations corresponding to given minmax edge ID and node.
        ///
        /// # Arguments
        /// * `min_edge_id`: EdgeT - Minimum edge ID for the slice.
        /// * `max_edge_id`: EdgeT - Maximum edge ID for the slice.
        /// * `source_node_id`: NodeT - The source node ID.
        /// * `destinations`: &'a Option<Vec<NodeT>> - The optional destinations slice that may have been provided when working with subsampling.
        pub(crate) fn get_destinations_slice<'a>(
            &'a self,
            min_edge_id: EdgeT,
            max_edge_id: EdgeT,
            destinations: &'a Option<Vec<NodeT>>,
        ) -> &'a [NodeT] {
            match (& self . destinations , destinations) { (_ , Some (dsts)) => dsts . as_slice () , (Some (dsts) , None) => & dsts [min_edge_id as usize .. max_edge_id as usize] , _ => { { :: core :: panicking :: panic_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["internal error: entered unreachable code: "] , & match (& "It is not possible to have both destinations and cached destinations at once." ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , })) } } }
        }
    }
}
pub use self::queries::*;
pub use self::queries_boolean::*;
pub use self::url_utilities::*;
pub mod test_utilities {
    //! Test functions used both for testing and fuzzing.
    use super::*;
    use itertools::Itertools;
    use log::warn;
    use num_traits::Zero;
    use rand::Rng;
    use rayon::iter::ParallelIterator;
    use std::collections::HashSet;
    use std::fs;
    use std::path::Path;
    #[cfg(target_os = "macos")]
    static DEFAULT_PATH: &str = "/tmp/";
    const NONEXISTENT : & str = "Cthulhu is a fictional cosmic entity created by writer H. P. Lovecraft and first introduced in the short story The Call of Cthulhu,[2] published in the American pulp magazine Weird Tales in 1928. Considered a Great Old One within the pantheon of Lovecraftian cosmic entities, the creature has since been featured in numerous popular culture references. Lovecraft depicts it as a gigantic entity worshipped by cultists, in shape like an octopus, a dragon, and a caricature of human form. Its name was given to the Lovecraft-inspired universe where it and its fellow entities existed, the Cthulhu Mythos." ;
    const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    /// Computes a random string of the chosen length
    pub fn random_string(len: usize) -> String {
        let mut rng = rand::thread_rng();
        (0..len)
            .map(|_| {
                let idx = rng.gen_range(0, CHARSET.len());
                CHARSET[idx] as char
            })
            .collect()
    }
    /// Computes a random path.
    pub fn random_path(path: Option<&str>) -> String {
        Path::new(path.unwrap_or(DEFAULT_PATH))
            .join(random_string(64))
            .to_str()
            .unwrap()
            .to_string()
    }
    #[allow(clippy::redundant_clone)]
    /// Load the Strings Protein Protein Interaction graph with given parametrization.
    /// This is our default graph we use on tests.
    pub fn load_ppi(
        load_nodes: bool,
        load_edge_types: bool,
        load_weights: bool,
        directed: bool,
        verbose: bool,
        skip_selfloops: bool,
    ) -> Graph {
        let graph_name = "STRING PPI".to_owned();
        let nodes_reader = if load_nodes {
            Some(
                NodeFileReader::new("tests/data/ppi/nodes.tsv".to_string())
                    .unwrap()
                    .set_verbose(Some(false))
                    .set_node_types_column_number(Some(1))
                    .set_nodes_column_number(Some(0))
                    .set_node_types_column(Some("category".to_string()))
                    .unwrap()
                    .set_default_node_type(Some("default".to_string()))
                    .set_nodes_column(Some("id".to_string()))
                    .unwrap()
                    .set_ignore_duplicates(Some(true))
                    .set_separator(Some("\t"))
                    .unwrap()
                    .set_header(Some(true))
                    .set_max_rows_number(Some(100000))
                    .set_rows_to_skip(Some(0))
                    .clone(),
            )
        } else {
            None
        };
        let edges_reader = EdgeFileReader::new("tests/data/ppi/edges.tsv".to_string())
            .unwrap()
            .set_verbose(Some(verbose))
            .set_ignore_duplicates(Some(true))
            .set_separator(Some("\t"))
            .unwrap()
            .set_header(Some(true))
            .set_rows_to_skip(Some(0))
            .set_sources_column(Some("subject".to_string()))
            .unwrap()
            .set_destinations_column(Some("object".to_string()))
            .unwrap()
            .set_weights_column(if load_weights {
                Some("weight".to_string())
            } else {
                None
            })
            .unwrap()
            .set_edge_types_column(if load_edge_types {
                Some("edge_label".to_string())
            } else {
                None
            })
            .unwrap()
            .set_default_edge_type(if load_edge_types {
                Some("Kebab".to_string())
            } else {
                None
            })
            .set_max_rows_number(Some(100000))
            .set_default_weight(if load_weights { Some(5.0) } else { None })
            .set_skip_selfloops(Some(skip_selfloops))
            .clone();
        let ppi = Graph::from_unsorted_csv(
            edges_reader,
            nodes_reader,
            directed,
            false,
            graph_name.clone(),
        )
        .unwrap();
        {
            match (&ppi.has_node_types(), &load_nodes) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (&ppi.has_edge_types(), &load_edge_types) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (&ppi.has_edge_weights(), &load_weights) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (&ppi.has_selfloops(), &!skip_selfloops) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::Some(::core::fmt::Arguments::new_v1(
                                &[
                                    "I was expecting the graph self-loops status to be ",
                                    " since we have given parameter skip_selfloops equal to ",
                                    ", but actually is ",
                                    ".\nThe graph report is: \n ",
                                ],
                                &match (
                                    &!skip_selfloops,
                                    &skip_selfloops,
                                    &ppi.has_selfloops(),
                                    &ppi.textual_report(),
                                ) {
                                    (arg0, arg1, arg2, arg3) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg2,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Debug::fmt),
                                    ],
                                },
                            )),
                        );
                    }
                }
            }
        };
        ppi
    }
    /// Load an empty graph instance
    pub fn load_empty_graph(directed: bool) -> Graph {
        Graph::from_integer_sorted(
            std::iter::empty(),
            0,
            Vocabulary::default(),
            None,
            None,
            directed,
            false,
            "Empty graph",
            false,
            false,
            false,
            false,
            false,
            false,
            false,
        )
        .unwrap()
    }
    #[allow(clippy::redundant_clone)]
    /// This is our default graph we use on tests with node types.
    pub fn load_cora() -> Graph {
        let graph_name = "Cora".to_owned();
        let edges_reader = EdgeFileReader::new("tests/data/cora/edges.tsv")
            .unwrap()
            .set_separator(Some("\t"))
            .unwrap()
            .set_verbose(Some(false))
            .set_sources_column(Some("subject"))
            .unwrap()
            .set_destinations_column(Some("object"))
            .unwrap()
            .set_edge_types_column(Some("edge_type"))
            .unwrap();
        let nodes_reader = Some(
            NodeFileReader::new("tests/data/cora/nodes.tsv")
                .unwrap()
                .set_separator(Some("\t"))
                .unwrap()
                .set_nodes_column(Some("id"))
                .unwrap()
                .set_verbose(Some(false))
                .set_node_types_column(Some("node_type"))
                .unwrap(),
        );
        Graph::from_unsorted_csv(edges_reader, nodes_reader, false, false, graph_name.clone())
            .unwrap()
    }
    /// Return WalksParameters to execute a first order walk.
    pub fn first_order_walker(graph: &Graph) -> Result<WalksParameters> {
        Ok(WalksParameters::new(8)?
            .set_iterations(Some(1))?
            .set_random_state(Some(43))
            .set_dense_node_mapping(Some(graph.get_dense_nodes_mapping())))
    }
    /// Return WalksParameters to execute a second order walk.
    pub fn second_order_walker(
        graph: &Graph,
        return_weight: WeightT,
        explore_weight: WeightT,
    ) -> Result<WalksParameters> {
        Ok(WalksParameters::new(8)?
            .set_iterations(Some(1))?
            .set_return_weight(Some(return_weight))?
            .set_explore_weight(Some(explore_weight))?
            .set_max_neighbours(Some(3))?
            .set_change_edge_type_weight(Some(2.0))?
            .set_change_node_type_weight(Some(2.0))?
            .set_dense_node_mapping(Some(graph.get_dense_nodes_mapping()))
            .set_random_state(Some(43)))
    }
    fn validate_vocabularies(graph: &Graph) {
        if let Some(ets) = &graph.edge_types {
            {
                match (&!ets.ids.is_empty(), &graph.has_edge_types()) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["We expected that if the graph has edge types then it cannot be empty. The report of the graph is:\n"] , & match (& graph . textual_report () ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                        }
                    }
                }
            };
        }
        if let Some(nts) = &graph.node_types {
            {
                match (&!nts.ids.is_empty(), &graph.has_node_types()) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
        }
        if let Some(ws) = &graph.weights {
            {
                match (&!ws.is_empty(), &graph.has_edge_weights()) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["We expect the edge weights vector to NOT be empty if the graph says it has weights.\nThe graph report is:\n"] , & match (& graph . textual_report () ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                        }
                    }
                }
            };
        }
    }
    /// Executes the default test suite for holdouts.
    pub fn default_holdout_test_suite(graph: &Graph, train: &Graph, test: &Graph) -> Result<()> {
        for g in &[graph, train, test] {
            validate_vocabularies(g);
        }
        test_graph_properties(train, None)?;
        test_graph_properties(test, None)?;
        if !!train.overlaps(&test)? {
            {
                ::std::rt::begin_panic("Training graph overlaps with test graph!")
            }
        };
        if !!test.overlaps(&train)? {
            {
                ::std::rt::begin_panic("Test graph overlaps with training graph!")
            }
        };
        if !graph.contains(&train)? {
            {
                ::std::rt::begin_panic("Graph does not training graph.")
            }
        };
        if !graph.contains(&test)? {
            {
                ::std::rt::begin_panic("Graph does not contain test graph.")
            }
        };
        let summed = (train | test)?;
        validate_vocabularies(&summed);
        if !summed.contains(&graph)? {
            {
                ::std::rt::begin_panic(
                    "Composed train and test graph do not contained original graph.",
                )
            }
        };
        let subtracted = (graph - test)?;
        validate_vocabularies(&subtracted);
        if !subtracted.contains(&train)? {
            {
                ::std::rt::begin_panic(
                    "Main graph subtracted test does not contain training graph.",
                )
            }
        };
        if !!subtracted.overlaps(&test)? {
            {
                ::std::rt::begin_panic("Main graph subtracted train does not contain test graph.")
            }
        };
        let xorred = (graph ^ test)?;
        validate_vocabularies(&xorred);
        if !xorred.contains(&train)? {
            {
                ::std::rt::begin_panic("Main graph xorred test does not contain training graph.")
            }
        };
        if !!xorred.overlaps(&test)? {
            {
                ::std::rt::begin_panic("Main graph xorred train does not contain testing graph.")
            }
        };
        let anded = (graph & test)?;
        validate_vocabularies(&anded);
        if !anded.contains(&test)? {
            {
                ::std::rt::begin_panic("Main graph anded test does not contain training graph.")
            }
        };
        Ok(())
    }
    /// Test that the spanning arborescence algorithm from bader is working correctly.
    pub fn test_spanning_arborescence_bader(graph: &Graph, verbose: Option<bool>) {
        let kruskal_tree = graph.spanning_arborescence_kruskal(verbose).0;
        let random_kruskal_tree = graph
            .random_spanning_arborescence_kruskal(Some(42), None, verbose)
            .0;
        if !graph.directed {
            let spanning_arborescence_bader: Vec<(NodeT, NodeT)> =
                graph.spanning_arborescence(verbose).unwrap().1.collect();
            {
                match (&spanning_arborescence_bader.len(), &kruskal_tree.len()) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["The number of extracted edges forming the spanning arborescence computed by the bader\'s algorithm does not match the one computed by kruskal. The graph report is:\n" , "\nThe bader\'s tree is:\n" , "\nThe kruskal\'s tree is:\n"] , & match (& graph . textual_report () , & spanning_arborescence_bader , & kruskal_tree) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                        }
                    }
                }
            };
        } else {
            if !graph.spanning_arborescence(verbose).is_err() {
                ::core::panicking::panic(
                    "assertion failed: graph.spanning_arborescence(verbose).is_err()",
                )
            };
        }
        {
            match (&(random_kruskal_tree.len() as usize), &kruskal_tree.len()) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
    }
    pub fn test_graph_properties(graph: &Graph, verbose: Option<bool>) -> Result<()> {
        validate_vocabularies(graph);
        let not_singleton_nodes = graph
            .get_edge_node_ids(true)
            .into_iter()
            .flatten()
            .unique()
            .collect::<HashSet<NodeT>>();
        let singleton_nodes = graph
            .iter_node_ids()
            .filter(|node_id| !not_singleton_nodes.contains(node_id))
            .collect::<HashSet<NodeT>>();
        {
            match (&!singleton_nodes.is_empty(), &graph.has_singleton_nodes()) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (
                &singleton_nodes.len(),
                &(graph.get_singleton_nodes_number() as usize),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        if !unsafe {
            singleton_nodes
                .iter()
                .all(|node_id| graph.is_unchecked_singleton_from_node_id(*node_id))
        } {
            :: core :: panicking :: panic ("assertion failed: unsafe {\\n    singleton_nodes.iter().all(|node_id|\\n                                   graph.is_unchecked_singleton_from_node_id(*node_id))\\n}")
        };
        if !unsafe {
            singleton_nodes
                .iter()
                .all(|node_id| graph.get_unchecked_node_degree_from_node_id(*node_id) == 0)
        } {
            :: core :: panicking :: panic ("assertion failed: unsafe {\\n    singleton_nodes.iter().all(|node_id|\\n                                   graph.get_unchecked_node_degree_from_node_id(*node_id)\\n                                       == 0)\\n}")
        };
        if !graph.is_directed() {
            let singleton_nodes_with_selfloops = graph
                .iter_node_ids()
                .filter(|node_id| unsafe {
                    graph.get_unchecked_node_degree_from_node_id(*node_id) > 0
                        && graph
                            .iter_unchecked_neighbour_node_ids_from_source_node_id(*node_id)
                            .all(|dst| dst == *node_id)
                })
                .collect::<HashSet<NodeT>>();
            {
                match (
                    &!singleton_nodes_with_selfloops.is_empty(),
                    &graph.has_singleton_nodes_with_selfloops(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["Singleton nodes with selfloops were found within the provided, but the graph would not seem to contain any.\nThe graph edge list is:\n" , "."] , & match (& graph . get_edge_node_ids (true) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                        }
                    }
                }
            };
            {
                match (
                    &singleton_nodes_with_selfloops.len(),
                    &(graph.get_singleton_nodes_with_selfloops_number() as usize),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            if !singleton_nodes_with_selfloops
                .iter()
                .all(|node_id| graph.is_singleton_with_selfloops_from_node_id(*node_id))
            {
                {
                    :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["The singleton with self-loops are defined as the set of nodes that exclusively have self-loop edges.\nWe have found the following list of singleton nodes with selfloops: " , "\n"] , & match (& singleton_nodes_with_selfloops ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , }))
                }
            };
        }
        if !graph.is_directed() {
            graph . iter_edge_node_ids (true) . for_each (| (_ , src_node_id , dst_node_id) | { if ! graph . has_edge_from_node_ids (dst_node_id , src_node_id) { { :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["In an undirected graph, for every edge there must have its own symmetric edge.\nIn the provided graph instance, for the edge from the source node ID " , " to the destination node ID " , " the symmetric edge does not exist.\nThis error is likely caused by some mis-parametrization in a method that is expected to produce a simmetric graph.\nThe complete set of edges in the graph is:\n"] , & match (& src_node_id , & dst_node_id , & graph . get_edge_node_ids (true)) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , })) } } ; }) ;
        }
        {
            match (
                &graph.iter_node_degrees().is_sorted(),
                &graph.has_nodes_sorted_by_increasing_outbound_node_degree(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["The cached value for the method has_nodes_sorted_by_increasing_outbound_node_degree does not match the computed method.\nThe degrees of this graph are:\n " , "\nThe reported order was: "] , & match (& graph . get_node_degrees () , & graph . has_nodes_sorted_by_increasing_outbound_node_degree ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , }))) ;
                    }
                }
            }
        };
        let mut degrees = graph.get_node_degrees();
        degrees.reverse();
        {
            match (
                &degrees.is_sorted(),
                &graph.has_nodes_sorted_by_decreasing_outbound_node_degree(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["The cached value for the method has_nodes_sorted_by_decreasing_outbound_node_degree does not match the computed method."] , & match () { () => [] , }))) ;
                    }
                }
            }
        };
        if graph.has_nodes() && (graph.has_singleton_nodes() || graph.has_trap_nodes()) {
            if !(graph.get_minimum_node_degree().unwrap() == 0) {
                {
                    :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["When the graph either contains singleton nodes or trap nodes we expect for the minimum node degree to be zero, but is " , "."] , & match (& graph . get_minimum_node_degree () . unwrap () ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }))
                }
            };
            if !(graph.iter_node_degrees().min().unwrap() == 0) {
                ::core::panicking::panic(
                    "assertion failed: graph.iter_node_degrees().min().unwrap() == 0",
                )
            };
        }
        if let (Ok(min_degree), Ok(max_degree)) = (
            graph.get_minimum_node_degree(),
            graph.get_maximum_node_degree(),
        ) {
            {
                match (
                    &(graph.has_nodes_sorted_by_decreasing_outbound_node_degree()
                        && graph.has_nodes_sorted_by_increasing_outbound_node_degree()),
                    &(min_degree == max_degree),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["When the the nodes are sorted both by decreasing and increasing node degree the minimum and maximum node degrees must be equal, and viceversa.\nThe computed minimum node degree is " , ".\nThe computed maximum node degree is " , ".\nThe result of has_nodes_sorted_by_decreasing_outbound_node_degree is " , ".\nThe result of has_nodes_sorted_by_increasing_outbound_node_degree is " , ".\nThe node degrees are:\n" , "."] , & match (& min_degree , & max_degree , & graph . has_nodes_sorted_by_decreasing_outbound_node_degree () , & graph . has_nodes_sorted_by_increasing_outbound_node_degree () , & graph . get_node_degrees ()) { (arg0 , arg1 , arg2 , arg3 , arg4) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg3 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg4 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                        }
                    }
                }
            };
        }
        if graph.has_edge_weights() {
            graph.iter_edge_weights().unwrap().for_each(|w| {
                if !!w.is_zero() {
                    {
                        ::std::rt::begin_panic("The graph cannot contain a zero weight. ")
                    }
                };
                if !!w.is_infinite() {
                    {
                        ::std::rt::begin_panic("The graph cannot contain an infinite weight. ")
                    }
                };
                if !!w.is_nan() {
                    {
                        ::std::rt::begin_panic("The graph cannot contain a nan weight. ")
                    }
                };
            });
            if !graph.is_directed() {
                graph . iter_edge_node_ids (false) . for_each (| (_ , src_node_id , dst_node_id) | unsafe { if ! ((graph . get_unchecked_edge_weight_from_node_ids (src_node_id , dst_node_id) - graph . get_unchecked_edge_weight_from_node_ids (dst_node_id , src_node_id)) . abs () < WeightT :: EPSILON) { { :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["In an undirected graph, we expect for the edge weights to be symmetrical but in the provided graph there has been found a case where the edge from " , " to " , " has weight " , ", while the edge from " , " to " , " has weight " , ", creating an asymetrical case."] , & match (& src_node_id , & dst_node_id , & graph . get_unchecked_edge_weight_from_node_ids (src_node_id , dst_node_id) , & dst_node_id , & src_node_id , & graph . get_unchecked_edge_weight_from_node_ids (dst_node_id , src_node_id)) { (arg0 , arg1 , arg2 , arg3 , arg4 , arg5) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg3 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg4 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg5 , :: core :: fmt :: Display :: fmt)] , })) } } ; }) ;
            }
        }
        {
            match (
                &graph.get_maximum_node_degree()?,
                &graph.iter_node_degrees().max().unwrap(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["The cached maximum degree does not match the one computed from the node degrees."] , & match () { () => [] , }))) ;
                    }
                }
            }
        };
        if !graph.is_directed() && !graph.has_singleton_nodes() {
            if !(graph.get_minimum_node_degree()? > 0) {
                ::core::panicking::panic("assertion failed: graph.get_minimum_node_degree()? > 0")
            };
            if !(graph.iter_node_degrees().min().unwrap() > 0) {
                ::core::panicking::panic(
                    "assertion failed: graph.iter_node_degrees().min().unwrap() > 0",
                )
            };
        }
        if !graph.is_directed() && graph.get_minimum_node_degree()? == 0 {
            if !graph.has_singleton_nodes() {
                ::core::panicking::panic("assertion failed: graph.has_singleton_nodes()")
            };
        }
        if graph.has_singleton_nodes() {
            if !graph.unique_sources.is_some() {
                ::core::panicking::panic("assertion failed: graph.unique_sources.is_some()")
            };
        }
        if !graph.has_disconnected_nodes() && !graph.has_trap_nodes() {
            if !(graph.get_minimum_node_degree()? > 0) {
                ::core::panicking::panic("assertion failed: graph.get_minimum_node_degree()? > 0")
            };
            if !(graph.iter_node_degrees().min().unwrap() > 0) {
                {
                    :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["Since the graph does not contain disconnected nodes nor it contains trap nodes, the minimum outbound node degree must be greater than zero.\n\nThe graph edges are: "] , & match (& graph . get_edge_node_ids (true) ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , }))
                }
            };
        }
        if graph.has_node_types() {
            if !graph.has_nodes() {
                ::core::panicking::panic("assertion failed: graph.has_nodes()")
            };
            {
                match (
                    &graph.get_known_node_types_number().unwrap(),
                    &graph
                        .iter_node_ids_and_node_type_ids()
                        .map(|(_, node_type)| node_type.is_some() as NodeT)
                        .sum(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            {
                match (
                    &graph.get_unknown_node_types_number().unwrap(),
                    &graph
                        .iter_node_ids_and_node_type_ids()
                        .map(|(_, node_type)| node_type.is_none() as NodeT)
                        .sum(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            if graph.has_unknown_node_types().unwrap() {
                if !graph
                    .iter_node_ids_and_node_type_ids()
                    .any(|(_, node_type)| node_type.is_none())
                {
                    :: core :: panicking :: panic ("assertion failed: graph.iter_node_ids_and_node_type_ids().any(|(_, node_type)|\\n                                                node_type.is_none())")
                };
                if !(graph.get_node_ids_with_unknown_node_types().unwrap().len() > 0) {
                    :: core :: panicking :: panic ("assertion failed: graph.get_node_ids_with_unknown_node_types().unwrap().len() > 0")
                };
            }
            if graph.has_known_node_types().unwrap() {
                if !graph
                    .iter_node_ids_and_node_type_ids()
                    .any(|(_, node_type)| node_type.is_some())
                {
                    :: core :: panicking :: panic ("assertion failed: graph.iter_node_ids_and_node_type_ids().any(|(_, node_type)|\\n                                                node_type.is_some())")
                };
                if !(graph.get_node_ids_with_known_node_types().unwrap().len() > 0) {
                    :: core :: panicking :: panic ("assertion failed: graph.get_node_ids_with_known_node_types().unwrap().len() > 0")
                };
            }
        }
        if graph.has_edge_types() {
            if !graph.has_edges() {
                ::core::panicking::panic("assertion failed: graph.has_edges()")
            };
            {
                match (
                    &graph.get_known_edge_types_number().unwrap(),
                    &graph
                        .iter_edge_node_ids_and_edge_type_id(true)
                        .map(|(_, _, _, edge_type)| edge_type.is_some() as EdgeT)
                        .sum(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            {
                match (
                    &graph.get_unknown_edge_types_number().unwrap(),
                    &graph
                        .iter_edge_node_ids_and_edge_type_id(true)
                        .map(|(_, _, _, edge_type)| edge_type.is_none() as EdgeT)
                        .sum(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            if graph.has_unknown_edge_types().unwrap() {
                if !graph
                    .iter_edge_node_ids_and_edge_type_id(true)
                    .any(|(_, _, _, edge_type)| edge_type.is_none())
                {
                    :: core :: panicking :: panic ("assertion failed: graph.iter_edge_node_ids_and_edge_type_id(true).any(|(_, _, _, edge_type)|\\n                                                        edge_type.is_none())")
                };
                if !(graph.get_edge_ids_with_unknown_edge_types().unwrap().len() > 0) {
                    :: core :: panicking :: panic ("assertion failed: graph.get_edge_ids_with_unknown_edge_types().unwrap().len() > 0")
                };
            }
            if graph.has_known_edge_types().unwrap() {
                if !graph
                    .iter_edge_node_ids_and_edge_type_id(true)
                    .any(|(_, _, _, edge_type)| edge_type.is_some())
                {
                    {
                        :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["We expected for the graph to contain at least one edge with a known edge type, but apparently it does not contain any. The graph contains " , " edges and would have seemed to contain " , " edges with known edge types."] , & match (& graph . get_directed_edges_number () , & graph . get_known_edge_types_number () . unwrap ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , }))
                    }
                };
                if !(graph.get_edge_ids_with_known_edge_types().unwrap().len() > 0) {
                    :: core :: panicking :: panic ("assertion failed: graph.get_edge_ids_with_known_edge_types().unwrap().len() > 0")
                };
            }
        }
        {
            match (
                &graph.singleton_nodes_with_selfloops.is_some(),
                &graph.has_singleton_nodes_with_selfloops(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (
                &graph.get_minimum_node_degree()?,
                &graph.iter_node_degrees().min().unwrap(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["The cached minimum degree does not match the one computed from the node degrees.\nThe outbound node degrees are: "] , & match (& graph . get_node_degrees () ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                    }
                }
            }
        };
        if graph.has_edge_weights() {
            if !((graph.get_weighted_maximum_node_degree()?
                - graph
                    .iter_weighted_node_degrees()?
                    .max_by(|a, b| a.partial_cmp(b).unwrap())
                    .unwrap())
            .abs()
                < f64::EPSILON)
            {
                {
                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(
                        &[
                            "The cached weighted maximum degree (",
                            ") does not match the one computed from the node degrees (",
                            "), where the node degrees list is ",
                            ".\nAdditionally the number of weighted singleton nodes is ",
                            ".",
                        ],
                        &match (
                            &graph.get_weighted_maximum_node_degree()?,
                            &graph
                                .iter_weighted_node_degrees()?
                                .max_by(|a, b| a.partial_cmp(b).unwrap())
                                .unwrap(),
                            &graph.get_weighted_node_degrees(),
                            &graph.get_weighted_singleton_nodes_number(),
                        ) {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Debug::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Debug::fmt),
                            ],
                        },
                    ))
                }
            };
            if !((graph.get_weighted_mininum_node_degree()?
                - graph
                    .iter_weighted_node_degrees()?
                    .min_by(|a, b| a.partial_cmp(b).unwrap())
                    .unwrap())
            .abs()
                < f64::EPSILON)
            {
                {
                    ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(
                        &[
                            "The cached weighted minimum degree (",
                            ") does not match the one computed from the node degrees (",
                            ").",
                        ],
                        &match (
                            &graph.get_weighted_mininum_node_degree()?,
                            &graph
                                .iter_weighted_node_degrees()?
                                .min_by(|a, b| a.partial_cmp(b).unwrap())
                                .unwrap(),
                        ) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                            ],
                        },
                    ))
                }
            };
        }
        {
            match (
                &graph
                    .singleton_nodes_with_selfloops
                    .as_ref()
                    .map_or(0, |x| x.len() as NodeT),
                &graph.get_singleton_nodes_with_selfloops_number(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        for singleton_node_id in graph.iter_singleton_node_ids() {
            if !(unsafe { graph.get_unchecked_node_degree_from_node_id(singleton_node_id) } == 0) {
                :: core :: panicking :: panic ("assertion failed: unsafe { graph.get_unchecked_node_degree_from_node_id(singleton_node_id) } ==\\n    0")
            };
            if !unsafe { graph.is_unchecked_singleton_from_node_id(singleton_node_id) } {
                :: core :: panicking :: panic ("assertion failed: unsafe { graph.is_unchecked_singleton_from_node_id(singleton_node_id) }")
            };
        }
        if !graph.is_directed() {
            for node_id in graph.iter_node_ids() {
                unsafe {
                    {
                        match (
                            &graph.is_unchecked_singleton_from_node_id(node_id),
                            &(graph.get_unchecked_node_degree_from_node_id(node_id) == 0),
                        ) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::None,
                                    );
                                }
                            }
                        }
                    }
                };
            }
        }
        if !graph
            .get_edge_id_from_node_names_and_edge_type_name(NONEXISTENT, NONEXISTENT, None)
            .is_err()
        {
            {
                ::std::rt::begin_panic("Graph contains non-existing edge.")
            }
        };
        if !!(graph.has_node_name_and_node_type_name(NONEXISTENT, None)) {
            {
                ::std::rt::begin_panic("The graph seems to have a non-existing node.")
            }
        };
        if !!(graph.has_node_name(NONEXISTENT)) {
            {
                ::std::rt::begin_panic("The graph seems to have a non-existing node.")
            }
        };
        if graph.has_singleton_nodes() {
            if !graph.has_nodes() {
                ::core::panicking::panic("assertion failed: graph.has_nodes()")
            };
        }
        if graph.has_singleton_nodes_with_selfloops() {
            if !graph.has_nodes() {
                ::core::panicking::panic("assertion failed: graph.has_nodes()")
            };
            if !graph.has_selfloops() {
                ::core::panicking::panic("assertion failed: graph.has_selfloops()")
            };
        }
        if !graph
            .get_edge_type_ids_from_edge_type_names(<[_]>::into_vec(box [Some(
                NONEXISTENT.to_string(),
            )]))
            .is_err()
        {
            {
                ::std::rt::begin_panic("The graph seems to have a non-existing edge type.")
            }
        };
        if !graph
            .get_node_type_ids_from_node_type_names(<[_]>::into_vec(box [Some(
                NONEXISTENT.to_string(),
            )]))
            .is_err()
        {
            {
                ::std::rt::begin_panic("The graph seems to have a non-existing node type.")
            }
        };
        {
            match (
                &(graph.get_connected_nodes_number()
                    + graph.get_singleton_nodes_number()
                    + graph.get_singleton_nodes_with_selfloops_number()),
                &graph.get_nodes_number(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["Sum of singleton and non singleton nodes number does not match."] , & match () { () => [] , }))) ;
                    }
                }
            }
        };
        {
            match (
                &graph.get_disconnected_nodes_number(),
                &(graph.get_singleton_nodes_number()
                    + graph.get_singleton_nodes_with_selfloops_number()),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["Sum of singleton and singleton with selfloops does not match the number of disconnected nodes."] , & match () { () => [] , }))) ;
                    }
                }
            }
        };
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Running connected components tests."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        755u32,
                    ),
                );
            }
        };
        let (_components_number, smallest, biggest) = graph.get_connected_components_number(None);
        if !(biggest >= smallest) {
            {
                ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(
                    &["smallest: ", " biggest: "],
                    &match (&smallest, &biggest) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ],
                    },
                ))
            }
        };
        if smallest == 1 {
            if !(graph.has_singleton_nodes() || graph.has_singleton_nodes_with_selfloops()) {
                {
                    :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["When the smallest component is one the graph must have singletons! Graph report: \n"] , & match (& graph . textual_report () ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , }))
                }
            };
        }
        {
            match (&!graph.has_nodes(), &(smallest == 0)) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["When the smallest component is zero the graph must be empty! Graph report: \n"] , & match (& graph . textual_report () ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                    }
                }
            }
        };
        if let Some(edge) = graph.iter_unique_edge_node_ids(true).next() {
            let src_string = unsafe { graph.get_unchecked_node_name_from_node_id(edge.0) };
            let dst_string = unsafe { graph.get_unchecked_node_name_from_node_id(edge.1) };
            let edge_id = graph.get_edge_id_from_node_names(&src_string, &dst_string)?;
            if graph.has_edge_types() {
                let edge_type = graph.get_edge_type_name_from_edge_id(edge_id)?;
                let clone_edge_type = edge_type.clone();
                if !graph.has_edge_from_node_names_and_edge_type_name(
                    &src_string,
                    &dst_string,
                    clone_edge_type.as_deref(),
                ) {
                    {
                        ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(
                            &[
                                "I was expecting for the edge (",
                                ", ",
                                ", ",
                                ") to exist, but it seems to not exist in graph ",
                            ],
                            &match (
                                &src_string,
                                &dst_string,
                                &edge_type,
                                &graph.textual_report(),
                            ) {
                                (arg0, arg1, arg2, arg3) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Debug::fmt),
                                    ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Debug::fmt),
                                ],
                            },
                        ))
                    }
                };
            } else {
                if !graph.has_edge_from_node_names(&src_string, &dst_string) {
                    {
                        ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(
                            &[
                                "I was expecting for the edge (",
                                ", ",
                                ") without type to exist, but it seems to not exist in graph ",
                            ],
                            &match (&src_string, &dst_string, &graph.textual_report()) {
                                (arg0, arg1, arg2) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Debug::fmt),
                                ],
                            },
                        ))
                    }
                };
            }
            if !(graph.has_node_name(&src_string) && graph.has_node_name(&dst_string)) {
                :: core :: panicking :: panic ("assertion failed: graph.has_node_name(&src_string) && graph.has_node_name(&dst_string)")
            };
            if graph.has_node_types() {
                if !(graph.has_node_name_and_node_type_name(
                    &src_string,
                    graph.get_node_type_names_from_node_name(&src_string)?,
                ) && graph.has_node_name_and_node_type_name(
                    &dst_string,
                    graph.get_node_type_names_from_node_name(&dst_string)?,
                )) {
                    {
                        :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["The nodes " , " and " , " with node types are not present in the graph.\nThe node types are " , " and " , ".\nThe first node existance is " , "\nThe second node existance is " , "\nThe graph report is "] , & match (& src_string , & dst_string , & graph . get_node_type_names_from_node_name (& src_string) , & graph . get_node_type_names_from_node_name (& dst_string) , & graph . has_node_name_and_node_type_name (& src_string , graph . get_node_type_names_from_node_name (& src_string) ?) , & graph . has_node_name_and_node_type_name (& dst_string , graph . get_node_type_names_from_node_name (& dst_string) ?) , & graph . textual_report ()) { (arg0 , arg1 , arg2 , arg3 , arg4 , arg5 , arg6) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg3 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg4 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg5 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg6 , :: core :: fmt :: Debug :: fmt)] , }))
                    }
                };
            }
            {
                match (
                    &graph.get_edge_id_from_node_names(&src_string, &dst_string)?,
                    &graph.get_edge_id_from_node_ids(edge.0, edge.1).unwrap(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::Some(::core::fmt::Arguments::new_v1(
                                    &["Check of given edge ID does not match."],
                                    &match () {
                                        () => [],
                                    },
                                )),
                            );
                        }
                    }
                }
            };
        }
        graph.report();
        graph.textual_report();
        graph.overlap_textual_report(&graph, verbose)?;
        for src in 0..5 {
            for dst in 0..5 {
                let _ = graph.get_preferential_attachment_from_node_ids(src, dst, true);
                let _ = graph.get_preferential_attachment_from_node_ids(src, dst, false);
                let _ = graph.get_jaccard_coefficient_from_node_ids(src, dst);
                let _ = graph.get_adamic_adar_index_from_node_ids(src, dst);
                let _ = graph.get_resource_allocation_index_from_node_ids(src, dst);
                if graph.has_edge_weights() {
                    let _ =
                        graph.get_weighted_preferential_attachment_from_node_ids(src, dst, true);
                    let _ =
                        graph.get_weighted_preferential_attachment_from_node_ids(src, dst, false);
                    let _ = graph.get_weighted_resource_allocation_index_from_node_ids(src, dst);
                }
            }
        }
        {
            match (
                &graph.has_node_types(),
                &graph.get_node_type_id_from_node_id(0).is_ok(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        if !graph
            .get_node_type_id_from_node_id(graph.get_nodes_number() + 1)
            .is_err()
        {
            {
                :: std :: rt :: begin_panic ("Given graph does not raise an exception when a node's node type greater than the number of available nodes is requested.")
            }
        };
        {
            match (
                &graph.has_edge_types(),
                &graph.get_edge_type_id_from_edge_id(0).is_ok(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        if !graph
            .get_edge_type_id_from_edge_id(graph.get_directed_edges_number() + 1)
            .is_err()
        {
            {
                :: std :: rt :: begin_panic ("Given graph does not raise an exception when a edge's edge type greater than the number of available edges is requested.")
            }
        };
        {
            match (
                &graph.get_node_type_id_from_node_id(0).is_ok(),
                &graph.has_node_types(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (
                &graph.get_edge_type_id_from_edge_id(0).is_ok(),
                &graph.has_edge_types(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (
                &graph.get_edge_type_id_counts_hashmap().is_ok(),
                &graph.has_edge_types(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (
                &graph.get_edge_type_id_counts_hashmap().is_ok(),
                &graph.has_edge_types(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        graph.strongly_connected_components();
        let (_, connected_components, total_connected_components, _, _) =
            graph.random_spanning_arborescence_kruskal(Some(42), None, verbose);
        let actual_components_number = connected_components.iter().unique().count() as NodeT;
        {
            match (&actual_components_number, &total_connected_components) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["The measured number of connected components (" , ") does not match the computed number of connected components (" , ").\nThat is, the components are not a dense set.\nThis is likely caused by a problem with the remapping of the components."] , & match (& actual_components_number , & total_connected_components) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , }))) ;
                    }
                }
            }
        };
        let max_component_id = connected_components.iter().max();
        if let Some(mci) = max_component_id {
            {
                match (&(*mci as usize), &(total_connected_components as usize - 1)) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["We expected the connected components to be a dense set.\n The obtained components are: \n" , "\n The graph report is:\n"] , & match (& connected_components , & graph . textual_report ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                        }
                    }
                }
            };
        }
        if !graph.is_directed() {
            let (connected_components, total_connected_components, _, _) =
                graph.connected_components(verbose).unwrap();
            let actual_components_number = connected_components.iter().unique().count() as NodeT;
            {
                match (&actual_components_number, &total_connected_components) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["The measured number of connected components (" , ") does not match the computed number of connected components (" , ")."] , & match (& actual_components_number , & total_connected_components) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , }))) ;
                        }
                    }
                }
            };
            let max_component_id = connected_components.iter().max();
            if let Some(mci) = max_component_id {
                {
                    match (&(*mci as usize), &(total_connected_components as usize - 1)) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["We expected the connected components to be a dense set.\n The obtained components are: \n" , "\n The graph report is:\n"] , & match (& connected_components , & graph . textual_report ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                            }
                        }
                    }
                };
            }
        }
        Ok(())
    }
    pub fn test_node_centralities(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        if graph.has_edges() {
            let node_degree_centralities = graph.get_degree_centrality().unwrap();
            {
                match (
                    &node_degree_centralities.len(),
                    &(graph.get_nodes_number() as usize),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            if !node_degree_centralities
                .iter()
                .cloned()
                .all(|value| value <= 1.0 && value >= 0.0)
            {
                {
                    :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["All node degrees centralities are expected to be within 0 and 1, but are " , "."] , & match (& node_degree_centralities ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt)] , }))
                }
            };
        }
        if graph.has_edge_weights() && !graph.has_negative_edge_weights().unwrap() {
            let node_degree_centralities = graph.get_weighted_degree_centrality().unwrap();
            {
                match (
                    &node_degree_centralities.len(),
                    &(graph.get_nodes_number() as usize),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            if !node_degree_centralities
                .iter()
                .cloned()
                .all(|value| value <= 1.0 && value >= 0.0)
            {
                {
                    :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["All weighted node degrees centralities are expected to be within 0 and 1, but are " , " and the node degrees are " , ", with the minimum weighted node degree being " , " and maximum weighted node degree being " , "."] , & match (& node_degree_centralities , & graph . get_weighted_node_degrees () , & graph . get_weighted_mininum_node_degree () . unwrap () , & graph . get_weighted_maximum_node_degree () . unwrap ()) { (arg0 , arg1 , arg2 , arg3) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg3 , :: core :: fmt :: Display :: fmt)] , }))
                }
            };
        }
        let node_betweenness_centralities = graph.get_betweenness_centrality(None, verbose);
        {
            match (
                &node_betweenness_centralities.len(),
                &(graph.get_nodes_number() as usize),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        node_betweenness_centralities
            .into_iter()
            .enumerate()
            .for_each(|(node_id, value)| {
                if unsafe { graph.is_unchecked_singleton_from_node_id(node_id as NodeT) } {
                    if !(value.abs() < f64::EPSILON) {
                        ::core::panicking::panic("assertion failed: value.abs() < f64::EPSILON")
                    };
                }
            });
        Ok(())
    }
    pub fn test_vertex_cover(graph: &mut Graph, _verbose: Option<bool>) -> Result<()> {
        let vertex_cover = graph.approximated_vertex_cover_set();
        graph
            .par_iter_edge_node_ids(true)
            .for_each(|(_, src_node_id, dst_node_id)| {
                if !(vertex_cover.contains(&src_node_id) || vertex_cover.contains(&dst_node_id)) {
                    {
                        ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(
                            &[
                                "We expected for either the node ",
                                " or ",
                                " to be in the vertex cover.\nThe vertex cover is ",
                            ],
                            &match (&src_node_id, &dst_node_id, &vertex_cover) {
                                (arg0, arg1, arg2) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Debug::fmt),
                                ],
                            },
                        ))
                    }
                };
            });
        Ok(())
    }
    pub fn test_bfs(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        if graph.get_nodes_number() > 100 {
            return Ok(());
        }
        if !graph.has_nodes() {
            if !graph
                .get_breath_first_search_from_node_ids(0, None, None, None)
                .is_err()
            {
                :: core :: panicking :: panic ("assertion failed: graph.get_breath_first_search_from_node_ids(0, None, None, None).is_err()")
            };
            return Ok(());
        }
        if !graph.is_directed() {
            let components_ids = graph.get_node_connected_component_ids(verbose);
            for maximal_depth in [None, Some(1), Some(2), Some(3)] {
                graph.iter_node_ids().for_each(|src_node_id| {
                    graph.iter_node_ids().for_each(|dst_node_id| unsafe {
                        let src_to_dst = graph.get_unchecked_minimum_path_node_ids_from_node_ids(
                            src_node_id,
                            dst_node_id,
                            maximal_depth,
                        );
                        let dst_to_src = graph.get_unchecked_minimum_path_node_ids_from_node_ids(
                            dst_node_id,
                            src_node_id,
                            maximal_depth,
                        );
                        if src_node_id == dst_node_id {
                            if !src_to_dst.is_err() {
                                ::core::panicking::panic("assertion failed: src_to_dst.is_err()")
                            };
                            if !dst_to_src.is_err() {
                                ::core::panicking::panic("assertion failed: dst_to_src.is_err()")
                            };
                            return;
                        }
                        if components_ids[src_node_id as usize]
                            != components_ids[dst_node_id as usize]
                        {
                            if !src_to_dst.is_err() {
                                ::core::panicking::panic("assertion failed: src_to_dst.is_err()")
                            };
                            if !dst_to_src.is_err() {
                                ::core::panicking::panic("assertion failed: dst_to_src.is_err()")
                            };
                            return;
                        }
                        if let (Ok(src_to_dst), Ok(dst_to_src)) = (src_to_dst, dst_to_src) {
                            {
                                match (&src_to_dst.len(), &dst_to_src.len()) {
                                    (left_val, right_val) => {
                                        if !(*left_val == *right_val) {
                                            let kind = ::core::panicking::AssertKind::Eq;
                                            ::core::panicking::assert_failed(
                                                kind,
                                                &*left_val,
                                                &*right_val,
                                                ::core::option::Option::None,
                                            );
                                        }
                                    }
                                }
                            };
                            {
                                match (
                                    &src_to_dst,
                                    &dst_to_src.into_iter().rev().collect::<Vec<_>>(),
                                ) {
                                    (left_val, right_val) => {
                                        if !(*left_val == *right_val) {
                                            let kind = ::core::panicking::AssertKind::Eq;
                                            ::core::panicking::assert_failed(
                                                kind,
                                                &*left_val,
                                                &*right_val,
                                                ::core::option::Option::None,
                                            );
                                        }
                                    }
                                }
                            };
                            let kpaths = graph
                                .get_unchecked_k_shortest_path_node_ids_from_node_ids(
                                    src_node_id,
                                    dst_node_id,
                                    5,
                                );
                            let min_length =
                                kpaths.into_iter().map(|path| path.len()).min().unwrap();
                            {
                                match (&min_length, &src_to_dst.len()) {
                                    (left_val, right_val) => {
                                        if !(*left_val == *right_val) {
                                            let kind = ::core::panicking::AssertKind::Eq;
                                            ::core::panicking::assert_failed(
                                                kind,
                                                &*left_val,
                                                &*right_val,
                                                ::core::option::Option::None,
                                            );
                                        }
                                    }
                                }
                            };
                        }
                    });
                });
            }
        }
        Ok(())
    }
    pub fn test_dijkstra(graph: &mut Graph, _verbose: Option<bool>) -> Result<()> {
        if graph.get_nodes_number() > 100 {
            return Ok(());
        }
        if !graph.has_nodes() {
            if !graph
                .get_dijkstra_from_node_ids(0, None, None, None, None, None)
                .is_err()
            {
                :: core :: panicking :: panic ("assertion failed: graph.get_dijkstra_from_node_ids(0, None, None, None, None, None).is_err()")
            };
            return Ok(());
        }
        if !graph.has_edge_weights() || graph.has_negative_edge_weights().unwrap() {
            if !graph
                .get_dijkstra_from_node_names(
                    unsafe { graph.get_unchecked_node_name_from_node_id(0).as_ref() },
                    None,
                    None,
                    None,
                    None,
                    None,
                )
                .is_err()
            {
                :: core :: panicking :: panic ("assertion failed: graph.get_dijkstra_from_node_names(unsafe {\\n                                       graph.get_unchecked_node_name_from_node_id(0).as_ref()\\n                                   }, None, None, None, None, None).is_err()")
            };
            return Ok(());
        }
        if !graph.is_directed() {
            for use_edge_weights_as_probabilities in [true, false] {
                if use_edge_weights_as_probabilities
                    && !graph.has_edge_weights_representing_probabilities().unwrap()
                {
                    continue;
                }
                graph . iter_node_ids () . for_each (| src_node_id | { graph . iter_node_ids () . for_each (| dst_node_id | unsafe { let (src_to_dst_distance , src_to_dst) = graph . get_unchecked_weighted_minimum_path_node_ids_from_node_ids (src_node_id , dst_node_id , Some (use_edge_weights_as_probabilities) , None) ; let (dst_to_src_distance , dst_to_src) = graph . get_unchecked_weighted_minimum_path_node_ids_from_node_ids (dst_node_id , src_node_id , Some (use_edge_weights_as_probabilities) , None) ; let src_to_dst_distance = src_to_dst_distance as WeightT ; let dst_to_src_distance = dst_to_src_distance as WeightT ; if ! (src_to_dst_distance . is_infinite () && dst_to_src_distance . is_infinite () || (src_to_dst_distance - dst_to_src_distance) . abs () < WeightT :: EPSILON) { { :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["The path from source to destination has distance " , " while the distance from destination to source has destination " , ". The path from source to destination is " , ", while the path from destination to source is " , ". The two paths should be symmetric and with the same distance.\nThe graph report is:\n"] , & match (& src_to_dst_distance , & dst_to_src_distance , & src_to_dst , & dst_to_src , & graph . textual_report ()) { (arg0 , arg1 , arg2 , arg3 , arg4) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg3 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg4 , :: core :: fmt :: Debug :: fmt)] , })) } } ; }) ; }) ;
            }
        }
        Ok(())
    }
    pub fn test_polygons(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        {
            match (
                &graph
                    .get_number_of_triangles_per_node(Some(false), None, verbose)
                    .into_iter()
                    .map(|triangles_number| triangles_number as EdgeT)
                    .sum::<EdgeT>(),
                &graph.get_number_of_triangles(Some(false), None, verbose),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        Ok(())
    }
    pub fn test_transitivity(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        if graph.get_nodes_number() > 1000 {
            return Ok(());
        }
        if !graph.has_edge_weights() && !graph.has_edge_types() {
            {
                match (
                    &graph.clone(),
                    &graph.get_transitive_closure(Some(0), verbose),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            let graph_with_selfloops = graph.add_selfloops(None, None, verbose).unwrap();
            {
                match (
                    &graph_with_selfloops,
                    &graph_with_selfloops.get_transitive_closure(Some(1), verbose),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["We expected the original graph to equal to the graph obtained after a single iteration of transitive closure, but they are different.\nThe to_dot of the first graph is: \n " , "\nThe to_dot of the second graph is: \n " , "\n"] , & match (& graph_with_selfloops . clone () . to_dot (Some (false)) , & graph_with_selfloops . get_transitive_closure (Some (1) , verbose) . to_dot (Some (false))) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , }))) ;
                        }
                    }
                }
            };
            let four_iterations = graph_with_selfloops.get_transitive_closure(Some(4), verbose);
            let two_times_two = graph_with_selfloops
                .get_transitive_closure(Some(2), verbose)
                .get_transitive_closure(Some(2), verbose);
            {
                match (&four_iterations, &two_times_two) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["We expected the graph after 4 transitive closures to be equal to the graph after two times two transitive closures.\nThe to_dot of the first graph is: \n " , "\nThe to_dot of the second graph is: \n " , "\n"] , & match (& four_iterations . to_dot (Some (false)) , & two_times_two . to_dot (Some (false))) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , }))) ;
                        }
                    }
                }
            };
        }
        let mut transitive_closure = graph.get_transitive_closure(None, verbose);
        let connected_components = graph.get_node_connected_component_ids(verbose);
        if !graph.is_directed() {
            for (src_node_id, src_component_id) in connected_components.iter().cloned().enumerate()
            {
                if unsafe { graph.is_unchecked_singleton_from_node_id(src_node_id as NodeT) } {
                    continue;
                }
                for (dst_node_id, dst_component_id) in
                    connected_components.iter().cloned().enumerate()
                {
                    {
                        match (
                            &transitive_closure
                                .has_edge_from_node_ids(src_node_id as NodeT, dst_node_id as NodeT),
                            &(src_component_id == dst_component_id),
                        ) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["In an undirected graph, the transitive closure of the graph should contain an edge between all nodes in the same component, but the node " , " and " , " have as component IDs " , " and " , " respectively, and the test has edge has returned " , "."] , & match (& src_node_id , & dst_node_id , & src_component_id , & dst_component_id , & transitive_closure . has_edge_from_node_ids (src_node_id as NodeT , dst_node_id as NodeT)) { (arg0 , arg1 , arg2 , arg3 , arg4) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg3 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg4 , :: core :: fmt :: Display :: fmt)] , }))) ;
                                }
                            }
                        }
                    };
                }
            }
        }
        test_graph_properties(&mut transitive_closure, verbose)?;
        Ok(())
    }
    pub fn test_all_paths(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        if graph.get_nodes_number() > 1000 {
            return Ok(());
        }
        for iteration in [None, Some(0), Some(1), Some(2)] {
            let mut unweighted_all_paths = graph.get_all_shortest_paths(iteration, verbose);
            test_graph_properties(&mut unweighted_all_paths, verbose)?;
        }
        if !graph.has_edge_weights() || graph.has_negative_edge_weights().unwrap() {
            if !graph
                .get_weighted_all_shortest_paths(None, None, verbose)
                .is_err()
            {
                :: core :: panicking :: panic ("assertion failed: graph.get_weighted_all_shortest_paths(None, None, verbose).is_err()")
            };
            return Ok(());
        }
        for iteration in [None, Some(0), Some(1), Some(2)] {
            let mut weighted_all_paths = graph
                .get_weighted_all_shortest_paths(iteration, None, verbose)
                .unwrap();
            test_graph_properties(&mut weighted_all_paths, verbose)?;
        }
        Ok(())
    }
    pub fn test_selfloops(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        if !!graph.drop_selfloops(verbose).has_selfloops() {
            ::core::panicking::panic(
                "assertion failed: !graph.drop_selfloops(verbose).has_selfloops()",
            )
        };
        {
            match (
                &graph.add_selfloops(None, Some(1.0), verbose).is_ok(),
                &graph.has_edge_weights(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let mut graph_with_selfloops = graph
            .add_selfloops(
                None,
                if graph.has_edge_weights() {
                    Some(1.0)
                } else {
                    None
                },
                verbose,
            )
            .unwrap();
        for node_id in graph.iter_node_ids() {
            if !graph_with_selfloops.has_selfloop_from_node_id(node_id) {
                ::core::panicking::panic(
                    "assertion failed: graph_with_selfloops.has_selfloop_from_node_id(node_id)",
                )
            };
        }
        test_graph_properties(&mut graph_with_selfloops, verbose)?;
        Ok(())
    }
    pub fn test_sorting(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        let sorted_increasing = graph.sort_by_increasing_outbound_node_degree(verbose);
        if !sorted_increasing.has_nodes_sorted_by_increasing_outbound_node_degree() {
            :: core :: panicking :: panic ("assertion failed: sorted_increasing.has_nodes_sorted_by_increasing_outbound_node_degree()")
        };
        let sorted_decreasing = graph.sort_by_decreasing_outbound_node_degree(verbose);
        if !sorted_decreasing.has_nodes_sorted_by_decreasing_outbound_node_degree() {
            :: core :: panicking :: panic ("assertion failed: sorted_decreasing.has_nodes_sorted_by_decreasing_outbound_node_degree()")
        };
        Ok(())
    }
    pub fn test_random_walks(graph: &mut Graph, _verbose: Option<bool>) -> Result<()> {
        let walker = first_order_walker(&graph)?;
        {
            match (&walker.clone(), &walker) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let walker2 = second_order_walker(&graph, 2.0, 2.0)?;
        {
            match (&walker2.clone(), &walker2) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        if !graph.directed {
            {
                let lvl = ::log::Level::Warn;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api_log(
                        ::core::fmt::Arguments::new_v1(
                            &["Executing random walks tests."],
                            &match () {
                                () => [],
                            },
                        ),
                        lvl,
                        &(
                            "graph::test_utilities",
                            "graph::test_utilities",
                            "src/test_utilities.rs",
                            1349u32,
                        ),
                    );
                }
            };
            for mode in 0..2 {
                if mode == 1 {
                    graph.enable(None, None, None)?;
                    if let Some(cumulative_node_degrees) = &graph.cumulative_node_degrees {
                        {
                            match (
                                &cumulative_node_degrees.len(),
                                &(graph.get_nodes_number() as usize),
                            ) {
                                (left_val, right_val) => {
                                    if !(*left_val == *right_val) {
                                        let kind = ::core::panicking::AssertKind::Eq;
                                        :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["Length of cumulative_node_degrees does not match number of nodes in the graph."] , & match () { () => [] , }))) ;
                                    }
                                }
                            }
                        };
                    }
                    if let Some(destinations) = &graph.destinations {
                        {
                            match (
                                &destinations.len(),
                                &(graph.get_directed_edges_number() as usize),
                            ) {
                                (left_val, right_val) => {
                                    if !(*left_val == *right_val) {
                                        let kind = ::core::panicking::AssertKind::Eq;
                                        :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["Length of destinations does not match number of edges in the graph."] , & match () { () => [] , }))) ;
                                    }
                                }
                            }
                        };
                    }
                }
                {
                    match (
                        &graph
                            .iter_random_walks(1, &walker)
                            .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),
                        &graph
                            .iter_random_walks(1, &walker)
                            .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::Some(::core::fmt::Arguments::new_v1(
                                        &["Walks of first order are not reproducible!"],
                                        &match () {
                                            () => [],
                                        },
                                    )),
                                );
                            }
                        }
                    }
                };
                {
                    match (
                        &graph
                            .iter_random_walks(1, &second_order_walker(&graph, 2.0, 2.0)?)
                            .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),
                        &graph
                            .iter_random_walks(1, &second_order_walker(&graph, 2.0, 2.0)?)
                            .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::Some(::core::fmt::Arguments::new_v1(
                                        &["Walks of second order are not reproducible!"],
                                        &match () {
                                            () => [],
                                        },
                                    )),
                                );
                            }
                        }
                    }
                };
                {
                    match (
                        &graph
                            .iter_complete_walks(&walker)
                            .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),
                        &graph
                            .iter_complete_walks(&walker)
                            .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::Some(::core::fmt::Arguments::new_v1(
                                        &["Complete first order walks are not reproducible!"],
                                        &match () {
                                            () => [],
                                        },
                                    )),
                                );
                            }
                        }
                    }
                };
                {
                    match (
                        &graph
                            .iter_complete_walks(&second_order_walker(&graph, 2.0, 2.0)?)
                            .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),
                        &graph
                            .iter_complete_walks(&second_order_walker(&graph, 2.0, 2.0)?)
                            .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::Some(::core::fmt::Arguments::new_v1(
                                        &["Complete second order walks are not reproducible!"],
                                        &match () {
                                            () => [],
                                        },
                                    )),
                                );
                            }
                        }
                    }
                };
                {
                    match (
                        &graph
                            .iter_complete_walks(&second_order_walker(&graph, 2.0, 1.0)?)
                            .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),
                        &graph
                            .iter_complete_walks(&second_order_walker(&graph, 2.0, 1.0)?)
                            .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::Some(::core::fmt::Arguments::new_v1(
                                        &["Complete second order walks are not reproducible!"],
                                        &match () {
                                            () => [],
                                        },
                                    )),
                                );
                            }
                        }
                    }
                };
                {
                    match (
                        &graph
                            .iter_complete_walks(&second_order_walker(&graph, 1.0, 2.0)?)
                            .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),
                        &graph
                            .iter_complete_walks(&second_order_walker(&graph, 1.0, 2.0)?)
                            .map(|iter| iter.collect::<Vec<Vec<NodeT>>>()),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::Some(::core::fmt::Arguments::new_v1(
                                        &["Complete second order walks are not reproducible!"],
                                        &match () {
                                            () => [],
                                        },
                                    )),
                                );
                            }
                        }
                    }
                };
            }
        } else {
            if !graph.iter_complete_walks(&walker).is_err() {
                ::core::panicking::panic(
                    "assertion failed: graph.iter_complete_walks(&walker).is_err()",
                )
            };
        }
        Ok(())
    }
    pub fn test_edge_holdouts(graph: &Graph, verbose: Option<bool>) -> Result<()> {
        if !graph.has_edge_types() {
            if !graph
                .connected_holdout(
                    0.8,
                    None,
                    Some(<[_]>::into_vec(box [None])),
                    Some(false),
                    None,
                )
                .is_err()
            {
                :: core :: panicking :: panic ("assertion failed: graph.connected_holdout(0.8, None, Some(vec![None]), Some(false),\\n                        None).is_err()")
            };
        }
        for include_all_edge_types in &[false, true] {
            let (train, test) = graph.random_holdout(
                0.6,
                None,
                Some(*include_all_edge_types),
                None,
                None,
                verbose,
            )?;
            default_holdout_test_suite(graph, &train, &test)?;
            let (train, test) =
                graph.connected_holdout(0.8, None, None, Some(*include_all_edge_types), verbose)?;
            {
                match (&graph.get_nodes_number(), &train.get_nodes_number()) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            {
                match (&graph.get_nodes_number(), &test.get_nodes_number()) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            let (original_total, original_min_comp, original_max_comp) =
                graph.get_connected_components_number(verbose);
            let (train_total, train_min_comp, train_max_comp) =
                train.get_connected_components_number(verbose);
            if original_total == 1 {
                if !(original_min_comp == original_max_comp) {
                    ::core::panicking::panic(
                        "assertion failed: original_min_comp == original_max_comp",
                    )
                };
                {
                    match (&original_min_comp, &graph.get_nodes_number()) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    }
                };
            }
            if original_total == 2 {
                if !(original_min_comp <= original_max_comp) {
                    ::core::panicking::panic(
                        "assertion failed: original_min_comp <= original_max_comp",
                    )
                };
                {
                    match (
                        &(original_min_comp + original_max_comp),
                        &graph.get_nodes_number(),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["When a graph contains two connected components, summing the two connected components should give the number of nodes in the graph.\nThe graph is " , "."] , & match (& if graph . is_directed () { "directed" } else { "undirected" } ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }))) ;
                            }
                        }
                    }
                };
            }
            if train_total == 1 {
                if !(train_min_comp == train_max_comp) {
                    ::core::panicking::panic("assertion failed: train_min_comp == train_max_comp")
                };
                {
                    match (&train_min_comp, &graph.get_nodes_number()) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    }
                };
            }
            if train_total == 2 {
                if !(train_min_comp <= train_max_comp) {
                    ::core::panicking::panic("assertion failed: train_min_comp <= train_max_comp")
                };
                {
                    match (
                        &(train_min_comp + train_max_comp),
                        &train.get_nodes_number(),
                    ) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    }
                };
            }
            {
                match (&train_total, &original_total) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["In a connected holdout the training graph must have the same number of connected components as in the original graph, but here the training graph has " , " components while the original graph has " , " components."] , & match (& train_total , & original_total) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , }))) ;
                        }
                    }
                }
            };
            {
                match (&train_min_comp, &original_min_comp) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["In a connected holdout the training graph must have the same number of connected components as in the original graph, but here the minimum connected component size of the training graph has size " , " while the corresponding one from the original graph has size " , "."] , & match (& train_min_comp , & original_min_comp) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , }))) ;
                        }
                    }
                }
            };
            {
                match (&train_max_comp, &original_max_comp) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["In a connected holdout the training graph must have the same number of connected components as in the original graph, but here the maximum connected component size of the training graph has size " , " while the corresponding one from the original graph has size " , "."] , & match (& train_max_comp , & original_max_comp) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , }))) ;
                        }
                    }
                }
            };
            default_holdout_test_suite(graph, &train, &test)?;
        }
        Ok(())
    }
    pub fn test_remove_components(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        if graph.get_connected_components_number(verbose).0 > 1 {
            let without_selfloops = graph.drop_selfloops(verbose);
            {
                match (
                    &graph.get_connected_components_number(verbose),
                    &without_selfloops.get_connected_components_number(verbose),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["We expected the graph to have the same components once we remove the selfloops.\nThe report of the original graph is " , "\nThe report of the filtered graph is " , "\nThe edge node ids of the original graph are " , "\nThe edge node ids of the filtered graph are " , "\n"] , & match (& graph . textual_report () , & without_selfloops . textual_report () , & graph . get_edge_node_ids (true) , & without_selfloops . get_edge_node_ids (true)) { (arg0 , arg1 , arg2 , arg3) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg3 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                        }
                    }
                }
            };
            let single_component =
                graph.remove_components(None, None, None, None, Some(1), verbose);
            if !single_component.is_ok() {
                {
                    :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["Removing all the components except the first one returned an error.\nThe error is:\n" , "\nand the graph report is:\n"] , & match (& single_component , & graph . textual_report ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }))
                }
            };
            let single_component_number = single_component
                .unwrap()
                .get_connected_components_number(verbose)
                .0;
            {
                match (&single_component_number, &1) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["Removing all the components except the first one returned a graph with " , " components, which is not one.\nThe report of the graph is:" , "\n"] , & match (& single_component_number , & graph . textual_report ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                        }
                    }
                }
            };
            let test = graph.remove_components(
                Some(<[_]>::into_vec(box [graph.nodes.unchecked_translate(0)])),
                None,
                None,
                None,
                None,
                verbose,
            )?;
            let without_selfloops = test.drop_selfloops(verbose);
            {
                match (
                    &without_selfloops.get_connected_components_number(verbose).0,
                    &1,
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["Expected number of components (1) is not matched!\nThe report of the original graph is " , "\nThe report of the graph with only one component is " , "\nThe report of the graph without selfloops is " , "\n"] , & match (& graph . textual_report () , & test . textual_report () , & without_selfloops . textual_report ()) { (arg0 , arg1 , arg2) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                        }
                    }
                }
            };
            if let Ok(node_type_name) = graph.get_node_type_name_from_node_type_id(0) {
                if !graph
                    .remove_components(
                        None,
                        Some(<[_]>::into_vec(box [Some(node_type_name)])),
                        None,
                        None,
                        None,
                        verbose,
                    )
                    .is_ok()
                {
                    :: core :: panicking :: panic ("assertion failed: graph.remove_components(None, Some(vec![Some(node_type_name)]), None, None,\\n                        None, verbose).is_ok()")
                };
            }
            if graph.has_unknown_node_types()? {
                let without_unknowns = graph.remove_components(
                    None,
                    Some(<[_]>::into_vec(box [None])),
                    None,
                    None,
                    None,
                    verbose,
                );
                if !without_unknowns.is_ok() {
                    {
                        :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["Could not remove components without node type None.\nThe error is " , "\nThe graph report is "] , & match (& without_unknowns , & graph . textual_report ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }))
                    }
                };
            }
            if let Ok(edge_type_name) = graph.get_edge_type_name_from_edge_type_id(0) {
                if !graph
                    .remove_components(
                        None,
                        None,
                        Some(<[_]>::into_vec(box [Some(edge_type_name)])),
                        None,
                        None,
                        verbose,
                    )
                    .is_ok()
                {
                    :: core :: panicking :: panic ("assertion failed: graph.remove_components(None, None, Some(vec![Some(edge_type_name)]), None,\\n                        None, verbose).is_ok()")
                };
            }
            if graph.has_unknown_edge_types()? {
                if !graph
                    .remove_components(
                        None,
                        None,
                        Some(<[_]>::into_vec(box [None])),
                        None,
                        None,
                        verbose,
                    )
                    .is_ok()
                {
                    :: core :: panicking :: panic ("assertion failed: graph.remove_components(None, None, Some(vec![None]), None, None,\\n                        verbose).is_ok()")
                };
            }
        } else {
            if !graph
                .remove_components(None, None, None, None, None, verbose)
                .is_ok()
            {
                {
                    ::std::rt::begin_panic(
                        "We expect it to be possible, now, to create empty graphs.",
                    )
                }
            };
        }
        Ok(())
    }
    pub fn test_kfold(graph: &mut Graph, _verbose: Option<bool>) -> Result<()> {
        let k = 3;
        for i in 0..k {
            let (train, test) = graph.kfold(k, i, None, None, None)?;
            if !(test.get_edges_number() <= (graph.get_edges_number() / k) + 1) {
                {
                    :: std :: rt :: begin_panic_fmt (& :: core :: fmt :: Arguments :: new_v1 (& ["Check that test kfolds respect size bound has failed!\nThe value of k is " , ".\nThe report of the original graph is:\n" , "\nThe report of the train graph is:\n" , "\nThe report of the test graph is:\n" , "\nWe expect that the test graph has at most " , " edges but it has " , ".\nThe holdout index is " , ".\n"] , & match (& k , & graph . textual_report () , & train . textual_report () , & test . textual_report () , & ((graph . get_edges_number () / k) + 1) , & test . get_edges_number () , & i) { (arg0 , arg1 , arg2 , arg3 , arg4 , arg5 , arg6) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg2 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg3 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg4 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg5 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg6 , :: core :: fmt :: Display :: fmt)] , }))
                }
            };
            default_holdout_test_suite(graph, &train, &test)?;
        }
        if let Ok(edge_t) = graph.get_edge_type_name_from_edge_type_id(0) {
            for i in 0..k {
                let (train, test) = graph.kfold(
                    k,
                    i,
                    Some(<[_]>::into_vec(box [Some(edge_t.clone())])),
                    None,
                    None,
                )?;
                default_holdout_test_suite(graph, &train, &test)?;
            }
        }
        Ok(())
    }
    pub fn test_negative_edges_generation(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        for only_from_same_component in &[true, false] {
            let negatives = graph.sample_negatives(
                graph.get_edges_number(),
                None,
                None,
                Some(*only_from_same_component),
                verbose,
            )?;
            {
                match (&graph.get_edges_number(), &negatives.get_edges_number()) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["We expect the graph and its negative graph to have the same number of edges but we got " , " and " , "."] , & match (& graph . get_edges_number () , & negatives . get_edges_number ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Display :: fmt)] , }))) ;
                        }
                    }
                }
            };
            validate_vocabularies(&negatives);
            if !graph.has_edge_types() {
                if !!graph.overlaps(&negatives)? {
                    ::core::panicking::panic("assertion failed: !graph.overlaps(&negatives)?")
                };
                if !!negatives.overlaps(&graph)? {
                    ::core::panicking::panic("assertion failed: !negatives.overlaps(&graph)?")
                };
            }
            let (neg_train, neg_test) =
                negatives.random_holdout(0.8, None, None, None, None, verbose)?;
            neg_test.get_trap_nodes_number();
            default_holdout_test_suite(&negatives, &neg_train, &neg_test)?;
        }
        Ok(())
    }
    pub fn test_subgraph_generation(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        let expected_nodes = graph.get_connected_nodes_number() / 10;
        let subgraph = graph.random_subgraph(expected_nodes, None, verbose)?;
        if !subgraph.overlaps(&graph)? {
            ::core::panicking::panic("assertion failed: subgraph.overlaps(&graph)?")
        };
        if !(subgraph.get_connected_nodes_number() <= expected_nodes + 1) {
            ::core::panicking::panic(
                "assertion failed: subgraph.get_connected_nodes_number() <= expected_nodes + 1",
            )
        };
        Ok(())
    }
    pub fn test_dump_graph(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        let node_file = random_path(None);
        let nodes_writer = NodeFileWriter::new(node_file.clone())
            .set_verbose(verbose)
            .set_separator(Some("\t"))
            .set_header(Some(true))
            .set_node_types_column_number(Some(4))
            .set_nodes_column_number(Some(6))
            .set_node_types_column(Some("node_types"))
            .set_nodes_column(Some("node_column".to_string()));
        nodes_writer.dump(&graph)?;
        fs::remove_file(node_file).unwrap();
        let edges_file = random_path(None);
        let edges_writer = EdgeFileWriter::new(edges_file.clone())
            .set_verbose(verbose)
            .set_separator(Some("\t"))
            .set_header(Some(true))
            .set_edge_types_column(Some("edge_types"))
            .set_destinations_column_number(Some(3))
            .set_weights_column(Some("weight".to_string()))
            .set_weights_column_number(Some(2))
            .set_sources_column(Some("The land of sushi".to_string()))
            .set_sources_column_number(Some(0))
            .set_destinations_column(Some("The land of pizza".to_string()))
            .set_destinations_column_number(Some(1));
        edges_writer.dump(&graph)?;
        fs::remove_file(edges_file).unwrap();
        Ok(())
    }
    pub fn test_embiggen_preprocessing(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        let walker = first_order_walker(&graph)?;
        if !graph.directed {
            let (terms_number, iterator) = graph.cooccurence_matrix(&walker, 3, verbose)?;
            {
                match (&terms_number, &iterator.count()) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            let window_size = 3;
            let batch_size = 256;
            let data = graph
                .node2vec(&walker, batch_size, window_size)?
                .collect::<Vec<_>>();
            {
                match (
                    &data.len(),
                    &(batch_size as usize
                        * walker.iterations as usize
                        * (walker.single_walk_parameters.walk_length as usize - window_size * 2)),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            for (context, _) in data.iter() {
                {
                    match (&context.len(), &(window_size * 2)) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    }
                };
            }
        }
        if graph.has_edges() {
            graph
                .link_prediction_degrees(
                    0,
                    Some(256),
                    Some(true),
                    Some(0.3),
                    Some(false),
                    Some(10),
                    Some(false),
                    None,
                )
                .unwrap()
                .collect::<Vec<_>>();
            graph
                .get_edge_prediction_mini_batch(
                    0,
                    Some(256),
                    Some(0.4),
                    None,
                    None,
                    Some(false),
                    Some(false),
                    Some(10),
                    Some(false),
                    None,
                )
                .unwrap()
                .collect::<Vec<_>>();
        }
        Ok(())
    }
    pub fn test_edgelist_generation(graph: &mut Graph, _verbose: Option<bool>) -> Result<()> {
        let _clique = graph.get_clique_edge_names(
            None,
            None,
            Some(false),
            None,
            Some(
                graph
                    .get_node_names()
                    .iter()
                    .take(3)
                    .cloned()
                    .collect::<HashSet<String>>(),
            ),
        );
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Running edge lists generator tests."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        1829u32,
                    ),
                );
            }
        };
        if graph.get_nodes_number() > 1 {
            let _bipartite = graph.get_bipartite_edge_names(
                None,
                Some(
                    [unsafe { graph.get_unchecked_node_name_from_node_id(0) }]
                        .iter()
                        .cloned()
                        .collect::<HashSet<String>>(),
                ),
                Some(
                    [unsafe { graph.get_unchecked_node_name_from_node_id(1) }]
                        .iter()
                        .cloned()
                        .collect::<HashSet<String>>(),
                ),
                None,
                None,
            )?;
            let _star = graph.get_star_edges(
                unsafe { graph.get_unchecked_node_name_from_node_id(0) },
                Some(false),
                Some(
                    [unsafe { graph.get_unchecked_node_name_from_node_id(1) }]
                        .iter()
                        .cloned()
                        .collect::<HashSet<String>>(),
                ),
                None,
            )?;
            let _star = graph.get_star_edge_names(
                unsafe { graph.get_unchecked_node_name_from_node_id(0) },
                Some(false),
                Some(
                    [unsafe { graph.get_unchecked_node_name_from_node_id(1) }]
                        .iter()
                        .cloned()
                        .collect::<HashSet<String>>(),
                ),
                None,
            )?;
        }
        Ok(())
    }
    pub fn test_nodelabel_holdouts(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        for use_stratification in [true, false] {
            if graph.get_known_node_types_number()? < 2
                || (use_stratification
                    && (graph.has_multilabel_node_types()? || graph.has_singleton_node_types()?))
            {
                if !graph
                    .node_label_holdout(0.8, Some(use_stratification), Some(42))
                    .is_err()
                {
                    :: core :: panicking :: panic ("assertion failed: graph.node_label_holdout(0.8, Some(use_stratification), Some(42)).is_err()")
                };
                continue;
            }
            let (train, test) =
                graph.node_label_holdout(0.8, Some(use_stratification), Some(42))?;
            if !train.has_unknown_node_types()? {
                ::core::panicking::panic("assertion failed: train.has_unknown_node_types()?")
            };
            if !test.has_unknown_node_types()? {
                ::core::panicking::panic("assertion failed: test.has_unknown_node_types()?")
            };
            if !!test
                .replace_unknown_node_types_with_node_type_name(
                    <[_]>::into_vec(box ["HALLO!".to_string()]),
                    verbose,
                )?
                .has_unknown_node_types()?
            {
                :: core :: panicking :: panic ("assertion failed: !test.replace_unknown_node_types_with_node_type_name(vec![\\\"HALLO!\\\".to_string()],\\n                                                     verbose)?.has_unknown_node_types()?")
            };
            let remerged = &mut (&train | &test)?;
            {
                match (&remerged.node_types, &graph.node_types) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            if !remerged.contains(graph)? {
                {
                    ::std::rt::begin_panic(
                        "The re-merged holdouts does not contain the original graph.",
                    )
                }
            };
            if !graph.contains(remerged)? {
                {
                    ::std::rt::begin_panic(
                        "The re-merged holdouts does not contain the original graph.",
                    )
                }
            };
            if !train.node_types.as_ref().map_or(false, |train_nts| {
                test.node_types.as_ref().map_or(false, |test_nts| {
                    train_nts.ids.iter().zip(test_nts.ids.iter()).all(
                        |(train_node_type, test_node_type)| {
                            !(train_node_type.is_some() && test_node_type.is_some())
                        },
                    )
                })
            }) {
                {
                    ::std::rt::begin_panic("The train and test node-label graphs are overlapping!")
                }
            };
        }
        Ok(())
    }
    pub fn test_edgelabel_holdouts(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        for use_stratification in [true, false].iter() {
            if *use_stratification && graph.has_singleton_edge_types()?
                || graph.get_directed_edges_number() - graph.get_unknown_edge_types_number()? < 2
                || !graph.has_edge_types()
            {
                if !graph
                    .edge_label_holdout(0.8, Some(*use_stratification), None)
                    .is_err()
                {
                    :: core :: panicking :: panic ("assertion failed: graph.edge_label_holdout(0.8, Some(*use_stratification), None).is_err()")
                };
                continue;
            }
            let (train, test) = graph.edge_label_holdout(0.8, Some(*use_stratification), None)?;
            if !train.has_unknown_edge_types()? {
                ::core::panicking::panic("assertion failed: train.has_unknown_edge_types()?")
            };
            if !test.has_unknown_edge_types()? {
                ::core::panicking::panic("assertion failed: test.has_unknown_edge_types()?")
            };
            if !!test
                .replace_unknown_edge_types_with_edge_type_name("HALLO!".to_string(), verbose)?
                .has_unknown_edge_types()?
            {
                :: core :: panicking :: panic ("assertion failed: !test.replace_unknown_edge_types_with_edge_type_name(\\\"HALLO!\\\".to_string(),\\n                                                     verbose)?.has_unknown_edge_types()?")
            };
            if !train.edge_types.as_ref().map_or(false, |train_nts| {
                test.edge_types.as_ref().map_or(false, |test_nts| {
                    train_nts.ids.iter().zip(test_nts.ids.iter()).all(
                        |(train_edge_type, test_edge_type)| {
                            !(train_edge_type.is_some() && test_edge_type.is_some())
                        },
                    )
                })
            }) {
                {
                    ::std::rt::begin_panic("The train and test edge-label graphs are overlapping!")
                }
            };
        }
        Ok(())
    }
    pub fn test_graph_filter(graph: &Graph, verbose: Option<bool>) -> Result<()> {
        let unfiltered = graph
            .filter_from_ids(
                None, None, None, None, None, None, None, None, None, None, None, None, None, None,
                None, None, None, None, verbose,
            )
            .unwrap();
        {
            match (&&unfiltered, &graph) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        if !graph
            .filter_from_names(
                None,
                Some(<[_]>::into_vec(box [NONEXISTENT])),
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                verbose,
            )
            .is_err()
        {
            :: core :: panicking :: panic ("assertion failed: graph.filter_from_names(None, Some(vec![NONEXISTENT]), None, None, None, None,\\n                        None, None, None, None, None, None, None, None, None,\\n                        None, verbose).is_err()")
        };
        for node_name in graph.iter_node_names().take(10) {
            let graph_without_given_name_result = graph.filter_from_names(
                None,
                Some(<[_]>::into_vec(box [node_name.as_str()])),
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                verbose,
            );
            if !graph_without_given_name_result.is_ok() {
                ::core::panicking::panic(
                    "assertion failed: graph_without_given_name_result.is_ok()",
                )
            };
            let graph_without_given_id = graph_without_given_name_result.unwrap();
            {
                match (
                    &graph_without_given_id.has_nodes(),
                    &(graph.get_nodes_number() > 1),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            if !!graph_without_given_id.has_node_name(node_name.as_str()) {
                ::core::panicking::panic(
                    "assertion failed: !graph_without_given_id.has_node_name(node_name.as_str())",
                )
            };
            let graph_with_given_name_result = graph.filter_from_names(
                Some(<[_]>::into_vec(box [node_name.as_str()])),
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                verbose,
            );
            if !graph_with_given_name_result.is_ok() {
                ::core::panicking::panic("assertion failed: graph_with_given_name_result.is_ok()")
            };
            let graph_with_given_node_name = graph_with_given_name_result.unwrap();
            {
                match (
                    &graph_with_given_node_name.has_selfloops(),
                    &graph.has_edge_from_node_names(node_name.as_ref(), node_name.as_ref()),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            {
                match (
                    &graph_with_given_node_name.has_edges(),
                    &graph_with_given_node_name.has_selfloops(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            {
                match (&graph_with_given_node_name.get_nodes_number(), &1) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            if !graph_with_given_node_name.has_node_name(node_name.as_str()) {
                :: core :: panicking :: panic ("assertion failed: graph_with_given_node_name.has_node_name(node_name.as_str())")
            };
        }
        for node_type_name in graph.iter_unique_node_type_names()?.take(10) {
            let graph_without_given_node_type_name_result = graph.filter_from_names(
                None,
                None,
                None,
                None,
                None,
                Some(<[_]>::into_vec(box [Some(node_type_name.clone())])),
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                None,
                verbose,
            );
            if !graph_without_given_node_type_name_result.is_ok() {
                ::core::panicking::panic(
                    "assertion failed: graph_without_given_node_type_name_result.is_ok()",
                )
            };
            let graph_without_given_node_type_name =
                graph_without_given_node_type_name_result.unwrap();
            if graph.get_node_types_number()? > 1 && !graph.has_multilabel_node_types()? {
                if !graph_without_given_node_type_name.has_node_types() {
                    ::core::panicking::panic(
                        "assertion failed: graph_without_given_node_type_name.has_node_types()",
                    )
                };
                if !graph_without_given_node_type_name.has_nodes() {
                    ::core::panicking::panic(
                        "assertion failed: graph_without_given_node_type_name.has_nodes()",
                    )
                };
            }
            if !!graph_without_given_node_type_name.has_node_type_name(node_type_name.as_str()) {
                :: core :: panicking :: panic ("assertion failed: !graph_without_given_node_type_name.has_node_type_name(node_type_name.as_str())")
            };
        }
        Ok(())
    }
    pub fn test_graph_removes(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        let without_edge_types = graph.remove_edge_types(verbose)?;
        validate_vocabularies(&without_edge_types);
        if !!without_edge_types.has_edge_types() {
            ::core::panicking::panic("assertion failed: !without_edge_types.has_edge_types()")
        };
        {
            match (
                &without_edge_types.has_edge_weights(),
                &graph.has_edge_weights(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (&without_edge_types.node_types, &graph.node_types) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        if !graph.is_multigraph() {
            {
                match (
                    &without_edge_types.get_unique_edges_number(),
                    &graph.get_unique_edges_number(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["Number of unique edges does not match in graph without edge types.\nThe report of the original graph is \n" , "\nThe report of the graph without edge types is \n"] , & match (& graph . textual_report () , & without_edge_types . textual_report ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                        }
                    }
                }
            };
            {
                match (
                    &without_edge_types.get_unique_selfloop_number(),
                    &graph.get_unique_selfloop_number(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["Number of unique self loops does not match in graph without edge types."] , & match () { () => [] , }))) ;
                        }
                    }
                }
            };
        }
        {
            match (&without_edge_types.nodes, &graph.nodes) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let without_node_types = graph.remove_node_types()?;
        validate_vocabularies(&without_node_types);
        if !!without_node_types.has_node_types() {
            ::core::panicking::panic("assertion failed: !without_node_types.has_node_types()")
        };
        {
            match (&graph.is_multigraph(), &without_node_types.is_multigraph()) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["If the original graph is a multigraph, the removal of node types should not change that."] , & match () { () => [] , }))) ;
                    }
                }
            }
        };
        {
            match (&without_node_types.weights, &graph.weights) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["We expected the weights not to change when removig node types.\nThe report of the original graph is " , ".\nThe report of the filtered graph is " , "."] , & match (& graph . textual_report () , & without_node_types . textual_report ()) { (arg0 , arg1) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Debug :: fmt) , :: core :: fmt :: ArgumentV1 :: new (arg1 , :: core :: fmt :: Debug :: fmt)] , }))) ;
                    }
                }
            }
        };
        {
            match (&without_node_types.has_selfloops(), &graph.has_selfloops()) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (&without_node_types.nodes, &graph.nodes) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let without_weights = graph.remove_edge_weights()?;
        validate_vocabularies(&without_weights);
        if !!without_weights.has_edge_weights() {
            ::core::panicking::panic("assertion failed: !without_weights.has_edge_weights()")
        };
        {
            match (&without_weights.node_types, &graph.node_types) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (&without_weights.has_selfloops(), &graph.has_selfloops()) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (&without_weights.nodes, &graph.nodes) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        Ok(())
    }
    pub fn test_clone_and_setters(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        let mut clone = graph.clone();
        clone = clone.set_all_edge_types("TEST_SET_ALL_EDGE_TYPES", verbose)?;
        if !!clone.is_multigraph() {
            ::core::panicking::panic("assertion failed: !clone.is_multigraph()")
        };
        clone = clone.set_all_node_types("TEST_SET_ALL_NODE_TYPES")?;
        {
            match (&clone.get_edge_types_number().unwrap(), &1) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::Some(::core::fmt::Arguments::new_v1(
                                &["Number of edge types of the graph is not 1."],
                                &match () {
                                    () => [],
                                },
                            )),
                        );
                    }
                }
            }
        };
        if !graph.is_multigraph() {
            {
                match (
                    &unsafe { clone.get_unchecked_edge_count_from_edge_type_id(Some(0)) },
                    &graph.get_directed_edges_number(),
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["Number of edges with the unique edge type does not match number of edges in the graph."] , & match () { () => [] , }))) ;
                        }
                    }
                }
            };
        }
        {
            match (&clone.get_node_types_number().unwrap(), &1) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::Some(::core::fmt::Arguments::new_v1(
                                &["Number of node types of the graph is not 1."],
                                &match () {
                                    () => [],
                                },
                            )),
                        );
                    }
                }
            }
        };
        {
            match (
                &clone.get_unchecked_node_count_from_node_type_id(Some(0)),
                &graph.get_nodes_number(),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (:: core :: fmt :: Arguments :: new_v1 (& ["Number of nodes with the unique node type does not match number of nodes in the graph."] , & match () { () => [] , }))) ;
                    }
                }
            }
        };
        Ok(())
    }
    pub fn test_graph_remapping(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        if !graph.are_nodes_remappable(&graph) {
            {
                ::std::rt::begin_panic("Graph always should be remappable to itself.")
            }
        };
        if !graph.remap_from_graph(&graph, verbose).is_ok() {
            {
                ::std::rt::begin_panic("Graph always should be remappable to itself.")
            }
        };
        Ok(())
    }
    pub fn test_graph_diameter(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        let (n_of_components, _, _) = graph.get_connected_components_number(verbose);
        {
            match (
                &graph.get_diameter_naive(Some(false), verbose),
                &graph.get_diameter(Some(false), verbose),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        match n_of_components {
            0 => {
                if !graph.get_diameter(Some(false), verbose).is_err() {
                    ::core::panicking::panic(
                        "assertion failed: graph.get_diameter(Some(false), verbose).is_err()",
                    )
                };
                if !graph.get_diameter(Some(true), verbose).is_err() {
                    ::core::panicking::panic(
                        "assertion failed: graph.get_diameter(Some(true), verbose).is_err()",
                    )
                };
            }
            1 => {
                if graph.get_nodes_number() == 1 && !graph.has_edges() {
                    if !graph
                        .get_diameter(Some(false), verbose)
                        .unwrap()
                        .is_infinite()
                    {
                        :: core :: panicking :: panic ("assertion failed: graph.get_diameter(Some(false), verbose).unwrap().is_infinite()")
                    };
                    if !graph
                        .get_diameter(Some(true), verbose)
                        .unwrap()
                        .is_infinite()
                    {
                        :: core :: panicking :: panic ("assertion failed: graph.get_diameter(Some(true), verbose).unwrap().is_infinite()")
                    };
                } else {
                    if !graph
                        .get_diameter(Some(false), verbose)
                        .unwrap()
                        .is_finite()
                    {
                        :: core :: panicking :: panic ("assertion failed: graph.get_diameter(Some(false), verbose).unwrap().is_finite()")
                    };
                    if !graph.get_diameter(Some(true), verbose).unwrap().is_finite() {
                        :: core :: panicking :: panic ("assertion failed: graph.get_diameter(Some(true), verbose).unwrap().is_finite()")
                    };
                }
            }
            _ => {
                if !graph
                    .get_diameter(Some(false), verbose)
                    .unwrap()
                    .is_infinite()
                {
                    :: core :: panicking :: panic ("assertion failed: graph.get_diameter(Some(false), verbose).unwrap().is_infinite()")
                };
            }
        }
        Ok(())
    }
    /// Executes near-complete test of all functions for the given graph.
    fn _default_test_suite(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Starting default test suite."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2230u32,
                    ),
                );
            }
        };
        let _ = test_graph_properties(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing SkipGram / CBOW / GloVe preprocessing."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2233u32,
                    ),
                );
            }
        };
        let _ = test_embiggen_preprocessing(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing subgraph generation."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2236u32,
                    ),
                );
            }
        };
        let _ = test_subgraph_generation(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing clone and setters."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2239u32,
                    ),
                );
            }
        };
        let _ = test_clone_and_setters(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing edge-label holdouts tests."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2242u32,
                    ),
                );
            }
        };
        let _ = test_edgelabel_holdouts(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing writing out graph to file."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2245u32,
                    ),
                );
            }
        };
        let _ = test_dump_graph(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing generic filtering mechanism."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2248u32,
                    ),
                );
            }
        };
        let _ = test_graph_filter(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing the spanning arborescences."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2251u32,
                    ),
                );
            }
        };
        let _ = test_spanning_arborescence_bader(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing the graph diameter."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2254u32,
                    ),
                );
            }
        };
        let _ = test_graph_diameter(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Running node-label holdouts tests."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2257u32,
                    ),
                );
            }
        };
        let _ = test_nodelabel_holdouts(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Running remove components tests."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2260u32,
                    ),
                );
            }
        };
        let _ = test_remove_components(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing removes."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2263u32,
                    ),
                );
            }
        };
        let _ = test_graph_removes(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing negative edges generation."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2266u32,
                    ),
                );
            }
        };
        let _ = test_negative_edges_generation(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Executing edge holdouts tests."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2269u32,
                    ),
                );
            }
        };
        let _ = test_edge_holdouts(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing k-fold holdouts."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2272u32,
                    ),
                );
            }
        };
        let _ = test_kfold(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing edge lists generation."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2275u32,
                    ),
                );
            }
        };
        let _ = test_edgelist_generation(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing graph remapping."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2278u32,
                    ),
                );
            }
        };
        let _ = test_graph_remapping(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing random walks."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2281u32,
                    ),
                );
            }
        };
        let _ = test_random_walks(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing BFS."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2284u32,
                    ),
                );
            }
        };
        let _ = test_bfs(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing dijkstra."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2287u32,
                    ),
                );
            }
        };
        let _ = test_dijkstra(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing approximated vertex cover"],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2290u32,
                    ),
                );
            }
        };
        let _ = test_vertex_cover(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing node centralities."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2293u32,
                    ),
                );
            }
        };
        let _ = test_node_centralities(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing polygons."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2296u32,
                    ),
                );
            }
        };
        let _ = test_polygons(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing transitivity."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2299u32,
                    ),
                );
            }
        };
        let _ = test_transitivity(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing all paths."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2303u32,
                    ),
                );
            }
        };
        let _ = test_all_paths(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing generation of selfloops."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2306u32,
                    ),
                );
            }
        };
        let _ = test_selfloops(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Testing sorting of the graph."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2309u32,
                    ),
                );
            }
        };
        let _ = test_sorting(graph, verbose);
        Ok(())
    }
    /// Executes near-complete test of all functions for the given graph.
    pub fn default_test_suite(graph: &mut Graph, verbose: Option<bool>) -> Result<()> {
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Starting default test suite."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2330u32,
                    ),
                );
            }
        };
        let _ = _default_test_suite(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Starting default test suite with speedups enabled."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2332u32,
                    ),
                );
            }
        };
        graph.enable(Some(true), Some(true), Some(true))?;
        let _ = _default_test_suite(graph, verbose);
        {
            let lvl = ::log::Level::Warn;
            if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                ::log::__private_api_log(
                    ::core::fmt::Arguments::new_v1(
                        &["Starting default test suite on transformed graphs."],
                        &match () {
                            () => [],
                        },
                    ),
                    lvl,
                    &(
                        "graph::test_utilities",
                        "graph::test_utilities",
                        "src/test_utilities.rs",
                        2335u32,
                    ),
                );
            }
        };
        {
            let mut transformed_graph = graph.get_laplacian_transformed_graph(verbose);
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph =
                graph.get_symmetric_normalized_transformed_graph(verbose)?;
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph =
                graph.get_symmetric_normalized_laplacian_transformed_graph(verbose)?;
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph =
                graph.get_random_walk_normalized_laplacian_transformed_graph(verbose);
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph = graph.get_weighted_laplacian_transformed_graph(verbose)?;
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph =
                graph.get_weighted_symmetric_normalized_transformed_graph(verbose)?;
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph =
                graph.get_weighted_symmetric_normalized_laplacian_transformed_graph(verbose)?;
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph =
                graph.get_weighted_random_walk_normalized_laplacian_transformed_graph(verbose)?;
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph = graph.to_upper_triangular(verbose);
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph = graph.to_lower_triangular(verbose);
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph = graph.to_main_diagonal(verbose);
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph = graph.to_anti_diagonal(verbose);
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph = graph.to_bidiagonal(verbose);
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph = graph.to_arrowhead(verbose);
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph = graph.to_transposed(verbose);
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        {
            let mut transformed_graph = graph.to_complementary(verbose);
            let _ = _default_test_suite(&mut transformed_graph, verbose);
        };
        Ok(())
    }
}
pub use self::edge_metrics::*;
pub use self::getters::*;
pub use self::graph::Graph;
pub use self::holdouts::*;
pub use self::operators::*;
pub use self::setters::*;
pub use self::tarjan::*;
pub use self::trees::*;
pub use self::types::*;
pub use self::walks::*;
pub use self::walks_parameters::*;
pub use preprocessing::*;
pub use tfidf::*;
mod dijkstra_queue {
    /// Reference classic binary heap
    pub struct DijkstraQueue {
        /// This is the actual heap, it contains the node_ids and are ordered based on
        /// self.distances[id]
        heap: Vec<usize>,
        /// The distance of every node in the graph
        distances: Vec<f64>,
        /// The mapping from each node to its position in the heap.
        /// This is only needed because we don't want to insert duplicated nodes.
        map: Vec<usize>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for DijkstraQueue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                DijkstraQueue {
                    heap: ref __self_0_0,
                    distances: ref __self_0_1,
                    map: ref __self_0_2,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "DijkstraQueue");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "heap",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "distances",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "map",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl DijkstraQueue {
        /// Initialize the queue with the given root, in this case the capacity
        /// should always be equal to the number of nodes in the graph.
        pub fn with_capacity_from_root(capacity: usize, root_node_id: usize) -> Self {
            let mut res = DijkstraQueue {
                heap: Vec::with_capacity(capacity),
                distances: ::alloc::vec::from_elem(f64::INFINITY, capacity),
                map: ::alloc::vec::from_elem(usize::MAX, capacity),
            };
            res.heap.push(root_node_id);
            res.map[root_node_id] = 0;
            res.distances[root_node_id] = 0.0;
            res
        }
        /// Get the index of the father of the given node
        #[inline]
        fn parent(node: usize) -> usize {
            (node.saturating_sub(1)) >> 1
        }
        /// Get the index of the left child
        #[inline]
        fn left(node: usize) -> usize {
            (node << 1) + 1
        }
        /// Get the index of the right child
        #[inline]
        fn right(node: usize) -> usize {
            (node << 1) + 2
        }
        pub fn is_empty(&self) -> bool {
            self.heap.is_empty()
        }
        pub fn len(&self) -> usize {
            self.heap.len()
        }
        /// add a value to the heap
        pub fn push(&mut self, node_id: usize, distance: f64) {
            if self.map[node_id as usize] != usize::MAX {
                let old_distance = self.distances[node_id as usize];
                if old_distance > distance {
                    self.distances[node_id as usize] = distance;
                    self.bubble_up(self.map[node_id as usize], distance);
                }
                return;
            }
            self.heap.push(node_id);
            self.distances[node_id as usize] = distance;
            self.bubble_up(self.len() - 1, distance);
        }
        fn bubble_up(&mut self, mut idx: usize, distance: f64) {
            loop {
                let parent_idx = DijkstraQueue::parent(idx);
                if distance >= self.distances[self.heap[parent_idx] as usize] {
                    break;
                }
                self.map[self.heap[idx]] = parent_idx;
                self.map[self.heap[parent_idx]] = idx;
                self.heap.swap(idx, parent_idx);
                idx = parent_idx;
            }
        }
        /// Return the computed distances
        pub fn unwrap(self) -> Vec<f64> {
            self.distances
        }
        /// remove and return the smallest value
        pub fn pop(&mut self) -> Option<usize> {
            if self.is_empty() {
                return None;
            }
            let number_of_elements = self.len() - 1;
            self.map[self.heap[0] as usize] = usize::MAX;
            self.map[self.heap[number_of_elements]] = 0;
            self.heap.swap(0, number_of_elements);
            let result = self.heap.pop();
            if !self.is_empty() {
                self.bubble_down(0, self.distances[self.heap[0] as usize]);
            }
            result
        }
        fn bubble_down(&mut self, mut idx: usize, distance: f64) {
            loop {
                let left_i = DijkstraQueue::left(idx);
                let right_i = DijkstraQueue::right(idx);
                let left_v = self
                    .heap
                    .get(left_i)
                    .map(|x| self.distances[*x])
                    .unwrap_or(f64::INFINITY);
                let right_v = self
                    .heap
                    .get(right_i)
                    .map(|x| self.distances[*x])
                    .unwrap_or(f64::INFINITY);
                let (smallest_i, smallest_v) = if left_v > right_v {
                    (right_i, right_v)
                } else {
                    (left_i, left_v)
                };
                if smallest_v < distance {
                    self.map[self.heap[idx]] = smallest_i;
                    self.map[self.heap[smallest_i]] = idx;
                    self.heap.swap(idx, smallest_i);
                    idx = smallest_i;
                    continue;
                }
                break;
            }
        }
    }
    use std::ops::{Index, IndexMut};
    impl Index<usize> for DijkstraQueue {
        type Output = f64;
        fn index(&self, node_id: usize) -> &f64 {
            &self.distances[node_id]
        }
    }
    impl IndexMut<usize> for DijkstraQueue {
        fn index_mut(&mut self, node_id: usize) -> &mut f64 {
            &mut self.distances[node_id]
        }
    }
}
pub use dijkstra_queue::*;
use vec_rand::splitmix64;
use tags::*;
mod visualizations {
    use super::*;
    impl Graph {
        /// Print the current graph in a format compatible with Graphviz dot's format.
        pub fn to_dot(&self, use_node_names: Option<bool>) -> String {
            let use_node_names = use_node_names.unwrap_or(false);
            let (graph_type, divider) = if self.is_directed() {
                ("digraph", "->")
            } else {
                ("graph", "--")
            };
            let mut result = {
                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                    &["", " G {\n"],
                    &match (&graph_type,) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ));
                res
            };
            for (_, src_id, src, dst_id, dst, _, _, weight) in
                self.iter_edge_node_names_and_edge_type_name_and_edge_weight(true)
            {
                let src_name = if use_node_names {
                    src
                } else {
                    {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&src_id,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    }
                };
                let dst_name = if use_node_names {
                    dst
                } else {
                    {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&dst_id,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    }
                };
                match weight {
                    Some(w) => {
                        result.extend(
                            {
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &["\t", " ", " ", " [label=\"", "\"];\n"],
                                    &match (&src_name, &divider, &dst_name, &w) {
                                        (arg0, arg1, arg2, arg3) => [
                                            ::core::fmt::ArgumentV1::new(
                                                arg0,
                                                ::core::fmt::Display::fmt,
                                            ),
                                            ::core::fmt::ArgumentV1::new(
                                                arg1,
                                                ::core::fmt::Display::fmt,
                                            ),
                                            ::core::fmt::ArgumentV1::new(
                                                arg2,
                                                ::core::fmt::Display::fmt,
                                            ),
                                            ::core::fmt::ArgumentV1::new(
                                                arg3,
                                                ::core::fmt::Display::fmt,
                                            ),
                                        ],
                                    },
                                ));
                                res
                            }
                            .chars(),
                        );
                    }
                    None => {
                        result.extend(
                            {
                                let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                    &["\t", " ", " ", ";\n"],
                                    &match (&src_name, &divider, &dst_name) {
                                        (arg0, arg1, arg2) => [
                                            ::core::fmt::ArgumentV1::new(
                                                arg0,
                                                ::core::fmt::Display::fmt,
                                            ),
                                            ::core::fmt::ArgumentV1::new(
                                                arg1,
                                                ::core::fmt::Display::fmt,
                                            ),
                                            ::core::fmt::ArgumentV1::new(
                                                arg2,
                                                ::core::fmt::Display::fmt,
                                            ),
                                        ],
                                    },
                                ));
                                res
                            }
                            .chars(),
                        );
                    }
                }
            }
            result.extend("\n}".chars());
            result
        }
    }
}
pub use visualizations::*;
